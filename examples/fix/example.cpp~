#include "example.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <winsock2.h>
#include <WS2tcpip.h>
#include <io.h>
#define isatty _isatty
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <unistd.h>
#define _open open
#define _dup2 dup2
#endif
#include <string.h>
#include <stdio.h>
#include <string>
#if __cplusplus < 201103L
#else
#include <cstdint>
#endif
typedef example ivy_class;
std::ofstream __ivy_out;
std::ofstream __ivy_modelfile;
void __ivy_exit(int code){exit(code);}

class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
    virtual void bind() {}
    virtual bool running() {return fdes() >= 0;}
    virtual bool background() {return false;}
    virtual ~reader() {}
};

class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
    virtual ~timer() {}
};

#ifdef _WIN32
DWORD WINAPI ReaderThreadFunction( LPVOID lpParam ) 
{
    reader *cr = (reader *) lpParam;
    cr->bind();
    while (true)
        cr->read();
    return 0;
} 

DWORD WINAPI TimerThreadFunction( LPVOID lpParam ) 
{
    timer *cr = (timer *) lpParam;
    while (true) {
        int ms = cr->ms_delay();
        Sleep(ms);
        cr->timeout(ms);
    }
    return 0;
} 
#else
void * _thread_reader(void *rdr_void) {
    reader *rdr = (reader *) rdr_void;
    rdr->bind();
    while(rdr->running()) {
        rdr->read();
    }
    delete rdr;
    return 0; // just to stop warning
}

void * _thread_timer( void *tmr_void ) 
{
    timer *tmr = (timer *) tmr_void;
    while (true) {
        int ms = tmr->ms_delay();
        struct timespec ts;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = (ms % 1000) * 1000000;
        nanosleep(&ts,NULL);
        tmr->timeout(ms);
    }
    return 0;
} 
#endif 

std::vector<reader *> threads;
std::vector<reader *> readers;
std::vector<timer *> timers;
bool initializing = false;

void example::install_reader(reader *r) {
    readers.push_back(r);
    if (!::initializing)
        r->bind();
}

void example::install_thread(reader *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ReaderThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(h);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_reader, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      

void example::install_timer(timer *r) {
    timers.push_back(r);
}

#ifdef _WIN32
    void example::__lock() { WaitForSingleObject(mutex,INFINITE); }
    void example::__unlock() { ReleaseMutex(mutex); }
#else
    void example::__lock() { pthread_mutex_lock(&mutex); }
    void example::__unlock() { pthread_mutex_unlock(&mutex); }
#endif
struct thunk__tcp_intf__handle_accept{
    example *__ivy;
    thunk__tcp_intf__handle_accept(example *__ivy): __ivy(__ivy){}
    void operator()(int s, example::ip__endpoint other) const {
        return __ivy->tcp_intf__handle_accept(s,other);
    }
};
struct thunk__tcp_intf__handle_connected{
    example *__ivy;
    thunk__tcp_intf__handle_connected(example *__ivy): __ivy(__ivy){}
    void operator()(int s) const {
        return __ivy->tcp_intf__handle_connected(s);
    }
};
struct thunk__tcp_intf__handle_fail{
    example *__ivy;
    thunk__tcp_intf__handle_fail(example *__ivy): __ivy(__ivy){}
    void operator()(int s) const {
        return __ivy->tcp_intf__handle_fail(s);
    }
};
struct thunk__tcp_intf__handle_recv{
    example *__ivy;
    thunk__tcp_intf__handle_recv(example *__ivy): __ivy(__ivy){}
    void operator()(int s, example::str x) const {
        return __ivy->tcp_intf__handle_recv(s,x);
    }
};

#include <string>
#include <vector>
#include <sstream>
#include <cstdlib>


using namespace hash_space;

inline z3::expr forall(const std::vector<z3::expr> &exprs, z3::expr const & b) {
    Z3_app *vars = new  Z3_app [exprs.size()];
    std::copy(exprs.begin(),exprs.end(),vars);
    Z3_ast r = Z3_mk_forall_const(b.ctx(), 0, exprs.size(), vars, 0, 0, b);
    b.check_error();
    delete[] vars;
    return z3::expr(b.ctx(), r);
}

class gen : public ivy_gen {

public:
    z3::context ctx;
    z3::solver slvr;
    z3::model model;

    hash_map<std::string, z3::sort> enum_sorts;
    hash_map<Z3_sort, z3::func_decl_vector> enum_values;
    hash_map<std::string, std::pair<unsigned long long, unsigned long long> > int_ranges;
    hash_map<std::string, z3::func_decl> decls_by_name;
    hash_map<Z3_symbol,int> enum_to_int;
    std::vector<Z3_symbol> sort_names;
    std::vector<Z3_sort> sorts;
    std::vector<Z3_symbol> decl_names;
    std::vector<Z3_func_decl> decls;
    std::vector<z3::expr> alits;
    int tmp_ctr;

    gen(): slvr(ctx), model(ctx,(Z3_model)0) {
        enum_sorts.insert(std::pair<std::string, z3::sort>("bool",ctx.bool_sort()));
        tmp_ctr = 0;
    }


public:
    virtual bool generate(example& obj)=0;
    virtual void execute(example& obj)=0;
    virtual ~gen(){}
    
    std::string fresh_name() {
        std::ostringstream ss;
        ss << "$tmp" << tmp_ctr++;
        return(ss.str());
    }

    z3::expr mk_apply_expr(const char *decl_name, unsigned num_args, const int *args){
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        return decl(arity,&expr_args[0]);
    }

    long long eval(const z3::expr &apply_expr) {
        try {
            z3::expr foo = model.eval(apply_expr,true);
            // std::cout << apply_expr << " = " << foo << std::endl;
            if (foo.is_int()) {
                assert(foo.is_numeral());
                int v;
                if (Z3_get_numeral_int(ctx,foo,&v) != Z3_TRUE) {
                    std::cerr << "integer value from Z3 too large for machine int: " << foo << std::endl;
                    assert(false);
                }
                return v;
            }
            if (foo.is_bv()) {
                assert(foo.is_numeral());
                uint64_t v;
                if (Z3_get_numeral_uint64(ctx,foo,&v) != Z3_TRUE) {
                    std::cerr << "bit vector value from Z3 too large for machine uint64: " << foo << std::endl;
                    assert(false);
                }
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    __strlit eval_string(const z3::expr &apply_expr) {
        try {
            z3::expr foo = model.eval(apply_expr,true);
            assert(Z3_is_string(ctx,foo));
            return Z3_get_string(ctx,foo);
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    long long eval_apply(const char *decl_name, unsigned num_args, const int *args) {
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        //        std::cout << "apply_expr: " << apply_expr << std::endl;
        try {
            z3::expr foo = model.eval(apply_expr,true);
            if (foo.is_int()) {
                assert(foo.is_numeral());
                int v;
                if (Z3_get_numeral_int(ctx,foo,&v) != Z3_TRUE) {
                    assert(false && "integer value from Z3 too large for machine int");
                }
                return v;
            }
            if (foo.is_bv()) {
                assert(foo.is_numeral());
                uint64_t v;
                if (Z3_get_numeral_uint64(ctx,foo,&v) != Z3_TRUE) {
                    assert(false && "bit vector value from Z3 too large for machine uint64");
                }
                return v;
            }
            if (foo.is_bv() || foo.is_int()) {
                assert(foo.is_numeral());
                unsigned v;
                if (Z3_get_numeral_uint(ctx,foo,&v) != Z3_TRUE)
                    assert(false && "bit vector value too large for machine int");
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    long long eval_apply(const char *decl_name) {
        return eval_apply(decl_name,0,(int *)0);
    }

    long long eval_apply(const char *decl_name, int arg0) {
        return eval_apply(decl_name,1,&arg0);
    }
    
    long long eval_apply(const char *decl_name, int arg0, int arg1) {
        int args[2] = {arg0,arg1};
        return eval_apply(decl_name,2,args);
    }

    long long eval_apply(const char *decl_name, int arg0, int arg1, int arg2) {
        int args[3] = {arg0,arg1,arg2};
        return eval_apply(decl_name,3,args);
    }

    long long eval_apply(const char *decl_name, int arg0, int arg1, int arg2, int arg3) {
        int args[4] = {arg0,arg1,arg2,arg3};
        return eval_apply(decl_name,4,args);
    }

    z3::expr apply(const char *decl_name, std::vector<z3::expr> &expr_args) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        unsigned arity = decl.arity();
        assert(arity == expr_args.size());
        return decl(arity,&expr_args[0]);
    }

    z3::expr apply(const char *decl_name) {
        std::vector<z3::expr> a;
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2, z3::expr arg3) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        a.push_back(arg3);
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2, z3::expr arg3, z3::expr arg4) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        a.push_back(arg3);
        a.push_back(arg4);
        return apply(decl_name,a);
    }

    z3::expr int_to_z3(const z3::sort &range, int64_t value) {
        if (range.is_bool())
            return ctx.bool_val((bool)value);
        if (range.is_bv())
            return ctx.bv_val((int)value,range.bv_size());
        if (range.is_int())
            return ctx.int_val((int)value);
        return enum_values.find(range)->second[(int)value]();
    }

    z3::expr int_to_z3(const z3::sort &range, const std::string& value) {
        return ctx.string_val(value);
    }

    std::pair<unsigned long long, unsigned long long> sort_range(const z3::sort &range, const std::string &sort_name) {
        std::pair<unsigned long long, unsigned long long> res;
        res.first = 0;
        if (range.is_bool())
            res.second = 1;
        else if (range.is_bv()) {
            int size = range.bv_size();
            if (size >= 64) 
                res.second = (unsigned long long)(-1);
            else res.second = (1 << size) - 1;
        }
        else if (range.is_int()) {
            if (int_ranges.find(sort_name) != int_ranges.end())
                res = int_ranges[sort_name];
            else res.second = 4;  // bogus -- we need a good way to randomize ints
        }
        else res.second = enum_values.find(range)->second.size() - 1;
        // std::cout <<  "sort range: " << range << " = " << res.first << " .. " << res.second << std::endl;
        return res;
    }

    int set(const char *decl_name, unsigned num_args, const int *args, int value) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        z3::expr apply_expr = decl(arity,&expr_args[0]);
        z3::sort range = decl.range();
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        //        std::cout << "pred: " << pred << std::endl;
        slvr.add(pred);
        return 0;
    }

    int set(const char *decl_name, int value) {
        return set(decl_name,0,(int *)0,value);
    }

    int set(const char *decl_name, int arg0, int value) {
        return set(decl_name,1,&arg0,value);
    }
    
    int set(const char *decl_name, int arg0, int arg1, int value) {
        int args[2] = {arg0,arg1};
        return set(decl_name,2,args,value);
    }

    int set(const char *decl_name, int arg0, int arg1, int arg2, int value) {
        int args[3] = {arg0,arg1,arg2};
        return set(decl_name,3,args,value);
    }

    void add_alit(const z3::expr &pred){
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "pred: " << pred << std::endl;
        std::ostringstream ss;
        ss << "alit:" << alits.size();
        z3::expr alit = ctx.bool_const(ss.str().c_str());
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "alit: " << alit << std::endl;
        alits.push_back(alit);
        slvr.add(!alit || pred);
    }

    unsigned long long random_range(std::pair<unsigned long long, unsigned long long> rng) {
        unsigned long long res = 0;
        for (unsigned i = 0; i < 4; i++) res = (res << 16) | (rand() & 0xffff);
        unsigned long long card = rng.second - rng.first;
        if (card != (unsigned long long)(-1))
            res = (res % (card+1)) + rng.first;
        return res;
    }

    void randomize(const z3::expr &apply_expr, const std::string &sort_name) {
        z3::sort range = apply_expr.get_sort();
//        std::cout << apply_expr << " : " << range << std::endl;
        unsigned long long value = random_range(sort_range(range,sort_name));
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        add_alit(pred);
    }

    void randomize(const char *decl_name, unsigned num_args, const int *args, const std::string &sort_name) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        z3::sort range = decl.range();
        unsigned long long value = random_range(sort_range(range,sort_name));
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        add_alit(pred);
    }

    void randomize(const char *decl_name, const std::string &sort_name) {
        randomize(decl_name,0,(int *)0,sort_name);
    }

    void randomize(const char *decl_name, int arg0, const std::string &sort_name) {
        randomize(decl_name,1,&arg0,sort_name);
    }
    
    void randomize(const char *decl_name, int arg0, int arg1, const std::string &sort_name) {
        int args[2] = {arg0,arg1};
        randomize(decl_name,2,args,sort_name);
    }

    void randomize(const char *decl_name, int arg0, int arg1, int arg2, const std::string &sort_name) {
        int args[3] = {arg0,arg1,arg2};
        randomize(decl_name,3,args,sort_name);
    }

    void push(){
        slvr.push();
    }

    void pop(){
        slvr.pop();
    }

    z3::sort sort(const char *name) {
        if (std::string("bool") == name)
            return ctx.bool_sort();
        return enum_sorts.find(name)->second;
    }

    void mk_enum(const char *sort_name, unsigned num_values, char const * const * value_names) {
        z3::func_decl_vector cs(ctx), ts(ctx);
        z3::sort sort = ctx.enumeration_sort(sort_name, num_values, value_names, cs, ts);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
        enum_values.insert(std::pair<Z3_sort, z3::func_decl_vector>(sort,cs));
        sort_names.push_back(Z3_mk_string_symbol(ctx,sort_name));
        sorts.push_back(sort);
        for(unsigned i = 0; i < num_values; i++){
            Z3_symbol sym = Z3_mk_string_symbol(ctx,value_names[i]);
            decl_names.push_back(sym);
            decls.push_back(cs[i]);
            enum_to_int[sym] = i;
        }
    }

    void mk_bv(const char *sort_name, unsigned width) {
        z3::sort sort = ctx.bv_sort(width);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_int(const char *sort_name) {
        z3::sort sort = ctx.int_sort();
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_string(const char *sort_name) {
        z3::sort sort = ctx.string_sort();
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_sort(const char *sort_name) {
        Z3_symbol symb = Z3_mk_string_symbol(ctx,sort_name);
        z3::sort sort(ctx,Z3_mk_uninterpreted_sort(ctx, symb));
//        z3::sort sort = ctx.uninterpreted_sort(sort_name);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
        sort_names.push_back(symb);
        sorts.push_back(sort);
    }

    void mk_decl(const char *decl_name, unsigned arity, const char **domain_names, const char *range_name) {
        std::vector<z3::sort> domain;
        for (unsigned i = 0; i < arity; i++) {
            if (enum_sorts.find(domain_names[i]) == enum_sorts.end()) {
                std::cout << "unknown sort: " << domain_names[i] << std::endl;
                exit(1);
            }
            domain.push_back(enum_sorts.find(domain_names[i])->second);
        }
        std::string bool_name("Bool");
        z3::sort range = (range_name == bool_name) ? ctx.bool_sort() : enum_sorts.find(range_name)->second;   
        z3::func_decl decl = ctx.function(decl_name,arity,&domain[0],range);
        decl_names.push_back(Z3_mk_string_symbol(ctx,decl_name));
        decls.push_back(decl);
        decls_by_name.insert(std::pair<std::string, z3::func_decl>(decl_name,decl));
    }

    void mk_const(const char *const_name, const char *sort_name) {
        mk_decl(const_name,0,0,sort_name);
    }

    void add(const std::string &z3inp) {
        z3::expr fmla(ctx,Z3_parse_smtlib2_string(ctx, z3inp.c_str(), sort_names.size(), &sort_names[0], &sorts[0], decl_names.size(), &decl_names[0], &decls[0]));
        ctx.check_error();

        slvr.add(fmla);
    }

    bool solve() {
        // std::cout << alits.size();
        static bool show_model = true;
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "begin check:\n" << slvr << "end check:\n" << std::endl;
        while(true){
            if (__ivy_modelfile.is_open()) {
                __ivy_modelfile << "(check-sat"; 
                for (unsigned i = 0; i < alits.size(); i++)
                    __ivy_modelfile << " " << alits[i];
                __ivy_modelfile << ")" << std::endl;
            }
            z3::check_result res = slvr.check(alits.size(),&alits[0]);
            if (res != z3::unsat)
                break;
            z3::expr_vector core = slvr.unsat_core();
            if (core.size() == 0){
//                if (__ivy_modelfile.is_open()) 
//                    __ivy_modelfile << "begin unsat:\n" << slvr << "end unsat:\n" << std::endl;
                return false;
            }
            if (__ivy_modelfile.is_open()) 
                for (unsigned i = 0; i < core.size(); i++)
                    __ivy_modelfile << "core: " << core[i] << std::endl;
            unsigned idx = rand() % core.size();
            z3::expr to_delete = core[idx];
            if (__ivy_modelfile.is_open()) 
                __ivy_modelfile << "to delete: " << to_delete << std::endl;
            for (unsigned i = 0; i < alits.size(); i++)
                if (z3::eq(alits[i],to_delete)) {
                    alits[i] = alits.back();
                    alits.pop_back();
                    break;
                }
        }
        model = slvr.get_model();
        alits.clear();

        if(__ivy_modelfile.is_open()){
            __ivy_modelfile << "begin sat:\n" << slvr << "end sat:\n" << std::endl;
            __ivy_modelfile << model;
            __ivy_modelfile.flush();
        }

        return true;
    }

    int choose(int rng, const char *name){
        if (decls_by_name.find(name) == decls_by_name.end())
            return 0;
        return eval_apply(name);
    }
};

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#ifndef __fallthrough
#define __fallthrough
#endif

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}




struct ivy_value {
    int pos;
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct deser_err {
};

struct ivy_ser {
    virtual void  set(long long) = 0;
    virtual void  set(bool) = 0;
    virtual void  setn(long long inp, int len) = 0;
    virtual void  set(const std::string &) = 0;
    virtual void  open_list(int len) = 0;
    virtual void  close_list() = 0;
    virtual void  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual void  open_tag(int, const std::string &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual ~ivy_ser(){}
};
struct ivy_binary_ser : public ivy_ser {
    std::vector<char> res;
    void setn(long long inp, int len) {
        for (int i = len-1; i >= 0 ; i--)
            res.push_back((inp>>(8*i))&0xff);
    }
    void set(long long inp) {
        setn(inp,sizeof(long long));
    }
    void set(bool inp) {
        set((long long)inp);
    }
    void set(const std::string &inp) {
        for (unsigned i = 0; i < inp.size(); i++)
            res.push_back(inp[i]);
        res.push_back(0);
    }
    void open_list(int len) {
        set((long long)len);
    }
    void close_list() {}
    void open_list_elem() {}
    void close_list_elem() {}
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    virtual void  open_tag(int tag, const std::string &) {
        set((long long)tag);
    }
    virtual void  close_tag() {}
};

struct ivy_deser {
    virtual void  get(long long&) = 0;
    virtual void  get(std::string &) = 0;
    virtual void  getn(long long &res, int bytes) = 0;
    virtual void  open_list() = 0;
    virtual void  close_list() = 0;
    virtual bool  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual int   open_tag(const std::vector<std::string> &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual void  end() = 0;
    virtual ~ivy_deser(){}
};

struct ivy_binary_deser : public ivy_deser {
    std::vector<char> inp;
    int pos;
    std::vector<int> lenstack;
    ivy_binary_deser(const std::vector<char> &inp) : inp(inp),pos(0) {}
    virtual bool more(unsigned bytes) {return inp.size() >= pos + bytes;}
    virtual bool can_end() {return pos == inp.size();}
    void get(long long &res) {
       getn(res,8);
    }
    void getn(long long &res, int bytes) {
        if (!more(bytes))
            throw deser_err();
        res = 0;
        for (int i = 0; i < bytes; i++)
            res = (res << 8) | (((long long)inp[pos++]) & 0xff);
    }
    void get(std::string &res) {
        while (more(1) && inp[pos]) {
//            if (inp[pos] == '"')
//                throw deser_err();
            res.push_back(inp[pos++]);
        }
        if(!(more(1) && inp[pos] == 0))
            throw deser_err();
        pos++;
    }
    void open_list() {
        long long len;
        get(len);
        lenstack.push_back(len);
    }
    void close_list() {
        lenstack.pop_back();
    }
    bool open_list_elem() {
        return lenstack.back();
    }
    void close_list_elem() {
        lenstack.back()--;
    }
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    int open_tag(const std::vector<std::string> &tags) {
        long long res;
        get(res);
        if (res >= tags.size())
            throw deser_err();
        return res;
    }
    void end() {
        if (!can_end())
            throw deser_err();
    }
};
struct ivy_socket_deser : public ivy_binary_deser {
      int sock;
    public:
      ivy_socket_deser(int sock, const std::vector<char> &inp)
          : ivy_binary_deser(inp), sock(sock) {}
    virtual bool more(unsigned bytes) {
        while (inp.size() < pos + bytes) {
            int oldsize = inp.size();
            int get = pos + bytes - oldsize;

            inp.resize(oldsize + get);
            int newbytes;
	    if ((newbytes = read(sock,&inp[oldsize],get)) < 0)
		 { std::cerr << "recvfrom failed\n"; exit(1); }
            inp.resize(oldsize + newbytes);
            if (newbytes == 0)
                 return false;
        }
        return true;
    }
    virtual bool can_end() {return true;}
};

struct out_of_bounds {
    std::string txt;
    int pos;
    out_of_bounds(int _idx, int pos = 0) : pos(pos){
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s, int pos = 0) : txt(s), pos(pos) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <class T> T __lit(const char *);

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom == "true";
}

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
    // int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
long long _arg<long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
//    long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned long long _arg<unsigned long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned long long res;
    s  >> res;
//    unsigned long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned _arg<unsigned>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned res;
    s  >> res;
//    unsigned res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}


std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom;
}

template <class T> void __ser(ivy_ser &res, const T &inp);

template <>
void __ser<int>(ivy_ser &res, const int &inp) {
    res.set((long long)inp);
}

template <>
void __ser<long long>(ivy_ser &res, const long long &inp) {
    res.set(inp);
}

template <>
void __ser<unsigned long long>(ivy_ser &res, const unsigned long long &inp) {
    res.set((long long)inp);
}

template <>
void __ser<unsigned>(ivy_ser &res, const unsigned &inp) {
    res.set((long long)inp);
}

template <>
void __ser<bool>(ivy_ser &res, const bool &inp) {
    res.set(inp);
}

template <>
void __ser<std::vector<bool>::const_reference>(ivy_ser &res, const std::vector<bool>::const_reference &inp) {
    bool thing = inp;
    res.set(thing);
} 

template <>
void __ser<__strlit>(ivy_ser &res, const __strlit &inp) {
    res.set(inp);
}

template <class T> void __deser(ivy_deser &inp, T &res);

template <>
void __deser<int>(ivy_deser &inp, int &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<long long>(ivy_deser &inp, long long &res) {
    inp.get(res);
}

template <>
void __deser<unsigned long long>(ivy_deser &inp, unsigned long long &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<unsigned>(ivy_deser &inp, unsigned &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<__strlit>(ivy_deser &inp, __strlit &res) {
    inp.get(res);
}

template <>
void __deser<bool>(ivy_deser &inp, bool &res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

void __deser(ivy_deser &inp, std::vector<bool>::reference res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

class gen;


template <class T> void __from_solver( gen &g, const  z3::expr &v, T &res);

template <>
void __from_solver<int>( gen &g, const  z3::expr &v, int &res) {
    res = g.eval(v);
}

template <>
void __from_solver<long long>( gen &g, const  z3::expr &v, long long &res) {
    res = g.eval(v);
}

template <>
void __from_solver<unsigned long long>( gen &g, const  z3::expr &v, unsigned long long &res) {
    res = g.eval(v);
}

template <>
void __from_solver<unsigned>( gen &g, const  z3::expr &v, unsigned &res) {
    res = g.eval(v);
}

template <>
void __from_solver<bool>( gen &g, const  z3::expr &v, bool &res) {
    res = g.eval(v);
}

template <>
void __from_solver<__strlit>( gen &g, const  z3::expr &v, __strlit &res) {
    res = g.eval_string(v);
}

template <class T>
class to_solver_class {
};

template <class T> z3::expr __to_solver( gen &g, const  z3::expr &v, T &val) {
    return to_solver_class<T>()(g,v,val);
}


template <>
z3::expr __to_solver<int>( gen &g, const  z3::expr &v, int &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<long long>( gen &g, const  z3::expr &v, long long &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<unsigned long long>( gen &g, const  z3::expr &v, unsigned long long &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<unsigned>( gen &g, const  z3::expr &v, unsigned &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<bool>( gen &g, const  z3::expr &v, bool &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<__strlit>( gen &g, const  z3::expr &v, __strlit &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    return v == g.int_to_z3(v.get_sort(),val);
}

template <class T>
class __random_string_class {
public:
    std::string operator()() {
        std::string res;
        res.push_back('a' + (rand() % 26)); // no empty strings for now
        while (rand() %2)
            res.push_back('a' + (rand() % 26));
        return res;
    }
};

template <class T> std::string __random_string(){
    return __random_string_class<T>()();
}

template <class T> void __randomize( gen &g, const  z3::expr &v, const std::string &sort_name);

template <>
void __randomize<int>( gen &g, const  z3::expr &v, const std::string &sort_name) {
    g.randomize(v,sort_name);
}

template <>
void __randomize<long long>( gen &g, const  z3::expr &v, const std::string &sort_name) {
    g.randomize(v,sort_name);
}

template <>
void __randomize<unsigned long long>( gen &g, const  z3::expr &v, const std::string &sort_name) {
    g.randomize(v,sort_name);
}

template <>
void __randomize<unsigned>( gen &g, const  z3::expr &v, const std::string &sort_name) {
    g.randomize(v,sort_name);
}

template <>
void __randomize<bool>( gen &g, const  z3::expr &v, const std::string &sort_name) {
    g.randomize(v,sort_name);
}

template <>
        void __randomize<__strlit>( gen &g, const  z3::expr &apply_expr, const std::string &sort_name) {
    z3::sort range = apply_expr.get_sort();
    __strlit value = (rand() % 2) ? "a" : "b";
    z3::expr val_expr = g.int_to_z3(range,value);
    z3::expr pred = apply_expr == val_expr;
    g.add_alit(pred);
}

static int z3_thunk_counter = 0;

template<typename D, typename R>
class z3_thunk : public thunk<D,R> {
    public:
       virtual z3::expr to_z3(gen &g, const  z3::expr &v) = 0;
};

z3::expr __z3_rename(const z3::expr &e, hash_map<std::string,std::string> &rn) {
    if (e.is_app()) {
        z3::func_decl decl = e.decl();
        z3::expr_vector args(e.ctx());
        unsigned arity = e.num_args();
        for (unsigned i = 0; i < arity; i++) {
            args.push_back(__z3_rename(e.arg(i),rn));
        }
        if (decl.name().kind() == Z3_STRING_SYMBOL) {
            std::string fun = decl.name().str();
            if (rn.find(fun) != rn.end()) {
                std::string newfun = rn[fun];
                std::vector<z3::sort> domain;
                for (unsigned i = 0; i < arity; i++) {
                    domain.push_back(decl.domain(i));
                }
                z3::sort range = e.decl().range();
                decl = e.ctx().function(newfun.c_str(),arity,&domain[0],range);
            }
        }
        return decl(args);
    } else if (e.is_quantifier()) {
        z3::expr body = __z3_rename(e.body(),rn);
        unsigned nb = Z3_get_quantifier_num_bound(e.ctx(),e);
        std::vector<Z3_symbol> bnames;
        std::vector<Z3_sort> bsorts;
        for (unsigned i = 0; i < nb; i++) {
            bnames.push_back(Z3_get_quantifier_bound_name(e.ctx(),e,i));
            bsorts.push_back(Z3_get_quantifier_bound_sort(e.ctx(),e,i));
        }
        Z3_ast q = Z3_mk_quantifier(e.ctx(),
                                    Z3_is_quantifier_forall(e.ctx(),e),
                                    Z3_get_quantifier_weight(e.ctx(),e),
                                    0,
                                    0,
                                    nb,
                                    &bsorts[0],
                                    &bnames[0],
                                    body);
        return z3::expr(e.ctx(),q);
    }
    return(e);
}

std::ostream &operator <<(std::ostream &s, const example::ip__protocol &t);
template <>
example::ip__protocol _arg<example::ip__protocol>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<example::ip__protocol>(ivy_ser &res, const example::ip__protocol&);
template <>
void  __deser<example::ip__protocol>(ivy_deser &inp, example::ip__protocol &res);
template <>
void __from_solver<example::ip__protocol>( gen &g, const  z3::expr &v, example::ip__protocol &res);
template <>
z3::expr __to_solver<example::ip__protocol>( gen &g, const  z3::expr &v, example::ip__protocol &val);
template <>
void __randomize<example::ip__protocol>( gen &g, const  z3::expr &v, const std::string &sort_name);
std::ostream &operator <<(std::ostream &s, const example::ip__endpoint &t);
template <>
example::ip__endpoint _arg<example::ip__endpoint>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<example::ip__endpoint>(ivy_ser &res, const example::ip__endpoint&);
template <>
void  __deser<example::ip__endpoint>(ivy_deser &inp, example::ip__endpoint &res);
std::ostream &operator <<(std::ostream &s, const example::ping &t);
template <>
example::ping _arg<example::ping>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<example::ping>(ivy_ser &res, const example::ping&);
template <>
void  __deser<example::ping>(ivy_deser &inp, example::ping &res);
std::ostream &operator <<(std::ostream &s, const example::pong &t);
template <>
example::pong _arg<example::pong>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<example::pong>(ivy_ser &res, const example::pong&);
template <>
void  __deser<example::pong>(ivy_deser &inp, example::pong &res);
template <>
void __from_solver<example::ip__endpoint>( gen &g, const  z3::expr &v, example::ip__endpoint &res);
template <>
z3::expr __to_solver<example::ip__endpoint>( gen &g, const  z3::expr &v, example::ip__endpoint &val);
template <>
void __randomize<example::ip__endpoint>( gen &g, const  z3::expr &v, const std::string &sort_name);
template <>
void __from_solver<example::ping>( gen &g, const  z3::expr &v, example::ping &res);
template <>
z3::expr __to_solver<example::ping>( gen &g, const  z3::expr &v, example::ping &val);
template <>
void __randomize<example::ping>( gen &g, const  z3::expr &v, const std::string &sort_name);
template <>
void __from_solver<example::pong>( gen &g, const  z3::expr &v, example::pong &res);
template <>
z3::expr __to_solver<example::pong>( gen &g, const  z3::expr &v, example::pong &val);
template <>
void __randomize<example::pong>( gen &g, const  z3::expr &v, const std::string &sort_name);

int example::msg::temp_counter = 0;

std::ostream &operator <<(std::ostream &s, const example::msg &t){
    s << "{";
    switch (t.tag) {
        case 0: s << "ping:" << example::msg::unwrap< example::ping >(t); break;
        case 1: s << "pong:" << example::msg::unwrap< example::pong >(t); break;

    }
    s << "}";
    return s;
}
template <>
example::msg _arg<example::msg>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].atom.size())
        throw out_of_bounds("unexpected value for sort msg: " + args[idx].atom,args[idx].pos);
    if (args[idx].fields.size() == 0)
        return example::msg();
    if (args[idx].fields.size() != 1)
        throw out_of_bounds("too many fields for sort msg (expected one)",args[idx].pos);
    if (args[idx].fields[0].atom == "ping") return example::msg(0, new example::msg::twrap<example::ping>(_arg<example::ping>(args[idx].fields[0].fields,0,0)));
    if (args[idx].fields[0].atom == "pong") return example::msg(1, new example::msg::twrap<example::pong>(_arg<example::pong>(args[idx].fields[0].fields,0,0)));

        throw out_of_bounds("unexpected field sort SORTNAME: " + args[idx].fields[0].atom, args[idx].pos);
}
template <>
void __ser<example::msg>(ivy_ser &res, const example::msg &inp) {
    if (inp.tag == 0) {res.open_tag(0,"ping"); __ser(res,example::msg::unwrap< example::ping >(inp)); res.close_tag();}
    if (inp.tag == 1) {res.open_tag(1,"pong"); __ser(res,example::msg::unwrap< example::pong >(inp)); res.close_tag();}

}
template <>
void __deser<example::msg>(ivy_deser &res, example::msg &inp) {
    std::vector<std::string> tags;
    tags.push_back("ping");
    tags.push_back("pong");

    int tag = res.open_tag(tags);
    switch (tag) {
    case 0: {example::ping tmp; __deser(res,tmp); inp = example::msg(0, new example::msg::twrap<example::ping>(tmp)); break;} 
    case 1: {example::pong tmp; __deser(res,tmp); inp = example::msg(1, new example::msg::twrap<example::pong>(tmp)); break;} 

    }
    res.close_tag();
}
#ifdef Z3PP_H_
template <>
void __from_solver<example::msg>( gen &g, const  z3::expr &v, example::msg &res) {
    {
        z3::sort sort = g.sort("ping");
        z3::func_decl pto = g.ctx.function("*>:msg:ping",g.sort("msg"),g.sort("ping"),g.ctx.bool_sort());
        // std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    example::ping tmp;
                    __from_solver(g,univ[i],tmp);                    res = example::msg(0, new example::msg::twrap<example::ping>(tmp));
                }
            }
        }
    }
    {
        z3::sort sort = g.sort("pong");
        z3::func_decl pto = g.ctx.function("*>:msg:pong",g.sort("msg"),g.sort("pong"),g.ctx.bool_sort());
        // std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    example::pong tmp;
                    __from_solver(g,univ[i],tmp);                    res = example::msg(1, new example::msg::twrap<example::pong>(tmp));
                }
            }
        }
    }

}
template <>
z3::expr __to_solver<example::msg>( gen &g, const  z3::expr &v, example::msg &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    if (val.tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:msg:ping",g.sort("msg"),g.sort("ping"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("ping"));
        example::ping tmp = example::msg::unwrap< example::ping >(val);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }
    if (val.tag == 1) {
        z3::func_decl pto = g.ctx.function("*>:msg:pong",g.sort("msg"),g.sort("pong"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("pong"));
        example::pong tmp = example::msg::unwrap< example::pong >(val);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }

    z3::expr conj = g.ctx.bool_val(false);
    {
        z3::func_decl pto = g.ctx.function("*>:msg:ping",g.sort("msg"),g.sort("ping"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("ping"));
        conj = conj && forall(Y,!pto(v,Y));
    }
    {
        z3::func_decl pto = g.ctx.function("*>:msg:pong",g.sort("msg"),g.sort("pong"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("pong"));
        conj = conj && forall(Y,!pto(v,Y));
    }

    return conj;
}
template <>
void __randomize<example::msg>( gen &g, const  z3::expr &apply_expr, const std::string &sort_name) {
    std::ostringstream os;
    os << "__msg__tmp" << example::msg::temp_counter++;
    std::string temp = os.str();
    z3::sort range = apply_expr.get_sort();
    z3::expr disj = g.ctx.bool_val(false);
int tag = rand() % 2;
    if (tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:msg:ping",g.sort("msg"),g.sort("ping"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("ping"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<example::ping>(g,X,"ping");
    }
    if (tag == 1) {
        z3::func_decl pto = g.ctx.function("*>:msg:pong",g.sort("msg"),g.sort("pong"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("pong"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<example::pong>(g,X,"pong");
    }

}
#endif
        template <typename T>
        T __string_segment(const T &a, long long lo, long long hi) {
            T res;
            lo = (lo < 0) ? 0 : lo;
            hi = (hi > a.size()) ? a.size() : hi;
            if (hi > lo) {
                res.resize(hi-lo);
                std::copy(a.begin()+lo,a.begin()+hi,res.begin());
            }
            return res;
        }
        	    std::ostream &operator <<(std::ostream &s, const example::str &a) {
	        s << '"';
		for (unsigned i = 0; i < a.size(); i++) {
		    s << (char)a[i];
		}
	        s << '"';
		return s;
            }

	    template <>
	    example::str _arg<example::str>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	         if (args[idx].fields.size())
                     throw out_of_bounds(idx);
	         example::str res;
	         std::string s = args[idx].atom;
	         for (unsigned __idx = 0; __idx < s.size(); __idx++)
	             res.push_back(s[__idx]);
	         return res;
	    }

	    template <>
	    example::str __lit<example::str>(const char *c) {
	         example::str res;
	         std::string s = c;
	         for (unsigned __idx = 0; __idx < s.size(); __idx++)
	             res.push_back(s[__idx]);
	         return res;
	    }

	    template <>
	    void __deser<example::str>(ivy_deser &inp, example::str &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<example::str>(ivy_ser &res, const example::str &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, example::str& val) {
	        z3::expr z3end = g.apply("str.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("str.value",z3val,g.int_to_z3(g.sort("index"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<example::str>( gen &g, const  z3::expr &v,example::str &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("str.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("str.value",v,g.int_to_z3(g.sort("index"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<example::str>( gen &g, const  z3::expr &v, const std::string &sort_name){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("index"),__sz);
                z3::expr pred =  g.apply("str.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<unsigned>(g,g.apply("str.value",v,g.int_to_z3(g.sort("index"),__i)),"uint[8]");
	    }
	    #endif

	
   // Maximum number of sent packets to queue on a channel. Because TCP also
   // buffers, the total number of untransmitted backets that can back up will be greater
   // than this. This number *must* be at least one to void packet corruption.

   #define MAX_TCP_SEND_QUEUE 16

   struct tcp_mutex {
#ifdef _WIN32
       HANDLE mutex;
       tcp_mutex() { mutex = CreateMutex(NULL,FALSE,NULL); }
       void lock() { WaitForSingleObject(mutex,INFINITE); }
       void unlock() { ReleaseMutex(mutex); }
#else
       pthread_mutex_t mutex;
       tcp_mutex() { pthread_mutex_init(&mutex,NULL); }
       void lock() { pthread_mutex_lock(&mutex); }
       void unlock() { pthread_mutex_unlock(&mutex); }
#endif
   };

   class tcp_queue {
       std::mutex mtx;
       std::condition_variable cv;
       bool closed;
       bool reported_closed;
       std::list<std::vector<char> > bufs;
    public:
       example::ip__endpoint other; // only acces while holding lock!
       tcp_queue(example::ip__endpoint other) : closed(false), reported_closed(false), other(other) {}
       bool enqueue_swap(std::vector<char> &buf) {
           std::unique_lock<std::mutex> lock(mtx);
           // mutex.lock();
           if (closed) {
               // mutex.unlock();
               return true;
           }
           if (bufs.size() < MAX_TCP_SEND_QUEUE) {
               bufs.push_back(std::vector<char>());
               buf.swap(bufs.back());
           }
           // mutex.unlock();
           // sem.up();
           cv.notify_all();
           return false;
       }
       bool dequeue_swap(std::vector<char> &buf) {
           std::unique_lock<std::mutex> lock(mtx);
           while(true) {
               // sem.down();
               // std::cout << "DEQUEUEING" << closed << std::endl;
               // mutex.lock();
               if (closed) {
                   if (reported_closed) {
                       // mutex.unlock();
                       cv.wait(lock);
                       continue;
                   }
                   reported_closed = true;
                   // mutex.unlock();
                   // std::cout << "REPORTING CLOSED" << std::endl;
                   return true;
               }
               if (bufs.size() > 0) {
                   buf.swap(bufs.front());
                   bufs.erase(bufs.begin());
                   // mutex.unlock();
                   return false;
               }
               cv.wait(lock);
               // mutex.unlock();
            }
       }
       void set_closed(bool report=true) {
           std::unique_lock<std::mutex> lock(mtx);
           // mutex.lock();
           closed = true;
           bufs.clear();
           if (!report)
               reported_closed = true;
           // mutex.unlock();
           // sem.up();
           cv.notify_all();
       }
       void set_open(example::ip__endpoint _other) {
           std::unique_lock<std::mutex> lock(mtx);
           // mutex.lock();
           closed = false;
           reported_closed = false;
           other = _other;
           // mutex.unlock();
           // sem.up();
           cv.notify_all();
       }
       void wait_open(bool closed_val = false){
           std::unique_lock<std::mutex> lock(mtx);
           while (true) {
               // mutex.lock();
               if (closed == closed_val) {
                   // mutex.unlock();
                   return;
               }
               // mutex.unlock();
               // sem.down();
               cv.wait(lock);
            }
       }

   };


    // construct a sockaddr_in for a specified process id using the configuration

    void get_tcp_addr(ivy_class *ivy, example::ip__endpoint addr, sockaddr_in &myaddr) {
        memset((char *)&myaddr, 0, sizeof(myaddr));
        myaddr.sin_family = AF_INET;
        myaddr.sin_addr.s_addr = htonl(addr.addr);
	myaddr.sin_port = htons(addr.port);
    }

    // get a new TCP socket

    int make_tcp_socket() {
        int sock = ::socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0)
            { std::cerr << "cannot create socket\n"; exit(1); }
        int one = 1;
        if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one)) < 0) 
            { perror("setsockopt failed"); exit(1); }
        return sock;
    }
    

    // This structure holds all the callbacks for the endpoint. These are function objects
    // that are called asynchronously.

    struct tcp_callbacks {
        thunk__tcp_intf__handle_accept acb;
        thunk__tcp_intf__handle_recv rcb;
        thunk__tcp_intf__handle_fail fcb;
        thunk__tcp_intf__handle_connected ccb;
        tcp_callbacks(const thunk__tcp_intf__handle_accept &acb,
                      const thunk__tcp_intf__handle_recv &rcb,
                      const thunk__tcp_intf__handle_fail &fcb,
                      const thunk__tcp_intf__handle_connected ccb)
            : acb(acb), rcb(rcb), fcb(fcb), ccb(ccb) {}
    };

    // This is a general class for an asynchronous task. These objects are called in a loop
    // by a thread allocated by the runtime. The fdes method returns a file descriptor
    // associated with the object. If fdes returns a negative value, the thread deletes the
    // object and terminates.

    class tcp_task : public reader {
      std::mutex sock_mtx;
      protected:
        int sock;           // socket associated to this task, or -1 if task complete
        tcp_callbacks cb;   // callbacks to ivy
        ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

      public:

        tcp_task(int sock, const tcp_callbacks &cb, ivy_class *ivy)
          : sock(sock), cb(cb), ivy(ivy) {} 

        virtual int fdes() {
            std::unique_lock<std::mutex> lock(sock_mutex);
            return sock;
        }


    };


    // This task reads messages from a socket and calls the "recv" callback.

    class tcp_reader : public tcp_task {
        std::vector<char> buf;
      public:
        tcp_reader(int sock, const tcp_callbacks &cb, ivy_class *ivy)
            : tcp_task(sock, cb, ivy) {
            
        }

        // This is called in a loop by the task thread.

        virtual void read() {
            std::unique_lock<std::mutex> lock(sock_mutex);
            if (sock < 0) return;
        
            std::cout << "RECEIVING\n";
            buf.resize(2048);
            int newbytes;
	    if ((newbytes = ::read(sock,&buf[0],2048)) < 0)
		 { perror("read failed"); exit(1); }

            if (newbytes == 0) {
                return;
            }

            std::cout << "RECEIVED\n";
            // copy received bytes into the result

            example::str pkt;
            pkt.resize(newbytes);
            std::copy(buf.begin(),buf.begin()+newbytes,pkt.begin());

            // call the "recv" callback with the received message

            ivy->__lock();
            cb.rcb(sock,pkt);
            ivy->__unlock();
        }
    };

    class tcp_reader_lock : public tcp_task {
        std::unique_lock<std::mutex> lock
      public:
        tcp_reader(int sock, const tcp_callbacks &cb, ivy_class *ivy, std::mutex *mtx)
            : tcp_reader(sock, cb, ivy), lock(*mtx) {
            
        }
        void kill() {
            std::unique_lock<std::mutex> lock(sock_mutex);
            sock = -1;
        }
    };

    // This class writes queued bytes to a socket. Packets can be added
    // asynchronously to the tail of the queue. If the socket is closed,
    // the queue will be emptied asynchrnonously. When the queue is empty the writer deletes
    // the queue and exits.

    // invariant: if socket is closed, queue is closed

    class tcp_writer : public tcp_task {
        tcp_queue *queue;
        bool connected;
        tcp_reader_lock *reader;
        std::mutex reader_mutex;
      public:
        tcp_writer(int sock, tcp_queue *queue, const tcp_callbacks &cb, ivy_class *ivy)
    : tcp_task(sock,cb,ivy), queue(queue), connected(false) {
            reader = new tcp_reader_lock(sock,cb,ivy,&reader_mutex);
            ivy->install_reader(reader);
        }

        virtual int fdes() {
            return sock;
        }

        // This is called in a loop by the task thread.

        virtual void read() {

            if (!connected) {
            
                // if the socket is not connected, wait for the queue to be open,
                // then connect

                queue->wait_open();
                connect();
                return;
            }

            // dequeue a packet to send

            std::vector<char> buf;
            bool qclosed = queue->dequeue_swap(buf);        

            // if queue has been closed asynchrononously, close the socket. 

            if (qclosed) {
                // std::cout << "CLOSING " << sock << std::endl;
                kill_reader();
                ::close(sock);
                connected = false;
                return;
            }

            // try a blocking send

#ifdef MSG_NOSIGNAL	    
            int bytes = send(sock,&buf[0],buf.size(),MSG_NOSIGNAL);
#else
            int bytes = send(sock,&buf[0],buf.size(),0);
#endif
        
            // std::cout << "SENT\n";

            // if not all bytes sent, channel has failed, close the queue

            if (bytes < (int)buf.size())
                fail_close();
        }

        void connect() {

            // Get the address of the other from the configuration

            // std::cout << "ENTERING CONNECT " << sock << std::endl;

            ivy -> __lock();               // can be asynchronous, so must lock ivy!
            struct sockaddr_in myaddr;
            example::ip__endpoint other = queue->other;
            get_tcp_addr(ivy,other,myaddr);
            ivy -> __unlock(); 

            // Call connect to make connection

            // std::cout << "CONNECTING sock=" << sock << "other=" << other << std::endl;

            int res = ::connect(sock,(sockaddr *)&myaddr,sizeof(myaddr));

            // If successful, call the "connected" callback, else "failed"
            
            ivy->__lock();
            if (res >= 0) {
                // std::cout << "CONNECT SUCCEEDED " << sock << std::endl;
                cb.ccb(sock);
                connected = true;
            }
            else {
                // std::cout << "CONNECT FAILED " << sock << std::endl;
                fail_close();
            }
            ivy->__unlock();

        }

        void fail_close() {
            queue -> set_closed(false);  // close queue synchronously

            // make sure socket is closed before fail callback, since this
            // might open another socket, and we don't want to build up
            // zombie sockets.

            // std::cout << "CLOSING ON FAILURE " << sock << std::endl;
            kill_reader();
            ::close(sock);
            cb.fcb(sock);
            connected = false;
        }

        void kill_reader() {
            reader->kill();
            std::unique_lock<std::mutex> lock(reader_mutex);
        }
    };

    // This task listens for connections on a socket in the background. 

    class tcp_listener : public tcp_task {
      public:

        // The constructor creates a socket to listen on.

        tcp_listener(const tcp_callbacks &cb, ivy_class *ivy)
            : tcp_task(0,cb,ivy) {
            sock = make_tcp_socket();
        }

        // The bind method is called by the runtime once, after initialization.
        // This allows us to query the configuration for our address and bind the socket.

        virtual void bind() {
        }

        // After binding, the thread calls read in a loop. In this case, we don't read,
        // we try accepting a connection. BUG: We should first call select to wait for a connection
        // to be available, then call accept while holding the ivy lock. This is needed to
        // guarantee the "accepted" appears to occur before "connected" which is required by
        // the the tcp interface specification.

        virtual void read() {
            // std::cout << "ACCEPTING\n";

            // Call accept to get an incoming connection request. May block.
            sockaddr_in other_addr;
            socklen_t addrlen = sizeof(other_addr);    
            int new_sock = accept(sock, (sockaddr *)&other_addr, &addrlen);

            // If this fails, something is very wrong: fail stop.
            if (new_sock < 0)
                { perror("accept failed"); exit(1); }

            example::ip__endpoint other;
	    other.addr = ntohl(other_addr.sin_addr.s_addr);
	    other.port = ntohs(other_addr.sin_port);

            // Run the "accept" callback. Since it's async, we must lock.
            ivy->__lock();
            cb.acb(new_sock,other);
            ivy->__unlock();

            // Install a reader task to read messages from the new socket.
            ivy->install_reader(new tcp_reader(new_sock,cb,ivy));
        }
    };



int example::___ivy_choose(int rng,const char *name,int id) {
        std::ostringstream ss;
        ss << name << ':' << id;;
        for (unsigned i = 0; i < ___ivy_stack.size(); i++)
            ss << ':' << ___ivy_stack[i];
        return ___ivy_gen->choose(rng,ss.str().c_str());
    }
unsigned long long example::str__begin(const str& A){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val = 0;
    return val;
}
unsigned example::str__value(const str& a, unsigned long long i){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long example::str__end(const str& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
void example::__init(){
    pending = false;
    {
        ___ivy_stack.push_back(238);
        tcp_sock = tcp_intf__connect(server_addr);
        ___ivy_stack.pop_back();
        std::cout << "{" << std::endl;
        std::cout << "    \"event\" : \"socket\"," << std::endl;
        std::cout << "    \"sock\" : ";
        std::cout << tcp_sock;
        std::cout << "," << std::endl;
        std::cout << "}" << std::endl;
    }
}
void example::ext__tcp_intf__failed(int s){
    {
    }
}
example::str example::ping__to_str(const ping& self){
    example::str res;
    res = __lit<str>("ping");
    return res;
}
void example::tcp_intf__handle_accept(int s, const ip__endpoint& other){
    ___ivy_stack.push_back(236);
    ext__tcp_intf__accept(s, other);
    ___ivy_stack.pop_back();
}
void example::ping__recv(const ping& self){
    {
        ivy_assert(false, "example.ivy: line 38");
    }
}
void example::tcp_intf__handle_fail(int s){
    ___ivy_stack.push_back(237);
    ext__tcp_intf__failed(s);
    ___ivy_stack.pop_back();
}
example::str example::msg__to_str(example::msg self){
    example::str res;
    {
    }
    return res;
}
example::str example::str__empty(){
    example::str a;
    {
        
    }
    return a;
}
void example::ext__ping__send(ping self){
    {
        ivy_assume(!pending, "example.ivy: line 34");
        pending = true;
        ___ivy_stack.push_back(239);
        writer__write(tcp_sock, example::msg(0, new example::msg::twrap<example::ping>(self)));
        ___ivy_stack.pop_back();
    }
}
void example::msg__recv(example::msg self){
    {
    }
}
void example::reader__handle(const str& s){
    if((s == __lit<str>("ping"))){
        {
                        ping loc__m;
    loc__m.foo = (bool)___ivy_choose(0,"loc:m",140);
            {
                ___ivy_stack.push_back(240);
                handle_msg(example::msg(0, new example::msg::twrap<example::ping>(loc__m)));
                ___ivy_stack.pop_back();
            }
        }
    }
    else {
        if((s == __lit<str>("pong"))){
            {
                                pong loc__m;
    loc__m.foo = (bool)___ivy_choose(0,"loc:m",141);
                {
                    ___ivy_stack.push_back(241);
                    handle_msg(example::msg(1, new example::msg::twrap<example::pong>(loc__m)));
                    ___ivy_stack.pop_back();
                }
            }
        }
    }
}
example::str example::pong__to_str(const pong& self){
    example::str res;
    res = __lit<str>("pong");
    return res;
}
void example::str__append(str& a, unsigned v){
    {

        a.push_back(v);
    }
}
void example::ext__tcp_intf__recv(int s, const str& p){
    {
        std::cout << "{" << std::endl;
        std::cout << "    \"event\" : \"recv\"," << std::endl;
        std::cout << "    \"sock\" : ";
        std::cout << s;
        std::cout << "," << std::endl;
        std::cout << "    \"inp\" : ";
        std::cout << p;
        std::cout << "," << std::endl;
        std::cout << "}" << std::endl;
        {
            {
                                unsigned long long loc__idx;
    loc__idx = (unsigned long long)___ivy_choose(0,"loc:idx",144);
                {
                    loc__idx = str__begin(p);
                    {
                                                unsigned long long loc__loc__end;
    loc__loc__end = (unsigned long long)___ivy_choose(0,"loc:loc:end",143);
                        {
                            loc__loc__end = str__end(p);
                            while((loc__idx < loc__loc__end)){
                                {
                                    {
                                                                                unsigned loc__b;
    loc__b = (unsigned)___ivy_choose(0,"loc:b",142);
                                        {
                                            loc__b = str__value(p,loc__idx);
                                            if((loc__b == (10 & 255))){
                                                {
                                                    ___ivy_stack.push_back(243);
                                                    reader__handle(reader__buffer);
                                                    ___ivy_stack.pop_back();
                                                    ___ivy_stack.push_back(244);
                                                    reader__buffer = str__empty();
                                                    ___ivy_stack.pop_back();
                                                }
                                            }
                                            else {
                                                ___ivy_stack.push_back(245);
                                                str__append(reader__buffer, loc__b);
                                                ___ivy_stack.pop_back();
                                            }
                                            ___ivy_stack.push_back(246);
                                            loc__idx = index__next(loc__idx);
                                            ___ivy_stack.pop_back();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void example::ext__tcp_intf__connected(int s){
    {
    }
}
void example::handle_msg(example::msg m){
    {
                pong self__COLON__pong;
        if (((m).tag == 1)) self__COLON__pong = example::msg::unwrap< example::pong >(m);
        if(((m).tag == 1)){
            ___ivy_stack.push_back(247);
            pong__recv(self__COLON__pong);
            ___ivy_stack.pop_back();
        }
        else {
            {
                                ping self__COLON__ping;
                if (((m).tag == 0)) self__COLON__ping = example::msg::unwrap< example::ping >(m);
                if(((m).tag == 0)){
                    ___ivy_stack.push_back(248);
                    ping__recv(self__COLON__ping);
                    ___ivy_stack.pop_back();
                }
                else {
                    ___ivy_stack.push_back(249);
                    msg__recv(m);
                    ___ivy_stack.pop_back();
                }
            }
        }
    }
}
int example::tcp_intf__connect(const ip__endpoint& other){
    int s;
    s = (int)___ivy_choose(0,"fml:s",0);
    s = make_tcp_socket();
    // std::cout << "SOCKET " << s << std::endl;

    // create a send queue for this socket, if needed, along with
    // its thread. if the queue exists, it must be closed, so
    // we open it.

    tcp_queue *queue;
    if (tcp_intf__send_queue.find(s) == tcp_intf__send_queue.end()) {
        tcp_intf__send_queue[s] = queue = new tcp_queue(other);
         install_thread(new tcp_writer(s,queue,*tcp_intf__cb,this));
    } else
        tcp_intf__send_queue[s] -> set_open(other);
    return s;
}
void example::ext__pong__send(pong self){
    {
        ivy_assume(false, "example.ivy: line 57");
        ___ivy_stack.push_back(250);
        writer__write(tcp_sock, example::msg(1, new example::msg::twrap<example::pong>(self)));
        ___ivy_stack.pop_back();
    }
}
unsigned long long example::index__next(unsigned long long x){
    unsigned long long y;
    y = (unsigned long long)___ivy_choose(0,"fml:y",0);
    {
        y = (x + 1);
    }
    return y;
}
void example::tcp_intf__handle_recv(int s, const str& x){
    ___ivy_stack.push_back(251);
    ext__tcp_intf__recv(s, x);
    ___ivy_stack.pop_back();
}
void example::pong__recv(const pong& self){
    {
        ivy_assert(pending, "example.ivy: line 53");
        pending = false;
    }
}
void example::writer__write(int s, example::msg inp){
    {
                str loc__0;
                bool loc__1;
    loc__1 = (bool)___ivy_choose(0,"loc:1",146);
        {
            {
                                pong self__COLON__pong;
                if (((inp).tag == 1)) self__COLON__pong = example::msg::unwrap< example::pong >(inp);
                if(((inp).tag == 1)){
                    ___ivy_stack.push_back(252);
                    loc__0 = pong__to_str(self__COLON__pong);
                    ___ivy_stack.pop_back();
                }
                else {
                    {
                                                ping self__COLON__ping;
                        if (((inp).tag == 0)) self__COLON__ping = example::msg::unwrap< example::ping >(inp);
                        if(((inp).tag == 0)){
                            ___ivy_stack.push_back(253);
                            loc__0 = ping__to_str(self__COLON__ping);
                            ___ivy_stack.pop_back();
                        }
                        else {
                            ___ivy_stack.push_back(254);
                            loc__0 = msg__to_str(inp);
                            ___ivy_stack.pop_back();
                        }
                    }
                }
            }
            ___ivy_stack.push_back(255);
            loc__1 = tcp_intf__send(s, loc__0);
            ___ivy_stack.pop_back();
            {
                                bool loc__ok;
    loc__ok = (bool)___ivy_choose(0,"loc:ok",145);
                {
                    loc__ok = loc__1;
                }
            }
        }
    }
}
bool example::tcp_intf__send(int s, const str& p){
    bool ok;
    ok = (bool)___ivy_choose(0,"fml:ok",0);
                    std::vector<char> buf;
                    buf.resize(p.size());
                    std::copy(p.begin(),p.end(),buf.begin());
    //                std::cout << "SENDING\n";
    
                    // if the send queue for this sock doesn's exist, it isn't open,
                    // so the client has violated the precondition. we do the bad client
                    // the service of not crashing.
    
                    if (tcp_intf__send_queue.find(s) == tcp_intf__send_queue.end())
                        ok = true;
    
                    else {
                        // get the send queue, and enqueue the packet, returning false if
                        // the queue is closed.
    
                        ok = !tcp_intf__send_queue[s]->enqueue_swap(buf);
                   }
    return ok;
}
void example::ext__tcp_intf__accept(int s, const ip__endpoint& other){
    {
    }
}
void example::tcp_intf__handle_connected(int s){
    ___ivy_stack.push_back(256);
    ext__tcp_intf__connected(s);
    ___ivy_stack.pop_back();
}
void example::__tick(int __timeout){
}
example::example(ip__endpoint server_addr){
#ifdef _WIN32
mutex = CreateMutex(NULL,FALSE,NULL);
#else
pthread_mutex_init(&mutex,NULL);
#endif
__lock();
    __CARD__index = 0;
    __CARD__tcp_intf__socket = 0;
    __CARD__uint__8__ = 256;
    __CARD__ip__addr = 4294967296;
    __CARD__ip__port = 65536;


    // Create the callbacks. In a parameterized instance, this creates
    // one set of callbacks for each endpoint id. When you put an
    // action in anti-quotes it creates a function object (a "thunk")
    // that captures the instance environment, in this case including
    // the instance's endpoint id "me".

    tcp_intf__cb = new tcp_callbacks(thunk__tcp_intf__handle_accept(this),thunk__tcp_intf__handle_recv(this),thunk__tcp_intf__handle_fail(this),thunk__tcp_intf__handle_connected(this));
this->server_addr = server_addr;
}
example::~example(){
    __lock(); // otherwise, thread may die holding lock!
    for (unsigned i = 0; i < thread_ids.size(); i++){
#ifdef _WIN32
       // No idea how to cancel a thread on Windows. We just suspend it
       // so it can't cause any harm as we destruct this object.
       SuspendThread(thread_ids[i]);
#else
        pthread_cancel(thread_ids[i]);
        pthread_join(thread_ids[i],NULL);
#endif
    }
    __unlock();
}

class init_gen : public gen {
public:
    init_gen(example&);
    bool generate(example&);
    void execute(example&){}
};
init_gen::init_gen(example &obj){
    mk_int("tcp_intf.socket");
mk_sort("ip.endpoint");
    mk_bv("ip.addr",32);
mk_sort("pong");
    mk_int("index");
    const char *ip__protocol_values[2] = {"ip.udp","ip.tcp"};
    mk_enum("ip.protocol",2,ip__protocol_values);
mk_sort("ping");
    mk_bv("uint[8]",8);
mk_sort("str");
mk_sort("msg");
    mk_bv("ip.port",16);
    const char *__tmp0_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.port",1,__tmp0_domain,"ip.port");
    const char *__tmp1_domain[1] = {"pong"};
    mk_decl("pong.foo",1,__tmp1_domain,"Bool");
    const char *__tmp2_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.protocol",1,__tmp2_domain,"ip.protocol");
    const char *__tmp3_domain[1] = {"str"};
    mk_decl("str.end",1,__tmp3_domain,"index");
    mk_const("tcp_sock","tcp_intf.socket");
    mk_const("_generating","Bool");
    const char *__tmp4_domain[1] = {"ping"};
    mk_decl("ping.foo",1,__tmp4_domain,"Bool");
    mk_const("reader.buffer","str");
    const char *__tmp5_domain[1] = {"str"};
    mk_decl("str.begin",1,__tmp5_domain,"index");
    const char *__tmp6_domain[2] = {"str","index"};
    mk_decl("str.value",2,__tmp6_domain,"uint[8]");
    mk_const("pending","Bool");
    mk_const("server_addr","ip.endpoint");
    const char *__tmp7_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.addr",1,__tmp7_domain,"ip.addr");
    add("(assert (and\
      and\
    ))");
}
bool init_gen::generate(example& obj) {
    example::msg::prepare();
    alits.clear();
    obj.tcp_sock = (int)0;
    obj._generating = (bool)(rand() % ((2)-(0)) + (0));
    obj.pending = (bool)(rand() % ((2)-(0)) + (0));

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {

    }
example::msg::cleanup();

    obj.___ivy_gen = this;
    obj.__init();
    return __res;
}
class ext__ping__send_gen : public gen {
  public:
    example::ping self;
    ext__ping__send_gen(example&);
    bool generate(example&);
    void execute(example&);
};
ext__ping__send_gen::ext__ping__send_gen(example &obj){
    mk_int("tcp_intf.socket");
mk_sort("ip.endpoint");
    mk_bv("ip.addr",32);
mk_sort("pong");
    mk_int("index");
    const char *ip__protocol_values[2] = {"ip.udp","ip.tcp"};
    mk_enum("ip.protocol",2,ip__protocol_values);
mk_sort("ping");
    mk_bv("uint[8]",8);
mk_sort("str");
mk_sort("msg");
    mk_bv("ip.port",16);
    const char *__tmp8_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.port",1,__tmp8_domain,"ip.port");
    const char *__tmp9_domain[1] = {"pong"};
    mk_decl("pong.foo",1,__tmp9_domain,"Bool");
    const char *__tmp10_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.protocol",1,__tmp10_domain,"ip.protocol");
    const char *__tmp11_domain[1] = {"str"};
    mk_decl("str.end",1,__tmp11_domain,"index");
    mk_const("tcp_sock","tcp_intf.socket");
    mk_const("_generating","Bool");
    const char *__tmp12_domain[1] = {"ping"};
    mk_decl("ping.foo",1,__tmp12_domain,"Bool");
    mk_const("reader.buffer","str");
    const char *__tmp13_domain[1] = {"str"};
    mk_decl("str.begin",1,__tmp13_domain,"index");
    const char *__tmp14_domain[2] = {"str","index"};
    mk_decl("str.value",2,__tmp14_domain,"uint[8]");
    mk_const("pending","Bool");
    mk_const("server_addr","ip.endpoint");
    const char *__tmp15_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.addr",1,__tmp15_domain,"ip.addr");
    mk_const("__fml:self","ping");
    const char *__tmp16_domain[2] = {"msg","pong"};
    mk_decl("*>:msg:pong",2,__tmp16_domain,"Bool");
    const char *__tmp17_domain[2] = {"msg","ping"};
    mk_decl("*>:msg:ping",2,__tmp17_domain,"Bool");
    add("(assert (let ((a!1 (forall ((|Z:ping| ping) (|X:msg| msg) (|Y:ping| ping)) "
"             (=> (and (|*>:msg:ping| |X:msg| |Y:ping|) "
"                      (|*>:msg:ping| |X:msg| |Z:ping|)) "
"                 (= |Y:ping| |Z:ping|)))) "
"      (a!2 (forall ((|Y:pong| pong) (|X:msg| msg) (|Z:pong| pong)) "
"             (=> (and (|*>:msg:pong| |X:msg| |Y:pong|) "
"                      (|*>:msg:pong| |X:msg| |Z:pong|)) "
"                 (= |Y:pong| |Z:pong|)))) "
"      (a!3 (forall ((|Z:ping| ping) (|Y:msg| msg) (|X:msg| msg)) "
"             (=> (and (|*>:msg:ping| |X:msg| |Z:ping|) "
"                      (|*>:msg:ping| |Y:msg| |Z:ping|)) "
"                 (= |X:msg| |Y:msg|)))) "
"      (a!4 (forall ((|Y:msg| msg) (|X:msg| msg) (|Z:pong| pong)) "
"             (=> (and (|*>:msg:pong| |X:msg| |Z:pong|) "
"                      (|*>:msg:pong| |Y:msg| |Z:pong|)) "
"                 (= |X:msg| |Y:msg|)))) "
"      (a!5 (forall ((|Y:pong| pong) (|Z:ping| ping) (|X:msg| msg)) "
"             (not (and (|*>:msg:pong| |X:msg| |Y:pong|) "
"                       (|*>:msg:ping| |X:msg| |Z:ping|)))))) "
"  (and (not pending) a!1 a!2 a!3 a!4 a!5)))");
}
bool ext__ping__send_gen::generate(example& obj) {
    push();
    example::msg::prepare();
    slvr.add(__to_solver(*this,apply("pending"),obj.pending));
    alits.clear();
    __randomize<example::ping>(*this,apply("__fml:self"),"ping");

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
                __from_solver<example::ping>(*this,apply("__fml:self"),self);

    }example::msg::cleanup();

    pop();
    obj.___ivy_gen = this;
    return __res;
}
void ext__ping__send_gen::execute(example& obj){
    __ivy_out << "> ping.send(" << self << ")" << std::endl;
    obj.ext__ping__send(self);
}
class ext__pong__send_gen : public gen {
  public:
    example::pong self;
    ext__pong__send_gen(example&);
    bool generate(example&);
    void execute(example&);
};
ext__pong__send_gen::ext__pong__send_gen(example &obj){
    mk_int("tcp_intf.socket");
mk_sort("ip.endpoint");
    mk_bv("ip.addr",32);
mk_sort("pong");
    mk_int("index");
    const char *ip__protocol_values[2] = {"ip.udp","ip.tcp"};
    mk_enum("ip.protocol",2,ip__protocol_values);
mk_sort("ping");
    mk_bv("uint[8]",8);
mk_sort("str");
mk_sort("msg");
    mk_bv("ip.port",16);
    const char *__tmp18_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.port",1,__tmp18_domain,"ip.port");
    const char *__tmp19_domain[1] = {"pong"};
    mk_decl("pong.foo",1,__tmp19_domain,"Bool");
    const char *__tmp20_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.protocol",1,__tmp20_domain,"ip.protocol");
    const char *__tmp21_domain[1] = {"str"};
    mk_decl("str.end",1,__tmp21_domain,"index");
    mk_const("tcp_sock","tcp_intf.socket");
    mk_const("_generating","Bool");
    const char *__tmp22_domain[1] = {"ping"};
    mk_decl("ping.foo",1,__tmp22_domain,"Bool");
    mk_const("reader.buffer","str");
    const char *__tmp23_domain[1] = {"str"};
    mk_decl("str.begin",1,__tmp23_domain,"index");
    const char *__tmp24_domain[2] = {"str","index"};
    mk_decl("str.value",2,__tmp24_domain,"uint[8]");
    mk_const("pending","Bool");
    mk_const("server_addr","ip.endpoint");
    const char *__tmp25_domain[1] = {"ip.endpoint"};
    mk_decl("ip.endpoint.addr",1,__tmp25_domain,"ip.addr");
    mk_const("__fml:self","pong");
    add("(assert (and or))");
}
bool ext__pong__send_gen::generate(example& obj) {
    push();
    example::msg::prepare();
    alits.clear();
    __randomize<example::pong>(*this,apply("__fml:self"),"pong");

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
                __from_solver<example::pong>(*this,apply("__fml:self"),self);

    }example::msg::cleanup();

    pop();
    obj.___ivy_gen = this;
    return __res;
}
void ext__pong__send_gen::execute(example& obj){
    __ivy_out << "> pong.send(" << self << ")" << std::endl;
    obj.ext__pong__send(self);
}
std::ostream &operator <<(std::ostream &s, const example::ip__endpoint &t){
    s<<"{";
    s<< "protocol:";
    s << t.protocol;
    s<<",";
    s<< "addr:";
    s << t.addr;
    s<<",";
    s<< "port:";
    s << t.port;
    s<<"}";
    return s;
}
template <>
void  __ser<example::ip__endpoint>(ivy_ser &res, const example::ip__endpoint&t){
    res.open_struct();
    res.open_field("protocol");
    __ser<example::ip__protocol>(res,t.protocol);
    res.close_field();
    res.open_field("addr");
    __ser<unsigned>(res,t.addr);
    res.close_field();
    res.open_field("port");
    __ser<unsigned>(res,t.port);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const example::ping &t){
    s<<"{";
    s<< "foo:";
    s << t.foo;
    s<<"}";
    return s;
}
template <>
void  __ser<example::ping>(ivy_ser &res, const example::ping&t){
    res.open_struct();
    res.open_field("foo");
    __ser<bool>(res,t.foo);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const example::pong &t){
    s<<"{";
    s<< "foo:";
    s << t.foo;
    s<<"}";
    return s;
}
template <>
void  __ser<example::pong>(ivy_ser &res, const example::pong&t){
    res.open_struct();
    res.open_field("foo");
    __ser<bool>(res,t.foo);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const example::ip__protocol &t){
    if (t == example::ip__udp) s<<"udp";
    if (t == example::ip__tcp) s<<"tcp";
    return s;
}
template <>
void  __ser<example::ip__protocol>(ivy_ser &res, const example::ip__protocol&t){
    __ser(res,(int)t);
}


int ask_ret(long long bound) {
    int res;
    while(true) {
        __ivy_out << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cerr << "value out of range" << std::endl;
    }
}



    class example_repl : public example {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assertion_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assertion failed\n";
            
            __ivy_exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assumption_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assumption failed\n";
            
            __ivy_exit(1);
        }
    }
    example_repl(ip__endpoint server_addr) : example(server_addr){}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
    int pos;
    syntax_error(int pos) : pos(pos) {}
};

void throw_syntax(int pos){
    throw syntax_error(pos);
}

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw_syntax(pos);
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    res.pos = pos;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw_syntax(pos);
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"') {
            char c = cmd[pos++];
            if (c == '\\') {
                if (pos == cmd.size())
                    throw_syntax(pos);
                c = cmd[pos++];
                c = (c == 'n') ? 10 : (c == 'r') ? 13 : (c == 't') ? 9 : c;
            }
            res.atom.push_back(c);
        }
        if(pos == cmd.size())
            throw_syntax(pos);
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw_syntax(pos);
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw_syntax(pos);
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
example::ip__endpoint _arg<example::ip__endpoint>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    example::ip__endpoint res;
    res.protocol = (example::ip__protocol)0;
    res.addr = (unsigned)0;
    res.port = (unsigned)0;
    ivy_value &arg = args[idx];
    std::vector<ivy_value> tmp_args(1);
    for (unsigned i = 0; i < arg.fields.size(); i++){
        if (arg.fields[i].is_member()){
            tmp_args[0] = arg.fields[i].fields[0];
            if (arg.fields[i].atom == "protocol"){
                try{
                    res.protocol = _arg<example::ip__protocol>(tmp_args,0,2);
                }
                catch(const out_of_bounds &err){
                    throw out_of_bounds("in field protocol: " + err.txt,err.pos);
                }
            }
            else if (arg.fields[i].atom == "addr"){
                try{
                    res.addr = _arg<unsigned>(tmp_args,0,4294967296);
                }
                catch(const out_of_bounds &err){
                    throw out_of_bounds("in field addr: " + err.txt,err.pos);
                }
            }
            else if (arg.fields[i].atom == "port"){
                try{
                    res.port = _arg<unsigned>(tmp_args,0,65536);
                }
                catch(const out_of_bounds &err){
                    throw out_of_bounds("in field port: " + err.txt,err.pos);
                }
            }
            else  throw out_of_bounds("unexpected field: " + arg.fields[i].atom,arg.fields[i].pos);
        }
        else throw out_of_bounds("expected struct",args[idx].pos);
    }
    return res;
}
template <>
void __deser<example::ip__endpoint>(ivy_deser &inp, example::ip__endpoint &res){
    inp.open_struct();
    inp.open_field("protocol");
    __deser(inp,res.protocol);
    inp.close_field();
    inp.open_field("addr");
    __deser(inp,res.addr);
    inp.close_field();
    inp.open_field("port");
    __deser(inp,res.port);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<example::ip__endpoint>( gen &g, const  z3::expr &v,example::ip__endpoint &res){
    __from_solver(g,g.apply("ip.endpoint.protocol",v),res.protocol);
    __from_solver(g,g.apply("ip.endpoint.addr",v),res.addr);
    __from_solver(g,g.apply("ip.endpoint.port",v),res.port);
}
template <>
z3::expr  __to_solver<example::ip__endpoint>( gen &g, const  z3::expr &v,example::ip__endpoint &val){
    std::string fname = g.fresh_name();
    z3::expr tmp = g.ctx.constant(fname.c_str(),g.sort("ip.endpoint"));
    g.slvr.add(__to_solver(g,g.apply("ip.endpoint.protocol",tmp),val.protocol));
    g.slvr.add(__to_solver(g,g.apply("ip.endpoint.addr",tmp),val.addr));
    g.slvr.add(__to_solver(g,g.apply("ip.endpoint.port",tmp),val.port));
    return v==tmp;
}
template <>
void  __randomize<example::ip__endpoint>( gen &g, const  z3::expr &v, const std::string &sort_name){
    __randomize<example::ip__protocol>(g,g.apply("ip.endpoint.protocol",v),"ip.protocol");
    __randomize<unsigned>(g,g.apply("ip.endpoint.addr",v),"ip.addr");
    __randomize<unsigned>(g,g.apply("ip.endpoint.port",v),"ip.port");
}
template <>
example::ping _arg<example::ping>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    example::ping res;
    res.foo = (bool)0;
    ivy_value &arg = args[idx];
    std::vector<ivy_value> tmp_args(1);
    for (unsigned i = 0; i < arg.fields.size(); i++){
        if (arg.fields[i].is_member()){
            tmp_args[0] = arg.fields[i].fields[0];
            if (arg.fields[i].atom == "foo"){
                try{
                    res.foo = _arg<bool>(tmp_args,0,2);
                }
                catch(const out_of_bounds &err){
                    throw out_of_bounds("in field foo: " + err.txt,err.pos);
                }
            }
            else  throw out_of_bounds("unexpected field: " + arg.fields[i].atom,arg.fields[i].pos);
        }
        else throw out_of_bounds("expected struct",args[idx].pos);
    }
    return res;
}
template <>
void __deser<example::ping>(ivy_deser &inp, example::ping &res){
    inp.open_struct();
    inp.open_field("foo");
    __deser(inp,res.foo);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<example::ping>( gen &g, const  z3::expr &v,example::ping &res){
    __from_solver(g,g.apply("ping.foo",v),res.foo);
}
template <>
z3::expr  __to_solver<example::ping>( gen &g, const  z3::expr &v,example::ping &val){
    std::string fname = g.fresh_name();
    z3::expr tmp = g.ctx.constant(fname.c_str(),g.sort("ping"));
    g.slvr.add(__to_solver(g,g.apply("ping.foo",tmp),val.foo));
    return v==tmp;
}
template <>
void  __randomize<example::ping>( gen &g, const  z3::expr &v, const std::string &sort_name){
    __randomize<bool>(g,g.apply("ping.foo",v),"bool");
}
template <>
example::pong _arg<example::pong>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    example::pong res;
    res.foo = (bool)0;
    ivy_value &arg = args[idx];
    std::vector<ivy_value> tmp_args(1);
    for (unsigned i = 0; i < arg.fields.size(); i++){
        if (arg.fields[i].is_member()){
            tmp_args[0] = arg.fields[i].fields[0];
            if (arg.fields[i].atom == "foo"){
                try{
                    res.foo = _arg<bool>(tmp_args,0,2);
                }
                catch(const out_of_bounds &err){
                    throw out_of_bounds("in field foo: " + err.txt,err.pos);
                }
            }
            else  throw out_of_bounds("unexpected field: " + arg.fields[i].atom,arg.fields[i].pos);
        }
        else throw out_of_bounds("expected struct",args[idx].pos);
    }
    return res;
}
template <>
void __deser<example::pong>(ivy_deser &inp, example::pong &res){
    inp.open_struct();
    inp.open_field("foo");
    __deser(inp,res.foo);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<example::pong>( gen &g, const  z3::expr &v,example::pong &res){
    __from_solver(g,g.apply("pong.foo",v),res.foo);
}
template <>
z3::expr  __to_solver<example::pong>( gen &g, const  z3::expr &v,example::pong &val){
    std::string fname = g.fresh_name();
    z3::expr tmp = g.ctx.constant(fname.c_str(),g.sort("pong"));
    g.slvr.add(__to_solver(g,g.apply("pong.foo",tmp),val.foo));
    return v==tmp;
}
template <>
void  __randomize<example::pong>( gen &g, const  z3::expr &v, const std::string &sort_name){
    __randomize<bool>(g,g.apply("pong.foo",v),"bool");
}
template <>
example::ip__protocol _arg<example::ip__protocol>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    ivy_value &arg = args[idx];
    if (arg.atom.size() == 0 || arg.fields.size() != 0) throw out_of_bounds(idx,arg.pos);
    if(arg.atom == "udp") return example::ip__udp;
    if(arg.atom == "tcp") return example::ip__tcp;
    throw out_of_bounds("bad value: " + arg.atom,arg.pos);
}
template <>
void __deser<example::ip__protocol>(ivy_deser &inp, example::ip__protocol &res){
    int __res;
    __deser(inp,__res);
    res = (example::ip__protocol)__res;
}
template <>
z3::expr  __to_solver<example::ip__protocol>( gen &g, const  z3::expr &v,example::ip__protocol &val){
    int thing = val;
    return __to_solver<int>(g,v,thing);
}
template <>
void  __from_solver<example::ip__protocol>( gen &g, const  z3::expr &v,example::ip__protocol &res){
    int temp;
    __from_solver<int>(g,v,temp);
    res = (example::ip__protocol)temp;
}
template <>
void  __randomize<example::ip__protocol>( gen &g, const  z3::expr &v, const std::string &sort_name){
    __randomize<int>(g,v,sort_name);
}


class stdin_reader: public reader {
    std::string buf;
    std::string eof_flag;

public:
    bool eof(){
      return eof_flag.size();
    }
    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        if (chars == 0) {  // EOF
            if (buf.size())
                process(buf);
            eof_flag = "eof";
        }
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        __ivy_out << line;
    }
};

class cmd_reader: public stdin_reader {
    int lineno;
public:
    example_repl &ivy;    

    cmd_reader(example_repl &_ivy) : ivy(_ivy) {
        lineno = 1;
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);
            ivy.__lock();

                if (action == "ping.send") {
                    check_arity(args,1,action);
                    ivy.ext__ping__send(_arg<example::ping>(args,0,0));
                }
                else
    
                if (action == "pong.send") {
                    check_arity(args,1,action);
                    ivy.ext__pong__send(_arg<example::pong>(args,0,0));
                }
                else
    
            {
                std::cerr << "undefined action: " << action << std::endl;
            }
            ivy.__unlock();
        }
        catch (syntax_error& err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": " << err.txt << " bad value" << std::endl;
        }
        catch (bad_arity &err) {
            ivy.__unlock();
            std::cerr << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
        lineno++;
    }
};



int main(int argc, char **argv){
        int test_iters = 100;
        int runs = 1;
    example::ip__endpoint p__server_addr;

    int seed = 1;
    int sleep_ms = 10;
    int final_ms = 0; 
    
    std::vector<char *> pargs; // positional args
    pargs.push_back(argv[0]);
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        size_t p = arg.find('=');
        if (p == std::string::npos)
            pargs.push_back(argv[i]);
        else {
            std::string param = arg.substr(0,p);
            std::string value = arg.substr(p+1);

            if (param == "out") {
                __ivy_out.open(value.c_str());
                if (!__ivy_out) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else if (param == "iters") {
                test_iters = atoi(value.c_str());
            }
            else if (param == "runs") {
                runs = atoi(value.c_str());
            }
            else if (param == "seed") {
                seed = atoi(value.c_str());
            }
            else if (param == "delay") {
                sleep_ms = atoi(value.c_str());
            }
            else if (param == "wait") {
                final_ms = atoi(value.c_str());
            }
            else if (param == "modelfile") {
                __ivy_modelfile.open(value.c_str());
                if (!__ivy_modelfile) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else {
                std::cerr << "unknown option: " << param << std::endl;
                return 1;
            }
        }
    }
    srand(seed);
    if (!__ivy_out.is_open())
        __ivy_out.basic_ios<char>::rdbuf(std::cout.rdbuf());
    argc = pargs.size();
    argv = &pargs[0];
    if (argc == 3){
        argc--;
        int fd = _open(argv[argc],0);
        if (fd < 0){
            std::cerr << "cannot open to read: " << argv[argc] << "\n";
            __ivy_exit(1);
        }
        _dup2(fd, 0);
    }
    if (argc != 2){
        std::cerr << "usage: example server_addr\n";
        __ivy_exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(1);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}
    try {
        int pos = 0;
        arg_values[0] = parse_value(args[0],pos);
        p__server_addr =  _arg<example::ip__endpoint>(arg_values,0,0);
    }
    catch(out_of_bounds &) {
        std::cerr << "parameter server_addr out of bounds\n";
        __ivy_exit(1);
    }
    catch(syntax_error &) {
        std::cerr << "syntax error in command argument\n";
        __ivy_exit(1);
    }

#ifdef _WIN32
    // Boilerplate from windows docs

    {
        WORD wVersionRequested;
        WSADATA wsaData;
        int err;

    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
        wVersionRequested = MAKEWORD(2, 2);

        err = WSAStartup(wVersionRequested, &wsaData);
        if (err != 0) {
            /* Tell the user that we could not find a usable */
            /* Winsock DLL.                                  */
            printf("WSAStartup failed with error: %d\n", err);
            return 1;
        }

    /* Confirm that the WinSock DLL supports 2.2.*/
    /* Note that if the DLL supports versions greater    */
    /* than 2.2 in addition to 2.2, it will still return */
    /* 2.2 in wVersion since that is the version we      */
    /* requested.                                        */

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            /* Tell the user that we could not find a usable */
            /* WinSock DLL.                                  */
            printf("Could not find a usable version of Winsock.dll\n");
            WSACleanup();
            return 1;
        }
    }
#endif
    for(int runidx = 0; runidx < runs; runidx++) {
    initializing = true;
    example_repl ivy(p__server_addr);
    for(unsigned i = 0; i < argc; i++) {ivy.__argv.push_back(argv[i]);}
    ivy._generating = false;

        ivy.__unlock();
        initializing = false;
        for(int rdridx = 0; rdridx < readers.size(); rdridx++) {
            readers[rdridx]->bind();
        }
                    
        init_gen my_init_gen(ivy);
        my_init_gen.generate(ivy);
        std::vector<gen *> generators;
        std::vector<double> weights;

        generators.push_back(new ext__ping__send_gen(ivy));
        weights.push_back(1.0);
        generators.push_back(new ext__pong__send_gen(ivy));
        weights.push_back(1.0);
        double totalweight = 2.0;
        int num_gens = 2;


#ifdef _WIN32
    LARGE_INTEGER freq;
    QueryPerformanceFrequency(&freq);
#endif
    double frnd = 0.0;
    bool do_over = false;
    for(int cycle = 0; cycle < test_iters; cycle++) {

//        std::cout << "totalweight = " << totalweight << std::endl;
//        double choices = totalweight + readers.size() + timers.size();
        double choices = totalweight + 5.0;
        if (do_over) {
           do_over = false;
        }  else {
            frnd = choices * (((double)rand())/(((double)RAND_MAX)+1.0));
        }
        // std::cout << "frnd = " << frnd << std::endl;
        if (frnd < totalweight) {
            int idx = 0;
            double sum = 0.0;
            while (idx < num_gens-1) {
                sum += weights[idx];
                if (frnd < sum)
                    break;
                idx++;
            }
            gen &g = *generators[idx];
            ivy.__lock();
#ifdef _WIN32
            LARGE_INTEGER before;
            QueryPerformanceCounter(&before);
#endif
            ivy._generating = true;
            bool sat = g.generate(ivy);
#ifdef _WIN32
            LARGE_INTEGER after;
            QueryPerformanceCounter(&after);
//            __ivy_out << "idx: " << idx << " sat: " << sat << " time: " << (((double)(after.QuadPart-before.QuadPart))/freq.QuadPart) << std::endl;
#endif
            if (sat){
                g.execute(ivy);
                ivy._generating = false;
                ivy.__unlock();
#ifdef _WIN32
                Sleep(sleep_ms);
#endif
            }
            else {
                ivy._generating = false;
                ivy.__unlock();
                cycle--;
            }
            continue;
        }


        fd_set rdfds;
        FD_ZERO(&rdfds);
        int maxfds = 0;

        for (unsigned i = 0; i < readers.size(); i++) {
            reader *r = readers[i];
            int fds = r->fdes();
            if (fds >= 0) {
                FD_SET(fds,&rdfds);
            }
            if (fds > maxfds)
                maxfds = fds;
        }

#ifdef _WIN32
        int timer_min = 15;
#else
        int timer_min = 5;
#endif

        struct timeval timeout;
        timeout.tv_sec = timer_min/1000;
        timeout.tv_usec = 1000 * (timer_min % 1000);

#ifdef _WIN32
        int foo;
        if (readers.size() == 0){  // winsock can't handle empty fdset!
            Sleep(timer_min);
            foo = 0;
        }
        else
            foo = select(maxfds+1,&rdfds,0,0,&timeout);
#else
        int foo = select(maxfds+1,&rdfds,0,0,&timeout);
#endif

        if (foo < 0)
#ifdef _WIN32
            {std::cerr << "select failed: " << WSAGetLastError() << std::endl; __ivy_exit(1);}
#else
            {perror("select failed"); __ivy_exit(1);}
#endif
        
        if (foo == 0){
           // std::cout << "TIMEOUT\n";            
           cycle--;
           for (unsigned i = 0; i < timers.size(); i++){
               if (timer_min >= timers[i]->ms_delay()) {
                   cycle++;
                   break;
               }
           }
           for (unsigned i = 0; i < timers.size(); i++)
               timers[i]->timeout(timer_min);
        }
        else {
            int fdc = 0;
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds))
                    fdc++;
            }
            // std::cout << "fdc = " << fdc << std::endl;
            int fdi = fdc * (((double)rand())/(((double)RAND_MAX)+1.0));
            fdc = 0;
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds)) {
                    if (fdc == fdi) {
                        // std::cout << "reader = " << i << std::endl;
                        r->read();
                        if (r->background()) {
                           cycle--;
                           do_over = true;
                        }
                        break;
                    }
                    fdc++;

                }
            }
        }            
    }
    
#ifdef _WIN32
                Sleep(final_ms);  // HACK: wait for late responses
#endif
    __ivy_out << "test_completed" << std::endl;
    if (runidx == runs-1) {
        struct timespec ts;
        int ms = 50;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = (ms % 1000) * 1000000;
        nanosleep(&ts,NULL);
        exit(0);
    }
    for (unsigned i = 0; i < readers.size(); i++)
        delete readers[i];
    readers.clear();
    for (unsigned i = 0; i < timers.size(); i++)
        delete timers[i];
    timers.clear();


    }
    return 0;
}
