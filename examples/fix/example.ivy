#lang ivy1.8

include ip
include tcp_host
include collections
include numbers
include string

# Types for encoding messages

alias byte = uint[8]
instance str : string(index,byte)

# Base class of messages

class msg = {
    method send   # message observed from client to server
    method recv   # message observed from server to client

    method to_str returns (res:str)  # convert message to string
}

# The protocol: clinet sends ping, server responds with pong
# ----------------------------------------------------------

# Protocol state: indicates a "ping" message is pending

var pending : bool

after init {
    pending := false;
}

# Ping message sent from clent to server

subclass ping of msg = {
    field foo : bool   # need a field to work around Ivy bug
    method recv
    method send

    # If we see it sent from client to server, set pending
    before send {
        require ~pending;
        pending := true;
    }

    # Ping should never be sent by server
    before recv {
        require false;
    }

    # Encoding of this message
    method to_str returns (res:str) = {
        res := "ping";
    }
}

# Pong message sent from server to client

subclass pong of msg = {
    field foo : bool   # need a field to work around Ivy bug
    method recv
    method send

    # On observing pong from server to client, pending set to false
    before recv {
        require pending;
        pending := false;
    }
    
    # Ping should never be sent by client
    before send {
        require false;
    }

    method to_str returns (res:str) = {
        res := "pong";
    }
}


# End of protocol spec

# The shim
# --------

# This module reads messages from a stream interface, decodes them,
# and calls `recv`. Messages are terminated with a newline character
# (10).

module msg_reader(intf,recv) = {

    var buffer : str
    
    implement intf.recv(s : intf.socket, inp : str)  {
        debug "recv" with sock = s, inp = inp;
        for idx,b in inp {
            if b = 10 {
                decode(buffer);
                buffer := str.empty;
            } else {
                buffer := buffer.append(b);
            }
        }
    }

    # Decoding happens here
    
    action decode(s : str) = {
        if s = "ping" {
            var m : ping;
            recv(m);
        } else if s = "pong" {
            var m : pong;
            recv(m);
        }
    }
}

# This module encodes messages and sends them on a stream interface.

module msg_writer(intf) = {

    var buffer : str
    
    action write(s : intf.socket, inp : msg) = {
        var enc := inp.to_str.append(10);
        var ok := intf.send(s,enc);
    }
}

# Instance a TCP interface

instance tcp_intf : tcp_host(ip.endpoint,str)

# A socket on the TCP interface

var tcp_sock : tcp_intf.socket

# Server address is passed in on command line.

parameter server_addr : ip.endpoint

# On init, connect to server.

after init {
    tcp_sock := tcp_intf.connect(server_addr);
}

# Instantiate a reader (decodeer) and writer (encoder)

instance reader : msg_reader(tcp_intf,handle_msg)
instance writer : msg_writer(tcp_intf)

# This is the call-back from the reader. Since the tester is
# simulating the client and we are testing a server, we call the
# `recv` method of the message. It would be `send` for testing a
# client.

action handle_msg(m : msg) = {
    m.recv;
}

# Since the tester is simulating the client, we export the `send`
# methods.  You might think we could export `msg.send`, but this
# doesn't work.

export ping.send
export pong.send

# On send, for each message type, we call the writer. It would be nice if we could
# say `after msg.send` but this doesn't work.

implement ping.send(self:ping) {
    writer.write(tcp_sock,self);
}

implement pong.send(self:pong) {
    writer.write(tcp_sock,self);
}

# Run like this:

# In one terminal:
#
#     $ python server.py
#

# In another terminal:
#
#     $ ./example '{addr:0x7f000001,port:4997}'
#




