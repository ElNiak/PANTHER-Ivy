#include "s3_test.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <winsock2.h>
#include <WS2tcpip.h>
#include <io.h>
#define isatty _isatty
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <unistd.h>
#define _open open
#define _dup2 dup2
#endif
#include <string.h>
#include <stdio.h>
#include <string>
#if __cplusplus < 201103L
#else
#include <cstdint>
#endif
typedef s3_test ivy_class;
std::ofstream __ivy_out;
std::ofstream __ivy_modelfile;
void __ivy_exit(int code){exit(code);}

class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
    virtual void bind() {}
    virtual bool running() {return fdes() >= 0;}
    virtual ~reader() {}
};

class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
    virtual ~timer() {}
};

#ifdef _WIN32
DWORD WINAPI ReaderThreadFunction( LPVOID lpParam ) 
{
    reader *cr = (reader *) lpParam;
    cr->bind();
    while (true)
        cr->read();
    return 0;
} 

DWORD WINAPI TimerThreadFunction( LPVOID lpParam ) 
{
    timer *cr = (timer *) lpParam;
    while (true) {
        int ms = cr->ms_delay();
        Sleep(ms);
        cr->timeout(ms);
    }
    return 0;
} 
#else
void * _thread_reader(void *rdr_void) {
    reader *rdr = (reader *) rdr_void;
    rdr->bind();
    while(rdr->running()) {
        rdr->read();
    }
    delete rdr;
    return 0; // just to stop warning
}

void * _thread_timer( void *tmr_void ) 
{
    timer *tmr = (timer *) tmr_void;
    while (true) {
        int ms = tmr->ms_delay();
        struct timespec ts;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = (ms % 1000) * 1000000;
        nanosleep(&ts,NULL);
        tmr->timeout(ms);
    }
    return 0;
} 
#endif 

void s3_test::install_reader(reader *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ReaderThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(h);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_reader, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      

void s3_test::install_thread(reader *r) {
    install_reader(r);
}

void s3_test::install_timer(timer *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            TimersThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(h);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_timer, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      


#ifdef _WIN32
    void s3_test::__lock() { WaitForSingleObject(mutex,INFINITE); }
    void s3_test::__unlock() { ReleaseMutex(mutex); }
#else
    void s3_test::__lock() { pthread_mutex_lock(&mutex); }
    void s3_test::__unlock() { pthread_mutex_unlock(&mutex); }
#endif
struct thunk___GetObject__response_GetObjectOutput{
    s3_test *__ivy;
    thunk___GetObject__response_GetObjectOutput(s3_test *__ivy): __ivy(__ivy){}
    void operator()(s3_test::_GetObjectOutput val) const {
        __ivy->_GetObject__response_GetObjectOutput(val);
    }
};
struct thunk___PutObject__response_PutObjectOutput{
    s3_test *__ivy;
    thunk___PutObject__response_PutObjectOutput(s3_test *__ivy): __ivy(__ivy){}
    void operator()(s3_test::_PutObjectOutput val) const {
        __ivy->_PutObject__response_PutObjectOutput(val);
    }
};

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#ifndef __fallthrough
#define __fallthrough
#endif

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}




struct ivy_value {
    int pos;
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct deser_err {
};

struct ivy_ser {
    virtual void  set(long long) = 0;
    virtual void  set(bool) = 0;
    virtual void  setn(long long inp, int len) = 0;
    virtual void  set(const std::string &) = 0;
    virtual void  open_list(int len) = 0;
    virtual void  close_list() = 0;
    virtual void  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual void  open_tag(int, const std::string &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual ~ivy_ser(){}
};
struct ivy_binary_ser : public ivy_ser {
    std::vector<char> res;
    void setn(long long inp, int len) {
        for (int i = len-1; i >= 0 ; i--)
            res.push_back((inp>>(8*i))&0xff);
    }
    void set(long long inp) {
        setn(inp,sizeof(long long));
    }
    void set(bool inp) {
        set((long long)inp);
    }
    void set(const std::string &inp) {
        for (unsigned i = 0; i < inp.size(); i++)
            res.push_back(inp[i]);
        res.push_back(0);
    }
    void open_list(int len) {
        set((long long)len);
    }
    void close_list() {}
    void open_list_elem() {}
    void close_list_elem() {}
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    virtual void  open_tag(int tag, const std::string &) {
        set((long long)tag);
    }
    virtual void  close_tag() {}
};

struct ivy_deser {
    virtual void  get(long long&) = 0;
    virtual void  get(std::string &) = 0;
    virtual void  getn(long long &res, int bytes) = 0;
    virtual void  open_list() = 0;
    virtual void  close_list() = 0;
    virtual bool  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual int   open_tag(const std::vector<std::string> &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual void  end() = 0;
    virtual ~ivy_deser(){}
};

struct ivy_binary_deser : public ivy_deser {
    std::vector<char> inp;
    int pos;
    std::vector<int> lenstack;
    ivy_binary_deser(const std::vector<char> &inp) : inp(inp),pos(0) {}
    virtual bool more(unsigned bytes) {return inp.size() >= pos + bytes;}
    virtual bool can_end() {return pos == inp.size();}
    void get(long long &res) {
       getn(res,8);
    }
    void getn(long long &res, int bytes) {
        if (!more(bytes))
            throw deser_err();
        res = 0;
        for (int i = 0; i < bytes; i++)
            res = (res << 8) | (((long long)inp[pos++]) & 0xff);
    }
    void get(std::string &res) {
        while (more(1) && inp[pos]) {
//            if (inp[pos] == '"')
//                throw deser_err();
            res.push_back(inp[pos++]);
        }
        if(!(more(1) && inp[pos] == 0))
            throw deser_err();
        pos++;
    }
    void open_list() {
        long long len;
        get(len);
        lenstack.push_back(len);
    }
    void close_list() {
        lenstack.pop_back();
    }
    bool open_list_elem() {
        return lenstack.back();
    }
    void close_list_elem() {
        lenstack.back()--;
    }
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    int open_tag(const std::vector<std::string> &tags) {
        long long res;
        get(res);
        if (res >= tags.size())
            throw deser_err();
        return res;
    }
    void end() {
        if (!can_end())
            throw deser_err();
    }
};
struct ivy_socket_deser : public ivy_binary_deser {
      int sock;
    public:
      ivy_socket_deser(int sock, const std::vector<char> &inp)
          : ivy_binary_deser(inp), sock(sock) {}
    virtual bool more(unsigned bytes) {
        while (inp.size() < pos + bytes) {
            int oldsize = inp.size();
            int get = pos + bytes - oldsize;
            get = (get < 1024) ? 1024 : get;
            inp.resize(oldsize + get);
            int newbytes;
	    if ((newbytes = read(sock,&inp[oldsize],get)) < 0)
		 { std::cerr << "recvfrom failed\n"; exit(1); }
            inp.resize(oldsize + newbytes);
            if (newbytes == 0)
                 return false;
        }
        return true;
    }
    virtual bool can_end() {return true;}
};

struct out_of_bounds {
    std::string txt;
    int pos;
    out_of_bounds(int _idx, int pos = 0) : pos(pos){
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s, int pos = 0) : txt(s), pos(pos) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <class T> T __lit(const char *);

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom == "true";
}

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
    // int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
long long _arg<long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
//    long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned long long _arg<unsigned long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned long long res;
    s  >> res;
//    unsigned long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned _arg<unsigned>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned res;
    s  >> res;
//    unsigned res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}


std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom;
}

template <class T> void __ser(ivy_ser &res, const T &inp);

template <>
void __ser<int>(ivy_ser &res, const int &inp) {
    res.set((long long)inp);
}

template <>
void __ser<long long>(ivy_ser &res, const long long &inp) {
    res.set(inp);
}

template <>
void __ser<unsigned long long>(ivy_ser &res, const unsigned long long &inp) {
    res.set((long long)inp);
}

template <>
void __ser<unsigned>(ivy_ser &res, const unsigned &inp) {
    res.set((long long)inp);
}

template <>
void __ser<bool>(ivy_ser &res, const bool &inp) {
    res.set(inp);
}

template <>
void __ser<std::vector<bool>::const_reference>(ivy_ser &res, const std::vector<bool>::const_reference &inp) {
    bool thing = inp;
    res.set(thing);
}

template <>
void __ser<__strlit>(ivy_ser &res, const __strlit &inp) {
    res.set(inp);
}

template <class T> void __deser(ivy_deser &inp, T &res);

template <>
void __deser<int>(ivy_deser &inp, int &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<long long>(ivy_deser &inp, long long &res) {
    inp.get(res);
}

template <>
void __deser<unsigned long long>(ivy_deser &inp, unsigned long long &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<unsigned>(ivy_deser &inp, unsigned &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<__strlit>(ivy_deser &inp, __strlit &res) {
    inp.get(res);
}

template <>
void __deser<bool>(ivy_deser &inp, bool &res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

void __deser(ivy_deser &inp, std::vector<bool>::reference res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

class gen;

std::ostream &operator <<(std::ostream &s, const s3_test::_AbortIncompleteMultipartUpload &t);
template <>
s3_test::_AbortIncompleteMultipartUpload _arg<s3_test::_AbortIncompleteMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AbortIncompleteMultipartUpload>(ivy_ser &res, const s3_test::_AbortIncompleteMultipartUpload&);
template <>
void  __deser<s3_test::_AbortIncompleteMultipartUpload>(ivy_deser &inp, s3_test::_AbortIncompleteMultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlPolicy &t);
template <>
s3_test::_AccessControlPolicy _arg<s3_test::_AccessControlPolicy>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AccessControlPolicy>(ivy_ser &res, const s3_test::_AccessControlPolicy&);
template <>
void  __deser<s3_test::_AccessControlPolicy>(ivy_deser &inp, s3_test::_AccessControlPolicy &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlTranslation &t);
template <>
s3_test::_AccessControlTranslation _arg<s3_test::_AccessControlTranslation>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AccessControlTranslation>(ivy_ser &res, const s3_test::_AccessControlTranslation&);
template <>
void  __deser<s3_test::_AccessControlTranslation>(ivy_deser &inp, s3_test::_AccessControlTranslation &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsAndOperator &t);
template <>
s3_test::_AnalyticsAndOperator _arg<s3_test::_AnalyticsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsAndOperator>(ivy_ser &res, const s3_test::_AnalyticsAndOperator&);
template <>
void  __deser<s3_test::_AnalyticsAndOperator>(ivy_deser &inp, s3_test::_AnalyticsAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsConfiguration &t);
template <>
s3_test::_AnalyticsConfiguration _arg<s3_test::_AnalyticsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsConfiguration>(ivy_ser &res, const s3_test::_AnalyticsConfiguration&);
template <>
void  __deser<s3_test::_AnalyticsConfiguration>(ivy_deser &inp, s3_test::_AnalyticsConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsExportDestination &t);
template <>
s3_test::_AnalyticsExportDestination _arg<s3_test::_AnalyticsExportDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsExportDestination>(ivy_ser &res, const s3_test::_AnalyticsExportDestination&);
template <>
void  __deser<s3_test::_AnalyticsExportDestination>(ivy_deser &inp, s3_test::_AnalyticsExportDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsFilter &t);
template <>
s3_test::_AnalyticsFilter _arg<s3_test::_AnalyticsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsFilter>(ivy_ser &res, const s3_test::_AnalyticsFilter&);
template <>
void  __deser<s3_test::_AnalyticsFilter>(ivy_deser &inp, s3_test::_AnalyticsFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsS3BucketDestination &t);
template <>
s3_test::_AnalyticsS3BucketDestination _arg<s3_test::_AnalyticsS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsS3BucketDestination>(ivy_ser &res, const s3_test::_AnalyticsS3BucketDestination&);
template <>
void  __deser<s3_test::_AnalyticsS3BucketDestination>(ivy_deser &inp, s3_test::_AnalyticsS3BucketDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Bucket &t);
template <>
s3_test::_Bucket _arg<s3_test::_Bucket>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Bucket>(ivy_ser &res, const s3_test::_Bucket&);
template <>
void  __deser<s3_test::_Bucket>(ivy_deser &inp, s3_test::_Bucket &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_BucketLifecycleConfiguration &t);
template <>
s3_test::_BucketLifecycleConfiguration _arg<s3_test::_BucketLifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_BucketLifecycleConfiguration>(ivy_ser &res, const s3_test::_BucketLifecycleConfiguration&);
template <>
void  __deser<s3_test::_BucketLifecycleConfiguration>(ivy_deser &inp, s3_test::_BucketLifecycleConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CORSRule &t);
template <>
s3_test::_CORSRule _arg<s3_test::_CORSRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CORSRule>(ivy_ser &res, const s3_test::_CORSRule&);
template <>
void  __deser<s3_test::_CORSRule>(ivy_deser &inp, s3_test::_CORSRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVInput &t);
template <>
s3_test::_CSVInput _arg<s3_test::_CSVInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CSVInput>(ivy_ser &res, const s3_test::_CSVInput&);
template <>
void  __deser<s3_test::_CSVInput>(ivy_deser &inp, s3_test::_CSVInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVOutput &t);
template <>
s3_test::_CSVOutput _arg<s3_test::_CSVOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CSVOutput>(ivy_ser &res, const s3_test::_CSVOutput&);
template <>
void  __deser<s3_test::_CSVOutput>(ivy_deser &inp, s3_test::_CSVOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CommonPrefix &t);
template <>
s3_test::_CommonPrefix _arg<s3_test::_CommonPrefix>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CommonPrefix>(ivy_ser &res, const s3_test::_CommonPrefix&);
template <>
void  __deser<s3_test::_CommonPrefix>(ivy_deser &inp, s3_test::_CommonPrefix &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedMultipartUpload &t);
template <>
s3_test::_CompletedMultipartUpload _arg<s3_test::_CompletedMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CompletedMultipartUpload>(ivy_ser &res, const s3_test::_CompletedMultipartUpload&);
template <>
void  __deser<s3_test::_CompletedMultipartUpload>(ivy_deser &inp, s3_test::_CompletedMultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedPart &t);
template <>
s3_test::_CompletedPart _arg<s3_test::_CompletedPart>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CompletedPart>(ivy_ser &res, const s3_test::_CompletedPart&);
template <>
void  __deser<s3_test::_CompletedPart>(ivy_deser &inp, s3_test::_CompletedPart &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Condition &t);
template <>
s3_test::_Condition _arg<s3_test::_Condition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Condition>(ivy_ser &res, const s3_test::_Condition&);
template <>
void  __deser<s3_test::_Condition>(ivy_deser &inp, s3_test::_Condition &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CreateBucketConfiguration &t);
template <>
s3_test::_CreateBucketConfiguration _arg<s3_test::_CreateBucketConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CreateBucketConfiguration>(ivy_ser &res, const s3_test::_CreateBucketConfiguration&);
template <>
void  __deser<s3_test::_CreateBucketConfiguration>(ivy_deser &inp, s3_test::_CreateBucketConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DefaultRetention &t);
template <>
s3_test::_DefaultRetention _arg<s3_test::_DefaultRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DefaultRetention>(ivy_ser &res, const s3_test::_DefaultRetention&);
template <>
void  __deser<s3_test::_DefaultRetention>(ivy_deser &inp, s3_test::_DefaultRetention &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerEntry &t);
template <>
s3_test::_DeleteMarkerEntry _arg<s3_test::_DeleteMarkerEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeleteMarkerEntry>(ivy_ser &res, const s3_test::_DeleteMarkerEntry&);
template <>
void  __deser<s3_test::_DeleteMarkerEntry>(ivy_deser &inp, s3_test::_DeleteMarkerEntry &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerReplication &t);
template <>
s3_test::_DeleteMarkerReplication _arg<s3_test::_DeleteMarkerReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeleteMarkerReplication>(ivy_ser &res, const s3_test::_DeleteMarkerReplication&);
template <>
void  __deser<s3_test::_DeleteMarkerReplication>(ivy_deser &inp, s3_test::_DeleteMarkerReplication &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeletedObject &t);
template <>
s3_test::_DeletedObject _arg<s3_test::_DeletedObject>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeletedObject>(ivy_ser &res, const s3_test::_DeletedObject&);
template <>
void  __deser<s3_test::_DeletedObject>(ivy_deser &inp, s3_test::_DeletedObject &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Destination &t);
template <>
s3_test::_Destination _arg<s3_test::_Destination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Destination>(ivy_ser &res, const s3_test::_Destination&);
template <>
void  __deser<s3_test::_Destination>(ivy_deser &inp, s3_test::_Destination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Encryption &t);
template <>
s3_test::_Encryption _arg<s3_test::_Encryption>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Encryption>(ivy_ser &res, const s3_test::_Encryption&);
template <>
void  __deser<s3_test::_Encryption>(ivy_deser &inp, s3_test::_Encryption &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_EncryptionConfiguration &t);
template <>
s3_test::_EncryptionConfiguration _arg<s3_test::_EncryptionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_EncryptionConfiguration>(ivy_ser &res, const s3_test::_EncryptionConfiguration&);
template <>
void  __deser<s3_test::_EncryptionConfiguration>(ivy_deser &inp, s3_test::_EncryptionConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Error &t);
template <>
s3_test::_Error _arg<s3_test::_Error>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Error>(ivy_ser &res, const s3_test::_Error&);
template <>
void  __deser<s3_test::_Error>(ivy_deser &inp, s3_test::_Error &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ExistingObjectReplication &t);
template <>
s3_test::_ExistingObjectReplication _arg<s3_test::_ExistingObjectReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ExistingObjectReplication>(ivy_ser &res, const s3_test::_ExistingObjectReplication&);
template <>
void  __deser<s3_test::_ExistingObjectReplication>(ivy_deser &inp, s3_test::_ExistingObjectReplication &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_FilterRule &t);
template <>
s3_test::_FilterRule _arg<s3_test::_FilterRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_FilterRule>(ivy_ser &res, const s3_test::_FilterRule&);
template <>
void  __deser<s3_test::_FilterRule>(ivy_deser &inp, s3_test::_FilterRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectOutput &t);
template <>
s3_test::_GetObjectOutput _arg<s3_test::_GetObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GetObjectOutput>(ivy_ser &res, const s3_test::_GetObjectOutput&);
template <>
void  __deser<s3_test::_GetObjectOutput>(ivy_deser &inp, s3_test::_GetObjectOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectRequest &t);
template <>
s3_test::_GetObjectRequest _arg<s3_test::_GetObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GetObjectRequest>(ivy_ser &res, const s3_test::_GetObjectRequest&);
template <>
void  __deser<s3_test::_GetObjectRequest>(ivy_deser &inp, s3_test::_GetObjectRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GlacierJobParameters &t);
template <>
s3_test::_GlacierJobParameters _arg<s3_test::_GlacierJobParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GlacierJobParameters>(ivy_ser &res, const s3_test::_GlacierJobParameters&);
template <>
void  __deser<s3_test::_GlacierJobParameters>(ivy_deser &inp, s3_test::_GlacierJobParameters &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Grant &t);
template <>
s3_test::_Grant _arg<s3_test::_Grant>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Grant>(ivy_ser &res, const s3_test::_Grant&);
template <>
void  __deser<s3_test::_Grant>(ivy_deser &inp, s3_test::_Grant &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Grantee &t);
template <>
s3_test::_Grantee _arg<s3_test::_Grantee>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Grantee>(ivy_ser &res, const s3_test::_Grantee&);
template <>
void  __deser<s3_test::_Grantee>(ivy_deser &inp, s3_test::_Grantee &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Initiator &t);
template <>
s3_test::_Initiator _arg<s3_test::_Initiator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Initiator>(ivy_ser &res, const s3_test::_Initiator&);
template <>
void  __deser<s3_test::_Initiator>(ivy_deser &inp, s3_test::_Initiator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InputSerialization &t);
template <>
s3_test::_InputSerialization _arg<s3_test::_InputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InputSerialization>(ivy_ser &res, const s3_test::_InputSerialization&);
template <>
void  __deser<s3_test::_InputSerialization>(ivy_deser &inp, s3_test::_InputSerialization &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringAndOperator &t);
template <>
s3_test::_IntelligentTieringAndOperator _arg<s3_test::_IntelligentTieringAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringAndOperator>(ivy_ser &res, const s3_test::_IntelligentTieringAndOperator&);
template <>
void  __deser<s3_test::_IntelligentTieringAndOperator>(ivy_deser &inp, s3_test::_IntelligentTieringAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringConfiguration &t);
template <>
s3_test::_IntelligentTieringConfiguration _arg<s3_test::_IntelligentTieringConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringConfiguration>(ivy_ser &res, const s3_test::_IntelligentTieringConfiguration&);
template <>
void  __deser<s3_test::_IntelligentTieringConfiguration>(ivy_deser &inp, s3_test::_IntelligentTieringConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringFilter &t);
template <>
s3_test::_IntelligentTieringFilter _arg<s3_test::_IntelligentTieringFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringFilter>(ivy_ser &res, const s3_test::_IntelligentTieringFilter&);
template <>
void  __deser<s3_test::_IntelligentTieringFilter>(ivy_deser &inp, s3_test::_IntelligentTieringFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryConfiguration &t);
template <>
s3_test::_InventoryConfiguration _arg<s3_test::_InventoryConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryConfiguration>(ivy_ser &res, const s3_test::_InventoryConfiguration&);
template <>
void  __deser<s3_test::_InventoryConfiguration>(ivy_deser &inp, s3_test::_InventoryConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryDestination &t);
template <>
s3_test::_InventoryDestination _arg<s3_test::_InventoryDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryDestination>(ivy_ser &res, const s3_test::_InventoryDestination&);
template <>
void  __deser<s3_test::_InventoryDestination>(ivy_deser &inp, s3_test::_InventoryDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryEncryption &t);
template <>
s3_test::_InventoryEncryption _arg<s3_test::_InventoryEncryption>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryEncryption>(ivy_ser &res, const s3_test::_InventoryEncryption&);
template <>
void  __deser<s3_test::_InventoryEncryption>(ivy_deser &inp, s3_test::_InventoryEncryption &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryFilter &t);
template <>
s3_test::_InventoryFilter _arg<s3_test::_InventoryFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryFilter>(ivy_ser &res, const s3_test::_InventoryFilter&);
template <>
void  __deser<s3_test::_InventoryFilter>(ivy_deser &inp, s3_test::_InventoryFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryS3BucketDestination &t);
template <>
s3_test::_InventoryS3BucketDestination _arg<s3_test::_InventoryS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryS3BucketDestination>(ivy_ser &res, const s3_test::_InventoryS3BucketDestination&);
template <>
void  __deser<s3_test::_InventoryS3BucketDestination>(ivy_deser &inp, s3_test::_InventoryS3BucketDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventorySchedule &t);
template <>
s3_test::_InventorySchedule _arg<s3_test::_InventorySchedule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventorySchedule>(ivy_ser &res, const s3_test::_InventorySchedule&);
template <>
void  __deser<s3_test::_InventorySchedule>(ivy_deser &inp, s3_test::_InventorySchedule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONInput &t);
template <>
s3_test::_JSONInput _arg<s3_test::_JSONInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_JSONInput>(ivy_ser &res, const s3_test::_JSONInput&);
template <>
void  __deser<s3_test::_JSONInput>(ivy_deser &inp, s3_test::_JSONInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONOutput &t);
template <>
s3_test::_JSONOutput _arg<s3_test::_JSONOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_JSONOutput>(ivy_ser &res, const s3_test::_JSONOutput&);
template <>
void  __deser<s3_test::_JSONOutput>(ivy_deser &inp, s3_test::_JSONOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LambdaFunctionConfiguration &t);
template <>
s3_test::_LambdaFunctionConfiguration _arg<s3_test::_LambdaFunctionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LambdaFunctionConfiguration>(ivy_ser &res, const s3_test::_LambdaFunctionConfiguration&);
template <>
void  __deser<s3_test::_LambdaFunctionConfiguration>(ivy_deser &inp, s3_test::_LambdaFunctionConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleConfiguration &t);
template <>
s3_test::_LifecycleConfiguration _arg<s3_test::_LifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleConfiguration>(ivy_ser &res, const s3_test::_LifecycleConfiguration&);
template <>
void  __deser<s3_test::_LifecycleConfiguration>(ivy_deser &inp, s3_test::_LifecycleConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleExpiration &t);
template <>
s3_test::_LifecycleExpiration _arg<s3_test::_LifecycleExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleExpiration>(ivy_ser &res, const s3_test::_LifecycleExpiration&);
template <>
void  __deser<s3_test::_LifecycleExpiration>(ivy_deser &inp, s3_test::_LifecycleExpiration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRule &t);
template <>
s3_test::_LifecycleRule _arg<s3_test::_LifecycleRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRule>(ivy_ser &res, const s3_test::_LifecycleRule&);
template <>
void  __deser<s3_test::_LifecycleRule>(ivy_deser &inp, s3_test::_LifecycleRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleAndOperator &t);
template <>
s3_test::_LifecycleRuleAndOperator _arg<s3_test::_LifecycleRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRuleAndOperator>(ivy_ser &res, const s3_test::_LifecycleRuleAndOperator&);
template <>
void  __deser<s3_test::_LifecycleRuleAndOperator>(ivy_deser &inp, s3_test::_LifecycleRuleAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleFilter &t);
template <>
s3_test::_LifecycleRuleFilter _arg<s3_test::_LifecycleRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRuleFilter>(ivy_ser &res, const s3_test::_LifecycleRuleFilter&);
template <>
void  __deser<s3_test::_LifecycleRuleFilter>(ivy_deser &inp, s3_test::_LifecycleRuleFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetadataEntry &t);
template <>
s3_test::_MetadataEntry _arg<s3_test::_MetadataEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetadataEntry>(ivy_ser &res, const s3_test::_MetadataEntry&);
template <>
void  __deser<s3_test::_MetadataEntry>(ivy_deser &inp, s3_test::_MetadataEntry &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Metrics &t);
template <>
s3_test::_Metrics _arg<s3_test::_Metrics>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Metrics>(ivy_ser &res, const s3_test::_Metrics&);
template <>
void  __deser<s3_test::_Metrics>(ivy_deser &inp, s3_test::_Metrics &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsAndOperator &t);
template <>
s3_test::_MetricsAndOperator _arg<s3_test::_MetricsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsAndOperator>(ivy_ser &res, const s3_test::_MetricsAndOperator&);
template <>
void  __deser<s3_test::_MetricsAndOperator>(ivy_deser &inp, s3_test::_MetricsAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsConfiguration &t);
template <>
s3_test::_MetricsConfiguration _arg<s3_test::_MetricsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsConfiguration>(ivy_ser &res, const s3_test::_MetricsConfiguration&);
template <>
void  __deser<s3_test::_MetricsConfiguration>(ivy_deser &inp, s3_test::_MetricsConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsFilter &t);
template <>
s3_test::_MetricsFilter _arg<s3_test::_MetricsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsFilter>(ivy_ser &res, const s3_test::_MetricsFilter&);
template <>
void  __deser<s3_test::_MetricsFilter>(ivy_deser &inp, s3_test::_MetricsFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MultipartUpload &t);
template <>
s3_test::_MultipartUpload _arg<s3_test::_MultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MultipartUpload>(ivy_ser &res, const s3_test::_MultipartUpload&);
template <>
void  __deser<s3_test::_MultipartUpload>(ivy_deser &inp, s3_test::_MultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionExpiration &t);
template <>
s3_test::_NoncurrentVersionExpiration _arg<s3_test::_NoncurrentVersionExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NoncurrentVersionExpiration>(ivy_ser &res, const s3_test::_NoncurrentVersionExpiration&);
template <>
void  __deser<s3_test::_NoncurrentVersionExpiration>(ivy_deser &inp, s3_test::_NoncurrentVersionExpiration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionTransition &t);
template <>
s3_test::_NoncurrentVersionTransition _arg<s3_test::_NoncurrentVersionTransition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NoncurrentVersionTransition>(ivy_ser &res, const s3_test::_NoncurrentVersionTransition&);
template <>
void  __deser<s3_test::_NoncurrentVersionTransition>(ivy_deser &inp, s3_test::_NoncurrentVersionTransition &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NotificationConfigurationFilter &t);
template <>
s3_test::_NotificationConfigurationFilter _arg<s3_test::_NotificationConfigurationFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NotificationConfigurationFilter>(ivy_ser &res, const s3_test::_NotificationConfigurationFilter&);
template <>
void  __deser<s3_test::_NotificationConfigurationFilter>(ivy_deser &inp, s3_test::_NotificationConfigurationFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Object &t);
template <>
s3_test::_Object _arg<s3_test::_Object>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Object>(ivy_ser &res, const s3_test::_Object&);
template <>
void  __deser<s3_test::_Object>(ivy_deser &inp, s3_test::_Object &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectIdentifier &t);
template <>
s3_test::_ObjectIdentifier _arg<s3_test::_ObjectIdentifier>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectIdentifier>(ivy_ser &res, const s3_test::_ObjectIdentifier&);
template <>
void  __deser<s3_test::_ObjectIdentifier>(ivy_deser &inp, s3_test::_ObjectIdentifier &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockConfiguration &t);
template <>
s3_test::_ObjectLockConfiguration _arg<s3_test::_ObjectLockConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockConfiguration>(ivy_ser &res, const s3_test::_ObjectLockConfiguration&);
template <>
void  __deser<s3_test::_ObjectLockConfiguration>(ivy_deser &inp, s3_test::_ObjectLockConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockLegalHold &t);
template <>
s3_test::_ObjectLockLegalHold _arg<s3_test::_ObjectLockLegalHold>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockLegalHold>(ivy_ser &res, const s3_test::_ObjectLockLegalHold&);
template <>
void  __deser<s3_test::_ObjectLockLegalHold>(ivy_deser &inp, s3_test::_ObjectLockLegalHold &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRetention &t);
template <>
s3_test::_ObjectLockRetention _arg<s3_test::_ObjectLockRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockRetention>(ivy_ser &res, const s3_test::_ObjectLockRetention&);
template <>
void  __deser<s3_test::_ObjectLockRetention>(ivy_deser &inp, s3_test::_ObjectLockRetention &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRule &t);
template <>
s3_test::_ObjectLockRule _arg<s3_test::_ObjectLockRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockRule>(ivy_ser &res, const s3_test::_ObjectLockRule&);
template <>
void  __deser<s3_test::_ObjectLockRule>(ivy_deser &inp, s3_test::_ObjectLockRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectVersion &t);
template <>
s3_test::_ObjectVersion _arg<s3_test::_ObjectVersion>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectVersion>(ivy_ser &res, const s3_test::_ObjectVersion&);
template <>
void  __deser<s3_test::_ObjectVersion>(ivy_deser &inp, s3_test::_ObjectVersion &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputLocation &t);
template <>
s3_test::_OutputLocation _arg<s3_test::_OutputLocation>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OutputLocation>(ivy_ser &res, const s3_test::_OutputLocation&);
template <>
void  __deser<s3_test::_OutputLocation>(ivy_deser &inp, s3_test::_OutputLocation &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputSerialization &t);
template <>
s3_test::_OutputSerialization _arg<s3_test::_OutputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OutputSerialization>(ivy_ser &res, const s3_test::_OutputSerialization&);
template <>
void  __deser<s3_test::_OutputSerialization>(ivy_deser &inp, s3_test::_OutputSerialization &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Owner &t);
template <>
s3_test::_Owner _arg<s3_test::_Owner>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Owner>(ivy_ser &res, const s3_test::_Owner&);
template <>
void  __deser<s3_test::_Owner>(ivy_deser &inp, s3_test::_Owner &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OwnershipControlsRule &t);
template <>
s3_test::_OwnershipControlsRule _arg<s3_test::_OwnershipControlsRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OwnershipControlsRule>(ivy_ser &res, const s3_test::_OwnershipControlsRule&);
template <>
void  __deser<s3_test::_OwnershipControlsRule>(ivy_deser &inp, s3_test::_OwnershipControlsRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ParquetInput &t);
template <>
s3_test::_ParquetInput _arg<s3_test::_ParquetInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ParquetInput>(ivy_ser &res, const s3_test::_ParquetInput&);
template <>
void  __deser<s3_test::_ParquetInput>(ivy_deser &inp, s3_test::_ParquetInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Part &t);
template <>
s3_test::_Part _arg<s3_test::_Part>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Part>(ivy_ser &res, const s3_test::_Part&);
template <>
void  __deser<s3_test::_Part>(ivy_deser &inp, s3_test::_Part &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectOutput &t);
template <>
s3_test::_PutObjectOutput _arg<s3_test::_PutObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_PutObjectOutput>(ivy_ser &res, const s3_test::_PutObjectOutput&);
template <>
void  __deser<s3_test::_PutObjectOutput>(ivy_deser &inp, s3_test::_PutObjectOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectRequest &t);
template <>
s3_test::_PutObjectRequest _arg<s3_test::_PutObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_PutObjectRequest>(ivy_ser &res, const s3_test::_PutObjectRequest&);
template <>
void  __deser<s3_test::_PutObjectRequest>(ivy_deser &inp, s3_test::_PutObjectRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_QueueConfiguration &t);
template <>
s3_test::_QueueConfiguration _arg<s3_test::_QueueConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_QueueConfiguration>(ivy_ser &res, const s3_test::_QueueConfiguration&);
template <>
void  __deser<s3_test::_QueueConfiguration>(ivy_deser &inp, s3_test::_QueueConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Redirect &t);
template <>
s3_test::_Redirect _arg<s3_test::_Redirect>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Redirect>(ivy_ser &res, const s3_test::_Redirect&);
template <>
void  __deser<s3_test::_Redirect>(ivy_deser &inp, s3_test::_Redirect &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicaModifications &t);
template <>
s3_test::_ReplicaModifications _arg<s3_test::_ReplicaModifications>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicaModifications>(ivy_ser &res, const s3_test::_ReplicaModifications&);
template <>
void  __deser<s3_test::_ReplicaModifications>(ivy_deser &inp, s3_test::_ReplicaModifications &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRule &t);
template <>
s3_test::_ReplicationRule _arg<s3_test::_ReplicationRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRule>(ivy_ser &res, const s3_test::_ReplicationRule&);
template <>
void  __deser<s3_test::_ReplicationRule>(ivy_deser &inp, s3_test::_ReplicationRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleAndOperator &t);
template <>
s3_test::_ReplicationRuleAndOperator _arg<s3_test::_ReplicationRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRuleAndOperator>(ivy_ser &res, const s3_test::_ReplicationRuleAndOperator&);
template <>
void  __deser<s3_test::_ReplicationRuleAndOperator>(ivy_deser &inp, s3_test::_ReplicationRuleAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleFilter &t);
template <>
s3_test::_ReplicationRuleFilter _arg<s3_test::_ReplicationRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRuleFilter>(ivy_ser &res, const s3_test::_ReplicationRuleFilter&);
template <>
void  __deser<s3_test::_ReplicationRuleFilter>(ivy_deser &inp, s3_test::_ReplicationRuleFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTime &t);
template <>
s3_test::_ReplicationTime _arg<s3_test::_ReplicationTime>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationTime>(ivy_ser &res, const s3_test::_ReplicationTime&);
template <>
void  __deser<s3_test::_ReplicationTime>(ivy_deser &inp, s3_test::_ReplicationTime &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTimeValue &t);
template <>
s3_test::_ReplicationTimeValue _arg<s3_test::_ReplicationTimeValue>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationTimeValue>(ivy_ser &res, const s3_test::_ReplicationTimeValue&);
template <>
void  __deser<s3_test::_ReplicationTimeValue>(ivy_deser &inp, s3_test::_ReplicationTimeValue &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RequestProgress &t);
template <>
s3_test::_RequestProgress _arg<s3_test::_RequestProgress>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RequestProgress>(ivy_ser &res, const s3_test::_RequestProgress&);
template <>
void  __deser<s3_test::_RequestProgress>(ivy_deser &inp, s3_test::_RequestProgress &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RestoreRequest &t);
template <>
s3_test::_RestoreRequest _arg<s3_test::_RestoreRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RestoreRequest>(ivy_ser &res, const s3_test::_RestoreRequest&);
template <>
void  __deser<s3_test::_RestoreRequest>(ivy_deser &inp, s3_test::_RestoreRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RoutingRule &t);
template <>
s3_test::_RoutingRule _arg<s3_test::_RoutingRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RoutingRule>(ivy_ser &res, const s3_test::_RoutingRule&);
template <>
void  __deser<s3_test::_RoutingRule>(ivy_deser &inp, s3_test::_RoutingRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Rule &t);
template <>
s3_test::_Rule _arg<s3_test::_Rule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Rule>(ivy_ser &res, const s3_test::_Rule&);
template <>
void  __deser<s3_test::_Rule>(ivy_deser &inp, s3_test::_Rule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_S3KeyFilter &t);
template <>
s3_test::_S3KeyFilter _arg<s3_test::_S3KeyFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_S3KeyFilter>(ivy_ser &res, const s3_test::_S3KeyFilter&);
template <>
void  __deser<s3_test::_S3KeyFilter>(ivy_deser &inp, s3_test::_S3KeyFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_S3Location &t);
template <>
s3_test::_S3Location _arg<s3_test::_S3Location>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_S3Location>(ivy_ser &res, const s3_test::_S3Location&);
template <>
void  __deser<s3_test::_S3Location>(ivy_deser &inp, s3_test::_S3Location &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SSEKMS &t);
template <>
s3_test::_SSEKMS _arg<s3_test::_SSEKMS>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SSEKMS>(ivy_ser &res, const s3_test::_SSEKMS&);
template <>
void  __deser<s3_test::_SSEKMS>(ivy_deser &inp, s3_test::_SSEKMS &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SSES3 &t);
template <>
s3_test::_SSES3 _arg<s3_test::_SSES3>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SSES3>(ivy_ser &res, const s3_test::_SSES3&);
template <>
void  __deser<s3_test::_SSES3>(ivy_deser &inp, s3_test::_SSES3 &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ScanRange &t);
template <>
s3_test::_ScanRange _arg<s3_test::_ScanRange>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ScanRange>(ivy_ser &res, const s3_test::_ScanRange&);
template <>
void  __deser<s3_test::_ScanRange>(ivy_deser &inp, s3_test::_ScanRange &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SelectParameters &t);
template <>
s3_test::_SelectParameters _arg<s3_test::_SelectParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SelectParameters>(ivy_ser &res, const s3_test::_SelectParameters&);
template <>
void  __deser<s3_test::_SelectParameters>(ivy_deser &inp, s3_test::_SelectParameters &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionByDefault &t);
template <>
s3_test::_ServerSideEncryptionByDefault _arg<s3_test::_ServerSideEncryptionByDefault>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ServerSideEncryptionByDefault>(ivy_ser &res, const s3_test::_ServerSideEncryptionByDefault&);
template <>
void  __deser<s3_test::_ServerSideEncryptionByDefault>(ivy_deser &inp, s3_test::_ServerSideEncryptionByDefault &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionRule &t);
template <>
s3_test::_ServerSideEncryptionRule _arg<s3_test::_ServerSideEncryptionRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ServerSideEncryptionRule>(ivy_ser &res, const s3_test::_ServerSideEncryptionRule&);
template <>
void  __deser<s3_test::_ServerSideEncryptionRule>(ivy_deser &inp, s3_test::_ServerSideEncryptionRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SourceSelectionCriteria &t);
template <>
s3_test::_SourceSelectionCriteria _arg<s3_test::_SourceSelectionCriteria>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SourceSelectionCriteria>(ivy_ser &res, const s3_test::_SourceSelectionCriteria&);
template <>
void  __deser<s3_test::_SourceSelectionCriteria>(ivy_deser &inp, s3_test::_SourceSelectionCriteria &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SseKmsEncryptedObjects &t);
template <>
s3_test::_SseKmsEncryptedObjects _arg<s3_test::_SseKmsEncryptedObjects>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SseKmsEncryptedObjects>(ivy_ser &res, const s3_test::_SseKmsEncryptedObjects&);
template <>
void  __deser<s3_test::_SseKmsEncryptedObjects>(ivy_deser &inp, s3_test::_SseKmsEncryptedObjects &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysis &t);
template <>
s3_test::_StorageClassAnalysis _arg<s3_test::_StorageClassAnalysis>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_StorageClassAnalysis>(ivy_ser &res, const s3_test::_StorageClassAnalysis&);
template <>
void  __deser<s3_test::_StorageClassAnalysis>(ivy_deser &inp, s3_test::_StorageClassAnalysis &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysisDataExport &t);
template <>
s3_test::_StorageClassAnalysisDataExport _arg<s3_test::_StorageClassAnalysisDataExport>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_StorageClassAnalysisDataExport>(ivy_ser &res, const s3_test::_StorageClassAnalysisDataExport&);
template <>
void  __deser<s3_test::_StorageClassAnalysisDataExport>(ivy_deser &inp, s3_test::_StorageClassAnalysisDataExport &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tag &t);
template <>
s3_test::_Tag _arg<s3_test::_Tag>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tag>(ivy_ser &res, const s3_test::_Tag&);
template <>
void  __deser<s3_test::_Tag>(ivy_deser &inp, s3_test::_Tag &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tagging &t);
template <>
s3_test::_Tagging _arg<s3_test::_Tagging>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tagging>(ivy_ser &res, const s3_test::_Tagging&);
template <>
void  __deser<s3_test::_Tagging>(ivy_deser &inp, s3_test::_Tagging &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_TargetGrant &t);
template <>
s3_test::_TargetGrant _arg<s3_test::_TargetGrant>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_TargetGrant>(ivy_ser &res, const s3_test::_TargetGrant&);
template <>
void  __deser<s3_test::_TargetGrant>(ivy_deser &inp, s3_test::_TargetGrant &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tiering &t);
template <>
s3_test::_Tiering _arg<s3_test::_Tiering>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tiering>(ivy_ser &res, const s3_test::_Tiering&);
template <>
void  __deser<s3_test::_Tiering>(ivy_deser &inp, s3_test::_Tiering &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_TopicConfiguration &t);
template <>
s3_test::_TopicConfiguration _arg<s3_test::_TopicConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_TopicConfiguration>(ivy_ser &res, const s3_test::_TopicConfiguration&);
template <>
void  __deser<s3_test::_TopicConfiguration>(ivy_deser &inp, s3_test::_TopicConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Transition &t);
template <>
s3_test::_Transition _arg<s3_test::_Transition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Transition>(ivy_ser &res, const s3_test::_Transition&);
template <>
void  __deser<s3_test::_Transition>(ivy_deser &inp, s3_test::_Transition &res);
        template <typename T>
        T __array_segment(const T &a, long long lo, long long hi) {
            T res;
            lo = (lo < 0) ? 0 : lo;
            hi = (hi > a.size()) ? a.size() : hi;
            if (hi > lo) {
                res.resize(hi-lo);
                std::copy(a.begin()+lo,a.begin()+hi,res.begin());
            }
            return res;
        }
        	    std::ostream &operator <<(std::ostream &s, const s3_test::blob &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::blob _arg<s3_test::blob>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::blob a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<unsigned>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::blob>(ivy_deser &inp, s3_test::blob &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::blob>(ivy_ser &res, const s3_test::blob &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::blob& val) {
	        z3::expr z3end = g.apply("blob.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("blob.value",z3val,g.int_to_z3(g.sort("blob.domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::blob>( gen &g, const  z3::expr &v,s3_test::blob &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("blob.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("blob.value",v,g.int_to_z3(g.sort("blob.domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::blob>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("blob.domain"),__sz);
                z3::expr pred =  g.apply("blob.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<unsigned>(g,g.apply("blob.value",v,g.int_to_z3(g.sort("blob.domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__string__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__string__ _arg<s3_test::option__string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__string__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<__strlit>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__string__>(ivy_deser &inp, s3_test::option__string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__string__>(ivy_ser &res, const s3_test::option__string__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__string__& val) {
	        z3::expr z3end = g.apply("option[string].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[string].value",z3val,g.int_to_z3(g.sort("option[string].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__string__>( gen &g, const  z3::expr &v,s3_test::option__string__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[string].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[string].value",v,g.int_to_z3(g.sort("option[string].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__string__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[string].domain_t"),__sz);
                z3::expr pred =  g.apply("option[string].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<__strlit>(g,g.apply("option[string].value",v,g.int_to_z3(g.sort("option[string].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Grant__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Grant__ _arg<s3_test::vector___Grant__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Grant__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Grant>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Grant__>(ivy_deser &inp, s3_test::vector___Grant__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Grant__>(ivy_ser &res, const s3_test::vector___Grant__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Grant__& val) {
	        z3::expr z3end = g.apply("vector[_Grant].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Grant].value",z3val,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Grant__>( gen &g, const  z3::expr &v,s3_test::vector___Grant__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Grant].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Grant].value",v,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Grant__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Grant].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Grant].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Grant>(g,g.apply("vector[_Grant].value",v,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Tag__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Tag__ _arg<s3_test::vector___Tag__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Tag__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tag>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Tag__>(ivy_deser &inp, s3_test::vector___Tag__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Tag__>(ivy_ser &res, const s3_test::vector___Tag__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Tag__& val) {
	        z3::expr z3end = g.apply("vector[_Tag].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Tag].value",z3val,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Tag__>( gen &g, const  z3::expr &v,s3_test::vector___Tag__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Tag].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Tag].value",v,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Tag__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Tag].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Tag].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tag>(g,g.apply("vector[_Tag].value",v,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AnalyticsFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AnalyticsFilter__ _arg<s3_test::option___AnalyticsFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AnalyticsFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AnalyticsFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AnalyticsFilter__>(ivy_deser &inp, s3_test::option___AnalyticsFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AnalyticsFilter__>(ivy_ser &res, const s3_test::option___AnalyticsFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AnalyticsFilter__& val) {
	        z3::expr z3end = g.apply("option[_AnalyticsFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AnalyticsFilter].value",z3val,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AnalyticsFilter__>( gen &g, const  z3::expr &v,s3_test::option___AnalyticsFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AnalyticsFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AnalyticsFilter].value",v,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AnalyticsFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AnalyticsFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AnalyticsFilter>(g,g.apply("option[_AnalyticsFilter].value",v,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleExpiration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleExpiration__ _arg<s3_test::option___LifecycleExpiration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleExpiration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleExpiration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleExpiration__>(ivy_deser &inp, s3_test::option___LifecycleExpiration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleExpiration__>(ivy_ser &res, const s3_test::option___LifecycleExpiration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleExpiration__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleExpiration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleExpiration].value",z3val,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleExpiration__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleExpiration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleExpiration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleExpiration].value",v,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleExpiration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleExpiration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleExpiration>(g,g.apply("option[_LifecycleExpiration].value",v,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleRuleFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleRuleFilter__ _arg<s3_test::option___LifecycleRuleFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleRuleFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleRuleFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleRuleFilter__>(ivy_deser &inp, s3_test::option___LifecycleRuleFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleRuleFilter__>(ivy_ser &res, const s3_test::option___LifecycleRuleFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleRuleFilter__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleRuleFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleRuleFilter].value",z3val,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleRuleFilter__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleRuleFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleRuleFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleRuleFilter].value",v,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleRuleFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleRuleFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleRuleFilter>(g,g.apply("option[_LifecycleRuleFilter].value",v,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Transition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Transition__ _arg<s3_test::vector___Transition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Transition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Transition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Transition__>(ivy_deser &inp, s3_test::vector___Transition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Transition__>(ivy_ser &res, const s3_test::vector___Transition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Transition__& val) {
	        z3::expr z3end = g.apply("vector[_Transition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Transition].value",z3val,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Transition__>( gen &g, const  z3::expr &v,s3_test::vector___Transition__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Transition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Transition].value",v,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Transition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Transition].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Transition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Transition>(g,g.apply("vector[_Transition].value",v,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___Transition____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___Transition____ _arg<s3_test::option__vector___Transition____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___Transition____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___Transition__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___Transition____>(ivy_deser &inp, s3_test::option__vector___Transition____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___Transition____>(ivy_ser &res, const s3_test::option__vector___Transition____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___Transition____& val) {
	        z3::expr z3end = g.apply("option[vector[_Transition]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_Transition]].value",z3val,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___Transition____>( gen &g, const  z3::expr &v,s3_test::option__vector___Transition____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_Transition]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_Transition]].value",v,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___Transition____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_Transition]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___Transition__>(g,g.apply("option[vector[_Transition]].value",v,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___NoncurrentVersionTransition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___NoncurrentVersionTransition__ _arg<s3_test::vector___NoncurrentVersionTransition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___NoncurrentVersionTransition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionTransition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___NoncurrentVersionTransition__>(ivy_deser &inp, s3_test::vector___NoncurrentVersionTransition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___NoncurrentVersionTransition__>(ivy_ser &res, const s3_test::vector___NoncurrentVersionTransition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___NoncurrentVersionTransition__& val) {
	        z3::expr z3end = g.apply("vector[_NoncurrentVersionTransition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_NoncurrentVersionTransition].value",z3val,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v,s3_test::vector___NoncurrentVersionTransition__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_NoncurrentVersionTransition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__sz);
                z3::expr pred =  g.apply("vector[_NoncurrentVersionTransition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionTransition>(g,g.apply("vector[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___NoncurrentVersionTransition____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___NoncurrentVersionTransition____ _arg<s3_test::option__vector___NoncurrentVersionTransition____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___NoncurrentVersionTransition____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___NoncurrentVersionTransition__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___NoncurrentVersionTransition____>(ivy_deser &inp, s3_test::option__vector___NoncurrentVersionTransition____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___NoncurrentVersionTransition____>(ivy_ser &res, const s3_test::option__vector___NoncurrentVersionTransition____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___NoncurrentVersionTransition____& val) {
	        z3::expr z3end = g.apply("option[vector[_NoncurrentVersionTransition]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",z3val,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___NoncurrentVersionTransition____>( gen &g, const  z3::expr &v,s3_test::option__vector___NoncurrentVersionTransition____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",v,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___NoncurrentVersionTransition____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_NoncurrentVersionTransition]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___NoncurrentVersionTransition__>(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",v,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NoncurrentVersionExpiration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NoncurrentVersionExpiration__ _arg<s3_test::option___NoncurrentVersionExpiration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NoncurrentVersionExpiration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionExpiration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NoncurrentVersionExpiration__>(ivy_deser &inp, s3_test::option___NoncurrentVersionExpiration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NoncurrentVersionExpiration__>(ivy_ser &res, const s3_test::option___NoncurrentVersionExpiration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NoncurrentVersionExpiration__& val) {
	        z3::expr z3end = g.apply("option[_NoncurrentVersionExpiration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NoncurrentVersionExpiration].value",z3val,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NoncurrentVersionExpiration__>( gen &g, const  z3::expr &v,s3_test::option___NoncurrentVersionExpiration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NoncurrentVersionExpiration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NoncurrentVersionExpiration].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NoncurrentVersionExpiration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NoncurrentVersionExpiration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionExpiration>(g,g.apply("option[_NoncurrentVersionExpiration].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AbortIncompleteMultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AbortIncompleteMultipartUpload__ _arg<s3_test::option___AbortIncompleteMultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AbortIncompleteMultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AbortIncompleteMultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AbortIncompleteMultipartUpload__>(ivy_deser &inp, s3_test::option___AbortIncompleteMultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AbortIncompleteMultipartUpload__>(ivy_ser &res, const s3_test::option___AbortIncompleteMultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AbortIncompleteMultipartUpload__& val) {
	        z3::expr z3end = g.apply("option[_AbortIncompleteMultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].value",z3val,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AbortIncompleteMultipartUpload__>( gen &g, const  z3::expr &v,s3_test::option___AbortIncompleteMultipartUpload__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].value",v,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AbortIncompleteMultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AbortIncompleteMultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AbortIncompleteMultipartUpload>(g,g.apply("option[_AbortIncompleteMultipartUpload].value",v,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___LifecycleRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___LifecycleRule__ _arg<s3_test::vector___LifecycleRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___LifecycleRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___LifecycleRule__>(ivy_deser &inp, s3_test::vector___LifecycleRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___LifecycleRule__>(ivy_ser &res, const s3_test::vector___LifecycleRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___LifecycleRule__& val) {
	        z3::expr z3end = g.apply("vector[_LifecycleRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_LifecycleRule].value",z3val,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___LifecycleRule__>( gen &g, const  z3::expr &v,s3_test::vector___LifecycleRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_LifecycleRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_LifecycleRule].value",v,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___LifecycleRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_LifecycleRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleRule>(g,g.apply("vector[_LifecycleRule].value",v,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___TargetGrant__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___TargetGrant__ _arg<s3_test::vector___TargetGrant__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___TargetGrant__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_TargetGrant>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___TargetGrant__>(ivy_deser &inp, s3_test::vector___TargetGrant__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___TargetGrant__>(ivy_ser &res, const s3_test::vector___TargetGrant__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___TargetGrant__& val) {
	        z3::expr z3end = g.apply("vector[_TargetGrant].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_TargetGrant].value",z3val,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___TargetGrant__>( gen &g, const  z3::expr &v,s3_test::vector___TargetGrant__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_TargetGrant].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_TargetGrant].value",v,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___TargetGrant__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__sz);
                z3::expr pred =  g.apply("vector[_TargetGrant].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_TargetGrant>(g,g.apply("vector[_TargetGrant].value",v,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___TargetGrant____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___TargetGrant____ _arg<s3_test::option__vector___TargetGrant____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___TargetGrant____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___TargetGrant__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___TargetGrant____>(ivy_deser &inp, s3_test::option__vector___TargetGrant____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___TargetGrant____>(ivy_ser &res, const s3_test::option__vector___TargetGrant____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___TargetGrant____& val) {
	        z3::expr z3end = g.apply("option[vector[_TargetGrant]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_TargetGrant]].value",z3val,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___TargetGrant____>( gen &g, const  z3::expr &v,s3_test::option__vector___TargetGrant____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_TargetGrant]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_TargetGrant]].value",v,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___TargetGrant____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_TargetGrant]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___TargetGrant__>(g,g.apply("option[vector[_TargetGrant]].value",v,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector__string__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector__string__ _arg<s3_test::vector__string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector__string__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<__strlit>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector__string__>(ivy_deser &inp, s3_test::vector__string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector__string__>(ivy_ser &res, const s3_test::vector__string__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector__string__& val) {
	        z3::expr z3end = g.apply("vector[string].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[string].value",z3val,g.int_to_z3(g.sort("vector[string].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector__string__>( gen &g, const  z3::expr &v,s3_test::vector__string__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[string].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[string].value",v,g.int_to_z3(g.sort("vector[string].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector__string__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[string].domain"),__sz);
                z3::expr pred =  g.apply("vector[string].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<__strlit>(g,g.apply("vector[string].value",v,g.int_to_z3(g.sort("vector[string].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector__string____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector__string____ _arg<s3_test::option__vector__string____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector__string____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector__string__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector__string____>(ivy_deser &inp, s3_test::option__vector__string____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector__string____>(ivy_ser &res, const s3_test::option__vector__string____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector__string____& val) {
	        z3::expr z3end = g.apply("option[vector[string]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[string]].value",z3val,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector__string____>( gen &g, const  z3::expr &v,s3_test::option__vector__string____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[string]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[string]].value",v,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector__string____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[string]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[string]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector__string__>(g,g.apply("option[vector[string]].value",v,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__integer__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__integer__ _arg<s3_test::option__integer__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__integer__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__integer__>(ivy_deser &inp, s3_test::option__integer__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__integer__>(ivy_ser &res, const s3_test::option__integer__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__integer__& val) {
	        z3::expr z3end = g.apply("option[integer].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[integer].value",z3val,g.int_to_z3(g.sort("option[integer].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__integer__>( gen &g, const  z3::expr &v,s3_test::option__integer__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[integer].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[integer].value",v,g.int_to_z3(g.sort("option[integer].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__integer__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[integer].domain_t"),__sz);
                z3::expr pred =  g.apply("option[integer].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[integer].value",v,g.int_to_z3(g.sort("option[integer].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CORSRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CORSRule__ _arg<s3_test::vector___CORSRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CORSRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CORSRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CORSRule__>(ivy_deser &inp, s3_test::vector___CORSRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CORSRule__>(ivy_ser &res, const s3_test::vector___CORSRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CORSRule__& val) {
	        z3::expr z3end = g.apply("vector[_CORSRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CORSRule].value",z3val,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CORSRule__>( gen &g, const  z3::expr &v,s3_test::vector___CORSRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CORSRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CORSRule].value",v,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CORSRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CORSRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CORSRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CORSRule>(g,g.apply("vector[_CORSRule].value",v,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CompletedPart__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CompletedPart__ _arg<s3_test::vector___CompletedPart__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CompletedPart__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CompletedPart>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CompletedPart__>(ivy_deser &inp, s3_test::vector___CompletedPart__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CompletedPart__>(ivy_ser &res, const s3_test::vector___CompletedPart__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CompletedPart__& val) {
	        z3::expr z3end = g.apply("vector[_CompletedPart].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CompletedPart].value",z3val,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CompletedPart__>( gen &g, const  z3::expr &v,s3_test::vector___CompletedPart__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CompletedPart].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CompletedPart].value",v,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CompletedPart__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CompletedPart].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CompletedPart>(g,g.apply("vector[_CompletedPart].value",v,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___CompletedMultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___CompletedMultipartUpload__ _arg<s3_test::option___CompletedMultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___CompletedMultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CompletedMultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___CompletedMultipartUpload__>(ivy_deser &inp, s3_test::option___CompletedMultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___CompletedMultipartUpload__>(ivy_ser &res, const s3_test::option___CompletedMultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___CompletedMultipartUpload__& val) {
	        z3::expr z3end = g.apply("option[_CompletedMultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_CompletedMultipartUpload].value",z3val,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___CompletedMultipartUpload__>( gen &g, const  z3::expr &v,s3_test::option___CompletedMultipartUpload__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_CompletedMultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_CompletedMultipartUpload].value",v,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___CompletedMultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_CompletedMultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CompletedMultipartUpload>(g,g.apply("option[_CompletedMultipartUpload].value",v,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__timestamp__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__timestamp__ _arg<s3_test::option__timestamp__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__timestamp__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__timestamp__>(ivy_deser &inp, s3_test::option__timestamp__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__timestamp__>(ivy_ser &res, const s3_test::option__timestamp__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__timestamp__& val) {
	        z3::expr z3end = g.apply("option[timestamp].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[timestamp].value",z3val,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__timestamp__>( gen &g, const  z3::expr &v,s3_test::option__timestamp__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[timestamp].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[timestamp].value",v,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__timestamp__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[timestamp].domain_t"),__sz);
                z3::expr pred =  g.apply("option[timestamp].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[timestamp].value",v,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::unordered_map__string____string__ &a) {
	        s << '[';
		for (auto i = a.begin(); i != a.end(); ++i) {
		    if (i != a.begin())
		        s << ',';
		    s << '[' << i->first << ',' << i->second << ']';
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::unordered_map__string____string__ _arg<s3_test::unordered_map__string____string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::unordered_map__string____string__ a;
	        for (unsigned i = 0; i < arg.fields.size(); i++) {
                    if (arg.fields[i].fields.size() != 2) 
	                throw out_of_bounds(idx);
		    a[_arg<__strlit>(arg.fields[i].fields,0,0)] = _arg<__strlit>(arg.fields[i].fields,1,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::unordered_map__string____string__>(ivy_deser &inp, s3_test::unordered_map__string____string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
                    __strlit k;
                    __strlit v;
	            __deser(inp,k);
	            __deser(inp,v);
                    res[k] = v;
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::unordered_map__string____string__>(ivy_ser &res, const s3_test::unordered_map__string____string__ &inp) {
	        res.open_list(inp.size());
		for (auto i = inp.begin(); i != inp.end(); ++i) {
		    res.open_list_elem();
	            __ser(res,i->first);
	            __ser(res,i->second);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__unordered_map__string____string____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__unordered_map__string____string____ _arg<s3_test::option__unordered_map__string____string____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__unordered_map__string____string____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::unordered_map__string____string__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__unordered_map__string____string____>(ivy_deser &inp, s3_test::option__unordered_map__string____string____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__unordered_map__string____string____>(ivy_ser &res, const s3_test::option__unordered_map__string____string____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__unordered_map__string____string____& val) {
	        z3::expr z3end = g.apply("option[unordered_map[string][string]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[unordered_map[string][string]].value",z3val,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__unordered_map__string____string____>( gen &g, const  z3::expr &v,s3_test::option__unordered_map__string____string____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[unordered_map[string][string]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[unordered_map[string][string]].value",v,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__unordered_map__string____string____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[unordered_map[string][string]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::unordered_map__string____string__>(g,g.apply("option[unordered_map[string][string]].value",v,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__bool__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__bool__ _arg<s3_test::option__bool__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__bool__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<bool>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__bool__>(ivy_deser &inp, s3_test::option__bool__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__bool__>(ivy_ser &res, const s3_test::option__bool__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__bool__& val) {
	        z3::expr z3end = g.apply("option[bool].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[bool].value",z3val,g.int_to_z3(g.sort("option[bool].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__bool__>( gen &g, const  z3::expr &v,s3_test::option__bool__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[bool].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[bool].value",v,g.int_to_z3(g.sort("option[bool].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__bool__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[bool].domain_t"),__sz);
                z3::expr pred =  g.apply("option[bool].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<bool>(g,g.apply("option[bool].value",v,g.int_to_z3(g.sort("option[bool].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___CreateBucketConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___CreateBucketConfiguration__ _arg<s3_test::option___CreateBucketConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___CreateBucketConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CreateBucketConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___CreateBucketConfiguration__>(ivy_deser &inp, s3_test::option___CreateBucketConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___CreateBucketConfiguration__>(ivy_ser &res, const s3_test::option___CreateBucketConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___CreateBucketConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_CreateBucketConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_CreateBucketConfiguration].value",z3val,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___CreateBucketConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___CreateBucketConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_CreateBucketConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_CreateBucketConfiguration].value",v,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___CreateBucketConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_CreateBucketConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CreateBucketConfiguration>(g,g.apply("option[_CreateBucketConfiguration].value",v,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ObjectIdentifier__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ObjectIdentifier__ _arg<s3_test::vector___ObjectIdentifier__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ObjectIdentifier__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectIdentifier>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ObjectIdentifier__>(ivy_deser &inp, s3_test::vector___ObjectIdentifier__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ObjectIdentifier__>(ivy_ser &res, const s3_test::vector___ObjectIdentifier__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ObjectIdentifier__& val) {
	        z3::expr z3end = g.apply("vector[_ObjectIdentifier].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ObjectIdentifier].value",z3val,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ObjectIdentifier__>( gen &g, const  z3::expr &v,s3_test::vector___ObjectIdentifier__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ObjectIdentifier].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ObjectIdentifier].value",v,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ObjectIdentifier__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ObjectIdentifier].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectIdentifier>(g,g.apply("vector[_ObjectIdentifier].value",v,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___DeletedObject__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___DeletedObject__ _arg<s3_test::vector___DeletedObject__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___DeletedObject__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeletedObject>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___DeletedObject__>(ivy_deser &inp, s3_test::vector___DeletedObject__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___DeletedObject__>(ivy_ser &res, const s3_test::vector___DeletedObject__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___DeletedObject__& val) {
	        z3::expr z3end = g.apply("vector[_DeletedObject].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_DeletedObject].value",z3val,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___DeletedObject__>( gen &g, const  z3::expr &v,s3_test::vector___DeletedObject__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_DeletedObject].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_DeletedObject].value",v,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___DeletedObject__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__sz);
                z3::expr pred =  g.apply("vector[_DeletedObject].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeletedObject>(g,g.apply("vector[_DeletedObject].value",v,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Error__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Error__ _arg<s3_test::vector___Error__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Error__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Error>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Error__>(ivy_deser &inp, s3_test::vector___Error__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Error__>(ivy_ser &res, const s3_test::vector___Error__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Error__& val) {
	        z3::expr z3end = g.apply("vector[_Error].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Error].value",z3val,g.int_to_z3(g.sort("vector[_Error].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Error__>( gen &g, const  z3::expr &v,s3_test::vector___Error__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Error].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Error].value",v,g.int_to_z3(g.sort("vector[_Error].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Error__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Error].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Error].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Error>(g,g.apply("vector[_Error].value",v,g.int_to_z3(g.sort("vector[_Error].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationTimeValue__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationTimeValue__ _arg<s3_test::option___ReplicationTimeValue__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationTimeValue__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationTimeValue>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationTimeValue__>(ivy_deser &inp, s3_test::option___ReplicationTimeValue__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationTimeValue__>(ivy_ser &res, const s3_test::option___ReplicationTimeValue__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationTimeValue__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationTimeValue].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationTimeValue].value",z3val,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationTimeValue__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationTimeValue__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationTimeValue].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationTimeValue].value",v,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationTimeValue__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationTimeValue].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationTimeValue>(g,g.apply("option[_ReplicationTimeValue].value",v,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AccessControlTranslation__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AccessControlTranslation__ _arg<s3_test::option___AccessControlTranslation__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AccessControlTranslation__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AccessControlTranslation>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AccessControlTranslation__>(ivy_deser &inp, s3_test::option___AccessControlTranslation__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AccessControlTranslation__>(ivy_ser &res, const s3_test::option___AccessControlTranslation__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AccessControlTranslation__& val) {
	        z3::expr z3end = g.apply("option[_AccessControlTranslation].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AccessControlTranslation].value",z3val,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AccessControlTranslation__>( gen &g, const  z3::expr &v,s3_test::option___AccessControlTranslation__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AccessControlTranslation].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AccessControlTranslation].value",v,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AccessControlTranslation__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AccessControlTranslation].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AccessControlTranslation>(g,g.apply("option[_AccessControlTranslation].value",v,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___EncryptionConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___EncryptionConfiguration__ _arg<s3_test::option___EncryptionConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___EncryptionConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_EncryptionConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___EncryptionConfiguration__>(ivy_deser &inp, s3_test::option___EncryptionConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___EncryptionConfiguration__>(ivy_ser &res, const s3_test::option___EncryptionConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___EncryptionConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_EncryptionConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_EncryptionConfiguration].value",z3val,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___EncryptionConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___EncryptionConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_EncryptionConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_EncryptionConfiguration].value",v,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___EncryptionConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_EncryptionConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_EncryptionConfiguration>(g,g.apply("option[_EncryptionConfiguration].value",v,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationTime__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationTime__ _arg<s3_test::option___ReplicationTime__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationTime__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationTime>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationTime__>(ivy_deser &inp, s3_test::option___ReplicationTime__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationTime__>(ivy_ser &res, const s3_test::option___ReplicationTime__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationTime__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationTime].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationTime].value",z3val,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationTime__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationTime__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationTime].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationTime].value",v,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationTime__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationTime].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationTime>(g,g.apply("option[_ReplicationTime].value",v,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Metrics__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Metrics__ _arg<s3_test::option___Metrics__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Metrics__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Metrics>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Metrics__>(ivy_deser &inp, s3_test::option___Metrics__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Metrics__>(ivy_ser &res, const s3_test::option___Metrics__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Metrics__& val) {
	        z3::expr z3end = g.apply("option[_Metrics].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Metrics].value",z3val,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Metrics__>( gen &g, const  z3::expr &v,s3_test::option___Metrics__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Metrics].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Metrics].value",v,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Metrics__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Metrics].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Metrics].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Metrics>(g,g.apply("option[_Metrics].value",v,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ServerSideEncryptionRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ServerSideEncryptionRule__ _arg<s3_test::vector___ServerSideEncryptionRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ServerSideEncryptionRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ServerSideEncryptionRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ServerSideEncryptionRule__>(ivy_deser &inp, s3_test::vector___ServerSideEncryptionRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ServerSideEncryptionRule__>(ivy_ser &res, const s3_test::vector___ServerSideEncryptionRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ServerSideEncryptionRule__& val) {
	        z3::expr z3end = g.apply("vector[_ServerSideEncryptionRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ServerSideEncryptionRule].value",z3val,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ServerSideEncryptionRule__>( gen &g, const  z3::expr &v,s3_test::vector___ServerSideEncryptionRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ServerSideEncryptionRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ServerSideEncryptionRule].value",v,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ServerSideEncryptionRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ServerSideEncryptionRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ServerSideEncryptionRule>(g,g.apply("vector[_ServerSideEncryptionRule].value",v,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___IntelligentTieringFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___IntelligentTieringFilter__ _arg<s3_test::option___IntelligentTieringFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___IntelligentTieringFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_IntelligentTieringFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___IntelligentTieringFilter__>(ivy_deser &inp, s3_test::option___IntelligentTieringFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___IntelligentTieringFilter__>(ivy_ser &res, const s3_test::option___IntelligentTieringFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___IntelligentTieringFilter__& val) {
	        z3::expr z3end = g.apply("option[_IntelligentTieringFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_IntelligentTieringFilter].value",z3val,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___IntelligentTieringFilter__>( gen &g, const  z3::expr &v,s3_test::option___IntelligentTieringFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_IntelligentTieringFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_IntelligentTieringFilter].value",v,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___IntelligentTieringFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_IntelligentTieringFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_IntelligentTieringFilter>(g,g.apply("option[_IntelligentTieringFilter].value",v,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Tiering__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Tiering__ _arg<s3_test::vector___Tiering__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Tiering__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tiering>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Tiering__>(ivy_deser &inp, s3_test::vector___Tiering__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Tiering__>(ivy_ser &res, const s3_test::vector___Tiering__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Tiering__& val) {
	        z3::expr z3end = g.apply("vector[_Tiering].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Tiering].value",z3val,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Tiering__>( gen &g, const  z3::expr &v,s3_test::vector___Tiering__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Tiering].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Tiering].value",v,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Tiering__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Tiering].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Tiering].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tiering>(g,g.apply("vector[_Tiering].value",v,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___InventoryEncryption__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___InventoryEncryption__ _arg<s3_test::option___InventoryEncryption__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___InventoryEncryption__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryEncryption>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___InventoryEncryption__>(ivy_deser &inp, s3_test::option___InventoryEncryption__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___InventoryEncryption__>(ivy_ser &res, const s3_test::option___InventoryEncryption__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___InventoryEncryption__& val) {
	        z3::expr z3end = g.apply("option[_InventoryEncryption].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_InventoryEncryption].value",z3val,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___InventoryEncryption__>( gen &g, const  z3::expr &v,s3_test::option___InventoryEncryption__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_InventoryEncryption].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_InventoryEncryption].value",v,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___InventoryEncryption__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_InventoryEncryption].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryEncryption>(g,g.apply("option[_InventoryEncryption].value",v,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___InventoryFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___InventoryFilter__ _arg<s3_test::option___InventoryFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___InventoryFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___InventoryFilter__>(ivy_deser &inp, s3_test::option___InventoryFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___InventoryFilter__>(ivy_ser &res, const s3_test::option___InventoryFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___InventoryFilter__& val) {
	        z3::expr z3end = g.apply("option[_InventoryFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_InventoryFilter].value",z3val,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___InventoryFilter__>( gen &g, const  z3::expr &v,s3_test::option___InventoryFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_InventoryFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_InventoryFilter].value",v,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___InventoryFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_InventoryFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryFilter>(g,g.apply("option[_InventoryFilter].value",v,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Transition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Transition__ _arg<s3_test::option___Transition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Transition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Transition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Transition__>(ivy_deser &inp, s3_test::option___Transition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Transition__>(ivy_ser &res, const s3_test::option___Transition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Transition__& val) {
	        z3::expr z3end = g.apply("option[_Transition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Transition].value",z3val,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Transition__>( gen &g, const  z3::expr &v,s3_test::option___Transition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Transition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Transition].value",v,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Transition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Transition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Transition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Transition>(g,g.apply("option[_Transition].value",v,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NoncurrentVersionTransition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NoncurrentVersionTransition__ _arg<s3_test::option___NoncurrentVersionTransition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NoncurrentVersionTransition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionTransition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NoncurrentVersionTransition__>(ivy_deser &inp, s3_test::option___NoncurrentVersionTransition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NoncurrentVersionTransition__>(ivy_ser &res, const s3_test::option___NoncurrentVersionTransition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NoncurrentVersionTransition__& val) {
	        z3::expr z3end = g.apply("option[_NoncurrentVersionTransition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NoncurrentVersionTransition].value",z3val,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v,s3_test::option___NoncurrentVersionTransition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NoncurrentVersionTransition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NoncurrentVersionTransition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionTransition>(g,g.apply("option[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Rule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Rule__ _arg<s3_test::vector___Rule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Rule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Rule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Rule__>(ivy_deser &inp, s3_test::vector___Rule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Rule__>(ivy_ser &res, const s3_test::vector___Rule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Rule__& val) {
	        z3::expr z3end = g.apply("vector[_Rule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Rule].value",z3val,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Rule__>( gen &g, const  z3::expr &v,s3_test::vector___Rule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Rule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Rule].value",v,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Rule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Rule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Rule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Rule>(g,g.apply("vector[_Rule].value",v,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___MetricsFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___MetricsFilter__ _arg<s3_test::option___MetricsFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___MetricsFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetricsFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___MetricsFilter__>(ivy_deser &inp, s3_test::option___MetricsFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___MetricsFilter__>(ivy_ser &res, const s3_test::option___MetricsFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___MetricsFilter__& val) {
	        z3::expr z3end = g.apply("option[_MetricsFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_MetricsFilter].value",z3val,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___MetricsFilter__>( gen &g, const  z3::expr &v,s3_test::option___MetricsFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_MetricsFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_MetricsFilter].value",v,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___MetricsFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_MetricsFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetricsFilter>(g,g.apply("option[_MetricsFilter].value",v,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___OwnershipControlsRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___OwnershipControlsRule__ _arg<s3_test::vector___OwnershipControlsRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___OwnershipControlsRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_OwnershipControlsRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___OwnershipControlsRule__>(ivy_deser &inp, s3_test::vector___OwnershipControlsRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___OwnershipControlsRule__>(ivy_ser &res, const s3_test::vector___OwnershipControlsRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___OwnershipControlsRule__& val) {
	        z3::expr z3end = g.apply("vector[_OwnershipControlsRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_OwnershipControlsRule].value",z3val,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___OwnershipControlsRule__>( gen &g, const  z3::expr &v,s3_test::vector___OwnershipControlsRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_OwnershipControlsRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_OwnershipControlsRule].value",v,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___OwnershipControlsRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_OwnershipControlsRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_OwnershipControlsRule>(g,g.apply("vector[_OwnershipControlsRule].value",v,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationRuleFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationRuleFilter__ _arg<s3_test::option___ReplicationRuleFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationRuleFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationRuleFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationRuleFilter__>(ivy_deser &inp, s3_test::option___ReplicationRuleFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationRuleFilter__>(ivy_ser &res, const s3_test::option___ReplicationRuleFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationRuleFilter__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationRuleFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationRuleFilter].value",z3val,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationRuleFilter__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationRuleFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationRuleFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationRuleFilter].value",v,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationRuleFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationRuleFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationRuleFilter>(g,g.apply("option[_ReplicationRuleFilter].value",v,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___SourceSelectionCriteria__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___SourceSelectionCriteria__ _arg<s3_test::option___SourceSelectionCriteria__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___SourceSelectionCriteria__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_SourceSelectionCriteria>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___SourceSelectionCriteria__>(ivy_deser &inp, s3_test::option___SourceSelectionCriteria__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___SourceSelectionCriteria__>(ivy_ser &res, const s3_test::option___SourceSelectionCriteria__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___SourceSelectionCriteria__& val) {
	        z3::expr z3end = g.apply("option[_SourceSelectionCriteria].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_SourceSelectionCriteria].value",z3val,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___SourceSelectionCriteria__>( gen &g, const  z3::expr &v,s3_test::option___SourceSelectionCriteria__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_SourceSelectionCriteria].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_SourceSelectionCriteria].value",v,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___SourceSelectionCriteria__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_SourceSelectionCriteria].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_SourceSelectionCriteria>(g,g.apply("option[_SourceSelectionCriteria].value",v,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ExistingObjectReplication__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ExistingObjectReplication__ _arg<s3_test::option___ExistingObjectReplication__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ExistingObjectReplication__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ExistingObjectReplication>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ExistingObjectReplication__>(ivy_deser &inp, s3_test::option___ExistingObjectReplication__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ExistingObjectReplication__>(ivy_ser &res, const s3_test::option___ExistingObjectReplication__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ExistingObjectReplication__& val) {
	        z3::expr z3end = g.apply("option[_ExistingObjectReplication].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ExistingObjectReplication].value",z3val,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ExistingObjectReplication__>( gen &g, const  z3::expr &v,s3_test::option___ExistingObjectReplication__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ExistingObjectReplication].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ExistingObjectReplication].value",v,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ExistingObjectReplication__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ExistingObjectReplication].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ExistingObjectReplication>(g,g.apply("option[_ExistingObjectReplication].value",v,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___DeleteMarkerReplication__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___DeleteMarkerReplication__ _arg<s3_test::option___DeleteMarkerReplication__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___DeleteMarkerReplication__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeleteMarkerReplication>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___DeleteMarkerReplication__>(ivy_deser &inp, s3_test::option___DeleteMarkerReplication__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___DeleteMarkerReplication__>(ivy_ser &res, const s3_test::option___DeleteMarkerReplication__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___DeleteMarkerReplication__& val) {
	        z3::expr z3end = g.apply("option[_DeleteMarkerReplication].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_DeleteMarkerReplication].value",z3val,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___DeleteMarkerReplication__>( gen &g, const  z3::expr &v,s3_test::option___DeleteMarkerReplication__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_DeleteMarkerReplication].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_DeleteMarkerReplication].value",v,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___DeleteMarkerReplication__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_DeleteMarkerReplication].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeleteMarkerReplication>(g,g.apply("option[_DeleteMarkerReplication].value",v,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ReplicationRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ReplicationRule__ _arg<s3_test::vector___ReplicationRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ReplicationRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ReplicationRule__>(ivy_deser &inp, s3_test::vector___ReplicationRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ReplicationRule__>(ivy_ser &res, const s3_test::vector___ReplicationRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ReplicationRule__& val) {
	        z3::expr z3end = g.apply("vector[_ReplicationRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ReplicationRule].value",z3val,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ReplicationRule__>( gen &g, const  z3::expr &v,s3_test::vector___ReplicationRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ReplicationRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ReplicationRule].value",v,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ReplicationRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ReplicationRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationRule>(g,g.apply("vector[_ReplicationRule].value",v,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Condition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Condition__ _arg<s3_test::option___Condition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Condition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Condition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Condition__>(ivy_deser &inp, s3_test::option___Condition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Condition__>(ivy_ser &res, const s3_test::option___Condition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Condition__& val) {
	        z3::expr z3end = g.apply("option[_Condition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Condition].value",z3val,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Condition__>( gen &g, const  z3::expr &v,s3_test::option___Condition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Condition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Condition].value",v,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Condition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Condition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Condition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Condition>(g,g.apply("option[_Condition].value",v,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___RoutingRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___RoutingRule__ _arg<s3_test::vector___RoutingRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___RoutingRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RoutingRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___RoutingRule__>(ivy_deser &inp, s3_test::vector___RoutingRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___RoutingRule__>(ivy_ser &res, const s3_test::vector___RoutingRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___RoutingRule__& val) {
	        z3::expr z3end = g.apply("vector[_RoutingRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_RoutingRule].value",z3val,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___RoutingRule__>( gen &g, const  z3::expr &v,s3_test::vector___RoutingRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_RoutingRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_RoutingRule].value",v,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___RoutingRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_RoutingRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RoutingRule>(g,g.apply("vector[_RoutingRule].value",v,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___FilterRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___FilterRule__ _arg<s3_test::vector___FilterRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___FilterRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_FilterRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___FilterRule__>(ivy_deser &inp, s3_test::vector___FilterRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___FilterRule__>(ivy_ser &res, const s3_test::vector___FilterRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___FilterRule__& val) {
	        z3::expr z3end = g.apply("vector[_FilterRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_FilterRule].value",z3val,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___FilterRule__>( gen &g, const  z3::expr &v,s3_test::vector___FilterRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_FilterRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_FilterRule].value",v,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___FilterRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_FilterRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_FilterRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_FilterRule>(g,g.apply("vector[_FilterRule].value",v,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NotificationConfigurationFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NotificationConfigurationFilter__ _arg<s3_test::option___NotificationConfigurationFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NotificationConfigurationFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NotificationConfigurationFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NotificationConfigurationFilter__>(ivy_deser &inp, s3_test::option___NotificationConfigurationFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NotificationConfigurationFilter__>(ivy_ser &res, const s3_test::option___NotificationConfigurationFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NotificationConfigurationFilter__& val) {
	        z3::expr z3end = g.apply("option[_NotificationConfigurationFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NotificationConfigurationFilter].value",z3val,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NotificationConfigurationFilter__>( gen &g, const  z3::expr &v,s3_test::option___NotificationConfigurationFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NotificationConfigurationFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NotificationConfigurationFilter].value",v,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NotificationConfigurationFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NotificationConfigurationFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NotificationConfigurationFilter>(g,g.apply("option[_NotificationConfigurationFilter].value",v,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___AnalyticsConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___AnalyticsConfiguration__ _arg<s3_test::vector___AnalyticsConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___AnalyticsConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AnalyticsConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___AnalyticsConfiguration__>(ivy_deser &inp, s3_test::vector___AnalyticsConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___AnalyticsConfiguration__>(ivy_ser &res, const s3_test::vector___AnalyticsConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___AnalyticsConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_AnalyticsConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_AnalyticsConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___AnalyticsConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___AnalyticsConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_AnalyticsConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_AnalyticsConfiguration].value",v,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___AnalyticsConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_AnalyticsConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AnalyticsConfiguration>(g,g.apply("vector[_AnalyticsConfiguration].value",v,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___IntelligentTieringConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___IntelligentTieringConfiguration__ _arg<s3_test::vector___IntelligentTieringConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___IntelligentTieringConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_IntelligentTieringConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___IntelligentTieringConfiguration__>(ivy_deser &inp, s3_test::vector___IntelligentTieringConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___IntelligentTieringConfiguration__>(ivy_ser &res, const s3_test::vector___IntelligentTieringConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___IntelligentTieringConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_IntelligentTieringConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_IntelligentTieringConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___IntelligentTieringConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___IntelligentTieringConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_IntelligentTieringConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_IntelligentTieringConfiguration].value",v,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___IntelligentTieringConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_IntelligentTieringConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_IntelligentTieringConfiguration>(g,g.apply("vector[_IntelligentTieringConfiguration].value",v,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___InventoryConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___InventoryConfiguration__ _arg<s3_test::vector___InventoryConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___InventoryConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___InventoryConfiguration__>(ivy_deser &inp, s3_test::vector___InventoryConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___InventoryConfiguration__>(ivy_ser &res, const s3_test::vector___InventoryConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___InventoryConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_InventoryConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_InventoryConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___InventoryConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___InventoryConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_InventoryConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_InventoryConfiguration].value",v,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___InventoryConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_InventoryConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryConfiguration>(g,g.apply("vector[_InventoryConfiguration].value",v,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MetricsConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MetricsConfiguration__ _arg<s3_test::vector___MetricsConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MetricsConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetricsConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MetricsConfiguration__>(ivy_deser &inp, s3_test::vector___MetricsConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MetricsConfiguration__>(ivy_ser &res, const s3_test::vector___MetricsConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MetricsConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_MetricsConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MetricsConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MetricsConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___MetricsConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MetricsConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MetricsConfiguration].value",v,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MetricsConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MetricsConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetricsConfiguration>(g,g.apply("vector[_MetricsConfiguration].value",v,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Bucket__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Bucket__ _arg<s3_test::vector___Bucket__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Bucket__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Bucket>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Bucket__>(ivy_deser &inp, s3_test::vector___Bucket__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Bucket__>(ivy_ser &res, const s3_test::vector___Bucket__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Bucket__& val) {
	        z3::expr z3end = g.apply("vector[_Bucket].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Bucket].value",z3val,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Bucket__>( gen &g, const  z3::expr &v,s3_test::vector___Bucket__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Bucket].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Bucket].value",v,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Bucket__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Bucket].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Bucket].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Bucket>(g,g.apply("vector[_Bucket].value",v,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MultipartUpload__ _arg<s3_test::vector___MultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MultipartUpload__>(ivy_deser &inp, s3_test::vector___MultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MultipartUpload__>(ivy_ser &res, const s3_test::vector___MultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MultipartUpload__& val) {
	        z3::expr z3end = g.apply("vector[_MultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MultipartUpload].value",z3val,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MultipartUpload__>( gen &g, const  z3::expr &v,s3_test::vector___MultipartUpload__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MultipartUpload].value",v,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MultipartUpload>(g,g.apply("vector[_MultipartUpload].value",v,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CommonPrefix__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CommonPrefix__ _arg<s3_test::vector___CommonPrefix__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CommonPrefix__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CommonPrefix>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CommonPrefix__>(ivy_deser &inp, s3_test::vector___CommonPrefix__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CommonPrefix__>(ivy_ser &res, const s3_test::vector___CommonPrefix__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CommonPrefix__& val) {
	        z3::expr z3end = g.apply("vector[_CommonPrefix].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CommonPrefix].value",z3val,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CommonPrefix__>( gen &g, const  z3::expr &v,s3_test::vector___CommonPrefix__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CommonPrefix].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CommonPrefix].value",v,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CommonPrefix__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CommonPrefix].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CommonPrefix>(g,g.apply("vector[_CommonPrefix].value",v,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ObjectVersion__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ObjectVersion__ _arg<s3_test::vector___ObjectVersion__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ObjectVersion__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectVersion>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ObjectVersion__>(ivy_deser &inp, s3_test::vector___ObjectVersion__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ObjectVersion__>(ivy_ser &res, const s3_test::vector___ObjectVersion__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ObjectVersion__& val) {
	        z3::expr z3end = g.apply("vector[_ObjectVersion].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ObjectVersion].value",z3val,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ObjectVersion__>( gen &g, const  z3::expr &v,s3_test::vector___ObjectVersion__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ObjectVersion].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ObjectVersion].value",v,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ObjectVersion__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ObjectVersion].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectVersion>(g,g.apply("vector[_ObjectVersion].value",v,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___DeleteMarkerEntry__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___DeleteMarkerEntry__ _arg<s3_test::vector___DeleteMarkerEntry__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___DeleteMarkerEntry__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeleteMarkerEntry>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___DeleteMarkerEntry__>(ivy_deser &inp, s3_test::vector___DeleteMarkerEntry__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___DeleteMarkerEntry__>(ivy_ser &res, const s3_test::vector___DeleteMarkerEntry__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___DeleteMarkerEntry__& val) {
	        z3::expr z3end = g.apply("vector[_DeleteMarkerEntry].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_DeleteMarkerEntry].value",z3val,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___DeleteMarkerEntry__>( gen &g, const  z3::expr &v,s3_test::vector___DeleteMarkerEntry__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_DeleteMarkerEntry].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_DeleteMarkerEntry].value",v,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___DeleteMarkerEntry__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__sz);
                z3::expr pred =  g.apply("vector[_DeleteMarkerEntry].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeleteMarkerEntry>(g,g.apply("vector[_DeleteMarkerEntry].value",v,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Object__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Object__ _arg<s3_test::vector___Object__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Object__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Object>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Object__>(ivy_deser &inp, s3_test::vector___Object__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Object__>(ivy_ser &res, const s3_test::vector___Object__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Object__& val) {
	        z3::expr z3end = g.apply("vector[_Object].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Object].value",z3val,g.int_to_z3(g.sort("vector[_Object].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Object__>( gen &g, const  z3::expr &v,s3_test::vector___Object__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Object].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Object].value",v,g.int_to_z3(g.sort("vector[_Object].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Object__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Object].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Object].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Object>(g,g.apply("vector[_Object].value",v,g.int_to_z3(g.sort("vector[_Object].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Part__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Part__ _arg<s3_test::vector___Part__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Part__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Part>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Part__>(ivy_deser &inp, s3_test::vector___Part__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Part__>(ivy_ser &res, const s3_test::vector___Part__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Part__& val) {
	        z3::expr z3end = g.apply("vector[_Part].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Part].value",z3val,g.int_to_z3(g.sort("vector[_Part].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Part__>( gen &g, const  z3::expr &v,s3_test::vector___Part__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Part].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Part].value",v,g.int_to_z3(g.sort("vector[_Part].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Part__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Part].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Part].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Part>(g,g.apply("vector[_Part].value",v,g.int_to_z3(g.sort("vector[_Part].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___TopicConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___TopicConfiguration__ _arg<s3_test::vector___TopicConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___TopicConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_TopicConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___TopicConfiguration__>(ivy_deser &inp, s3_test::vector___TopicConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___TopicConfiguration__>(ivy_ser &res, const s3_test::vector___TopicConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___TopicConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_TopicConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_TopicConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___TopicConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___TopicConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_TopicConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_TopicConfiguration].value",v,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___TopicConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_TopicConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_TopicConfiguration>(g,g.apply("vector[_TopicConfiguration].value",v,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___QueueConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___QueueConfiguration__ _arg<s3_test::vector___QueueConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___QueueConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_QueueConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___QueueConfiguration__>(ivy_deser &inp, s3_test::vector___QueueConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___QueueConfiguration__>(ivy_ser &res, const s3_test::vector___QueueConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___QueueConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_QueueConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_QueueConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___QueueConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___QueueConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_QueueConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_QueueConfiguration].value",v,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___QueueConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_QueueConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_QueueConfiguration>(g,g.apply("vector[_QueueConfiguration].value",v,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___LambdaFunctionConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___LambdaFunctionConfiguration__ _arg<s3_test::vector___LambdaFunctionConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___LambdaFunctionConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LambdaFunctionConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___LambdaFunctionConfiguration__>(ivy_deser &inp, s3_test::vector___LambdaFunctionConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___LambdaFunctionConfiguration__>(ivy_ser &res, const s3_test::vector___LambdaFunctionConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___LambdaFunctionConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_LambdaFunctionConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_LambdaFunctionConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___LambdaFunctionConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___LambdaFunctionConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_LambdaFunctionConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_LambdaFunctionConfiguration].value",v,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___LambdaFunctionConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_LambdaFunctionConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LambdaFunctionConfiguration>(g,g.apply("vector[_LambdaFunctionConfiguration].value",v,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Encryption__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Encryption__ _arg<s3_test::option___Encryption__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Encryption__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Encryption>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Encryption__>(ivy_deser &inp, s3_test::option___Encryption__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Encryption__>(ivy_ser &res, const s3_test::option___Encryption__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Encryption__& val) {
	        z3::expr z3end = g.apply("option[_Encryption].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Encryption].value",z3val,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Encryption__>( gen &g, const  z3::expr &v,s3_test::option___Encryption__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Encryption].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Encryption].value",v,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Encryption__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Encryption].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Encryption].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Encryption>(g,g.apply("option[_Encryption].value",v,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___Grant____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___Grant____ _arg<s3_test::option__vector___Grant____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___Grant____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___Grant__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___Grant____>(ivy_deser &inp, s3_test::option__vector___Grant____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___Grant____>(ivy_ser &res, const s3_test::option__vector___Grant____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___Grant____& val) {
	        z3::expr z3end = g.apply("option[vector[_Grant]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_Grant]].value",z3val,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___Grant____>( gen &g, const  z3::expr &v,s3_test::option__vector___Grant____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_Grant]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_Grant]].value",v,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___Grant____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_Grant]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___Grant__>(g,g.apply("option[vector[_Grant]].value",v,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Tagging__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Tagging__ _arg<s3_test::option___Tagging__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Tagging__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tagging>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Tagging__>(ivy_deser &inp, s3_test::option___Tagging__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Tagging__>(ivy_ser &res, const s3_test::option___Tagging__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Tagging__& val) {
	        z3::expr z3end = g.apply("option[_Tagging].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Tagging].value",z3val,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Tagging__>( gen &g, const  z3::expr &v,s3_test::option___Tagging__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Tagging].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Tagging].value",v,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Tagging__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Tagging].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Tagging].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tagging>(g,g.apply("option[_Tagging].value",v,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MetadataEntry__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MetadataEntry__ _arg<s3_test::vector___MetadataEntry__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MetadataEntry__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetadataEntry>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MetadataEntry__>(ivy_deser &inp, s3_test::vector___MetadataEntry__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MetadataEntry__>(ivy_ser &res, const s3_test::vector___MetadataEntry__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MetadataEntry__& val) {
	        z3::expr z3end = g.apply("vector[_MetadataEntry].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MetadataEntry].value",z3val,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MetadataEntry__>( gen &g, const  z3::expr &v,s3_test::vector___MetadataEntry__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MetadataEntry].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MetadataEntry].value",v,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MetadataEntry__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MetadataEntry].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetadataEntry>(g,g.apply("vector[_MetadataEntry].value",v,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___MetadataEntry____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___MetadataEntry____ _arg<s3_test::option__vector___MetadataEntry____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___MetadataEntry____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___MetadataEntry__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___MetadataEntry____>(ivy_deser &inp, s3_test::option__vector___MetadataEntry____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___MetadataEntry____>(ivy_ser &res, const s3_test::option__vector___MetadataEntry____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___MetadataEntry____& val) {
	        z3::expr z3end = g.apply("option[vector[_MetadataEntry]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_MetadataEntry]].value",z3val,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___MetadataEntry____>( gen &g, const  z3::expr &v,s3_test::option__vector___MetadataEntry____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_MetadataEntry]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_MetadataEntry]].value",v,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___MetadataEntry____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_MetadataEntry]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___MetadataEntry__>(g,g.apply("option[vector[_MetadataEntry]].value",v,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AccessControlPolicy__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AccessControlPolicy__ _arg<s3_test::option___AccessControlPolicy__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AccessControlPolicy__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AccessControlPolicy>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AccessControlPolicy__>(ivy_deser &inp, s3_test::option___AccessControlPolicy__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AccessControlPolicy__>(ivy_ser &res, const s3_test::option___AccessControlPolicy__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AccessControlPolicy__& val) {
	        z3::expr z3end = g.apply("option[_AccessControlPolicy].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AccessControlPolicy].value",z3val,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AccessControlPolicy__>( gen &g, const  z3::expr &v,s3_test::option___AccessControlPolicy__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AccessControlPolicy].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AccessControlPolicy].value",v,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AccessControlPolicy__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AccessControlPolicy].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AccessControlPolicy>(g,g.apply("option[_AccessControlPolicy].value",v,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___BucketLifecycleConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___BucketLifecycleConfiguration__ _arg<s3_test::option___BucketLifecycleConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___BucketLifecycleConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_BucketLifecycleConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___BucketLifecycleConfiguration__>(ivy_deser &inp, s3_test::option___BucketLifecycleConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___BucketLifecycleConfiguration__>(ivy_ser &res, const s3_test::option___BucketLifecycleConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___BucketLifecycleConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_BucketLifecycleConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_BucketLifecycleConfiguration].value",z3val,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___BucketLifecycleConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___BucketLifecycleConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_BucketLifecycleConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_BucketLifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___BucketLifecycleConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_BucketLifecycleConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_BucketLifecycleConfiguration>(g,g.apply("option[_BucketLifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleConfiguration__ _arg<s3_test::option___LifecycleConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleConfiguration__>(ivy_deser &inp, s3_test::option___LifecycleConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleConfiguration__>(ivy_ser &res, const s3_test::option___LifecycleConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleConfiguration].value",z3val,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleConfiguration>(g,g.apply("option[_LifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockLegalHold__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockLegalHold__ _arg<s3_test::option___ObjectLockLegalHold__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockLegalHold__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockLegalHold>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockLegalHold__>(ivy_deser &inp, s3_test::option___ObjectLockLegalHold__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockLegalHold__>(ivy_ser &res, const s3_test::option___ObjectLockLegalHold__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockLegalHold__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockLegalHold].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockLegalHold].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockLegalHold__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockLegalHold__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockLegalHold].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockLegalHold].value",v,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockLegalHold__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockLegalHold].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockLegalHold>(g,g.apply("option[_ObjectLockLegalHold].value",v,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockConfiguration__ _arg<s3_test::option___ObjectLockConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockConfiguration__>(ivy_deser &inp, s3_test::option___ObjectLockConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockConfiguration__>(ivy_ser &res, const s3_test::option___ObjectLockConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockConfiguration].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockConfiguration].value",v,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockConfiguration>(g,g.apply("option[_ObjectLockConfiguration].value",v,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__blob__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__blob__ _arg<s3_test::option__blob__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__blob__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::blob>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__blob__>(ivy_deser &inp, s3_test::option__blob__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__blob__>(ivy_ser &res, const s3_test::option__blob__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__blob__& val) {
	        z3::expr z3end = g.apply("option[blob].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[blob].value",z3val,g.int_to_z3(g.sort("option[blob].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__blob__>( gen &g, const  z3::expr &v,s3_test::option__blob__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[blob].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[blob].value",v,g.int_to_z3(g.sort("option[blob].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__blob__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[blob].domain_t"),__sz);
                z3::expr pred =  g.apply("option[blob].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::blob>(g,g.apply("option[blob].value",v,g.int_to_z3(g.sort("option[blob].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__long__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__long__ _arg<s3_test::option__long__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__long__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__long__>(ivy_deser &inp, s3_test::option__long__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__long__>(ivy_ser &res, const s3_test::option__long__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__long__& val) {
	        z3::expr z3end = g.apply("option[long].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[long].value",z3val,g.int_to_z3(g.sort("option[long].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__long__>( gen &g, const  z3::expr &v,s3_test::option__long__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[long].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[long].value",v,g.int_to_z3(g.sort("option[long].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__long__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[long].domain_t"),__sz);
                z3::expr pred =  g.apply("option[long].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[long].value",v,g.int_to_z3(g.sort("option[long].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockRetention__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockRetention__ _arg<s3_test::option___ObjectLockRetention__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockRetention__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockRetention>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockRetention__>(ivy_deser &inp, s3_test::option___ObjectLockRetention__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockRetention__>(ivy_ser &res, const s3_test::option___ObjectLockRetention__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockRetention__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockRetention].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockRetention].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockRetention__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockRetention__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockRetention].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockRetention].value",v,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockRetention__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockRetention].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockRetention>(g,g.apply("option[_ObjectLockRetention].value",v,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___RestoreRequest__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___RestoreRequest__ _arg<s3_test::option___RestoreRequest__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___RestoreRequest__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RestoreRequest>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___RestoreRequest__>(ivy_deser &inp, s3_test::option___RestoreRequest__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___RestoreRequest__>(ivy_ser &res, const s3_test::option___RestoreRequest__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___RestoreRequest__& val) {
	        z3::expr z3end = g.apply("option[_RestoreRequest].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_RestoreRequest].value",z3val,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___RestoreRequest__>( gen &g, const  z3::expr &v,s3_test::option___RestoreRequest__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_RestoreRequest].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_RestoreRequest].value",v,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___RestoreRequest__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_RestoreRequest].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RestoreRequest>(g,g.apply("option[_RestoreRequest].value",v,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___RequestProgress__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___RequestProgress__ _arg<s3_test::option___RequestProgress__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___RequestProgress__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RequestProgress>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___RequestProgress__>(ivy_deser &inp, s3_test::option___RequestProgress__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___RequestProgress__>(ivy_ser &res, const s3_test::option___RequestProgress__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___RequestProgress__& val) {
	        z3::expr z3end = g.apply("option[_RequestProgress].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_RequestProgress].value",z3val,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___RequestProgress__>( gen &g, const  z3::expr &v,s3_test::option___RequestProgress__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_RequestProgress].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_RequestProgress].value",v,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___RequestProgress__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_RequestProgress].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RequestProgress>(g,g.apply("option[_RequestProgress].value",v,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ScanRange__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ScanRange__ _arg<s3_test::option___ScanRange__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ScanRange__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ScanRange>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ScanRange__>(ivy_deser &inp, s3_test::option___ScanRange__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ScanRange__>(ivy_ser &res, const s3_test::option___ScanRange__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ScanRange__& val) {
	        z3::expr z3end = g.apply("option[_ScanRange].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ScanRange].value",z3val,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ScanRange__>( gen &g, const  z3::expr &v,s3_test::option___ScanRange__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ScanRange].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ScanRange].value",v,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ScanRange__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ScanRange].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ScanRange>(g,g.apply("option[_ScanRange].value",v,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)));
	    }
	    #endif

	#include <aws/core/Aws.h>
#include <aws/s3/S3Client.h>
#include <sstream>

std::shared_ptr<Aws::IOStream> blob_to_iostream(const s3_test::blob &data) {
    Aws::String s((char*)data.data(),data.size());
    std::cout << "data: " << s << 
    Aws::IOStream *x = new Aws::StringStream(s);
    std::shared_ptr<Aws::IOStream> y(x);
    return y;
}

Aws::Map<Aws::String, Aws::String> map_to_aws(s3_test::unordered_map__string____string__ map) {
    Aws::Map<Aws::String, Aws::String> res;
    for(auto it=map.begin(), en=map.end(); it != en; ++it){
        res[it->first.c_str()] = it->second.c_str();
    }
    return res;
}

#include <aws/s3/model/AbortMultipartUploadRequest.h>
#include <aws/s3/model/CompleteMultipartUploadRequest.h>
#include <aws/s3/model/CopyObjectRequest.h>
#include <aws/s3/model/CreateBucketRequest.h>
#include <aws/s3/model/CreateMultipartUploadRequest.h>
#include <aws/s3/model/DeleteBucketRequest.h>
#include <aws/s3/model/DeleteBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketCorsRequest.h>
#include <aws/s3/model/DeleteBucketEncryptionRequest.h>
#include <aws/s3/model/DeleteBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketLifecycleRequest.h>
#include <aws/s3/model/DeleteBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketOwnershipControlsRequest.h>
#include <aws/s3/model/DeleteBucketPolicyRequest.h>
#include <aws/s3/model/DeleteBucketReplicationRequest.h>
#include <aws/s3/model/DeleteBucketTaggingRequest.h>
#include <aws/s3/model/DeleteBucketWebsiteRequest.h>
#include <aws/s3/model/DeleteObjectRequest.h>
#include <aws/s3/model/DeleteObjectTaggingRequest.h>
#include <aws/s3/model/DeleteObjectsRequest.h>
#include <aws/s3/model/DeletePublicAccessBlockRequest.h>
#include <aws/s3/model/GetBucketAccelerateConfigurationRequest.h>
#include <aws/s3/model/GetBucketAclRequest.h>
#include <aws/s3/model/GetBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/GetBucketCorsRequest.h>
#include <aws/s3/model/GetBucketEncryptionRequest.h>
#include <aws/s3/model/GetBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/GetBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/GetBucketLifecycleConfigurationRequest.h>
#include <aws/s3/model/GetBucketLocationRequest.h>
#include <aws/s3/model/GetBucketLoggingRequest.h>
#include <aws/s3/model/GetBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/GetBucketNotificationConfigurationRequest.h>
#include <aws/s3/model/GetBucketOwnershipControlsRequest.h>
#include <aws/s3/model/GetBucketPolicyRequest.h>
#include <aws/s3/model/GetBucketPolicyStatusRequest.h>
#include <aws/s3/model/GetBucketReplicationRequest.h>
#include <aws/s3/model/GetBucketRequestPaymentRequest.h>
#include <aws/s3/model/GetBucketTaggingRequest.h>
#include <aws/s3/model/GetBucketVersioningRequest.h>
#include <aws/s3/model/GetBucketWebsiteRequest.h>
#include <aws/s3/model/GetObjectRequest.h>
#include <aws/s3/model/GetObjectAclRequest.h>
#include <aws/s3/model/GetObjectLegalHoldRequest.h>
#include <aws/s3/model/GetObjectLockConfigurationRequest.h>
#include <aws/s3/model/GetObjectRetentionRequest.h>
#include <aws/s3/model/GetObjectTaggingRequest.h>
#include <aws/s3/model/GetObjectTorrentRequest.h>
#include <aws/s3/model/GetPublicAccessBlockRequest.h>
#include <aws/s3/model/HeadBucketRequest.h>
#include <aws/s3/model/HeadObjectRequest.h>
#include <aws/s3/model/ListBucketAnalyticsConfigurationsRequest.h>
#include <aws/s3/model/ListBucketIntelligentTieringConfigurationsRequest.h>
#include <aws/s3/model/ListBucketInventoryConfigurationsRequest.h>
#include <aws/s3/model/ListBucketMetricsConfigurationsRequest.h>
#include <aws/s3/model/ListMultipartUploadsRequest.h>
#include <aws/s3/model/ListObjectVersionsRequest.h>
#include <aws/s3/model/ListObjectsRequest.h>
#include <aws/s3/model/ListObjectsV2Request.h>
#include <aws/s3/model/ListPartsRequest.h>
#include <aws/s3/model/PutBucketAccelerateConfigurationRequest.h>
#include <aws/s3/model/PutBucketAclRequest.h>
#include <aws/s3/model/PutBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/PutBucketCorsRequest.h>
#include <aws/s3/model/PutBucketEncryptionRequest.h>
#include <aws/s3/model/PutBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/PutBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/PutBucketLifecycleConfigurationRequest.h>
#include <aws/s3/model/PutBucketLoggingRequest.h>
#include <aws/s3/model/PutBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/PutBucketNotificationConfigurationRequest.h>
#include <aws/s3/model/PutBucketOwnershipControlsRequest.h>
#include <aws/s3/model/PutBucketPolicyRequest.h>
#include <aws/s3/model/PutBucketReplicationRequest.h>
#include <aws/s3/model/PutBucketRequestPaymentRequest.h>
#include <aws/s3/model/PutBucketTaggingRequest.h>
#include <aws/s3/model/PutBucketVersioningRequest.h>
#include <aws/s3/model/PutBucketWebsiteRequest.h>
#include <aws/s3/model/PutObjectRequest.h>
#include <aws/s3/model/PutObjectAclRequest.h>
#include <aws/s3/model/PutObjectLegalHoldRequest.h>
#include <aws/s3/model/PutObjectLockConfigurationRequest.h>
#include <aws/s3/model/PutObjectRetentionRequest.h>
#include <aws/s3/model/PutObjectTaggingRequest.h>
#include <aws/s3/model/PutPublicAccessBlockRequest.h>
#include <aws/s3/model/RestoreObjectRequest.h>
#include <aws/s3/model/SelectObjectContentRequest.h>
#include <aws/s3/model/UploadPartRequest.h>
#include <aws/s3/model/UploadPartCopyRequest.h>
#include <aws/s3/model/WriteGetObjectResponseRequest.h>
int s3_test::___ivy_choose(int rng,const char *name,int id) {
        return 0;
    }
unsigned s3_test::blob__value(const blob& a, unsigned long long i){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::blob__end(const blob& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
__strlit s3_test::option__string____value(const option__string__& a, unsigned i){
    __strlit val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__string____end(const option__string__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Grant s3_test::vector___Grant____value(const vector___Grant__& a, unsigned long long i){
    s3_test::_Grant val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Grant____end(const vector___Grant__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tag s3_test::vector___Tag____value(const vector___Tag__& a, unsigned long long i){
    s3_test::_Tag val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Tag____end(const vector___Tag__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AnalyticsFilter s3_test::option___AnalyticsFilter____value(const option___AnalyticsFilter__& a, unsigned i){
    s3_test::_AnalyticsFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AnalyticsFilter____end(const option___AnalyticsFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleExpiration s3_test::option___LifecycleExpiration____value(const option___LifecycleExpiration__& a, unsigned i){
    s3_test::_LifecycleExpiration val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._ExpiredObjectDeleteMarker_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleExpiration____end(const option___LifecycleExpiration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleRuleFilter s3_test::option___LifecycleRuleFilter____value(const option___LifecycleRuleFilter__& a, unsigned i){
    s3_test::_LifecycleRuleFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleRuleFilter____end(const option___LifecycleRuleFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Transition s3_test::vector___Transition____value(const vector___Transition__& a, unsigned long long i){
    s3_test::_Transition val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Transition____end(const vector___Transition__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___Transition__ s3_test::option__vector___Transition______value(const option__vector___Transition____& a, unsigned i){
    s3_test::vector___Transition__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___Transition______end(const option__vector___Transition____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionTransition s3_test::vector___NoncurrentVersionTransition____value(const vector___NoncurrentVersionTransition__& a, unsigned long long i){
    s3_test::_NoncurrentVersionTransition val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___NoncurrentVersionTransition____end(const vector___NoncurrentVersionTransition__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___NoncurrentVersionTransition__ s3_test::option__vector___NoncurrentVersionTransition______value(const option__vector___NoncurrentVersionTransition____& a, unsigned i){
    s3_test::vector___NoncurrentVersionTransition__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___NoncurrentVersionTransition______end(const option__vector___NoncurrentVersionTransition____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionExpiration s3_test::option___NoncurrentVersionExpiration____value(const option___NoncurrentVersionExpiration__& a, unsigned i){
    s3_test::_NoncurrentVersionExpiration val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NoncurrentVersionExpiration____end(const option___NoncurrentVersionExpiration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AbortIncompleteMultipartUpload s3_test::option___AbortIncompleteMultipartUpload____value(const option___AbortIncompleteMultipartUpload__& a, unsigned i){
    s3_test::_AbortIncompleteMultipartUpload val;
    val._DaysAfterInitiation_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AbortIncompleteMultipartUpload____end(const option___AbortIncompleteMultipartUpload__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleRule s3_test::vector___LifecycleRule____value(const vector___LifecycleRule__& a, unsigned long long i){
    s3_test::_LifecycleRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___LifecycleRule____end(const vector___LifecycleRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_TargetGrant s3_test::vector___TargetGrant____value(const vector___TargetGrant__& a, unsigned long long i){
    s3_test::_TargetGrant val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___TargetGrant____end(const vector___TargetGrant__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___TargetGrant__ s3_test::option__vector___TargetGrant______value(const option__vector___TargetGrant____& a, unsigned i){
    s3_test::vector___TargetGrant__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___TargetGrant______end(const option__vector___TargetGrant____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
__strlit s3_test::vector__string____value(const vector__string__& a, unsigned long long i){
    __strlit val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector__string____end(const vector__string__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector__string__ s3_test::option__vector__string______value(const option__vector__string____& a, unsigned i){
    s3_test::vector__string__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector__string______end(const option__vector__string____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__integer____value(const option__integer__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__integer____end(const option__integer__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CORSRule s3_test::vector___CORSRule____value(const vector___CORSRule__& a, unsigned long long i){
    s3_test::_CORSRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CORSRule____end(const vector___CORSRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CompletedPart s3_test::vector___CompletedPart____value(const vector___CompletedPart__& a, unsigned long long i){
    s3_test::_CompletedPart val;
    val._PartNumber_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CompletedPart____end(const vector___CompletedPart__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CompletedMultipartUpload s3_test::option___CompletedMultipartUpload____value(const option___CompletedMultipartUpload__& a, unsigned i){
    s3_test::_CompletedMultipartUpload val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___CompletedMultipartUpload____end(const option___CompletedMultipartUpload__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__timestamp____value(const option__timestamp__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__timestamp____end(const option__timestamp__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::unordered_map__string____string__ s3_test::option__unordered_map__string____string______value(const option__unordered_map__string____string____& a, unsigned i){
    s3_test::unordered_map__string____string__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__unordered_map__string____string______end(const option__unordered_map__string____string____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
bool s3_test::option__bool____value(const option__bool__& a, unsigned i){
    bool val;
    val = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__bool____end(const option__bool__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CreateBucketConfiguration s3_test::option___CreateBucketConfiguration____value(const option___CreateBucketConfiguration__& a, unsigned i){
    s3_test::_CreateBucketConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___CreateBucketConfiguration____end(const option___CreateBucketConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectIdentifier s3_test::vector___ObjectIdentifier____value(const vector___ObjectIdentifier__& a, unsigned long long i){
    s3_test::_ObjectIdentifier val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ObjectIdentifier____end(const vector___ObjectIdentifier__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeletedObject s3_test::vector___DeletedObject____value(const vector___DeletedObject__& a, unsigned long long i){
    s3_test::_DeletedObject val;
    val._DeleteMarker_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___DeletedObject____end(const vector___DeletedObject__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Error s3_test::vector___Error____value(const vector___Error__& a, unsigned long long i){
    s3_test::_Error val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Error____end(const vector___Error__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationTimeValue s3_test::option___ReplicationTimeValue____value(const option___ReplicationTimeValue__& a, unsigned i){
    s3_test::_ReplicationTimeValue val;
    val._Minutes_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationTimeValue____end(const option___ReplicationTimeValue__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AccessControlTranslation s3_test::option___AccessControlTranslation____value(const option___AccessControlTranslation__& a, unsigned i){
    s3_test::_AccessControlTranslation val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AccessControlTranslation____end(const option___AccessControlTranslation__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_EncryptionConfiguration s3_test::option___EncryptionConfiguration____value(const option___EncryptionConfiguration__& a, unsigned i){
    s3_test::_EncryptionConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___EncryptionConfiguration____end(const option___EncryptionConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationTime s3_test::option___ReplicationTime____value(const option___ReplicationTime__& a, unsigned i){
    s3_test::_ReplicationTime val;
    val._Time_._Minutes_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationTime____end(const option___ReplicationTime__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Metrics s3_test::option___Metrics____value(const option___Metrics__& a, unsigned i){
    s3_test::_Metrics val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Metrics____end(const option___Metrics__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ServerSideEncryptionRule s3_test::vector___ServerSideEncryptionRule____value(const vector___ServerSideEncryptionRule__& a, unsigned long long i){
    s3_test::_ServerSideEncryptionRule val;
    val._BucketKeyEnabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ServerSideEncryptionRule____end(const vector___ServerSideEncryptionRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_IntelligentTieringFilter s3_test::option___IntelligentTieringFilter____value(const option___IntelligentTieringFilter__& a, unsigned i){
    s3_test::_IntelligentTieringFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___IntelligentTieringFilter____end(const option___IntelligentTieringFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tiering s3_test::vector___Tiering____value(const vector___Tiering__& a, unsigned long long i){
    s3_test::_Tiering val;
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Tiering____end(const vector___Tiering__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryEncryption s3_test::option___InventoryEncryption____value(const option___InventoryEncryption__& a, unsigned i){
    s3_test::_InventoryEncryption val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___InventoryEncryption____end(const option___InventoryEncryption__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryFilter s3_test::option___InventoryFilter____value(const option___InventoryFilter__& a, unsigned i){
    s3_test::_InventoryFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___InventoryFilter____end(const option___InventoryFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Transition s3_test::option___Transition____value(const option___Transition__& a, unsigned i){
    s3_test::_Transition val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Transition____end(const option___Transition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionTransition s3_test::option___NoncurrentVersionTransition____value(const option___NoncurrentVersionTransition__& a, unsigned i){
    s3_test::_NoncurrentVersionTransition val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NoncurrentVersionTransition____end(const option___NoncurrentVersionTransition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Rule s3_test::vector___Rule____value(const vector___Rule__& a, unsigned long long i){
    s3_test::_Rule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Rule____end(const vector___Rule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetricsFilter s3_test::option___MetricsFilter____value(const option___MetricsFilter__& a, unsigned i){
    s3_test::_MetricsFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___MetricsFilter____end(const option___MetricsFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_OwnershipControlsRule s3_test::vector___OwnershipControlsRule____value(const vector___OwnershipControlsRule__& a, unsigned long long i){
    s3_test::_OwnershipControlsRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___OwnershipControlsRule____end(const vector___OwnershipControlsRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationRuleFilter s3_test::option___ReplicationRuleFilter____value(const option___ReplicationRuleFilter__& a, unsigned i){
    s3_test::_ReplicationRuleFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationRuleFilter____end(const option___ReplicationRuleFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_SourceSelectionCriteria s3_test::option___SourceSelectionCriteria____value(const option___SourceSelectionCriteria__& a, unsigned i){
    s3_test::_SourceSelectionCriteria val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___SourceSelectionCriteria____end(const option___SourceSelectionCriteria__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ExistingObjectReplication s3_test::option___ExistingObjectReplication____value(const option___ExistingObjectReplication__& a, unsigned i){
    s3_test::_ExistingObjectReplication val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ExistingObjectReplication____end(const option___ExistingObjectReplication__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeleteMarkerReplication s3_test::option___DeleteMarkerReplication____value(const option___DeleteMarkerReplication__& a, unsigned i){
    s3_test::_DeleteMarkerReplication val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___DeleteMarkerReplication____end(const option___DeleteMarkerReplication__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationRule s3_test::vector___ReplicationRule____value(const vector___ReplicationRule__& a, unsigned long long i){
    s3_test::_ReplicationRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ReplicationRule____end(const vector___ReplicationRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Condition s3_test::option___Condition____value(const option___Condition__& a, unsigned i){
    s3_test::_Condition val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Condition____end(const option___Condition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RoutingRule s3_test::vector___RoutingRule____value(const vector___RoutingRule__& a, unsigned long long i){
    s3_test::_RoutingRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___RoutingRule____end(const vector___RoutingRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_FilterRule s3_test::vector___FilterRule____value(const vector___FilterRule__& a, unsigned long long i){
    s3_test::_FilterRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___FilterRule____end(const vector___FilterRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NotificationConfigurationFilter s3_test::option___NotificationConfigurationFilter____value(const option___NotificationConfigurationFilter__& a, unsigned i){
    s3_test::_NotificationConfigurationFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NotificationConfigurationFilter____end(const option___NotificationConfigurationFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AnalyticsConfiguration s3_test::vector___AnalyticsConfiguration____value(const vector___AnalyticsConfiguration__& a, unsigned long long i){
    s3_test::_AnalyticsConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___AnalyticsConfiguration____end(const vector___AnalyticsConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_IntelligentTieringConfiguration s3_test::vector___IntelligentTieringConfiguration____value(const vector___IntelligentTieringConfiguration__& a, unsigned long long i){
    s3_test::_IntelligentTieringConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___IntelligentTieringConfiguration____end(const vector___IntelligentTieringConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryConfiguration s3_test::vector___InventoryConfiguration____value(const vector___InventoryConfiguration__& a, unsigned long long i){
    s3_test::_InventoryConfiguration val;
    val._IsEnabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___InventoryConfiguration____end(const vector___InventoryConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetricsConfiguration s3_test::vector___MetricsConfiguration____value(const vector___MetricsConfiguration__& a, unsigned long long i){
    s3_test::_MetricsConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MetricsConfiguration____end(const vector___MetricsConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Bucket s3_test::vector___Bucket____value(const vector___Bucket__& a, unsigned long long i){
    s3_test::_Bucket val;
    val._CreationDate_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Bucket____end(const vector___Bucket__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MultipartUpload s3_test::vector___MultipartUpload____value(const vector___MultipartUpload__& a, unsigned long long i){
    s3_test::_MultipartUpload val;
    val._Initiated_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MultipartUpload____end(const vector___MultipartUpload__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CommonPrefix s3_test::vector___CommonPrefix____value(const vector___CommonPrefix__& a, unsigned long long i){
    s3_test::_CommonPrefix val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CommonPrefix____end(const vector___CommonPrefix__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectVersion s3_test::vector___ObjectVersion____value(const vector___ObjectVersion__& a, unsigned long long i){
    s3_test::_ObjectVersion val;
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val._IsLatest_ = (bool)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ObjectVersion____end(const vector___ObjectVersion__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeleteMarkerEntry s3_test::vector___DeleteMarkerEntry____value(const vector___DeleteMarkerEntry__& a, unsigned long long i){
    s3_test::_DeleteMarkerEntry val;
    val._IsLatest_ = (bool)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___DeleteMarkerEntry____end(const vector___DeleteMarkerEntry__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Object s3_test::vector___Object____value(const vector___Object__& a, unsigned long long i){
    s3_test::_Object val;
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Object____end(const vector___Object__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Part s3_test::vector___Part____value(const vector___Part__& a, unsigned long long i){
    s3_test::_Part val;
    val._PartNumber_ = (int)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Part____end(const vector___Part__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_TopicConfiguration s3_test::vector___TopicConfiguration____value(const vector___TopicConfiguration__& a, unsigned long long i){
    s3_test::_TopicConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___TopicConfiguration____end(const vector___TopicConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_QueueConfiguration s3_test::vector___QueueConfiguration____value(const vector___QueueConfiguration__& a, unsigned long long i){
    s3_test::_QueueConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___QueueConfiguration____end(const vector___QueueConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LambdaFunctionConfiguration s3_test::vector___LambdaFunctionConfiguration____value(const vector___LambdaFunctionConfiguration__& a, unsigned long long i){
    s3_test::_LambdaFunctionConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___LambdaFunctionConfiguration____end(const vector___LambdaFunctionConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Encryption s3_test::option___Encryption____value(const option___Encryption__& a, unsigned i){
    s3_test::_Encryption val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Encryption____end(const option___Encryption__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___Grant__ s3_test::option__vector___Grant______value(const option__vector___Grant____& a, unsigned i){
    s3_test::vector___Grant__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___Grant______end(const option__vector___Grant____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tagging s3_test::option___Tagging____value(const option___Tagging__& a, unsigned i){
    s3_test::_Tagging val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Tagging____end(const option___Tagging__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetadataEntry s3_test::vector___MetadataEntry____value(const vector___MetadataEntry__& a, unsigned long long i){
    s3_test::_MetadataEntry val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MetadataEntry____end(const vector___MetadataEntry__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___MetadataEntry__ s3_test::option__vector___MetadataEntry______value(const option__vector___MetadataEntry____& a, unsigned i){
    s3_test::vector___MetadataEntry__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___MetadataEntry______end(const option__vector___MetadataEntry____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AccessControlPolicy s3_test::option___AccessControlPolicy____value(const option___AccessControlPolicy__& a, unsigned i){
    s3_test::_AccessControlPolicy val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AccessControlPolicy____end(const option___AccessControlPolicy__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_BucketLifecycleConfiguration s3_test::option___BucketLifecycleConfiguration____value(const option___BucketLifecycleConfiguration__& a, unsigned i){
    s3_test::_BucketLifecycleConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___BucketLifecycleConfiguration____end(const option___BucketLifecycleConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleConfiguration s3_test::option___LifecycleConfiguration____value(const option___LifecycleConfiguration__& a, unsigned i){
    s3_test::_LifecycleConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleConfiguration____end(const option___LifecycleConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockLegalHold s3_test::option___ObjectLockLegalHold____value(const option___ObjectLockLegalHold__& a, unsigned i){
    s3_test::_ObjectLockLegalHold val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockLegalHold____end(const option___ObjectLockLegalHold__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockConfiguration s3_test::option___ObjectLockConfiguration____value(const option___ObjectLockConfiguration__& a, unsigned i){
    s3_test::_ObjectLockConfiguration val;
    val._Rule_._DefaultRetention_._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._Rule_._DefaultRetention_._Years_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockConfiguration____end(const option___ObjectLockConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::blob s3_test::option__blob____value(const option__blob__& a, unsigned i){
    s3_test::blob val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__blob____end(const option__blob__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__long____value(const option__long__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__long____end(const option__long__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockRetention s3_test::option___ObjectLockRetention____value(const option___ObjectLockRetention__& a, unsigned i){
    s3_test::_ObjectLockRetention val;
    val._RetainUntilDate_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockRetention____end(const option___ObjectLockRetention__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RestoreRequest s3_test::option___RestoreRequest____value(const option___RestoreRequest__& a, unsigned i){
    s3_test::_RestoreRequest val;
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._SelectParameters_._InputSerialization_._CSV_._AllowQuotedRecordDelimiter_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___RestoreRequest____end(const option___RestoreRequest__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RequestProgress s3_test::option___RequestProgress____value(const option___RequestProgress__& a, unsigned i){
    s3_test::_RequestProgress val;
    val._Enabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___RequestProgress____end(const option___RequestProgress__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ScanRange s3_test::option___ScanRange____value(const option___ScanRange__& a, unsigned i){
    s3_test::_ScanRange val;
    val._Start_ = (int)___ivy_choose(0,"ret:val",0);
    val._End_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ScanRange____end(const option___ScanRange__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
void s3_test::ext__get(__strlit bucket, __strlit key){
    {
        {
            _GetObjectRequest loc__req;
            {
                loc__req._Bucket_ = bucket;
                loc__req._Key_ = key;
                ext___GetObject__request(loc__req);
            }
        }
    }
}
void s3_test::__init(){
    {
    }
}
void s3_test::_GetObject__response_GetObjectOutput(const _GetObjectOutput& val){
    imp___GetObject__response_GetObjectOutput(val);
}
void s3_test::imp___GetObject__response_GetObjectOutput(const _GetObjectOutput& val){
    {
    }
}
void s3_test::imp___PutObject__response_PutObjectOutput(const _PutObjectOutput& val){
    {
    }
}
void s3_test::ext__put(__strlit bucket, __strlit key, blob data){
    {
        {
            _PutObjectRequest loc__req;
            {
                loc__req._Bucket_ = bucket;
                loc__req._Key_ = key;
                ext__option__blob____append(loc__req._Body_, data);
                ext___PutObject__request(loc__req);
            }
        }
    }
}
void s3_test::ext___PutObject__request(const _PutObjectRequest& input){
    {
    
        Aws::Client::ClientConfiguration config;
        Aws::S3::S3Client s3_client(config);
        Aws::S3::Model::PutObjectRequest request;
        if (input._ACL_.size()) {
            request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
        }
        if (input._Body_.size()) {
            request.SetBody(blob_to_iostream(input._Body_[0]));
        }
        request.SetBucket(input._Bucket_.c_str());
        if (input._CacheControl_.size()) {
            request.SetCacheControl(input._CacheControl_[0].c_str());
        }
        if (input._ContentDisposition_.size()) {
            request.SetContentDisposition(input._ContentDisposition_[0].c_str());
        }
        if (input._ContentEncoding_.size()) {
            request.SetContentEncoding(input._ContentEncoding_[0].c_str());
        }
        if (input._ContentLanguage_.size()) {
            request.SetContentLanguage(input._ContentLanguage_[0].c_str());
        }
        if (input._ContentLength_.size()) {
            request.SetContentLength(input._ContentLength_[0]);
        }
        if (input._ContentMD5_.size()) {
            request.SetContentMD5(input._ContentMD5_[0].c_str());
        }
        if (input._ContentType_.size()) {
            request.SetContentType(input._ContentType_[0].c_str());
        }
        if (input._Expires_.size()) {
            request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
        }
        if (input._GrantFullControl_.size()) {
            request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
        }
        if (input._GrantRead_.size()) {
            request.SetGrantRead(input._GrantRead_[0].c_str());
        }
        if (input._GrantReadACP_.size()) {
            request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
        }
        if (input._GrantWriteACP_.size()) {
            request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
        }
        request.SetKey(input._Key_.c_str());
        if (input._Metadata_.size()) {
            request.SetMetadata(map_to_aws(input._Metadata_[0]));
        }
        if (input._ServerSideEncryption_.size()) {
            request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
        }
        if (input._StorageClass_.size()) {
            request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
        }
        if (input._WebsiteRedirectLocation_.size()) {
            request.SetWebsiteRedirectLocation(input._WebsiteRedirectLocation_[0].c_str());
        }
        if (input._SSECustomerAlgorithm_.size()) {
            request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
        }
        if (input._SSECustomerKey_.size()) {
            request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
        }
        if (input._SSECustomerKeyMD5_.size()) {
            request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
        }
        if (input._SSEKMSKeyId_.size()) {
            request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
        }
        if (input._SSEKMSEncryptionContext_.size()) {
            request.SetSSEKMSEncryptionContext(input._SSEKMSEncryptionContext_[0].c_str());
        }
        if (input._BucketKeyEnabled_.size()) {
            request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
        }
        if (input._RequestPayer_.size()) {
            request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
        }
        if (input._Tagging_.size()) {
            request.SetTagging(input._Tagging_[0].c_str());
        }
        if (input._ObjectLockMode_.size()) {
            request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
        }
        if (input._ObjectLockRetainUntilDate_.size()) {
            request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
        }
        if (input._ObjectLockLegalHoldStatus_.size()) {
            request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
        }
        if (input._ExpectedBucketOwner_.size()) {
            request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
        }
        Aws::S3::Model::PutObjectOutcome outcome = s3_client.PutObject(request);
        if (outcome.IsSuccess()) {
            auto result = outcome.GetResultWithOwnership();
            _PutObjectOutput res;
            res._Expiration_ = result.GetExpiration().c_str();
            res._ETag_ = result.GetETag().c_str();
            res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
            res._VersionId_ = result.GetVersionId().c_str();
            res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
            res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
            res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
            res._SSEKMSEncryptionContext_ = result.GetSSEKMSEncryptionContext().c_str();
            res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
            res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
            thunk___PutObject__response_PutObjectOutput(this)(res);
        }
    }
}
void s3_test::ext___GetObject__request(const _GetObjectRequest& input){
    {
    
        Aws::Client::ClientConfiguration config;
        Aws::S3::S3Client s3_client(config);
        Aws::S3::Model::GetObjectRequest request;
        request.SetBucket(input._Bucket_.c_str());
        if (input._IfMatch_.size()) {
            request.SetIfMatch(input._IfMatch_[0].c_str());
        }
        if (input._IfModifiedSince_.size()) {
            request.SetIfModifiedSince(Aws::Utils::DateTime((int64_t)input._IfModifiedSince_[0]));
        }
        if (input._IfNoneMatch_.size()) {
            request.SetIfNoneMatch(input._IfNoneMatch_[0].c_str());
        }
        if (input._IfUnmodifiedSince_.size()) {
            request.SetIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._IfUnmodifiedSince_[0]));
        }
        request.SetKey(input._Key_.c_str());
        if (input._Range_.size()) {
            request.SetRange(input._Range_[0].c_str());
        }
        if (input._ResponseCacheControl_.size()) {
            request.SetResponseCacheControl(input._ResponseCacheControl_[0].c_str());
        }
        if (input._ResponseContentDisposition_.size()) {
            request.SetResponseContentDisposition(input._ResponseContentDisposition_[0].c_str());
        }
        if (input._ResponseContentEncoding_.size()) {
            request.SetResponseContentEncoding(input._ResponseContentEncoding_[0].c_str());
        }
        if (input._ResponseContentLanguage_.size()) {
            request.SetResponseContentLanguage(input._ResponseContentLanguage_[0].c_str());
        }
        if (input._ResponseContentType_.size()) {
            request.SetResponseContentType(input._ResponseContentType_[0].c_str());
        }
        if (input._ResponseExpires_.size()) {
            request.SetResponseExpires(Aws::Utils::DateTime((int64_t)input._ResponseExpires_[0]));
        }
        if (input._VersionId_.size()) {
            request.SetVersionId(input._VersionId_[0].c_str());
        }
        if (input._SSECustomerAlgorithm_.size()) {
            request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
        }
        if (input._SSECustomerKey_.size()) {
            request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
        }
        if (input._SSECustomerKeyMD5_.size()) {
            request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
        }
        if (input._RequestPayer_.size()) {
            request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
        }
        if (input._PartNumber_.size()) {
            request.SetPartNumber(input._PartNumber_[0]);
        }
        if (input._ExpectedBucketOwner_.size()) {
            request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
        }
        Aws::S3::Model::GetObjectOutcome outcome = s3_client.GetObject(request);
        if (outcome.IsSuccess()) {
            auto result = outcome.GetResultWithOwnership();
            _GetObjectOutput res;
            res._Body_.insert(res._Body_.end(), std::istream_iterator<char>(result.GetBody()),std::istream_iterator<char>{});
            res._DeleteMarker_ = result.GetDeleteMarker();
            res._AcceptRanges_ = result.GetAcceptRanges().c_str();
            res._Expiration_ = result.GetExpiration().c_str();
            res._Restore_ = result.GetRestore().c_str();
            res._LastModified_ = result.GetLastModified().Millis();
            res._ContentLength_ = result.GetContentLength();
            res._ETag_ = result.GetETag().c_str();
            res._MissingMeta_ = result.GetMissingMeta();
            res._VersionId_ = result.GetVersionId().c_str();
            res._CacheControl_ = result.GetCacheControl().c_str();
            res._ContentDisposition_ = result.GetContentDisposition().c_str();
            res._ContentEncoding_ = result.GetContentEncoding().c_str();
            res._ContentLanguage_ = result.GetContentLanguage().c_str();
            res._ContentRange_ = result.GetContentRange().c_str();
            res._ContentType_ = result.GetContentType().c_str();
            res._Expires_ = result.GetExpires().Millis();
            res._WebsiteRedirectLocation_ = result.GetWebsiteRedirectLocation().c_str();
            res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
            for (auto it = result.GetMetadata().begin(), en = result.GetMetadata().end(); it != en; ++it) { res._Metadata_[it->first.c_str()] = it->second.c_str(); }
            res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
            res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
            res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
            res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
            res._StorageClass_ = Aws::S3::Model::StorageClassMapper::GetNameForStorageClass(result.GetStorageClass()).c_str();
            res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
            res._ReplicationStatus_ = Aws::S3::Model::ReplicationStatusMapper::GetNameForReplicationStatus(result.GetReplicationStatus()).c_str();
            res._PartsCount_ = result.GetPartsCount();
            res._TagCount_ = result.GetTagCount();
            res._ObjectLockMode_ = Aws::S3::Model::ObjectLockModeMapper::GetNameForObjectLockMode(result.GetObjectLockMode()).c_str();
            res._ObjectLockRetainUntilDate_ = result.GetObjectLockRetainUntilDate().Millis();
            res._ObjectLockLegalHoldStatus_ = Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetNameForObjectLockLegalHoldStatus(result.GetObjectLockLegalHoldStatus()).c_str();
            thunk___GetObject__response_GetObjectOutput(this)(res);
        }
    }
}
void s3_test::_PutObject__response_PutObjectOutput(const _PutObjectOutput& val){
    imp___PutObject__response_PutObjectOutput(val);
}
void s3_test::ext__option__blob____append(option__blob__& a, const blob& v){
    {

        a.push_back(v);
    }
}
void s3_test::__tick(int __timeout){
}
s3_test::s3_test(){
#ifdef _WIN32
mutex = CreateMutex(NULL,FALSE,NULL);
#else
pthread_mutex_init(&mutex,NULL);
#endif
__lock();
    __CARD__option__vector___NoncurrentVersionTransition______domain_t = 2;
    __CARD__vector___TargetGrant____domain = 0;
    __CARD__option___ReplicationTime____domain_t = 2;
    __CARD__vector___ReplicationRule____domain = 0;
    __CARD__byte = 256;
    __CARD__option__long____domain_t = 2;
    __CARD__option___AbortIncompleteMultipartUpload____domain_t = 2;
    __CARD__option___InventoryEncryption____domain_t = 2;
    __CARD__long = 0;
    __CARD__vector___Object____domain = 0;
    __CARD__option___NoncurrentVersionExpiration____domain_t = 2;
    __CARD__vector___ObjectVersion____domain = 0;
    __CARD__option___RequestProgress____domain_t = 2;
    __CARD__option___NoncurrentVersionTransition____domain_t = 2;
    __CARD__option___Transition____domain_t = 2;
    __CARD__option___NotificationConfigurationFilter____domain_t = 2;
    __CARD__vector__string____domain = 0;
    __CARD__option___ObjectLockRetention____domain_t = 2;
    __CARD__option___MetricsFilter____domain_t = 2;
    __CARD__string = 0;
    __CARD__vector___NoncurrentVersionTransition____domain = 0;
    __CARD__timestamp = 0;
    __CARD__vector___RoutingRule____domain = 0;
    __CARD__option___ReplicationTimeValue____domain_t = 2;
    __CARD__vector___CORSRule____domain = 0;
    __CARD__vector___DeletedObject____domain = 0;
    __CARD__integer = 0;
    __CARD__vector___Bucket____domain = 0;
    __CARD__option__vector___TargetGrant______domain_t = 2;
    __CARD__vector___ObjectIdentifier____domain = 0;
    __CARD__vector___Grant____domain = 0;
    __CARD__option__vector__string______domain_t = 2;
    __CARD__vector___CompletedPart____domain = 0;
    __CARD__vector___FilterRule____domain = 0;
    __CARD__option___LifecycleRuleFilter____domain_t = 2;
    __CARD__option__unordered_map__string____string______domain_t = 2;
    __CARD__option___CompletedMultipartUpload____domain_t = 2;
    __CARD__vector___TopicConfiguration____domain = 0;
    __CARD__vector___Tiering____domain = 0;
    __CARD__vector___DeleteMarkerEntry____domain = 0;
    __CARD__option___BucketLifecycleConfiguration____domain_t = 2;
    __CARD__vector___MultipartUpload____domain = 0;
    __CARD__option___EncryptionConfiguration____domain_t = 2;
    __CARD__option___SourceSelectionCriteria____domain_t = 2;
    __CARD__option___LifecycleExpiration____domain_t = 2;
    __CARD__option___CreateBucketConfiguration____domain_t = 2;
    __CARD__option__vector___Transition______domain_t = 2;
    __CARD__vector___LambdaFunctionConfiguration____domain = 0;
    __CARD__vector___ServerSideEncryptionRule____domain = 0;
    __CARD__vector___MetricsConfiguration____domain = 0;
    __CARD__option__string____domain_t = 2;
    __CARD__vector___IntelligentTieringConfiguration____domain = 0;
    __CARD__option___ObjectLockLegalHold____domain_t = 2;
    __CARD__vector___Part____domain = 0;
    __CARD__blob__domain = 0;
    __CARD__option___Condition____domain_t = 2;
    __CARD__vector___CommonPrefix____domain = 0;
    __CARD__option___LifecycleConfiguration____domain_t = 2;
    __CARD__option__integer____domain_t = 2;
    __CARD__option___AccessControlPolicy____domain_t = 2;
    __CARD__vector___Error____domain = 0;
    __CARD__vector___Transition____domain = 0;
    __CARD__option___AccessControlTranslation____domain_t = 2;
    __CARD__vector___MetadataEntry____domain = 0;
    __CARD__vector___OwnershipControlsRule____domain = 0;
    __CARD__option___Tagging____domain_t = 2;
    __CARD__option___DeleteMarkerReplication____domain_t = 2;
    __CARD__option___ScanRange____domain_t = 2;
    __CARD__option__bool____domain_t = 2;
    __CARD__option___Encryption____domain_t = 2;
    __CARD__option___ExistingObjectReplication____domain_t = 2;
    __CARD__option___Metrics____domain_t = 2;
    __CARD__option__blob____domain_t = 2;
    __CARD__option___IntelligentTieringFilter____domain_t = 2;
    __CARD__vector___Rule____domain = 0;
    __CARD__option__vector___Grant______domain_t = 2;
    __CARD__option___ReplicationRuleFilter____domain_t = 2;
    __CARD__vector___InventoryConfiguration____domain = 0;
    __CARD__option__vector___MetadataEntry______domain_t = 2;
    __CARD__option___RestoreRequest____domain_t = 2;
    __CARD__option__timestamp____domain_t = 2;
    __CARD__option___ObjectLockConfiguration____domain_t = 2;
    __CARD__vector___LifecycleRule____domain = 0;
    __CARD__option___AnalyticsFilter____domain_t = 2;
    __CARD__vector___QueueConfiguration____domain = 0;
    __CARD__vector___AnalyticsConfiguration____domain = 0;
    __CARD__option___InventoryFilter____domain_t = 2;
    __CARD__vector___Tag____domain = 0;
    {
        Aws::SDKOptions options;
        Aws::InitAPI(options);
    }
    _generating = (bool)___ivy_choose(0,"init",0);
}
s3_test::~s3_test(){
    __lock(); // otherwise, thread may die holding lock!
    for (unsigned i = 0; i < thread_ids.size(); i++){
#ifdef _WIN32
       // No idea how to cancel a thread on Windows. We just suspend it
       // so it can't cause any harm as we destruct this object.
       SuspendThread(thread_ids[i]);
#else
        pthread_cancel(thread_ids[i]);
        pthread_join(thread_ids[i],NULL);
#endif
    }
    __unlock();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AbortIncompleteMultipartUpload &t){
    s<<"{";
    s<< "_DaysAfterInitiation_:";
    s << t._DaysAfterInitiation_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AbortIncompleteMultipartUpload>(ivy_ser &res, const s3_test::_AbortIncompleteMultipartUpload&t){
    res.open_struct();
    res.open_field("_DaysAfterInitiation_");
    __ser<int>(res,t._DaysAfterInitiation_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Grantee &t){
    s<<"{";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<",";
    s<< "_EmailAddress_:";
    s << t._EmailAddress_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Type_:";
    s << t._Type_;
    s<<",";
    s<< "_URI_:";
    s << t._URI_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Grantee>(ivy_ser &res, const s3_test::_Grantee&t){
    res.open_struct();
    res.open_field("_DisplayName_");
    __ser<s3_test::option__string__>(res,t._DisplayName_);
    res.close_field();
    res.open_field("_EmailAddress_");
    __ser<s3_test::option__string__>(res,t._EmailAddress_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Type_");
    __ser<__strlit>(res,t._Type_);
    res.close_field();
    res.open_field("_URI_");
    __ser<s3_test::option__string__>(res,t._URI_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Grant &t){
    s<<"{";
    s<< "_Grantee_:";
    s << t._Grantee_;
    s<<",";
    s<< "_Permission_:";
    s << t._Permission_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Grant>(ivy_ser &res, const s3_test::_Grant&t){
    res.open_struct();
    res.open_field("_Grantee_");
    __ser<s3_test::_Grantee>(res,t._Grantee_);
    res.close_field();
    res.open_field("_Permission_");
    __ser<__strlit>(res,t._Permission_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Owner &t){
    s<<"{";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Owner>(ivy_ser &res, const s3_test::_Owner&t){
    res.open_struct();
    res.open_field("_DisplayName_");
    __ser<__strlit>(res,t._DisplayName_);
    res.close_field();
    res.open_field("_ID_");
    __ser<__strlit>(res,t._ID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlPolicy &t){
    s<<"{";
    s<< "_Grants_:";
    s << t._Grants_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AccessControlPolicy>(ivy_ser &res, const s3_test::_AccessControlPolicy&t){
    res.open_struct();
    res.open_field("_Grants_");
    __ser<s3_test::vector___Grant__>(res,t._Grants_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlTranslation &t){
    s<<"{";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AccessControlTranslation>(ivy_ser &res, const s3_test::_AccessControlTranslation&t){
    res.open_struct();
    res.open_field("_Owner_");
    __ser<__strlit>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tag &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tag>(ivy_ser &res, const s3_test::_Tag&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_Value_");
    __ser<__strlit>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsAndOperator>(ivy_ser &res, const s3_test::_AnalyticsAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsFilter>(ivy_ser &res, const s3_test::_AnalyticsFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_AnalyticsAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsS3BucketDestination &t){
    s<<"{";
    s<< "_Format_:";
    s << t._Format_;
    s<<",";
    s<< "_BucketAccountId_:";
    s << t._BucketAccountId_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsS3BucketDestination>(ivy_ser &res, const s3_test::_AnalyticsS3BucketDestination&t){
    res.open_struct();
    res.open_field("_Format_");
    __ser<__strlit>(res,t._Format_);
    res.close_field();
    res.open_field("_BucketAccountId_");
    __ser<s3_test::option__string__>(res,t._BucketAccountId_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<__strlit>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsExportDestination &t){
    s<<"{";
    s<< "_S3BucketDestination_:";
    s << t._S3BucketDestination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsExportDestination>(ivy_ser &res, const s3_test::_AnalyticsExportDestination&t){
    res.open_struct();
    res.open_field("_S3BucketDestination_");
    __ser<s3_test::_AnalyticsS3BucketDestination>(res,t._S3BucketDestination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysisDataExport &t){
    s<<"{";
    s<< "_OutputSchemaVersion_:";
    s << t._OutputSchemaVersion_;
    s<<",";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_StorageClassAnalysisDataExport>(ivy_ser &res, const s3_test::_StorageClassAnalysisDataExport&t){
    res.open_struct();
    res.open_field("_OutputSchemaVersion_");
    __ser<__strlit>(res,t._OutputSchemaVersion_);
    res.close_field();
    res.open_field("_Destination_");
    __ser<s3_test::_AnalyticsExportDestination>(res,t._Destination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysis &t){
    s<<"{";
    s<< "_DataExport_:";
    s << t._DataExport_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_StorageClassAnalysis>(ivy_ser &res, const s3_test::_StorageClassAnalysis&t){
    res.open_struct();
    res.open_field("_DataExport_");
    __ser<s3_test::_StorageClassAnalysisDataExport>(res,t._DataExport_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_StorageClassAnalysis_:";
    s << t._StorageClassAnalysis_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsConfiguration>(ivy_ser &res, const s3_test::_AnalyticsConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<__strlit>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___AnalyticsFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_StorageClassAnalysis_");
    __ser<s3_test::_StorageClassAnalysis>(res,t._StorageClassAnalysis_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Bucket &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_CreationDate_:";
    s << t._CreationDate_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Bucket>(ivy_ser &res, const s3_test::_Bucket&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<__strlit>(res,t._Name_);
    res.close_field();
    res.open_field("_CreationDate_");
    __ser<int>(res,t._CreationDate_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleExpiration &t){
    s<<"{";
    s<< "_Date_:";
    s << t._Date_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_ExpiredObjectDeleteMarker_:";
    s << t._ExpiredObjectDeleteMarker_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleExpiration>(ivy_ser &res, const s3_test::_LifecycleExpiration&t){
    res.open_struct();
    res.open_field("_Date_");
    __ser<int>(res,t._Date_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_ExpiredObjectDeleteMarker_");
    __ser<bool>(res,t._ExpiredObjectDeleteMarker_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRuleAndOperator>(ivy_ser &res, const s3_test::_LifecycleRuleAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRuleFilter>(ivy_ser &res, const s3_test::_LifecycleRuleFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_LifecycleRuleAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Transition &t){
    s<<"{";
    s<< "_Date_:";
    s << t._Date_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Transition>(ivy_ser &res, const s3_test::_Transition&t){
    res.open_struct();
    res.open_field("_Date_");
    __ser<int>(res,t._Date_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionTransition &t){
    s<<"{";
    s<< "_NoncurrentDays_:";
    s << t._NoncurrentDays_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NoncurrentVersionTransition>(ivy_ser &res, const s3_test::_NoncurrentVersionTransition&t){
    res.open_struct();
    res.open_field("_NoncurrentDays_");
    __ser<int>(res,t._NoncurrentDays_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionExpiration &t){
    s<<"{";
    s<< "_NoncurrentDays_:";
    s << t._NoncurrentDays_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NoncurrentVersionExpiration>(ivy_ser &res, const s3_test::_NoncurrentVersionExpiration&t){
    res.open_struct();
    res.open_field("_NoncurrentDays_");
    __ser<int>(res,t._NoncurrentDays_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRule &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Transitions_:";
    s << t._Transitions_;
    s<<",";
    s<< "_NoncurrentVersionTransitions_:";
    s << t._NoncurrentVersionTransitions_;
    s<<",";
    s<< "_NoncurrentVersionExpiration_:";
    s << t._NoncurrentVersionExpiration_;
    s<<",";
    s<< "_AbortIncompleteMultipartUpload_:";
    s << t._AbortIncompleteMultipartUpload_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRule>(ivy_ser &res, const s3_test::_LifecycleRule&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<s3_test::option___LifecycleExpiration__>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___LifecycleRuleFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_Transitions_");
    __ser<s3_test::option__vector___Transition____>(res,t._Transitions_);
    res.close_field();
    res.open_field("_NoncurrentVersionTransitions_");
    __ser<s3_test::option__vector___NoncurrentVersionTransition____>(res,t._NoncurrentVersionTransitions_);
    res.close_field();
    res.open_field("_NoncurrentVersionExpiration_");
    __ser<s3_test::option___NoncurrentVersionExpiration__>(res,t._NoncurrentVersionExpiration_);
    res.close_field();
    res.open_field("_AbortIncompleteMultipartUpload_");
    __ser<s3_test::option___AbortIncompleteMultipartUpload__>(res,t._AbortIncompleteMultipartUpload_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_BucketLifecycleConfiguration &t){
    s<<"{";
    s<< "_Rules_:";
    s << t._Rules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_BucketLifecycleConfiguration>(ivy_ser &res, const s3_test::_BucketLifecycleConfiguration&t){
    res.open_struct();
    res.open_field("_Rules_");
    __ser<s3_test::vector___LifecycleRule__>(res,t._Rules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_TargetGrant &t){
    s<<"{";
    s<< "_Grantee_:";
    s << t._Grantee_;
    s<<",";
    s<< "_Permission_:";
    s << t._Permission_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_TargetGrant>(ivy_ser &res, const s3_test::_TargetGrant&t){
    res.open_struct();
    res.open_field("_Grantee_");
    __ser<s3_test::_Grantee>(res,t._Grantee_);
    res.close_field();
    res.open_field("_Permission_");
    __ser<__strlit>(res,t._Permission_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CORSRule &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_AllowedHeaders_:";
    s << t._AllowedHeaders_;
    s<<",";
    s<< "_AllowedMethods_:";
    s << t._AllowedMethods_;
    s<<",";
    s<< "_AllowedOrigins_:";
    s << t._AllowedOrigins_;
    s<<",";
    s<< "_ExposeHeaders_:";
    s << t._ExposeHeaders_;
    s<<",";
    s<< "_MaxAgeSeconds_:";
    s << t._MaxAgeSeconds_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CORSRule>(ivy_ser &res, const s3_test::_CORSRule&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_AllowedHeaders_");
    __ser<s3_test::option__vector__string____>(res,t._AllowedHeaders_);
    res.close_field();
    res.open_field("_AllowedMethods_");
    __ser<s3_test::vector__string__>(res,t._AllowedMethods_);
    res.close_field();
    res.open_field("_AllowedOrigins_");
    __ser<s3_test::vector__string__>(res,t._AllowedOrigins_);
    res.close_field();
    res.open_field("_ExposeHeaders_");
    __ser<s3_test::option__vector__string____>(res,t._ExposeHeaders_);
    res.close_field();
    res.open_field("_MaxAgeSeconds_");
    __ser<s3_test::option__integer__>(res,t._MaxAgeSeconds_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVInput &t){
    s<<"{";
    s<< "_FileHeaderInfo_:";
    s << t._FileHeaderInfo_;
    s<<",";
    s<< "_Comments_:";
    s << t._Comments_;
    s<<",";
    s<< "_QuoteEscapeCharacter_:";
    s << t._QuoteEscapeCharacter_;
    s<<",";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<",";
    s<< "_FieldDelimiter_:";
    s << t._FieldDelimiter_;
    s<<",";
    s<< "_QuoteCharacter_:";
    s << t._QuoteCharacter_;
    s<<",";
    s<< "_AllowQuotedRecordDelimiter_:";
    s << t._AllowQuotedRecordDelimiter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CSVInput>(ivy_ser &res, const s3_test::_CSVInput&t){
    res.open_struct();
    res.open_field("_FileHeaderInfo_");
    __ser<__strlit>(res,t._FileHeaderInfo_);
    res.close_field();
    res.open_field("_Comments_");
    __ser<__strlit>(res,t._Comments_);
    res.close_field();
    res.open_field("_QuoteEscapeCharacter_");
    __ser<__strlit>(res,t._QuoteEscapeCharacter_);
    res.close_field();
    res.open_field("_RecordDelimiter_");
    __ser<__strlit>(res,t._RecordDelimiter_);
    res.close_field();
    res.open_field("_FieldDelimiter_");
    __ser<__strlit>(res,t._FieldDelimiter_);
    res.close_field();
    res.open_field("_QuoteCharacter_");
    __ser<__strlit>(res,t._QuoteCharacter_);
    res.close_field();
    res.open_field("_AllowQuotedRecordDelimiter_");
    __ser<bool>(res,t._AllowQuotedRecordDelimiter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVOutput &t){
    s<<"{";
    s<< "_QuoteFields_:";
    s << t._QuoteFields_;
    s<<",";
    s<< "_QuoteEscapeCharacter_:";
    s << t._QuoteEscapeCharacter_;
    s<<",";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<",";
    s<< "_FieldDelimiter_:";
    s << t._FieldDelimiter_;
    s<<",";
    s<< "_QuoteCharacter_:";
    s << t._QuoteCharacter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CSVOutput>(ivy_ser &res, const s3_test::_CSVOutput&t){
    res.open_struct();
    res.open_field("_QuoteFields_");
    __ser<__strlit>(res,t._QuoteFields_);
    res.close_field();
    res.open_field("_QuoteEscapeCharacter_");
    __ser<__strlit>(res,t._QuoteEscapeCharacter_);
    res.close_field();
    res.open_field("_RecordDelimiter_");
    __ser<__strlit>(res,t._RecordDelimiter_);
    res.close_field();
    res.open_field("_FieldDelimiter_");
    __ser<__strlit>(res,t._FieldDelimiter_);
    res.close_field();
    res.open_field("_QuoteCharacter_");
    __ser<__strlit>(res,t._QuoteCharacter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CommonPrefix &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CommonPrefix>(ivy_ser &res, const s3_test::_CommonPrefix&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedPart &t){
    s<<"{";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CompletedPart>(ivy_ser &res, const s3_test::_CompletedPart&t){
    res.open_struct();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_PartNumber_");
    __ser<int>(res,t._PartNumber_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedMultipartUpload &t){
    s<<"{";
    s<< "_Parts_:";
    s << t._Parts_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CompletedMultipartUpload>(ivy_ser &res, const s3_test::_CompletedMultipartUpload&t){
    res.open_struct();
    res.open_field("_Parts_");
    __ser<s3_test::vector___CompletedPart__>(res,t._Parts_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Condition &t){
    s<<"{";
    s<< "_HttpErrorCodeReturnedEquals_:";
    s << t._HttpErrorCodeReturnedEquals_;
    s<<",";
    s<< "_KeyPrefixEquals_:";
    s << t._KeyPrefixEquals_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Condition>(ivy_ser &res, const s3_test::_Condition&t){
    res.open_struct();
    res.open_field("_HttpErrorCodeReturnedEquals_");
    __ser<__strlit>(res,t._HttpErrorCodeReturnedEquals_);
    res.close_field();
    res.open_field("_KeyPrefixEquals_");
    __ser<__strlit>(res,t._KeyPrefixEquals_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CreateBucketConfiguration &t){
    s<<"{";
    s<< "_LocationConstraint_:";
    s << t._LocationConstraint_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CreateBucketConfiguration>(ivy_ser &res, const s3_test::_CreateBucketConfiguration&t){
    res.open_struct();
    res.open_field("_LocationConstraint_");
    __ser<__strlit>(res,t._LocationConstraint_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DefaultRetention &t){
    s<<"{";
    s<< "_Mode_:";
    s << t._Mode_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_Years_:";
    s << t._Years_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DefaultRetention>(ivy_ser &res, const s3_test::_DefaultRetention&t){
    res.open_struct();
    res.open_field("_Mode_");
    __ser<__strlit>(res,t._Mode_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_Years_");
    __ser<int>(res,t._Years_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectIdentifier &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectIdentifier>(ivy_ser &res, const s3_test::_ObjectIdentifier&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::option__string__>(res,t._VersionId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerEntry &t){
    s<<"{";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_IsLatest_:";
    s << t._IsLatest_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeleteMarkerEntry>(ivy_ser &res, const s3_test::_DeleteMarkerEntry&t){
    res.open_struct();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_IsLatest_");
    __ser<bool>(res,t._IsLatest_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerReplication &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeleteMarkerReplication>(ivy_ser &res, const s3_test::_DeleteMarkerReplication&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeletedObject &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_DeleteMarker_:";
    s << t._DeleteMarker_;
    s<<",";
    s<< "_DeleteMarkerVersionId_:";
    s << t._DeleteMarkerVersionId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeletedObject>(ivy_ser &res, const s3_test::_DeletedObject&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_DeleteMarker_");
    __ser<bool>(res,t._DeleteMarker_);
    res.close_field();
    res.open_field("_DeleteMarkerVersionId_");
    __ser<__strlit>(res,t._DeleteMarkerVersionId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Error &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_Code_:";
    s << t._Code_;
    s<<",";
    s<< "_Message_:";
    s << t._Message_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Error>(ivy_ser &res, const s3_test::_Error&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_Code_");
    __ser<__strlit>(res,t._Code_);
    res.close_field();
    res.open_field("_Message_");
    __ser<__strlit>(res,t._Message_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_EncryptionConfiguration &t){
    s<<"{";
    s<< "_ReplicaKmsKeyID_:";
    s << t._ReplicaKmsKeyID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_EncryptionConfiguration>(ivy_ser &res, const s3_test::_EncryptionConfiguration&t){
    res.open_struct();
    res.open_field("_ReplicaKmsKeyID_");
    __ser<__strlit>(res,t._ReplicaKmsKeyID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTimeValue &t){
    s<<"{";
    s<< "_Minutes_:";
    s << t._Minutes_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationTimeValue>(ivy_ser &res, const s3_test::_ReplicationTimeValue&t){
    res.open_struct();
    res.open_field("_Minutes_");
    __ser<int>(res,t._Minutes_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTime &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Time_:";
    s << t._Time_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationTime>(ivy_ser &res, const s3_test::_ReplicationTime&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_Time_");
    __ser<s3_test::_ReplicationTimeValue>(res,t._Time_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Metrics &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_EventThreshold_:";
    s << t._EventThreshold_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Metrics>(ivy_ser &res, const s3_test::_Metrics&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_EventThreshold_");
    __ser<s3_test::option___ReplicationTimeValue__>(res,t._EventThreshold_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Destination &t){
    s<<"{";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Account_:";
    s << t._Account_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_AccessControlTranslation_:";
    s << t._AccessControlTranslation_;
    s<<",";
    s<< "_EncryptionConfiguration_:";
    s << t._EncryptionConfiguration_;
    s<<",";
    s<< "_ReplicationTime_:";
    s << t._ReplicationTime_;
    s<<",";
    s<< "_Metrics_:";
    s << t._Metrics_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Destination>(ivy_ser &res, const s3_test::_Destination&t){
    res.open_struct();
    res.open_field("_Bucket_");
    __ser<__strlit>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Account_");
    __ser<s3_test::option__string__>(res,t._Account_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_AccessControlTranslation_");
    __ser<s3_test::option___AccessControlTranslation__>(res,t._AccessControlTranslation_);
    res.close_field();
    res.open_field("_EncryptionConfiguration_");
    __ser<s3_test::option___EncryptionConfiguration__>(res,t._EncryptionConfiguration_);
    res.close_field();
    res.open_field("_ReplicationTime_");
    __ser<s3_test::option___ReplicationTime__>(res,t._ReplicationTime_);
    res.close_field();
    res.open_field("_Metrics_");
    __ser<s3_test::option___Metrics__>(res,t._Metrics_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Encryption &t){
    s<<"{";
    s<< "_EncryptionType_:";
    s << t._EncryptionType_;
    s<<",";
    s<< "_KMSKeyId_:";
    s << t._KMSKeyId_;
    s<<",";
    s<< "_KMSContext_:";
    s << t._KMSContext_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Encryption>(ivy_ser &res, const s3_test::_Encryption&t){
    res.open_struct();
    res.open_field("_EncryptionType_");
    __ser<__strlit>(res,t._EncryptionType_);
    res.close_field();
    res.open_field("_KMSKeyId_");
    __ser<s3_test::option__string__>(res,t._KMSKeyId_);
    res.close_field();
    res.open_field("_KMSContext_");
    __ser<s3_test::option__string__>(res,t._KMSContext_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ExistingObjectReplication &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ExistingObjectReplication>(ivy_ser &res, const s3_test::_ExistingObjectReplication&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_FilterRule &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_FilterRule>(ivy_ser &res, const s3_test::_FilterRule&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<__strlit>(res,t._Name_);
    res.close_field();
    res.open_field("_Value_");
    __ser<__strlit>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionByDefault &t){
    s<<"{";
    s<< "_SSEAlgorithm_:";
    s << t._SSEAlgorithm_;
    s<<",";
    s<< "_KMSMasterKeyID_:";
    s << t._KMSMasterKeyID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ServerSideEncryptionByDefault>(ivy_ser &res, const s3_test::_ServerSideEncryptionByDefault&t){
    res.open_struct();
    res.open_field("_SSEAlgorithm_");
    __ser<__strlit>(res,t._SSEAlgorithm_);
    res.close_field();
    res.open_field("_KMSMasterKeyID_");
    __ser<s3_test::option__string__>(res,t._KMSMasterKeyID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionRule &t){
    s<<"{";
    s<< "_ApplyServerSideEncryptionByDefault_:";
    s << t._ApplyServerSideEncryptionByDefault_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ServerSideEncryptionRule>(ivy_ser &res, const s3_test::_ServerSideEncryptionRule&t){
    res.open_struct();
    res.open_field("_ApplyServerSideEncryptionByDefault_");
    __ser<s3_test::_ServerSideEncryptionByDefault>(res,t._ApplyServerSideEncryptionByDefault_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringAndOperator>(ivy_ser &res, const s3_test::_IntelligentTieringAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringFilter>(ivy_ser &res, const s3_test::_IntelligentTieringFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_IntelligentTieringAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tiering &t){
    s<<"{";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_AccessTier_:";
    s << t._AccessTier_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tiering>(ivy_ser &res, const s3_test::_Tiering&t){
    res.open_struct();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_AccessTier_");
    __ser<__strlit>(res,t._AccessTier_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Tierings_:";
    s << t._Tierings_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringConfiguration>(ivy_ser &res, const s3_test::_IntelligentTieringConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<__strlit>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___IntelligentTieringFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_Tierings_");
    __ser<s3_test::vector___Tiering__>(res,t._Tierings_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SSES3 &t){
    s<<"{";
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SSES3>(ivy_ser &res, const s3_test::_SSES3&t){
    res.open_struct();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SSEKMS &t){
    s<<"{";
    s<< "_KeyId_:";
    s << t._KeyId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SSEKMS>(ivy_ser &res, const s3_test::_SSEKMS&t){
    res.open_struct();
    res.open_field("_KeyId_");
    __ser<__strlit>(res,t._KeyId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryEncryption &t){
    s<<"{";
    s<< "_SSES3_:";
    s << t._SSES3_;
    s<<",";
    s<< "_SSEKMS_:";
    s << t._SSEKMS_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryEncryption>(ivy_ser &res, const s3_test::_InventoryEncryption&t){
    res.open_struct();
    res.open_field("_SSES3_");
    __ser<s3_test::_SSES3>(res,t._SSES3_);
    res.close_field();
    res.open_field("_SSEKMS_");
    __ser<s3_test::_SSEKMS>(res,t._SSEKMS_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryS3BucketDestination &t){
    s<<"{";
    s<< "_AccountId_:";
    s << t._AccountId_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Format_:";
    s << t._Format_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Encryption_:";
    s << t._Encryption_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryS3BucketDestination>(ivy_ser &res, const s3_test::_InventoryS3BucketDestination&t){
    res.open_struct();
    res.open_field("_AccountId_");
    __ser<s3_test::option__string__>(res,t._AccountId_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<__strlit>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Format_");
    __ser<__strlit>(res,t._Format_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Encryption_");
    __ser<s3_test::option___InventoryEncryption__>(res,t._Encryption_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryDestination &t){
    s<<"{";
    s<< "_S3BucketDestination_:";
    s << t._S3BucketDestination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryDestination>(ivy_ser &res, const s3_test::_InventoryDestination&t){
    res.open_struct();
    res.open_field("_S3BucketDestination_");
    __ser<s3_test::_InventoryS3BucketDestination>(res,t._S3BucketDestination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryFilter>(ivy_ser &res, const s3_test::_InventoryFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventorySchedule &t){
    s<<"{";
    s<< "_Frequency_:";
    s << t._Frequency_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventorySchedule>(ivy_ser &res, const s3_test::_InventorySchedule&t){
    res.open_struct();
    res.open_field("_Frequency_");
    __ser<__strlit>(res,t._Frequency_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryConfiguration &t){
    s<<"{";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<",";
    s<< "_IsEnabled_:";
    s << t._IsEnabled_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_IncludedObjectVersions_:";
    s << t._IncludedObjectVersions_;
    s<<",";
    s<< "_OptionalFields_:";
    s << t._OptionalFields_;
    s<<",";
    s<< "_Schedule_:";
    s << t._Schedule_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryConfiguration>(ivy_ser &res, const s3_test::_InventoryConfiguration&t){
    res.open_struct();
    res.open_field("_Destination_");
    __ser<s3_test::_InventoryDestination>(res,t._Destination_);
    res.close_field();
    res.open_field("_IsEnabled_");
    __ser<bool>(res,t._IsEnabled_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___InventoryFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Id_");
    __ser<__strlit>(res,t._Id_);
    res.close_field();
    res.open_field("_IncludedObjectVersions_");
    __ser<__strlit>(res,t._IncludedObjectVersions_);
    res.close_field();
    res.open_field("_OptionalFields_");
    __ser<s3_test::option__vector__string____>(res,t._OptionalFields_);
    res.close_field();
    res.open_field("_Schedule_");
    __ser<s3_test::_InventorySchedule>(res,t._Schedule_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Rule &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Transition_:";
    s << t._Transition_;
    s<<",";
    s<< "_NoncurrentVersionTransition_:";
    s << t._NoncurrentVersionTransition_;
    s<<",";
    s<< "_NoncurrentVersionExpiration_:";
    s << t._NoncurrentVersionExpiration_;
    s<<",";
    s<< "_AbortIncompleteMultipartUpload_:";
    s << t._AbortIncompleteMultipartUpload_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Rule>(ivy_ser &res, const s3_test::_Rule&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<s3_test::option___LifecycleExpiration__>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_Transition_");
    __ser<s3_test::option___Transition__>(res,t._Transition_);
    res.close_field();
    res.open_field("_NoncurrentVersionTransition_");
    __ser<s3_test::option___NoncurrentVersionTransition__>(res,t._NoncurrentVersionTransition_);
    res.close_field();
    res.open_field("_NoncurrentVersionExpiration_");
    __ser<s3_test::option___NoncurrentVersionExpiration__>(res,t._NoncurrentVersionExpiration_);
    res.close_field();
    res.open_field("_AbortIncompleteMultipartUpload_");
    __ser<s3_test::option___AbortIncompleteMultipartUpload__>(res,t._AbortIncompleteMultipartUpload_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsAndOperator>(ivy_ser &res, const s3_test::_MetricsAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsFilter>(ivy_ser &res, const s3_test::_MetricsFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_MetricsAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsConfiguration>(ivy_ser &res, const s3_test::_MetricsConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<__strlit>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___MetricsFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OwnershipControlsRule &t){
    s<<"{";
    s<< "_ObjectOwnership_:";
    s << t._ObjectOwnership_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OwnershipControlsRule>(ivy_ser &res, const s3_test::_OwnershipControlsRule&t){
    res.open_struct();
    res.open_field("_ObjectOwnership_");
    __ser<__strlit>(res,t._ObjectOwnership_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRuleAndOperator>(ivy_ser &res, const s3_test::_ReplicationRuleAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRuleFilter>(ivy_ser &res, const s3_test::_ReplicationRuleFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_ReplicationRuleAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SseKmsEncryptedObjects &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SseKmsEncryptedObjects>(ivy_ser &res, const s3_test::_SseKmsEncryptedObjects&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicaModifications &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicaModifications>(ivy_ser &res, const s3_test::_ReplicaModifications&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SourceSelectionCriteria &t){
    s<<"{";
    s<< "_SseKmsEncryptedObjects_:";
    s << t._SseKmsEncryptedObjects_;
    s<<",";
    s<< "_ReplicaModifications_:";
    s << t._ReplicaModifications_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SourceSelectionCriteria>(ivy_ser &res, const s3_test::_SourceSelectionCriteria&t){
    res.open_struct();
    res.open_field("_SseKmsEncryptedObjects_");
    __ser<s3_test::_SseKmsEncryptedObjects>(res,t._SseKmsEncryptedObjects_);
    res.close_field();
    res.open_field("_ReplicaModifications_");
    __ser<s3_test::_ReplicaModifications>(res,t._ReplicaModifications_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRule &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Priority_:";
    s << t._Priority_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_SourceSelectionCriteria_:";
    s << t._SourceSelectionCriteria_;
    s<<",";
    s<< "_ExistingObjectReplication_:";
    s << t._ExistingObjectReplication_;
    s<<",";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<",";
    s<< "_DeleteMarkerReplication_:";
    s << t._DeleteMarkerReplication_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRule>(ivy_ser &res, const s3_test::_ReplicationRule&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Priority_");
    __ser<s3_test::option__integer__>(res,t._Priority_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___ReplicationRuleFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.open_field("_SourceSelectionCriteria_");
    __ser<s3_test::option___SourceSelectionCriteria__>(res,t._SourceSelectionCriteria_);
    res.close_field();
    res.open_field("_ExistingObjectReplication_");
    __ser<s3_test::option___ExistingObjectReplication__>(res,t._ExistingObjectReplication_);
    res.close_field();
    res.open_field("_Destination_");
    __ser<s3_test::_Destination>(res,t._Destination_);
    res.close_field();
    res.open_field("_DeleteMarkerReplication_");
    __ser<s3_test::option___DeleteMarkerReplication__>(res,t._DeleteMarkerReplication_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Redirect &t){
    s<<"{";
    s<< "_HostName_:";
    s << t._HostName_;
    s<<",";
    s<< "_HttpRedirectCode_:";
    s << t._HttpRedirectCode_;
    s<<",";
    s<< "_Protocol_:";
    s << t._Protocol_;
    s<<",";
    s<< "_ReplaceKeyPrefixWith_:";
    s << t._ReplaceKeyPrefixWith_;
    s<<",";
    s<< "_ReplaceKeyWith_:";
    s << t._ReplaceKeyWith_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Redirect>(ivy_ser &res, const s3_test::_Redirect&t){
    res.open_struct();
    res.open_field("_HostName_");
    __ser<__strlit>(res,t._HostName_);
    res.close_field();
    res.open_field("_HttpRedirectCode_");
    __ser<__strlit>(res,t._HttpRedirectCode_);
    res.close_field();
    res.open_field("_Protocol_");
    __ser<__strlit>(res,t._Protocol_);
    res.close_field();
    res.open_field("_ReplaceKeyPrefixWith_");
    __ser<__strlit>(res,t._ReplaceKeyPrefixWith_);
    res.close_field();
    res.open_field("_ReplaceKeyWith_");
    __ser<__strlit>(res,t._ReplaceKeyWith_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RoutingRule &t){
    s<<"{";
    s<< "_Condition_:";
    s << t._Condition_;
    s<<",";
    s<< "_Redirect_:";
    s << t._Redirect_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RoutingRule>(ivy_ser &res, const s3_test::_RoutingRule&t){
    res.open_struct();
    res.open_field("_Condition_");
    __ser<s3_test::option___Condition__>(res,t._Condition_);
    res.close_field();
    res.open_field("_Redirect_");
    __ser<s3_test::_Redirect>(res,t._Redirect_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockLegalHold &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockLegalHold>(ivy_ser &res, const s3_test::_ObjectLockLegalHold&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<__strlit>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRule &t){
    s<<"{";
    s<< "_DefaultRetention_:";
    s << t._DefaultRetention_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockRule>(ivy_ser &res, const s3_test::_ObjectLockRule&t){
    res.open_struct();
    res.open_field("_DefaultRetention_");
    __ser<s3_test::_DefaultRetention>(res,t._DefaultRetention_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockConfiguration &t){
    s<<"{";
    s<< "_ObjectLockEnabled_:";
    s << t._ObjectLockEnabled_;
    s<<",";
    s<< "_Rule_:";
    s << t._Rule_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockConfiguration>(ivy_ser &res, const s3_test::_ObjectLockConfiguration&t){
    res.open_struct();
    res.open_field("_ObjectLockEnabled_");
    __ser<__strlit>(res,t._ObjectLockEnabled_);
    res.close_field();
    res.open_field("_Rule_");
    __ser<s3_test::_ObjectLockRule>(res,t._Rule_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectOutput &t){
    s<<"{";
    s<< "_Body_:";
    s << t._Body_;
    s<<",";
    s<< "_DeleteMarker_:";
    s << t._DeleteMarker_;
    s<<",";
    s<< "_AcceptRanges_:";
    s << t._AcceptRanges_;
    s<<",";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_Restore_:";
    s << t._Restore_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ContentLength_:";
    s << t._ContentLength_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_MissingMeta_:";
    s << t._MissingMeta_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_CacheControl_:";
    s << t._CacheControl_;
    s<<",";
    s<< "_ContentDisposition_:";
    s << t._ContentDisposition_;
    s<<",";
    s<< "_ContentEncoding_:";
    s << t._ContentEncoding_;
    s<<",";
    s<< "_ContentLanguage_:";
    s << t._ContentLanguage_;
    s<<",";
    s<< "_ContentRange_:";
    s << t._ContentRange_;
    s<<",";
    s<< "_ContentType_:";
    s << t._ContentType_;
    s<<",";
    s<< "_Expires_:";
    s << t._Expires_;
    s<<",";
    s<< "_WebsiteRedirectLocation_:";
    s << t._WebsiteRedirectLocation_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_Metadata_:";
    s << t._Metadata_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_RequestCharged_:";
    s << t._RequestCharged_;
    s<<",";
    s<< "_ReplicationStatus_:";
    s << t._ReplicationStatus_;
    s<<",";
    s<< "_PartsCount_:";
    s << t._PartsCount_;
    s<<",";
    s<< "_TagCount_:";
    s << t._TagCount_;
    s<<",";
    s<< "_ObjectLockMode_:";
    s << t._ObjectLockMode_;
    s<<",";
    s<< "_ObjectLockRetainUntilDate_:";
    s << t._ObjectLockRetainUntilDate_;
    s<<",";
    s<< "_ObjectLockLegalHoldStatus_:";
    s << t._ObjectLockLegalHoldStatus_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GetObjectOutput>(ivy_ser &res, const s3_test::_GetObjectOutput&t){
    res.open_struct();
    res.open_field("_Body_");
    __ser<s3_test::blob>(res,t._Body_);
    res.close_field();
    res.open_field("_DeleteMarker_");
    __ser<bool>(res,t._DeleteMarker_);
    res.close_field();
    res.open_field("_AcceptRanges_");
    __ser<__strlit>(res,t._AcceptRanges_);
    res.close_field();
    res.open_field("_Expiration_");
    __ser<__strlit>(res,t._Expiration_);
    res.close_field();
    res.open_field("_Restore_");
    __ser<__strlit>(res,t._Restore_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ContentLength_");
    __ser<int>(res,t._ContentLength_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_MissingMeta_");
    __ser<int>(res,t._MissingMeta_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_CacheControl_");
    __ser<__strlit>(res,t._CacheControl_);
    res.close_field();
    res.open_field("_ContentDisposition_");
    __ser<__strlit>(res,t._ContentDisposition_);
    res.close_field();
    res.open_field("_ContentEncoding_");
    __ser<__strlit>(res,t._ContentEncoding_);
    res.close_field();
    res.open_field("_ContentLanguage_");
    __ser<__strlit>(res,t._ContentLanguage_);
    res.close_field();
    res.open_field("_ContentRange_");
    __ser<__strlit>(res,t._ContentRange_);
    res.close_field();
    res.open_field("_ContentType_");
    __ser<__strlit>(res,t._ContentType_);
    res.close_field();
    res.open_field("_Expires_");
    __ser<int>(res,t._Expires_);
    res.close_field();
    res.open_field("_WebsiteRedirectLocation_");
    __ser<__strlit>(res,t._WebsiteRedirectLocation_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<__strlit>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_Metadata_");
    __ser<s3_test::unordered_map__string____string__>(res,t._Metadata_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<__strlit>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<__strlit>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<__strlit>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_RequestCharged_");
    __ser<__strlit>(res,t._RequestCharged_);
    res.close_field();
    res.open_field("_ReplicationStatus_");
    __ser<__strlit>(res,t._ReplicationStatus_);
    res.close_field();
    res.open_field("_PartsCount_");
    __ser<int>(res,t._PartsCount_);
    res.close_field();
    res.open_field("_TagCount_");
    __ser<int>(res,t._TagCount_);
    res.close_field();
    res.open_field("_ObjectLockMode_");
    __ser<__strlit>(res,t._ObjectLockMode_);
    res.close_field();
    res.open_field("_ObjectLockRetainUntilDate_");
    __ser<int>(res,t._ObjectLockRetainUntilDate_);
    res.close_field();
    res.open_field("_ObjectLockLegalHoldStatus_");
    __ser<__strlit>(res,t._ObjectLockLegalHoldStatus_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectRequest &t){
    s<<"{";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_IfMatch_:";
    s << t._IfMatch_;
    s<<",";
    s<< "_IfModifiedSince_:";
    s << t._IfModifiedSince_;
    s<<",";
    s<< "_IfNoneMatch_:";
    s << t._IfNoneMatch_;
    s<<",";
    s<< "_IfUnmodifiedSince_:";
    s << t._IfUnmodifiedSince_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Range_:";
    s << t._Range_;
    s<<",";
    s<< "_ResponseCacheControl_:";
    s << t._ResponseCacheControl_;
    s<<",";
    s<< "_ResponseContentDisposition_:";
    s << t._ResponseContentDisposition_;
    s<<",";
    s<< "_ResponseContentEncoding_:";
    s << t._ResponseContentEncoding_;
    s<<",";
    s<< "_ResponseContentLanguage_:";
    s << t._ResponseContentLanguage_;
    s<<",";
    s<< "_ResponseContentType_:";
    s << t._ResponseContentType_;
    s<<",";
    s<< "_ResponseExpires_:";
    s << t._ResponseExpires_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKey_:";
    s << t._SSECustomerKey_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_RequestPayer_:";
    s << t._RequestPayer_;
    s<<",";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<",";
    s<< "_ExpectedBucketOwner_:";
    s << t._ExpectedBucketOwner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GetObjectRequest>(ivy_ser &res, const s3_test::_GetObjectRequest&t){
    res.open_struct();
    res.open_field("_Bucket_");
    __ser<__strlit>(res,t._Bucket_);
    res.close_field();
    res.open_field("_IfMatch_");
    __ser<s3_test::option__string__>(res,t._IfMatch_);
    res.close_field();
    res.open_field("_IfModifiedSince_");
    __ser<s3_test::option__timestamp__>(res,t._IfModifiedSince_);
    res.close_field();
    res.open_field("_IfNoneMatch_");
    __ser<s3_test::option__string__>(res,t._IfNoneMatch_);
    res.close_field();
    res.open_field("_IfUnmodifiedSince_");
    __ser<s3_test::option__timestamp__>(res,t._IfUnmodifiedSince_);
    res.close_field();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_Range_");
    __ser<s3_test::option__string__>(res,t._Range_);
    res.close_field();
    res.open_field("_ResponseCacheControl_");
    __ser<s3_test::option__string__>(res,t._ResponseCacheControl_);
    res.close_field();
    res.open_field("_ResponseContentDisposition_");
    __ser<s3_test::option__string__>(res,t._ResponseContentDisposition_);
    res.close_field();
    res.open_field("_ResponseContentEncoding_");
    __ser<s3_test::option__string__>(res,t._ResponseContentEncoding_);
    res.close_field();
    res.open_field("_ResponseContentLanguage_");
    __ser<s3_test::option__string__>(res,t._ResponseContentLanguage_);
    res.close_field();
    res.open_field("_ResponseContentType_");
    __ser<s3_test::option__string__>(res,t._ResponseContentType_);
    res.close_field();
    res.open_field("_ResponseExpires_");
    __ser<s3_test::option__timestamp__>(res,t._ResponseExpires_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::option__string__>(res,t._VersionId_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::option__string__>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKey_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKey_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_RequestPayer_");
    __ser<s3_test::option__string__>(res,t._RequestPayer_);
    res.close_field();
    res.open_field("_PartNumber_");
    __ser<s3_test::option__integer__>(res,t._PartNumber_);
    res.close_field();
    res.open_field("_ExpectedBucketOwner_");
    __ser<s3_test::option__string__>(res,t._ExpectedBucketOwner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRetention &t){
    s<<"{";
    s<< "_Mode_:";
    s << t._Mode_;
    s<<",";
    s<< "_RetainUntilDate_:";
    s << t._RetainUntilDate_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockRetention>(ivy_ser &res, const s3_test::_ObjectLockRetention&t){
    res.open_struct();
    res.open_field("_Mode_");
    __ser<__strlit>(res,t._Mode_);
    res.close_field();
    res.open_field("_RetainUntilDate_");
    __ser<int>(res,t._RetainUntilDate_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GlacierJobParameters &t){
    s<<"{";
    s<< "_Tier_:";
    s << t._Tier_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GlacierJobParameters>(ivy_ser &res, const s3_test::_GlacierJobParameters&t){
    res.open_struct();
    res.open_field("_Tier_");
    __ser<__strlit>(res,t._Tier_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Initiator &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Initiator>(ivy_ser &res, const s3_test::_Initiator&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<__strlit>(res,t._ID_);
    res.close_field();
    res.open_field("_DisplayName_");
    __ser<__strlit>(res,t._DisplayName_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONInput &t){
    s<<"{";
    s<< "_Type_:";
    s << t._Type_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_JSONInput>(ivy_ser &res, const s3_test::_JSONInput&t){
    res.open_struct();
    res.open_field("_Type_");
    __ser<__strlit>(res,t._Type_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ParquetInput &t){
    s<<"{";
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ParquetInput>(ivy_ser &res, const s3_test::_ParquetInput&t){
    res.open_struct();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InputSerialization &t){
    s<<"{";
    s<< "_CSV_:";
    s << t._CSV_;
    s<<",";
    s<< "_CompressionType_:";
    s << t._CompressionType_;
    s<<",";
    s<< "_JSON_:";
    s << t._JSON_;
    s<<",";
    s<< "_Parquet_:";
    s << t._Parquet_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InputSerialization>(ivy_ser &res, const s3_test::_InputSerialization&t){
    res.open_struct();
    res.open_field("_CSV_");
    __ser<s3_test::_CSVInput>(res,t._CSV_);
    res.close_field();
    res.open_field("_CompressionType_");
    __ser<__strlit>(res,t._CompressionType_);
    res.close_field();
    res.open_field("_JSON_");
    __ser<s3_test::_JSONInput>(res,t._JSON_);
    res.close_field();
    res.open_field("_Parquet_");
    __ser<s3_test::_ParquetInput>(res,t._Parquet_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONOutput &t){
    s<<"{";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_JSONOutput>(ivy_ser &res, const s3_test::_JSONOutput&t){
    res.open_struct();
    res.open_field("_RecordDelimiter_");
    __ser<__strlit>(res,t._RecordDelimiter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_S3KeyFilter &t){
    s<<"{";
    s<< "_FilterRules_:";
    s << t._FilterRules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_S3KeyFilter>(ivy_ser &res, const s3_test::_S3KeyFilter&t){
    res.open_struct();
    res.open_field("_FilterRules_");
    __ser<s3_test::vector___FilterRule__>(res,t._FilterRules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NotificationConfigurationFilter &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NotificationConfigurationFilter>(ivy_ser &res, const s3_test::_NotificationConfigurationFilter&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::_S3KeyFilter>(res,t._Key_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LambdaFunctionConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_LambdaFunctionArn_:";
    s << t._LambdaFunctionArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LambdaFunctionConfiguration>(ivy_ser &res, const s3_test::_LambdaFunctionConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_LambdaFunctionArn_");
    __ser<__strlit>(res,t._LambdaFunctionArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleConfiguration &t){
    s<<"{";
    s<< "_Rules_:";
    s << t._Rules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleConfiguration>(ivy_ser &res, const s3_test::_LifecycleConfiguration&t){
    res.open_struct();
    res.open_field("_Rules_");
    __ser<s3_test::vector___Rule__>(res,t._Rules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MultipartUpload &t){
    s<<"{";
    s<< "_UploadId_:";
    s << t._UploadId_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Initiated_:";
    s << t._Initiated_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<",";
    s<< "_Initiator_:";
    s << t._Initiator_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MultipartUpload>(ivy_ser &res, const s3_test::_MultipartUpload&t){
    res.open_struct();
    res.open_field("_UploadId_");
    __ser<__strlit>(res,t._UploadId_);
    res.close_field();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_Initiated_");
    __ser<int>(res,t._Initiated_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.open_field("_Initiator_");
    __ser<s3_test::_Initiator>(res,t._Initiator_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectVersion &t){
    s<<"{";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_IsLatest_:";
    s << t._IsLatest_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectVersion>(ivy_ser &res, const s3_test::_ObjectVersion&t){
    res.open_struct();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_IsLatest_");
    __ser<bool>(res,t._IsLatest_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Object &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Object>(ivy_ser &res, const s3_test::_Object&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<__strlit>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Part &t){
    s<<"{";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Part>(ivy_ser &res, const s3_test::_Part&t){
    res.open_struct();
    res.open_field("_PartNumber_");
    __ser<int>(res,t._PartNumber_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetadataEntry &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetadataEntry>(ivy_ser &res, const s3_test::_MetadataEntry&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<__strlit>(res,t._Name_);
    res.close_field();
    res.open_field("_Value_");
    __ser<__strlit>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_TopicConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_TopicArn_:";
    s << t._TopicArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_TopicConfiguration>(ivy_ser &res, const s3_test::_TopicConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_TopicArn_");
    __ser<__strlit>(res,t._TopicArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_QueueConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_QueueArn_:";
    s << t._QueueArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_QueueConfiguration>(ivy_ser &res, const s3_test::_QueueConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_QueueArn_");
    __ser<__strlit>(res,t._QueueArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tagging &t){
    s<<"{";
    s<< "_TagSet_:";
    s << t._TagSet_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tagging>(ivy_ser &res, const s3_test::_Tagging&t){
    res.open_struct();
    res.open_field("_TagSet_");
    __ser<s3_test::vector___Tag__>(res,t._TagSet_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_S3Location &t){
    s<<"{";
    s<< "_BucketName_:";
    s << t._BucketName_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Encryption_:";
    s << t._Encryption_;
    s<<",";
    s<< "_CannedACL_:";
    s << t._CannedACL_;
    s<<",";
    s<< "_AccessControlList_:";
    s << t._AccessControlList_;
    s<<",";
    s<< "_Tagging_:";
    s << t._Tagging_;
    s<<",";
    s<< "_UserMetadata_:";
    s << t._UserMetadata_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_S3Location>(ivy_ser &res, const s3_test::_S3Location&t){
    res.open_struct();
    res.open_field("_BucketName_");
    __ser<__strlit>(res,t._BucketName_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<__strlit>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Encryption_");
    __ser<s3_test::option___Encryption__>(res,t._Encryption_);
    res.close_field();
    res.open_field("_CannedACL_");
    __ser<s3_test::option__string__>(res,t._CannedACL_);
    res.close_field();
    res.open_field("_AccessControlList_");
    __ser<s3_test::option__vector___Grant____>(res,t._AccessControlList_);
    res.close_field();
    res.open_field("_Tagging_");
    __ser<s3_test::option___Tagging__>(res,t._Tagging_);
    res.close_field();
    res.open_field("_UserMetadata_");
    __ser<s3_test::option__vector___MetadataEntry____>(res,t._UserMetadata_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputLocation &t){
    s<<"{";
    s<< "_S3_:";
    s << t._S3_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OutputLocation>(ivy_ser &res, const s3_test::_OutputLocation&t){
    res.open_struct();
    res.open_field("_S3_");
    __ser<s3_test::_S3Location>(res,t._S3_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputSerialization &t){
    s<<"{";
    s<< "_CSV_:";
    s << t._CSV_;
    s<<",";
    s<< "_JSON_:";
    s << t._JSON_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OutputSerialization>(ivy_ser &res, const s3_test::_OutputSerialization&t){
    res.open_struct();
    res.open_field("_CSV_");
    __ser<s3_test::_CSVOutput>(res,t._CSV_);
    res.close_field();
    res.open_field("_JSON_");
    __ser<s3_test::_JSONOutput>(res,t._JSON_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectOutput &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_SSEKMSEncryptionContext_:";
    s << t._SSEKMSEncryptionContext_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_RequestCharged_:";
    s << t._RequestCharged_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_PutObjectOutput>(ivy_ser &res, const s3_test::_PutObjectOutput&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<__strlit>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<__strlit>(res,t._ETag_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<__strlit>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<__strlit>(res,t._VersionId_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<__strlit>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<__strlit>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<__strlit>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_SSEKMSEncryptionContext_");
    __ser<__strlit>(res,t._SSEKMSEncryptionContext_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_RequestCharged_");
    __ser<__strlit>(res,t._RequestCharged_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectRequest &t){
    s<<"{";
    s<< "_ACL_:";
    s << t._ACL_;
    s<<",";
    s<< "_Body_:";
    s << t._Body_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_CacheControl_:";
    s << t._CacheControl_;
    s<<",";
    s<< "_ContentDisposition_:";
    s << t._ContentDisposition_;
    s<<",";
    s<< "_ContentEncoding_:";
    s << t._ContentEncoding_;
    s<<",";
    s<< "_ContentLanguage_:";
    s << t._ContentLanguage_;
    s<<",";
    s<< "_ContentLength_:";
    s << t._ContentLength_;
    s<<",";
    s<< "_ContentMD5_:";
    s << t._ContentMD5_;
    s<<",";
    s<< "_ContentType_:";
    s << t._ContentType_;
    s<<",";
    s<< "_Expires_:";
    s << t._Expires_;
    s<<",";
    s<< "_GrantFullControl_:";
    s << t._GrantFullControl_;
    s<<",";
    s<< "_GrantRead_:";
    s << t._GrantRead_;
    s<<",";
    s<< "_GrantReadACP_:";
    s << t._GrantReadACP_;
    s<<",";
    s<< "_GrantWriteACP_:";
    s << t._GrantWriteACP_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Metadata_:";
    s << t._Metadata_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_WebsiteRedirectLocation_:";
    s << t._WebsiteRedirectLocation_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKey_:";
    s << t._SSECustomerKey_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_SSEKMSEncryptionContext_:";
    s << t._SSEKMSEncryptionContext_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_RequestPayer_:";
    s << t._RequestPayer_;
    s<<",";
    s<< "_Tagging_:";
    s << t._Tagging_;
    s<<",";
    s<< "_ObjectLockMode_:";
    s << t._ObjectLockMode_;
    s<<",";
    s<< "_ObjectLockRetainUntilDate_:";
    s << t._ObjectLockRetainUntilDate_;
    s<<",";
    s<< "_ObjectLockLegalHoldStatus_:";
    s << t._ObjectLockLegalHoldStatus_;
    s<<",";
    s<< "_ExpectedBucketOwner_:";
    s << t._ExpectedBucketOwner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_PutObjectRequest>(ivy_ser &res, const s3_test::_PutObjectRequest&t){
    res.open_struct();
    res.open_field("_ACL_");
    __ser<s3_test::option__string__>(res,t._ACL_);
    res.close_field();
    res.open_field("_Body_");
    __ser<s3_test::option__blob__>(res,t._Body_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<__strlit>(res,t._Bucket_);
    res.close_field();
    res.open_field("_CacheControl_");
    __ser<s3_test::option__string__>(res,t._CacheControl_);
    res.close_field();
    res.open_field("_ContentDisposition_");
    __ser<s3_test::option__string__>(res,t._ContentDisposition_);
    res.close_field();
    res.open_field("_ContentEncoding_");
    __ser<s3_test::option__string__>(res,t._ContentEncoding_);
    res.close_field();
    res.open_field("_ContentLanguage_");
    __ser<s3_test::option__string__>(res,t._ContentLanguage_);
    res.close_field();
    res.open_field("_ContentLength_");
    __ser<s3_test::option__long__>(res,t._ContentLength_);
    res.close_field();
    res.open_field("_ContentMD5_");
    __ser<s3_test::option__string__>(res,t._ContentMD5_);
    res.close_field();
    res.open_field("_ContentType_");
    __ser<s3_test::option__string__>(res,t._ContentType_);
    res.close_field();
    res.open_field("_Expires_");
    __ser<s3_test::option__timestamp__>(res,t._Expires_);
    res.close_field();
    res.open_field("_GrantFullControl_");
    __ser<s3_test::option__string__>(res,t._GrantFullControl_);
    res.close_field();
    res.open_field("_GrantRead_");
    __ser<s3_test::option__string__>(res,t._GrantRead_);
    res.close_field();
    res.open_field("_GrantReadACP_");
    __ser<s3_test::option__string__>(res,t._GrantReadACP_);
    res.close_field();
    res.open_field("_GrantWriteACP_");
    __ser<s3_test::option__string__>(res,t._GrantWriteACP_);
    res.close_field();
    res.open_field("_Key_");
    __ser<__strlit>(res,t._Key_);
    res.close_field();
    res.open_field("_Metadata_");
    __ser<s3_test::option__unordered_map__string____string____>(res,t._Metadata_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<s3_test::option__string__>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_WebsiteRedirectLocation_");
    __ser<s3_test::option__string__>(res,t._WebsiteRedirectLocation_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::option__string__>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKey_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKey_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<s3_test::option__string__>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_SSEKMSEncryptionContext_");
    __ser<s3_test::option__string__>(res,t._SSEKMSEncryptionContext_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<s3_test::option__bool__>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_RequestPayer_");
    __ser<s3_test::option__string__>(res,t._RequestPayer_);
    res.close_field();
    res.open_field("_Tagging_");
    __ser<s3_test::option__string__>(res,t._Tagging_);
    res.close_field();
    res.open_field("_ObjectLockMode_");
    __ser<s3_test::option__string__>(res,t._ObjectLockMode_);
    res.close_field();
    res.open_field("_ObjectLockRetainUntilDate_");
    __ser<s3_test::option__timestamp__>(res,t._ObjectLockRetainUntilDate_);
    res.close_field();
    res.open_field("_ObjectLockLegalHoldStatus_");
    __ser<s3_test::option__string__>(res,t._ObjectLockLegalHoldStatus_);
    res.close_field();
    res.open_field("_ExpectedBucketOwner_");
    __ser<s3_test::option__string__>(res,t._ExpectedBucketOwner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RequestProgress &t){
    s<<"{";
    s<< "_Enabled_:";
    s << t._Enabled_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RequestProgress>(ivy_ser &res, const s3_test::_RequestProgress&t){
    res.open_struct();
    res.open_field("_Enabled_");
    __ser<bool>(res,t._Enabled_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SelectParameters &t){
    s<<"{";
    s<< "_InputSerialization_:";
    s << t._InputSerialization_;
    s<<",";
    s<< "_ExpressionType_:";
    s << t._ExpressionType_;
    s<<",";
    s<< "_Expression_:";
    s << t._Expression_;
    s<<",";
    s<< "_OutputSerialization_:";
    s << t._OutputSerialization_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SelectParameters>(ivy_ser &res, const s3_test::_SelectParameters&t){
    res.open_struct();
    res.open_field("_InputSerialization_");
    __ser<s3_test::_InputSerialization>(res,t._InputSerialization_);
    res.close_field();
    res.open_field("_ExpressionType_");
    __ser<__strlit>(res,t._ExpressionType_);
    res.close_field();
    res.open_field("_Expression_");
    __ser<__strlit>(res,t._Expression_);
    res.close_field();
    res.open_field("_OutputSerialization_");
    __ser<s3_test::_OutputSerialization>(res,t._OutputSerialization_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RestoreRequest &t){
    s<<"{";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_GlacierJobParameters_:";
    s << t._GlacierJobParameters_;
    s<<",";
    s<< "_Type_:";
    s << t._Type_;
    s<<",";
    s<< "_Tier_:";
    s << t._Tier_;
    s<<",";
    s<< "_Description_:";
    s << t._Description_;
    s<<",";
    s<< "_SelectParameters_:";
    s << t._SelectParameters_;
    s<<",";
    s<< "_OutputLocation_:";
    s << t._OutputLocation_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RestoreRequest>(ivy_ser &res, const s3_test::_RestoreRequest&t){
    res.open_struct();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_GlacierJobParameters_");
    __ser<s3_test::_GlacierJobParameters>(res,t._GlacierJobParameters_);
    res.close_field();
    res.open_field("_Type_");
    __ser<__strlit>(res,t._Type_);
    res.close_field();
    res.open_field("_Tier_");
    __ser<__strlit>(res,t._Tier_);
    res.close_field();
    res.open_field("_Description_");
    __ser<__strlit>(res,t._Description_);
    res.close_field();
    res.open_field("_SelectParameters_");
    __ser<s3_test::_SelectParameters>(res,t._SelectParameters_);
    res.close_field();
    res.open_field("_OutputLocation_");
    __ser<s3_test::_OutputLocation>(res,t._OutputLocation_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ScanRange &t){
    s<<"{";
    s<< "_Start_:";
    s << t._Start_;
    s<<",";
    s<< "_End_:";
    s << t._End_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ScanRange>(ivy_ser &res, const s3_test::_ScanRange&t){
    res.open_struct();
    res.open_field("_Start_");
    __ser<int>(res,t._Start_);
    res.close_field();
    res.open_field("_End_");
    __ser<int>(res,t._End_);
    res.close_field();
    res.close_struct();
}


int ask_ret(long long bound) {
    int res;
    while(true) {
        __ivy_out << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cerr << "value out of range" << std::endl;
    }
}



    class s3_test_repl : public s3_test {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assertion_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assertion failed\n";
            
            __ivy_exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assumption_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assumption failed\n";
            
            __ivy_exit(1);
        }
    }
    s3_test_repl() : s3_test(){}
    virtual void imp___PutObject__response_PutObjectOutput(const _PutObjectOutput& val){
    __ivy_out  << "< _PutObject.response_PutObjectOutput" << "(" << val << ")" << std::endl;
}
    virtual void imp___GetObject__response_GetObjectOutput(const _GetObjectOutput& val){
    __ivy_out  << "< _GetObject.response_GetObjectOutput" << "(" << val << ")" << std::endl;
}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
    int pos;
    syntax_error(int pos) : pos(pos) {}
};

void throw_syntax(int pos){
    throw syntax_error(pos);
}

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw_syntax(pos);
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    res.pos = pos;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw_syntax(pos);
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"') {
            char c = cmd[pos++];
            if (c == '\\') {
                if (pos == cmd.size())
                    throw_syntax(pos);
                c = cmd[pos++];
                c = (c == 'n') ? 10 : (c == 'r') ? 13 : (c == 't') ? 9 : c;
            }
            res.atom.push_back(c);
        }
        if(pos == cmd.size())
            throw_syntax(pos);
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw_syntax(pos);
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw_syntax(pos);
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
s3_test::_AbortIncompleteMultipartUpload _arg<s3_test::_AbortIncompleteMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AbortIncompleteMultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DaysAfterInitiation_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DaysAfterInitiation_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DaysAfterInitiation_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AbortIncompleteMultipartUpload>(ivy_deser &inp, s3_test::_AbortIncompleteMultipartUpload &res){
    inp.open_struct();
    inp.open_field("_DaysAfterInitiation_");
    __deser(inp,res._DaysAfterInitiation_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AccessControlPolicy _arg<s3_test::_AccessControlPolicy>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AccessControlPolicy res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grants_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grants_ = _arg<s3_test::vector___Grant__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grants_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AccessControlPolicy>(ivy_deser &inp, s3_test::_AccessControlPolicy &res){
    inp.open_struct();
    inp.open_field("_Grants_");
    __deser(inp,res._Grants_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AccessControlTranslation _arg<s3_test::_AccessControlTranslation>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AccessControlTranslation res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Owner_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AccessControlTranslation>(ivy_deser &inp, s3_test::_AccessControlTranslation &res){
    inp.open_struct();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AnalyticsAndOperator _arg<s3_test::_AnalyticsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsAndOperator>(ivy_deser &inp, s3_test::_AnalyticsAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AnalyticsConfiguration _arg<s3_test::_AnalyticsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___AnalyticsFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClassAnalysis_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClassAnalysis_ = _arg<s3_test::_StorageClassAnalysis>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClassAnalysis_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsConfiguration>(ivy_deser &inp, s3_test::_AnalyticsConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_StorageClassAnalysis_");
    __deser(inp,res._StorageClassAnalysis_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AnalyticsExportDestination _arg<s3_test::_AnalyticsExportDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsExportDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3BucketDestination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3BucketDestination_ = _arg<s3_test::_AnalyticsS3BucketDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3BucketDestination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsExportDestination>(ivy_deser &inp, s3_test::_AnalyticsExportDestination &res){
    inp.open_struct();
    inp.open_field("_S3BucketDestination_");
    __deser(inp,res._S3BucketDestination_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AnalyticsFilter _arg<s3_test::_AnalyticsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_AnalyticsAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsFilter>(ivy_deser &inp, s3_test::_AnalyticsFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_AnalyticsS3BucketDestination _arg<s3_test::_AnalyticsS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsS3BucketDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Format_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Format_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Format_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_BucketAccountId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._BucketAccountId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketAccountId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Bucket_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsS3BucketDestination>(ivy_deser &inp, s3_test::_AnalyticsS3BucketDestination &res){
    inp.open_struct();
    inp.open_field("_Format_");
    __deser(inp,res._Format_);
    inp.close_field();
    inp.open_field("_BucketAccountId_");
    __deser(inp,res._BucketAccountId_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Bucket _arg<s3_test::_Bucket>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Bucket res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_CreationDate_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._CreationDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CreationDate_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Bucket>(ivy_deser &inp, s3_test::_Bucket &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_CreationDate_");
    __deser(inp,res._CreationDate_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_BucketLifecycleConfiguration _arg<s3_test::_BucketLifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_BucketLifecycleConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Rules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Rules_ = _arg<s3_test::vector___LifecycleRule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_BucketLifecycleConfiguration>(ivy_deser &inp, s3_test::_BucketLifecycleConfiguration &res){
    inp.open_struct();
    inp.open_field("_Rules_");
    __deser(inp,res._Rules_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CORSRule _arg<s3_test::_CORSRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CORSRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_AllowedHeaders_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._AllowedHeaders_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedHeaders_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_AllowedMethods_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._AllowedMethods_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedMethods_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_AllowedOrigins_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._AllowedOrigins_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedOrigins_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ExposeHeaders_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ExposeHeaders_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExposeHeaders_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_MaxAgeSeconds_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._MaxAgeSeconds_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _MaxAgeSeconds_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CORSRule>(ivy_deser &inp, s3_test::_CORSRule &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_AllowedHeaders_");
    __deser(inp,res._AllowedHeaders_);
    inp.close_field();
    inp.open_field("_AllowedMethods_");
    __deser(inp,res._AllowedMethods_);
    inp.close_field();
    inp.open_field("_AllowedOrigins_");
    __deser(inp,res._AllowedOrigins_);
    inp.close_field();
    inp.open_field("_ExposeHeaders_");
    __deser(inp,res._ExposeHeaders_);
    inp.close_field();
    inp.open_field("_MaxAgeSeconds_");
    __deser(inp,res._MaxAgeSeconds_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CSVInput _arg<s3_test::_CSVInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CSVInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_FileHeaderInfo_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._FileHeaderInfo_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FileHeaderInfo_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Comments_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Comments_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Comments_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_QuoteEscapeCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._QuoteEscapeCharacter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteEscapeCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._RecordDelimiter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_FieldDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._FieldDelimiter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FieldDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_QuoteCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._QuoteCharacter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_AllowQuotedRecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._AllowQuotedRecordDelimiter_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowQuotedRecordDelimiter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CSVInput>(ivy_deser &inp, s3_test::_CSVInput &res){
    inp.open_struct();
    inp.open_field("_FileHeaderInfo_");
    __deser(inp,res._FileHeaderInfo_);
    inp.close_field();
    inp.open_field("_Comments_");
    __deser(inp,res._Comments_);
    inp.close_field();
    inp.open_field("_QuoteEscapeCharacter_");
    __deser(inp,res._QuoteEscapeCharacter_);
    inp.close_field();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.open_field("_FieldDelimiter_");
    __deser(inp,res._FieldDelimiter_);
    inp.close_field();
    inp.open_field("_QuoteCharacter_");
    __deser(inp,res._QuoteCharacter_);
    inp.close_field();
    inp.open_field("_AllowQuotedRecordDelimiter_");
    __deser(inp,res._AllowQuotedRecordDelimiter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CSVOutput _arg<s3_test::_CSVOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CSVOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_QuoteFields_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._QuoteFields_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteFields_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_QuoteEscapeCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._QuoteEscapeCharacter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteEscapeCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._RecordDelimiter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_FieldDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._FieldDelimiter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FieldDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_QuoteCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._QuoteCharacter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteCharacter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CSVOutput>(ivy_deser &inp, s3_test::_CSVOutput &res){
    inp.open_struct();
    inp.open_field("_QuoteFields_");
    __deser(inp,res._QuoteFields_);
    inp.close_field();
    inp.open_field("_QuoteEscapeCharacter_");
    __deser(inp,res._QuoteEscapeCharacter_);
    inp.close_field();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.open_field("_FieldDelimiter_");
    __deser(inp,res._FieldDelimiter_);
    inp.close_field();
    inp.open_field("_QuoteCharacter_");
    __deser(inp,res._QuoteCharacter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CommonPrefix _arg<s3_test::_CommonPrefix>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CommonPrefix res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CommonPrefix>(ivy_deser &inp, s3_test::_CommonPrefix &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CompletedMultipartUpload _arg<s3_test::_CompletedMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CompletedMultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Parts_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Parts_ = _arg<s3_test::vector___CompletedPart__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Parts_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CompletedMultipartUpload>(ivy_deser &inp, s3_test::_CompletedMultipartUpload &res){
    inp.open_struct();
    inp.open_field("_Parts_");
    __deser(inp,res._Parts_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CompletedPart _arg<s3_test::_CompletedPart>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CompletedPart res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._PartNumber_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CompletedPart>(ivy_deser &inp, s3_test::_CompletedPart &res){
    inp.open_struct();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Condition _arg<s3_test::_Condition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Condition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_HttpErrorCodeReturnedEquals_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._HttpErrorCodeReturnedEquals_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HttpErrorCodeReturnedEquals_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KeyPrefixEquals_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KeyPrefixEquals_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KeyPrefixEquals_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Condition>(ivy_deser &inp, s3_test::_Condition &res){
    inp.open_struct();
    inp.open_field("_HttpErrorCodeReturnedEquals_");
    __deser(inp,res._HttpErrorCodeReturnedEquals_);
    inp.close_field();
    inp.open_field("_KeyPrefixEquals_");
    __deser(inp,res._KeyPrefixEquals_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_CreateBucketConfiguration _arg<s3_test::_CreateBucketConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CreateBucketConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_LocationConstraint_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._LocationConstraint_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LocationConstraint_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CreateBucketConfiguration>(ivy_deser &inp, s3_test::_CreateBucketConfiguration &res){
    inp.open_struct();
    inp.open_field("_LocationConstraint_");
    __deser(inp,res._LocationConstraint_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_DefaultRetention _arg<s3_test::_DefaultRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DefaultRetention res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Mode_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Mode_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Mode_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Years_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Years_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Years_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DefaultRetention>(ivy_deser &inp, s3_test::_DefaultRetention &res){
    inp.open_struct();
    inp.open_field("_Mode_");
    __deser(inp,res._Mode_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_Years_");
    __deser(inp,res._Years_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_DeleteMarkerEntry _arg<s3_test::_DeleteMarkerEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeleteMarkerEntry res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_IsLatest_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._IsLatest_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsLatest_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeleteMarkerEntry>(ivy_deser &inp, s3_test::_DeleteMarkerEntry &res){
    inp.open_struct();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_IsLatest_");
    __deser(inp,res._IsLatest_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_DeleteMarkerReplication _arg<s3_test::_DeleteMarkerReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeleteMarkerReplication res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeleteMarkerReplication>(ivy_deser &inp, s3_test::_DeleteMarkerReplication &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_DeletedObject _arg<s3_test::_DeletedObject>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeletedObject res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_DeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._DeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarker_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_DeleteMarkerVersionId_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._DeleteMarkerVersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarkerVersionId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeletedObject>(ivy_deser &inp, s3_test::_DeletedObject &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_DeleteMarker_");
    __deser(inp,res._DeleteMarker_);
    inp.close_field();
    inp.open_field("_DeleteMarkerVersionId_");
    __deser(inp,res._DeleteMarkerVersionId_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Destination _arg<s3_test::_Destination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Destination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Bucket_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Account_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Account_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Account_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_AccessControlTranslation_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._AccessControlTranslation_ = _arg<s3_test::option___AccessControlTranslation__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessControlTranslation_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_EncryptionConfiguration_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._EncryptionConfiguration_ = _arg<s3_test::option___EncryptionConfiguration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EncryptionConfiguration_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_ReplicationTime_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._ReplicationTime_ = _arg<s3_test::option___ReplicationTime__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicationTime_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Metrics_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Metrics_ = _arg<s3_test::option___Metrics__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metrics_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Destination>(ivy_deser &inp, s3_test::_Destination &res){
    inp.open_struct();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Account_");
    __deser(inp,res._Account_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_AccessControlTranslation_");
    __deser(inp,res._AccessControlTranslation_);
    inp.close_field();
    inp.open_field("_EncryptionConfiguration_");
    __deser(inp,res._EncryptionConfiguration_);
    inp.close_field();
    inp.open_field("_ReplicationTime_");
    __deser(inp,res._ReplicationTime_);
    inp.close_field();
    inp.open_field("_Metrics_");
    __deser(inp,res._Metrics_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Encryption _arg<s3_test::_Encryption>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Encryption res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_EncryptionType_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._EncryptionType_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EncryptionType_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KMSKeyId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_KMSContext_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._KMSContext_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSContext_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Encryption>(ivy_deser &inp, s3_test::_Encryption &res){
    inp.open_struct();
    inp.open_field("_EncryptionType_");
    __deser(inp,res._EncryptionType_);
    inp.close_field();
    inp.open_field("_KMSKeyId_");
    __deser(inp,res._KMSKeyId_);
    inp.close_field();
    inp.open_field("_KMSContext_");
    __deser(inp,res._KMSContext_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_EncryptionConfiguration _arg<s3_test::_EncryptionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_EncryptionConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ReplicaKmsKeyID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ReplicaKmsKeyID_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicaKmsKeyID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_EncryptionConfiguration>(ivy_deser &inp, s3_test::_EncryptionConfiguration &res){
    inp.open_struct();
    inp.open_field("_ReplicaKmsKeyID_");
    __deser(inp,res._ReplicaKmsKeyID_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Error _arg<s3_test::_Error>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Error res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Code_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Code_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Code_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Message_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Message_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Message_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Error>(ivy_deser &inp, s3_test::_Error &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_Code_");
    __deser(inp,res._Code_);
    inp.close_field();
    inp.open_field("_Message_");
    __deser(inp,res._Message_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ExistingObjectReplication _arg<s3_test::_ExistingObjectReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ExistingObjectReplication res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ExistingObjectReplication>(ivy_deser &inp, s3_test::_ExistingObjectReplication &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_FilterRule _arg<s3_test::_FilterRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_FilterRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_FilterRule>(ivy_deser &inp, s3_test::_FilterRule &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_GetObjectOutput _arg<s3_test::_GetObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GetObjectOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 32) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Body_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Body_ = _arg<s3_test::blob>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Body_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_DeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._DeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarker_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_AcceptRanges_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._AcceptRanges_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AcceptRanges_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Expiration_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Restore_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Restore_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Restore_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ContentLength_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ContentLength_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLength_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_MissingMeta_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._MissingMeta_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _MissingMeta_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_CacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._CacheControl_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_ContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._ContentDisposition_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_ContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._ContentEncoding_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_ContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._ContentLanguage_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_ContentRange_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._ContentRange_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentRange_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_ContentType_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._ContentType_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_Expires_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._Expires_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expires_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_WebsiteRedirectLocation_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._WebsiteRedirectLocation_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _WebsiteRedirectLocation_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._ServerSideEncryption_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_Metadata_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._Metadata_ = _arg<s3_test::unordered_map__string____string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metadata_: " + err.txt,err.pos);
    }
    if (arg.fields[20].is_member()){
        tmp_args[0] = arg.fields[20].fields[0];
        if (arg.fields[20].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[20].atom,arg.fields[20].pos);
    }
    else{
        tmp_args[0] = arg.fields[20];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[21].is_member()){
        tmp_args[0] = arg.fields[21].fields[0];
        if (arg.fields[21].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[21].atom,arg.fields[21].pos);
    }
    else{
        tmp_args[0] = arg.fields[21];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[22].is_member()){
        tmp_args[0] = arg.fields[22].fields[0];
        if (arg.fields[22].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[22].atom,arg.fields[22].pos);
    }
    else{
        tmp_args[0] = arg.fields[22];
    }
    try{
        res._SSEKMSKeyId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[23].is_member()){
        tmp_args[0] = arg.fields[23].fields[0];
        if (arg.fields[23].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[23].atom,arg.fields[23].pos);
    }
    else{
        tmp_args[0] = arg.fields[23];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[24].is_member()){
        tmp_args[0] = arg.fields[24].fields[0];
        if (arg.fields[24].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[24].atom,arg.fields[24].pos);
    }
    else{
        tmp_args[0] = arg.fields[24];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[25].is_member()){
        tmp_args[0] = arg.fields[25].fields[0];
        if (arg.fields[25].atom != "_RequestCharged_") throw out_of_bounds("unexpected field: " + arg.fields[25].atom,arg.fields[25].pos);
    }
    else{
        tmp_args[0] = arg.fields[25];
    }
    try{
        res._RequestCharged_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestCharged_: " + err.txt,err.pos);
    }
    if (arg.fields[26].is_member()){
        tmp_args[0] = arg.fields[26].fields[0];
        if (arg.fields[26].atom != "_ReplicationStatus_") throw out_of_bounds("unexpected field: " + arg.fields[26].atom,arg.fields[26].pos);
    }
    else{
        tmp_args[0] = arg.fields[26];
    }
    try{
        res._ReplicationStatus_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicationStatus_: " + err.txt,err.pos);
    }
    if (arg.fields[27].is_member()){
        tmp_args[0] = arg.fields[27].fields[0];
        if (arg.fields[27].atom != "_PartsCount_") throw out_of_bounds("unexpected field: " + arg.fields[27].atom,arg.fields[27].pos);
    }
    else{
        tmp_args[0] = arg.fields[27];
    }
    try{
        res._PartsCount_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartsCount_: " + err.txt,err.pos);
    }
    if (arg.fields[28].is_member()){
        tmp_args[0] = arg.fields[28].fields[0];
        if (arg.fields[28].atom != "_TagCount_") throw out_of_bounds("unexpected field: " + arg.fields[28].atom,arg.fields[28].pos);
    }
    else{
        tmp_args[0] = arg.fields[28];
    }
    try{
        res._TagCount_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TagCount_: " + err.txt,err.pos);
    }
    if (arg.fields[29].is_member()){
        tmp_args[0] = arg.fields[29].fields[0];
        if (arg.fields[29].atom != "_ObjectLockMode_") throw out_of_bounds("unexpected field: " + arg.fields[29].atom,arg.fields[29].pos);
    }
    else{
        tmp_args[0] = arg.fields[29];
    }
    try{
        res._ObjectLockMode_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockMode_: " + err.txt,err.pos);
    }
    if (arg.fields[30].is_member()){
        tmp_args[0] = arg.fields[30].fields[0];
        if (arg.fields[30].atom != "_ObjectLockRetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[30].atom,arg.fields[30].pos);
    }
    else{
        tmp_args[0] = arg.fields[30];
    }
    try{
        res._ObjectLockRetainUntilDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockRetainUntilDate_: " + err.txt,err.pos);
    }
    if (arg.fields[31].is_member()){
        tmp_args[0] = arg.fields[31].fields[0];
        if (arg.fields[31].atom != "_ObjectLockLegalHoldStatus_") throw out_of_bounds("unexpected field: " + arg.fields[31].atom,arg.fields[31].pos);
    }
    else{
        tmp_args[0] = arg.fields[31];
    }
    try{
        res._ObjectLockLegalHoldStatus_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockLegalHoldStatus_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GetObjectOutput>(ivy_deser &inp, s3_test::_GetObjectOutput &res){
    inp.open_struct();
    inp.open_field("_Body_");
    __deser(inp,res._Body_);
    inp.close_field();
    inp.open_field("_DeleteMarker_");
    __deser(inp,res._DeleteMarker_);
    inp.close_field();
    inp.open_field("_AcceptRanges_");
    __deser(inp,res._AcceptRanges_);
    inp.close_field();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_Restore_");
    __deser(inp,res._Restore_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ContentLength_");
    __deser(inp,res._ContentLength_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_MissingMeta_");
    __deser(inp,res._MissingMeta_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_CacheControl_");
    __deser(inp,res._CacheControl_);
    inp.close_field();
    inp.open_field("_ContentDisposition_");
    __deser(inp,res._ContentDisposition_);
    inp.close_field();
    inp.open_field("_ContentEncoding_");
    __deser(inp,res._ContentEncoding_);
    inp.close_field();
    inp.open_field("_ContentLanguage_");
    __deser(inp,res._ContentLanguage_);
    inp.close_field();
    inp.open_field("_ContentRange_");
    __deser(inp,res._ContentRange_);
    inp.close_field();
    inp.open_field("_ContentType_");
    __deser(inp,res._ContentType_);
    inp.close_field();
    inp.open_field("_Expires_");
    __deser(inp,res._Expires_);
    inp.close_field();
    inp.open_field("_WebsiteRedirectLocation_");
    __deser(inp,res._WebsiteRedirectLocation_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_Metadata_");
    __deser(inp,res._Metadata_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_RequestCharged_");
    __deser(inp,res._RequestCharged_);
    inp.close_field();
    inp.open_field("_ReplicationStatus_");
    __deser(inp,res._ReplicationStatus_);
    inp.close_field();
    inp.open_field("_PartsCount_");
    __deser(inp,res._PartsCount_);
    inp.close_field();
    inp.open_field("_TagCount_");
    __deser(inp,res._TagCount_);
    inp.close_field();
    inp.open_field("_ObjectLockMode_");
    __deser(inp,res._ObjectLockMode_);
    inp.close_field();
    inp.open_field("_ObjectLockRetainUntilDate_");
    __deser(inp,res._ObjectLockRetainUntilDate_);
    inp.close_field();
    inp.open_field("_ObjectLockLegalHoldStatus_");
    __deser(inp,res._ObjectLockLegalHoldStatus_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_GetObjectRequest _arg<s3_test::_GetObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GetObjectRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 20) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Bucket_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_IfMatch_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._IfMatch_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfMatch_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_IfModifiedSince_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._IfModifiedSince_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfModifiedSince_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_IfNoneMatch_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._IfNoneMatch_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfNoneMatch_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_IfUnmodifiedSince_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._IfUnmodifiedSince_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfUnmodifiedSince_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Range_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Range_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Range_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ResponseCacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ResponseCacheControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseCacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_ResponseContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._ResponseContentDisposition_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_ResponseContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._ResponseContentEncoding_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_ResponseContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._ResponseContentLanguage_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_ResponseContentType_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._ResponseContentType_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_ResponseExpires_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._ResponseExpires_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseExpires_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._VersionId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_SSECustomerKey_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._SSECustomerKey_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKey_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_RequestPayer_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._RequestPayer_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestPayer_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._PartNumber_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_ExpectedBucketOwner_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._ExpectedBucketOwner_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpectedBucketOwner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GetObjectRequest>(ivy_deser &inp, s3_test::_GetObjectRequest &res){
    inp.open_struct();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_IfMatch_");
    __deser(inp,res._IfMatch_);
    inp.close_field();
    inp.open_field("_IfModifiedSince_");
    __deser(inp,res._IfModifiedSince_);
    inp.close_field();
    inp.open_field("_IfNoneMatch_");
    __deser(inp,res._IfNoneMatch_);
    inp.close_field();
    inp.open_field("_IfUnmodifiedSince_");
    __deser(inp,res._IfUnmodifiedSince_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Range_");
    __deser(inp,res._Range_);
    inp.close_field();
    inp.open_field("_ResponseCacheControl_");
    __deser(inp,res._ResponseCacheControl_);
    inp.close_field();
    inp.open_field("_ResponseContentDisposition_");
    __deser(inp,res._ResponseContentDisposition_);
    inp.close_field();
    inp.open_field("_ResponseContentEncoding_");
    __deser(inp,res._ResponseContentEncoding_);
    inp.close_field();
    inp.open_field("_ResponseContentLanguage_");
    __deser(inp,res._ResponseContentLanguage_);
    inp.close_field();
    inp.open_field("_ResponseContentType_");
    __deser(inp,res._ResponseContentType_);
    inp.close_field();
    inp.open_field("_ResponseExpires_");
    __deser(inp,res._ResponseExpires_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKey_");
    __deser(inp,res._SSECustomerKey_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_RequestPayer_");
    __deser(inp,res._RequestPayer_);
    inp.close_field();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.open_field("_ExpectedBucketOwner_");
    __deser(inp,res._ExpectedBucketOwner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_GlacierJobParameters _arg<s3_test::_GlacierJobParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GlacierJobParameters res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Tier_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Tier_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tier_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GlacierJobParameters>(ivy_deser &inp, s3_test::_GlacierJobParameters &res){
    inp.open_struct();
    inp.open_field("_Tier_");
    __deser(inp,res._Tier_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Grant _arg<s3_test::_Grant>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Grant res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grantee_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grantee_ = _arg<s3_test::_Grantee>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grantee_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Permission_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Permission_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Permission_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Grant>(ivy_deser &inp, s3_test::_Grant &res){
    inp.open_struct();
    inp.open_field("_Grantee_");
    __deser(inp,res._Grantee_);
    inp.close_field();
    inp.open_field("_Permission_");
    __deser(inp,res._Permission_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Grantee _arg<s3_test::_Grantee>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Grantee res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DisplayName_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_EmailAddress_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._EmailAddress_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EmailAddress_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Type_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_URI_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._URI_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _URI_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Grantee>(ivy_deser &inp, s3_test::_Grantee &res){
    inp.open_struct();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.open_field("_EmailAddress_");
    __deser(inp,res._EmailAddress_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.open_field("_URI_");
    __deser(inp,res._URI_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Initiator _arg<s3_test::_Initiator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Initiator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._DisplayName_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Initiator>(ivy_deser &inp, s3_test::_Initiator &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InputSerialization _arg<s3_test::_InputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InputSerialization res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_CSV_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._CSV_ = _arg<s3_test::_CSVInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CSV_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_CompressionType_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._CompressionType_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CompressionType_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_JSON_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._JSON_ = _arg<s3_test::_JSONInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _JSON_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Parquet_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Parquet_ = _arg<s3_test::_ParquetInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Parquet_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InputSerialization>(ivy_deser &inp, s3_test::_InputSerialization &res){
    inp.open_struct();
    inp.open_field("_CSV_");
    __deser(inp,res._CSV_);
    inp.close_field();
    inp.open_field("_CompressionType_");
    __deser(inp,res._CompressionType_);
    inp.close_field();
    inp.open_field("_JSON_");
    __deser(inp,res._JSON_);
    inp.close_field();
    inp.open_field("_Parquet_");
    __deser(inp,res._Parquet_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_IntelligentTieringAndOperator _arg<s3_test::_IntelligentTieringAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringAndOperator>(ivy_deser &inp, s3_test::_IntelligentTieringAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_IntelligentTieringConfiguration _arg<s3_test::_IntelligentTieringConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___IntelligentTieringFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Tierings_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Tierings_ = _arg<s3_test::vector___Tiering__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tierings_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringConfiguration>(ivy_deser &inp, s3_test::_IntelligentTieringConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Tierings_");
    __deser(inp,res._Tierings_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_IntelligentTieringFilter _arg<s3_test::_IntelligentTieringFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_IntelligentTieringAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringFilter>(ivy_deser &inp, s3_test::_IntelligentTieringFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventoryConfiguration _arg<s3_test::_InventoryConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Destination_ = _arg<s3_test::_InventoryDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_IsEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._IsEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Filter_ = _arg<s3_test::option___InventoryFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Id_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_IncludedObjectVersions_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._IncludedObjectVersions_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IncludedObjectVersions_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_OptionalFields_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._OptionalFields_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OptionalFields_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Schedule_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Schedule_ = _arg<s3_test::_InventorySchedule>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Schedule_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryConfiguration>(ivy_deser &inp, s3_test::_InventoryConfiguration &res){
    inp.open_struct();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.open_field("_IsEnabled_");
    __deser(inp,res._IsEnabled_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_IncludedObjectVersions_");
    __deser(inp,res._IncludedObjectVersions_);
    inp.close_field();
    inp.open_field("_OptionalFields_");
    __deser(inp,res._OptionalFields_);
    inp.close_field();
    inp.open_field("_Schedule_");
    __deser(inp,res._Schedule_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventoryDestination _arg<s3_test::_InventoryDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3BucketDestination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3BucketDestination_ = _arg<s3_test::_InventoryS3BucketDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3BucketDestination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryDestination>(ivy_deser &inp, s3_test::_InventoryDestination &res){
    inp.open_struct();
    inp.open_field("_S3BucketDestination_");
    __deser(inp,res._S3BucketDestination_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventoryEncryption _arg<s3_test::_InventoryEncryption>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryEncryption res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SSES3_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SSES3_ = _arg<s3_test::_SSES3>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSES3_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_SSEKMS_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._SSEKMS_ = _arg<s3_test::_SSEKMS>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMS_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryEncryption>(ivy_deser &inp, s3_test::_InventoryEncryption &res){
    inp.open_struct();
    inp.open_field("_SSES3_");
    __deser(inp,res._SSES3_);
    inp.close_field();
    inp.open_field("_SSEKMS_");
    __deser(inp,res._SSEKMS_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventoryFilter _arg<s3_test::_InventoryFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryFilter>(ivy_deser &inp, s3_test::_InventoryFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventoryS3BucketDestination _arg<s3_test::_InventoryS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryS3BucketDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_AccountId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._AccountId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccountId_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Bucket_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Format_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Format_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Format_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Encryption_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Encryption_ = _arg<s3_test::option___InventoryEncryption__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Encryption_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryS3BucketDestination>(ivy_deser &inp, s3_test::_InventoryS3BucketDestination &res){
    inp.open_struct();
    inp.open_field("_AccountId_");
    __deser(inp,res._AccountId_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Format_");
    __deser(inp,res._Format_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Encryption_");
    __deser(inp,res._Encryption_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_InventorySchedule _arg<s3_test::_InventorySchedule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventorySchedule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Frequency_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Frequency_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Frequency_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventorySchedule>(ivy_deser &inp, s3_test::_InventorySchedule &res){
    inp.open_struct();
    inp.open_field("_Frequency_");
    __deser(inp,res._Frequency_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_JSONInput _arg<s3_test::_JSONInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_JSONInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Type_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_JSONInput>(ivy_deser &inp, s3_test::_JSONInput &res){
    inp.open_struct();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_JSONOutput _arg<s3_test::_JSONOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_JSONOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._RecordDelimiter_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_JSONOutput>(ivy_deser &inp, s3_test::_JSONOutput &res){
    inp.open_struct();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LambdaFunctionConfiguration _arg<s3_test::_LambdaFunctionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LambdaFunctionConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LambdaFunctionArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LambdaFunctionArn_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LambdaFunctionArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LambdaFunctionConfiguration>(ivy_deser &inp, s3_test::_LambdaFunctionConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_LambdaFunctionArn_");
    __deser(inp,res._LambdaFunctionArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LifecycleConfiguration _arg<s3_test::_LifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Rules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Rules_ = _arg<s3_test::vector___Rule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleConfiguration>(ivy_deser &inp, s3_test::_LifecycleConfiguration &res){
    inp.open_struct();
    inp.open_field("_Rules_");
    __deser(inp,res._Rules_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LifecycleExpiration _arg<s3_test::_LifecycleExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleExpiration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Date_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Date_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Date_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ExpiredObjectDeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ExpiredObjectDeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpiredObjectDeleteMarker_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleExpiration>(ivy_deser &inp, s3_test::_LifecycleExpiration &res){
    inp.open_struct();
    inp.open_field("_Date_");
    __deser(inp,res._Date_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_ExpiredObjectDeleteMarker_");
    __deser(inp,res._ExpiredObjectDeleteMarker_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LifecycleRule _arg<s3_test::_LifecycleRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 9) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<s3_test::option___LifecycleExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___LifecycleRuleFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Transitions_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Transitions_ = _arg<s3_test::option__vector___Transition____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Transitions_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_NoncurrentVersionTransitions_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._NoncurrentVersionTransitions_ = _arg<s3_test::option__vector___NoncurrentVersionTransition____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionTransitions_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_NoncurrentVersionExpiration_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._NoncurrentVersionExpiration_ = _arg<s3_test::option___NoncurrentVersionExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionExpiration_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_AbortIncompleteMultipartUpload_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._AbortIncompleteMultipartUpload_ = _arg<s3_test::option___AbortIncompleteMultipartUpload__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AbortIncompleteMultipartUpload_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRule>(ivy_deser &inp, s3_test::_LifecycleRule &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Transitions_");
    __deser(inp,res._Transitions_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionTransitions_");
    __deser(inp,res._NoncurrentVersionTransitions_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionExpiration_");
    __deser(inp,res._NoncurrentVersionExpiration_);
    inp.close_field();
    inp.open_field("_AbortIncompleteMultipartUpload_");
    __deser(inp,res._AbortIncompleteMultipartUpload_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LifecycleRuleAndOperator _arg<s3_test::_LifecycleRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRuleAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRuleAndOperator>(ivy_deser &inp, s3_test::_LifecycleRuleAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_LifecycleRuleFilter _arg<s3_test::_LifecycleRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRuleFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_LifecycleRuleAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRuleFilter>(ivy_deser &inp, s3_test::_LifecycleRuleFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_MetadataEntry _arg<s3_test::_MetadataEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetadataEntry res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetadataEntry>(ivy_deser &inp, s3_test::_MetadataEntry &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Metrics _arg<s3_test::_Metrics>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Metrics res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_EventThreshold_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._EventThreshold_ = _arg<s3_test::option___ReplicationTimeValue__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EventThreshold_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Metrics>(ivy_deser &inp, s3_test::_Metrics &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_EventThreshold_");
    __deser(inp,res._EventThreshold_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_MetricsAndOperator _arg<s3_test::_MetricsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsAndOperator>(ivy_deser &inp, s3_test::_MetricsAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_MetricsConfiguration _arg<s3_test::_MetricsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___MetricsFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsConfiguration>(ivy_deser &inp, s3_test::_MetricsConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_MetricsFilter _arg<s3_test::_MetricsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_MetricsAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsFilter>(ivy_deser &inp, s3_test::_MetricsFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_MultipartUpload _arg<s3_test::_MultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_UploadId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._UploadId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _UploadId_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Initiated_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Initiated_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Initiated_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Initiator_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Initiator_ = _arg<s3_test::_Initiator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Initiator_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MultipartUpload>(ivy_deser &inp, s3_test::_MultipartUpload &res){
    inp.open_struct();
    inp.open_field("_UploadId_");
    __deser(inp,res._UploadId_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Initiated_");
    __deser(inp,res._Initiated_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.open_field("_Initiator_");
    __deser(inp,res._Initiator_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_NoncurrentVersionExpiration _arg<s3_test::_NoncurrentVersionExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NoncurrentVersionExpiration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_NoncurrentDays_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._NoncurrentDays_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentDays_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NoncurrentVersionExpiration>(ivy_deser &inp, s3_test::_NoncurrentVersionExpiration &res){
    inp.open_struct();
    inp.open_field("_NoncurrentDays_");
    __deser(inp,res._NoncurrentDays_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_NoncurrentVersionTransition _arg<s3_test::_NoncurrentVersionTransition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NoncurrentVersionTransition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_NoncurrentDays_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._NoncurrentDays_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentDays_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NoncurrentVersionTransition>(ivy_deser &inp, s3_test::_NoncurrentVersionTransition &res){
    inp.open_struct();
    inp.open_field("_NoncurrentDays_");
    __deser(inp,res._NoncurrentDays_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_NotificationConfigurationFilter _arg<s3_test::_NotificationConfigurationFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NotificationConfigurationFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::_S3KeyFilter>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NotificationConfigurationFilter>(ivy_deser &inp, s3_test::_NotificationConfigurationFilter &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Object _arg<s3_test::_Object>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Object res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Object>(ivy_deser &inp, s3_test::_Object &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectIdentifier _arg<s3_test::_ObjectIdentifier>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectIdentifier res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectIdentifier>(ivy_deser &inp, s3_test::_ObjectIdentifier &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectLockConfiguration _arg<s3_test::_ObjectLockConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ObjectLockEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ObjectLockEnabled_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Rule_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Rule_ = _arg<s3_test::_ObjectLockRule>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rule_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockConfiguration>(ivy_deser &inp, s3_test::_ObjectLockConfiguration &res){
    inp.open_struct();
    inp.open_field("_ObjectLockEnabled_");
    __deser(inp,res._ObjectLockEnabled_);
    inp.close_field();
    inp.open_field("_Rule_");
    __deser(inp,res._Rule_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectLockLegalHold _arg<s3_test::_ObjectLockLegalHold>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockLegalHold res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockLegalHold>(ivy_deser &inp, s3_test::_ObjectLockLegalHold &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectLockRetention _arg<s3_test::_ObjectLockRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockRetention res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Mode_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Mode_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Mode_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_RetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._RetainUntilDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RetainUntilDate_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockRetention>(ivy_deser &inp, s3_test::_ObjectLockRetention &res){
    inp.open_struct();
    inp.open_field("_Mode_");
    __deser(inp,res._Mode_);
    inp.close_field();
    inp.open_field("_RetainUntilDate_");
    __deser(inp,res._RetainUntilDate_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectLockRule _arg<s3_test::_ObjectLockRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DefaultRetention_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DefaultRetention_ = _arg<s3_test::_DefaultRetention>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DefaultRetention_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockRule>(ivy_deser &inp, s3_test::_ObjectLockRule &res){
    inp.open_struct();
    inp.open_field("_DefaultRetention_");
    __deser(inp,res._DefaultRetention_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ObjectVersion _arg<s3_test::_ObjectVersion>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectVersion res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_IsLatest_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._IsLatest_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsLatest_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectVersion>(ivy_deser &inp, s3_test::_ObjectVersion &res){
    inp.open_struct();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_IsLatest_");
    __deser(inp,res._IsLatest_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_OutputLocation _arg<s3_test::_OutputLocation>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OutputLocation res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3_ = _arg<s3_test::_S3Location>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OutputLocation>(ivy_deser &inp, s3_test::_OutputLocation &res){
    inp.open_struct();
    inp.open_field("_S3_");
    __deser(inp,res._S3_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_OutputSerialization _arg<s3_test::_OutputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OutputSerialization res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_CSV_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._CSV_ = _arg<s3_test::_CSVOutput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CSV_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_JSON_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._JSON_ = _arg<s3_test::_JSONOutput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _JSON_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OutputSerialization>(ivy_deser &inp, s3_test::_OutputSerialization &res){
    inp.open_struct();
    inp.open_field("_CSV_");
    __deser(inp,res._CSV_);
    inp.close_field();
    inp.open_field("_JSON_");
    __deser(inp,res._JSON_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Owner _arg<s3_test::_Owner>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Owner res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DisplayName_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Owner>(ivy_deser &inp, s3_test::_Owner &res){
    inp.open_struct();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_OwnershipControlsRule _arg<s3_test::_OwnershipControlsRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OwnershipControlsRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ObjectOwnership_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ObjectOwnership_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectOwnership_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OwnershipControlsRule>(ivy_deser &inp, s3_test::_OwnershipControlsRule &res){
    inp.open_struct();
    inp.open_field("_ObjectOwnership_");
    __deser(inp,res._ObjectOwnership_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ParquetInput _arg<s3_test::_ParquetInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ParquetInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 0) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    return res;
}
template <>
void __deser<s3_test::_ParquetInput>(ivy_deser &inp, s3_test::_ParquetInput &res){
    inp.open_struct();
    inp.close_struct();
}
template <>
s3_test::_Part _arg<s3_test::_Part>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Part res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._PartNumber_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Part>(ivy_deser &inp, s3_test::_Part &res){
    inp.open_struct();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_PutObjectOutput _arg<s3_test::_PutObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_PutObjectOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 10) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ETag_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ServerSideEncryption_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._VersionId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._SSEKMSKeyId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_SSEKMSEncryptionContext_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._SSEKMSEncryptionContext_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSEncryptionContext_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_RequestCharged_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._RequestCharged_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestCharged_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_PutObjectOutput>(ivy_deser &inp, s3_test::_PutObjectOutput &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_SSEKMSEncryptionContext_");
    __deser(inp,res._SSEKMSEncryptionContext_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_RequestCharged_");
    __deser(inp,res._RequestCharged_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_PutObjectRequest _arg<s3_test::_PutObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_PutObjectRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 32) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ACL_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ACL_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ACL_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Body_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Body_ = _arg<s3_test::option__blob__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Body_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Bucket_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_CacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._CacheControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ContentDisposition_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_ContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._ContentEncoding_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ContentLanguage_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ContentLength_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ContentLength_ = _arg<s3_test::option__long__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLength_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_ContentMD5_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._ContentMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_ContentType_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._ContentType_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_Expires_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._Expires_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expires_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_GrantFullControl_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._GrantFullControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantFullControl_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_GrantRead_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._GrantRead_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantRead_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_GrantReadACP_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._GrantReadACP_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantReadACP_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_GrantWriteACP_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._GrantWriteACP_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantWriteACP_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_Metadata_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._Metadata_ = _arg<s3_test::option__unordered_map__string____string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metadata_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._ServerSideEncryption_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_WebsiteRedirectLocation_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._WebsiteRedirectLocation_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _WebsiteRedirectLocation_: " + err.txt,err.pos);
    }
    if (arg.fields[20].is_member()){
        tmp_args[0] = arg.fields[20].fields[0];
        if (arg.fields[20].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[20].atom,arg.fields[20].pos);
    }
    else{
        tmp_args[0] = arg.fields[20];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[21].is_member()){
        tmp_args[0] = arg.fields[21].fields[0];
        if (arg.fields[21].atom != "_SSECustomerKey_") throw out_of_bounds("unexpected field: " + arg.fields[21].atom,arg.fields[21].pos);
    }
    else{
        tmp_args[0] = arg.fields[21];
    }
    try{
        res._SSECustomerKey_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKey_: " + err.txt,err.pos);
    }
    if (arg.fields[22].is_member()){
        tmp_args[0] = arg.fields[22].fields[0];
        if (arg.fields[22].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[22].atom,arg.fields[22].pos);
    }
    else{
        tmp_args[0] = arg.fields[22];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[23].is_member()){
        tmp_args[0] = arg.fields[23].fields[0];
        if (arg.fields[23].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[23].atom,arg.fields[23].pos);
    }
    else{
        tmp_args[0] = arg.fields[23];
    }
    try{
        res._SSEKMSKeyId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[24].is_member()){
        tmp_args[0] = arg.fields[24].fields[0];
        if (arg.fields[24].atom != "_SSEKMSEncryptionContext_") throw out_of_bounds("unexpected field: " + arg.fields[24].atom,arg.fields[24].pos);
    }
    else{
        tmp_args[0] = arg.fields[24];
    }
    try{
        res._SSEKMSEncryptionContext_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSEncryptionContext_: " + err.txt,err.pos);
    }
    if (arg.fields[25].is_member()){
        tmp_args[0] = arg.fields[25].fields[0];
        if (arg.fields[25].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[25].atom,arg.fields[25].pos);
    }
    else{
        tmp_args[0] = arg.fields[25];
    }
    try{
        res._BucketKeyEnabled_ = _arg<s3_test::option__bool__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[26].is_member()){
        tmp_args[0] = arg.fields[26].fields[0];
        if (arg.fields[26].atom != "_RequestPayer_") throw out_of_bounds("unexpected field: " + arg.fields[26].atom,arg.fields[26].pos);
    }
    else{
        tmp_args[0] = arg.fields[26];
    }
    try{
        res._RequestPayer_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestPayer_: " + err.txt,err.pos);
    }
    if (arg.fields[27].is_member()){
        tmp_args[0] = arg.fields[27].fields[0];
        if (arg.fields[27].atom != "_Tagging_") throw out_of_bounds("unexpected field: " + arg.fields[27].atom,arg.fields[27].pos);
    }
    else{
        tmp_args[0] = arg.fields[27];
    }
    try{
        res._Tagging_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tagging_: " + err.txt,err.pos);
    }
    if (arg.fields[28].is_member()){
        tmp_args[0] = arg.fields[28].fields[0];
        if (arg.fields[28].atom != "_ObjectLockMode_") throw out_of_bounds("unexpected field: " + arg.fields[28].atom,arg.fields[28].pos);
    }
    else{
        tmp_args[0] = arg.fields[28];
    }
    try{
        res._ObjectLockMode_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockMode_: " + err.txt,err.pos);
    }
    if (arg.fields[29].is_member()){
        tmp_args[0] = arg.fields[29].fields[0];
        if (arg.fields[29].atom != "_ObjectLockRetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[29].atom,arg.fields[29].pos);
    }
    else{
        tmp_args[0] = arg.fields[29];
    }
    try{
        res._ObjectLockRetainUntilDate_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockRetainUntilDate_: " + err.txt,err.pos);
    }
    if (arg.fields[30].is_member()){
        tmp_args[0] = arg.fields[30].fields[0];
        if (arg.fields[30].atom != "_ObjectLockLegalHoldStatus_") throw out_of_bounds("unexpected field: " + arg.fields[30].atom,arg.fields[30].pos);
    }
    else{
        tmp_args[0] = arg.fields[30];
    }
    try{
        res._ObjectLockLegalHoldStatus_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockLegalHoldStatus_: " + err.txt,err.pos);
    }
    if (arg.fields[31].is_member()){
        tmp_args[0] = arg.fields[31].fields[0];
        if (arg.fields[31].atom != "_ExpectedBucketOwner_") throw out_of_bounds("unexpected field: " + arg.fields[31].atom,arg.fields[31].pos);
    }
    else{
        tmp_args[0] = arg.fields[31];
    }
    try{
        res._ExpectedBucketOwner_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpectedBucketOwner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_PutObjectRequest>(ivy_deser &inp, s3_test::_PutObjectRequest &res){
    inp.open_struct();
    inp.open_field("_ACL_");
    __deser(inp,res._ACL_);
    inp.close_field();
    inp.open_field("_Body_");
    __deser(inp,res._Body_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_CacheControl_");
    __deser(inp,res._CacheControl_);
    inp.close_field();
    inp.open_field("_ContentDisposition_");
    __deser(inp,res._ContentDisposition_);
    inp.close_field();
    inp.open_field("_ContentEncoding_");
    __deser(inp,res._ContentEncoding_);
    inp.close_field();
    inp.open_field("_ContentLanguage_");
    __deser(inp,res._ContentLanguage_);
    inp.close_field();
    inp.open_field("_ContentLength_");
    __deser(inp,res._ContentLength_);
    inp.close_field();
    inp.open_field("_ContentMD5_");
    __deser(inp,res._ContentMD5_);
    inp.close_field();
    inp.open_field("_ContentType_");
    __deser(inp,res._ContentType_);
    inp.close_field();
    inp.open_field("_Expires_");
    __deser(inp,res._Expires_);
    inp.close_field();
    inp.open_field("_GrantFullControl_");
    __deser(inp,res._GrantFullControl_);
    inp.close_field();
    inp.open_field("_GrantRead_");
    __deser(inp,res._GrantRead_);
    inp.close_field();
    inp.open_field("_GrantReadACP_");
    __deser(inp,res._GrantReadACP_);
    inp.close_field();
    inp.open_field("_GrantWriteACP_");
    __deser(inp,res._GrantWriteACP_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Metadata_");
    __deser(inp,res._Metadata_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_WebsiteRedirectLocation_");
    __deser(inp,res._WebsiteRedirectLocation_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKey_");
    __deser(inp,res._SSECustomerKey_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_SSEKMSEncryptionContext_");
    __deser(inp,res._SSEKMSEncryptionContext_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_RequestPayer_");
    __deser(inp,res._RequestPayer_);
    inp.close_field();
    inp.open_field("_Tagging_");
    __deser(inp,res._Tagging_);
    inp.close_field();
    inp.open_field("_ObjectLockMode_");
    __deser(inp,res._ObjectLockMode_);
    inp.close_field();
    inp.open_field("_ObjectLockRetainUntilDate_");
    __deser(inp,res._ObjectLockRetainUntilDate_);
    inp.close_field();
    inp.open_field("_ObjectLockLegalHoldStatus_");
    __deser(inp,res._ObjectLockLegalHoldStatus_);
    inp.close_field();
    inp.open_field("_ExpectedBucketOwner_");
    __deser(inp,res._ExpectedBucketOwner_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_QueueConfiguration _arg<s3_test::_QueueConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_QueueConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_QueueArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._QueueArn_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QueueArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_QueueConfiguration>(ivy_deser &inp, s3_test::_QueueConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_QueueArn_");
    __deser(inp,res._QueueArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Redirect _arg<s3_test::_Redirect>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Redirect res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_HostName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._HostName_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HostName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_HttpRedirectCode_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._HttpRedirectCode_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HttpRedirectCode_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Protocol_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Protocol_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Protocol_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_ReplaceKeyPrefixWith_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._ReplaceKeyPrefixWith_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplaceKeyPrefixWith_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ReplaceKeyWith_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ReplaceKeyWith_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplaceKeyWith_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Redirect>(ivy_deser &inp, s3_test::_Redirect &res){
    inp.open_struct();
    inp.open_field("_HostName_");
    __deser(inp,res._HostName_);
    inp.close_field();
    inp.open_field("_HttpRedirectCode_");
    __deser(inp,res._HttpRedirectCode_);
    inp.close_field();
    inp.open_field("_Protocol_");
    __deser(inp,res._Protocol_);
    inp.close_field();
    inp.open_field("_ReplaceKeyPrefixWith_");
    __deser(inp,res._ReplaceKeyPrefixWith_);
    inp.close_field();
    inp.open_field("_ReplaceKeyWith_");
    __deser(inp,res._ReplaceKeyWith_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicaModifications _arg<s3_test::_ReplicaModifications>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicaModifications res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicaModifications>(ivy_deser &inp, s3_test::_ReplicaModifications &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicationRule _arg<s3_test::_ReplicationRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 9) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Priority_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Priority_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Priority_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___ReplicationRuleFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SourceSelectionCriteria_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SourceSelectionCriteria_ = _arg<s3_test::option___SourceSelectionCriteria__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SourceSelectionCriteria_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ExistingObjectReplication_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ExistingObjectReplication_ = _arg<s3_test::option___ExistingObjectReplication__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExistingObjectReplication_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._Destination_ = _arg<s3_test::_Destination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_DeleteMarkerReplication_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._DeleteMarkerReplication_ = _arg<s3_test::option___DeleteMarkerReplication__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarkerReplication_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRule>(ivy_deser &inp, s3_test::_ReplicationRule &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Priority_");
    __deser(inp,res._Priority_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_SourceSelectionCriteria_");
    __deser(inp,res._SourceSelectionCriteria_);
    inp.close_field();
    inp.open_field("_ExistingObjectReplication_");
    __deser(inp,res._ExistingObjectReplication_);
    inp.close_field();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.open_field("_DeleteMarkerReplication_");
    __deser(inp,res._DeleteMarkerReplication_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicationRuleAndOperator _arg<s3_test::_ReplicationRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRuleAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRuleAndOperator>(ivy_deser &inp, s3_test::_ReplicationRuleAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicationRuleFilter _arg<s3_test::_ReplicationRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRuleFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_ReplicationRuleAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRuleFilter>(ivy_deser &inp, s3_test::_ReplicationRuleFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicationTime _arg<s3_test::_ReplicationTime>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationTime res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Time_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Time_ = _arg<s3_test::_ReplicationTimeValue>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Time_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationTime>(ivy_deser &inp, s3_test::_ReplicationTime &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Time_");
    __deser(inp,res._Time_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ReplicationTimeValue _arg<s3_test::_ReplicationTimeValue>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationTimeValue res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Minutes_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Minutes_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Minutes_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationTimeValue>(ivy_deser &inp, s3_test::_ReplicationTimeValue &res){
    inp.open_struct();
    inp.open_field("_Minutes_");
    __deser(inp,res._Minutes_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_RequestProgress _arg<s3_test::_RequestProgress>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RequestProgress res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Enabled_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Enabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Enabled_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RequestProgress>(ivy_deser &inp, s3_test::_RequestProgress &res){
    inp.open_struct();
    inp.open_field("_Enabled_");
    __deser(inp,res._Enabled_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_RestoreRequest _arg<s3_test::_RestoreRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RestoreRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_GlacierJobParameters_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._GlacierJobParameters_ = _arg<s3_test::_GlacierJobParameters>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GlacierJobParameters_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Type_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Tier_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Tier_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tier_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Description_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Description_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Description_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SelectParameters_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SelectParameters_ = _arg<s3_test::_SelectParameters>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SelectParameters_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_OutputLocation_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._OutputLocation_ = _arg<s3_test::_OutputLocation>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputLocation_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RestoreRequest>(ivy_deser &inp, s3_test::_RestoreRequest &res){
    inp.open_struct();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_GlacierJobParameters_");
    __deser(inp,res._GlacierJobParameters_);
    inp.close_field();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.open_field("_Tier_");
    __deser(inp,res._Tier_);
    inp.close_field();
    inp.open_field("_Description_");
    __deser(inp,res._Description_);
    inp.close_field();
    inp.open_field("_SelectParameters_");
    __deser(inp,res._SelectParameters_);
    inp.close_field();
    inp.open_field("_OutputLocation_");
    __deser(inp,res._OutputLocation_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_RoutingRule _arg<s3_test::_RoutingRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RoutingRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Condition_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Condition_ = _arg<s3_test::option___Condition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Condition_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Redirect_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Redirect_ = _arg<s3_test::_Redirect>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Redirect_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RoutingRule>(ivy_deser &inp, s3_test::_RoutingRule &res){
    inp.open_struct();
    inp.open_field("_Condition_");
    __deser(inp,res._Condition_);
    inp.close_field();
    inp.open_field("_Redirect_");
    __deser(inp,res._Redirect_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Rule _arg<s3_test::_Rule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Rule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<s3_test::option___LifecycleExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Transition_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Transition_ = _arg<s3_test::option___Transition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Transition_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_NoncurrentVersionTransition_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._NoncurrentVersionTransition_ = _arg<s3_test::option___NoncurrentVersionTransition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionTransition_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_NoncurrentVersionExpiration_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._NoncurrentVersionExpiration_ = _arg<s3_test::option___NoncurrentVersionExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionExpiration_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_AbortIncompleteMultipartUpload_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._AbortIncompleteMultipartUpload_ = _arg<s3_test::option___AbortIncompleteMultipartUpload__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AbortIncompleteMultipartUpload_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Rule>(ivy_deser &inp, s3_test::_Rule &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Transition_");
    __deser(inp,res._Transition_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionTransition_");
    __deser(inp,res._NoncurrentVersionTransition_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionExpiration_");
    __deser(inp,res._NoncurrentVersionExpiration_);
    inp.close_field();
    inp.open_field("_AbortIncompleteMultipartUpload_");
    __deser(inp,res._AbortIncompleteMultipartUpload_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_S3KeyFilter _arg<s3_test::_S3KeyFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_S3KeyFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_FilterRules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._FilterRules_ = _arg<s3_test::vector___FilterRule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FilterRules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_S3KeyFilter>(ivy_deser &inp, s3_test::_S3KeyFilter &res){
    inp.open_struct();
    inp.open_field("_FilterRules_");
    __deser(inp,res._FilterRules_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_S3Location _arg<s3_test::_S3Location>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_S3Location res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_BucketName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._BucketName_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Prefix_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Encryption_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Encryption_ = _arg<s3_test::option___Encryption__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Encryption_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_CannedACL_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._CannedACL_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CannedACL_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_AccessControlList_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._AccessControlList_ = _arg<s3_test::option__vector___Grant____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessControlList_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Tagging_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Tagging_ = _arg<s3_test::option___Tagging__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tagging_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_UserMetadata_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._UserMetadata_ = _arg<s3_test::option__vector___MetadataEntry____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _UserMetadata_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_S3Location>(ivy_deser &inp, s3_test::_S3Location &res){
    inp.open_struct();
    inp.open_field("_BucketName_");
    __deser(inp,res._BucketName_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Encryption_");
    __deser(inp,res._Encryption_);
    inp.close_field();
    inp.open_field("_CannedACL_");
    __deser(inp,res._CannedACL_);
    inp.close_field();
    inp.open_field("_AccessControlList_");
    __deser(inp,res._AccessControlList_);
    inp.close_field();
    inp.open_field("_Tagging_");
    __deser(inp,res._Tagging_);
    inp.close_field();
    inp.open_field("_UserMetadata_");
    __deser(inp,res._UserMetadata_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_SSEKMS _arg<s3_test::_SSEKMS>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SSEKMS res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_KeyId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._KeyId_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KeyId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SSEKMS>(ivy_deser &inp, s3_test::_SSEKMS &res){
    inp.open_struct();
    inp.open_field("_KeyId_");
    __deser(inp,res._KeyId_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_SSES3 _arg<s3_test::_SSES3>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SSES3 res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 0) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    return res;
}
template <>
void __deser<s3_test::_SSES3>(ivy_deser &inp, s3_test::_SSES3 &res){
    inp.open_struct();
    inp.close_struct();
}
template <>
s3_test::_ScanRange _arg<s3_test::_ScanRange>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ScanRange res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Start_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Start_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Start_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_End_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._End_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _End_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ScanRange>(ivy_deser &inp, s3_test::_ScanRange &res){
    inp.open_struct();
    inp.open_field("_Start_");
    __deser(inp,res._Start_);
    inp.close_field();
    inp.open_field("_End_");
    __deser(inp,res._End_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_SelectParameters _arg<s3_test::_SelectParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SelectParameters res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_InputSerialization_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._InputSerialization_ = _arg<s3_test::_InputSerialization>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _InputSerialization_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ExpressionType_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ExpressionType_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpressionType_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Expression_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Expression_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expression_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_OutputSerialization_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._OutputSerialization_ = _arg<s3_test::_OutputSerialization>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputSerialization_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SelectParameters>(ivy_deser &inp, s3_test::_SelectParameters &res){
    inp.open_struct();
    inp.open_field("_InputSerialization_");
    __deser(inp,res._InputSerialization_);
    inp.close_field();
    inp.open_field("_ExpressionType_");
    __deser(inp,res._ExpressionType_);
    inp.close_field();
    inp.open_field("_Expression_");
    __deser(inp,res._Expression_);
    inp.close_field();
    inp.open_field("_OutputSerialization_");
    __deser(inp,res._OutputSerialization_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ServerSideEncryptionByDefault _arg<s3_test::_ServerSideEncryptionByDefault>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ServerSideEncryptionByDefault res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SSEAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SSEAlgorithm_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KMSMasterKeyID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KMSMasterKeyID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSMasterKeyID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ServerSideEncryptionByDefault>(ivy_deser &inp, s3_test::_ServerSideEncryptionByDefault &res){
    inp.open_struct();
    inp.open_field("_SSEAlgorithm_");
    __deser(inp,res._SSEAlgorithm_);
    inp.close_field();
    inp.open_field("_KMSMasterKeyID_");
    __deser(inp,res._KMSMasterKeyID_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_ServerSideEncryptionRule _arg<s3_test::_ServerSideEncryptionRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ServerSideEncryptionRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ApplyServerSideEncryptionByDefault_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ApplyServerSideEncryptionByDefault_ = _arg<s3_test::_ServerSideEncryptionByDefault>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ApplyServerSideEncryptionByDefault_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ServerSideEncryptionRule>(ivy_deser &inp, s3_test::_ServerSideEncryptionRule &res){
    inp.open_struct();
    inp.open_field("_ApplyServerSideEncryptionByDefault_");
    __deser(inp,res._ApplyServerSideEncryptionByDefault_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_SourceSelectionCriteria _arg<s3_test::_SourceSelectionCriteria>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SourceSelectionCriteria res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SseKmsEncryptedObjects_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SseKmsEncryptedObjects_ = _arg<s3_test::_SseKmsEncryptedObjects>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SseKmsEncryptedObjects_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ReplicaModifications_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ReplicaModifications_ = _arg<s3_test::_ReplicaModifications>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicaModifications_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SourceSelectionCriteria>(ivy_deser &inp, s3_test::_SourceSelectionCriteria &res){
    inp.open_struct();
    inp.open_field("_SseKmsEncryptedObjects_");
    __deser(inp,res._SseKmsEncryptedObjects_);
    inp.close_field();
    inp.open_field("_ReplicaModifications_");
    __deser(inp,res._ReplicaModifications_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_SseKmsEncryptedObjects _arg<s3_test::_SseKmsEncryptedObjects>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SseKmsEncryptedObjects res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SseKmsEncryptedObjects>(ivy_deser &inp, s3_test::_SseKmsEncryptedObjects &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_StorageClassAnalysis _arg<s3_test::_StorageClassAnalysis>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_StorageClassAnalysis res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DataExport_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DataExport_ = _arg<s3_test::_StorageClassAnalysisDataExport>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DataExport_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_StorageClassAnalysis>(ivy_deser &inp, s3_test::_StorageClassAnalysis &res){
    inp.open_struct();
    inp.open_field("_DataExport_");
    __deser(inp,res._DataExport_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_StorageClassAnalysisDataExport _arg<s3_test::_StorageClassAnalysisDataExport>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_StorageClassAnalysisDataExport res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_OutputSchemaVersion_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._OutputSchemaVersion_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputSchemaVersion_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Destination_ = _arg<s3_test::_AnalyticsExportDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_StorageClassAnalysisDataExport>(ivy_deser &inp, s3_test::_StorageClassAnalysisDataExport &res){
    inp.open_struct();
    inp.open_field("_OutputSchemaVersion_");
    __deser(inp,res._OutputSchemaVersion_);
    inp.close_field();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Tag _arg<s3_test::_Tag>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tag res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tag>(ivy_deser &inp, s3_test::_Tag &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Tagging _arg<s3_test::_Tagging>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tagging res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_TagSet_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._TagSet_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TagSet_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tagging>(ivy_deser &inp, s3_test::_Tagging &res){
    inp.open_struct();
    inp.open_field("_TagSet_");
    __deser(inp,res._TagSet_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_TargetGrant _arg<s3_test::_TargetGrant>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_TargetGrant res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grantee_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grantee_ = _arg<s3_test::_Grantee>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grantee_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Permission_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Permission_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Permission_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_TargetGrant>(ivy_deser &inp, s3_test::_TargetGrant &res){
    inp.open_struct();
    inp.open_field("_Grantee_");
    __deser(inp,res._Grantee_);
    inp.close_field();
    inp.open_field("_Permission_");
    __deser(inp,res._Permission_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Tiering _arg<s3_test::_Tiering>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tiering res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_AccessTier_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._AccessTier_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessTier_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tiering>(ivy_deser &inp, s3_test::_Tiering &res){
    inp.open_struct();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_AccessTier_");
    __deser(inp,res._AccessTier_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_TopicConfiguration _arg<s3_test::_TopicConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_TopicConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_TopicArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._TopicArn_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TopicArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_TopicConfiguration>(ivy_deser &inp, s3_test::_TopicConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_TopicArn_");
    __deser(inp,res._TopicArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
s3_test::_Transition _arg<s3_test::_Transition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Transition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Date_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Date_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Date_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<__strlit>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Transition>(ivy_deser &inp, s3_test::_Transition &res){
    inp.open_struct();
    inp.open_field("_Date_");
    __deser(inp,res._Date_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}


class stdin_reader: public reader {
    std::string buf;
    std::string eof_flag;

public:
    bool eof(){
      return eof_flag.size();
    }
    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        if (chars == 0) {  // EOF
            if (buf.size())
                process(buf);
            eof_flag = "eof";
        }
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        __ivy_out << line;
    }
};

class cmd_reader: public stdin_reader {
    int lineno;
public:
    s3_test_repl &ivy;    

    cmd_reader(s3_test_repl &_ivy) : ivy(_ivy) {
        lineno = 1;
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);
            ivy.__lock();

                if (action == "get") {
                    check_arity(args,2,action);
                    ivy.ext__get(_arg<__strlit>(args,0,0),_arg<__strlit>(args,1,0));
                }
                else
    
                if (action == "put") {
                    check_arity(args,3,action);
                    ivy.ext__put(_arg<__strlit>(args,0,0),_arg<__strlit>(args,1,0),_arg<s3_test::blob>(args,2,0));
                }
                else
    
            {
                std::cerr << "undefined action: " << action << std::endl;
            }
            ivy.__unlock();
        }
        catch (syntax_error& err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": " << err.txt << " bad value" << std::endl;
        }
        catch (bad_arity &err) {
            ivy.__unlock();
            std::cerr << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
        lineno++;
    }
};



int main(int argc, char **argv){
        int test_iters = 100;
        int runs = 1;

    int seed = 1;
    int sleep_ms = 10;
    int final_ms = 0; 
    
    std::vector<char *> pargs; // positional args
    pargs.push_back(argv[0]);
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        size_t p = arg.find('=');
        if (p == std::string::npos)
            pargs.push_back(argv[i]);
        else {
            std::string param = arg.substr(0,p);
            std::string value = arg.substr(p+1);

            if (param == "out") {
                __ivy_out.open(value.c_str());
                if (!__ivy_out) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else if (param == "iters") {
                test_iters = atoi(value.c_str());
            }
            else if (param == "runs") {
                runs = atoi(value.c_str());
            }
            else if (param == "seed") {
                seed = atoi(value.c_str());
            }
            else if (param == "delay") {
                sleep_ms = atoi(value.c_str());
            }
            else if (param == "wait") {
                final_ms = atoi(value.c_str());
            }
            else if (param == "modelfile") {
                __ivy_modelfile.open(value.c_str());
                if (!__ivy_modelfile) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else {
                std::cerr << "unknown option: " << param << std::endl;
                return 1;
            }
        }
    }
    srand(seed);
    if (!__ivy_out.is_open())
        __ivy_out.basic_ios<char>::rdbuf(std::cout.rdbuf());
    argc = pargs.size();
    argv = &pargs[0];
    if (argc == 2){
        argc--;
        int fd = _open(argv[argc],0);
        if (fd < 0){
            std::cerr << "cannot open to read: " << argv[argc] << "\n";
            __ivy_exit(1);
        }
        _dup2(fd, 0);
    }
    if (argc != 1){
        std::cerr << "usage: s3_test \n";
        __ivy_exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(0);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}

#ifdef _WIN32
    // Boilerplate from windows docs

    {
        WORD wVersionRequested;
        WSADATA wsaData;
        int err;

    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
        wVersionRequested = MAKEWORD(2, 2);

        err = WSAStartup(wVersionRequested, &wsaData);
        if (err != 0) {
            /* Tell the user that we could not find a usable */
            /* Winsock DLL.                                  */
            printf("WSAStartup failed with error: %d\n", err);
            return 1;
        }

    /* Confirm that the WinSock DLL supports 2.2.*/
    /* Note that if the DLL supports versions greater    */
    /* than 2.2 in addition to 2.2, it will still return */
    /* 2.2 in wVersion since that is the version we      */
    /* requested.                                        */

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            /* Tell the user that we could not find a usable */
            /* WinSock DLL.                                  */
            printf("Could not find a usable version of Winsock.dll\n");
            WSACleanup();
            return 1;
        }
    }
#endif
    s3_test_repl ivy;
    for(unsigned i = 0; i < argc; i++) {ivy.__argv.push_back(argv[i]);}
    ivy.__init();


    ivy.__unlock();

    cmd_reader *cr = new cmd_reader(ivy);

    // The main thread runs the console reader

    while (!cr->eof())
        cr->read();
    return 0;

    return 0;
}
