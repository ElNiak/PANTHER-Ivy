#lang ivy1.7

type data_t
type txid_t


export action put(txid:txid_t, data:data_t)
export action end_put(txid:txid_t, ok:bool)
export action get(txid:txid_t)
export action end_get(txid:txid_t, ok:bool, data:data_t)

relation hb(T:txid_t, U:txid_t)
relation pending(T:txid_t)
relation completed(T:txid_t)
relation failed(T:txid_t)
relation used(T:txid_t,U:txid_t)
relation is_put(T:txid_t)
function value(T:txid_t) : data_t


after init {
    hb(T:txid_t, U:txid_t) := false;
    pending(T:txid_t) := false;
    completed(T:txid_t) := false;
    used(T:txid_t,U:txid_t) := false;
}

before put {
    require ~pending(txid) & ~completed(txid) & ~failed(txid);
}

after put {
    # record the transaction
    pending(txid) := true;
    is_put(txid) := true;
    value(txid) := data;
    # add a happens-before arc from all completed transactions
    hb(T,txid) := completed(T);
}

before end_put {
    require pending(txid);
    require used(txid,U) -> ok;
}

after end_put {
    # record terminatino and completion
    pending(txid) := false;
    completed(txid) := ok;
    failed(txid) := ~ok;
}

after get {
    # record the transaction
    pending(txid) := true;
    is_put(txid) := false;
    # add a happens-before arc from all completed transactions
    hb(T,txid) := completed(T);
}

after end_get {
    # record completion
    pending(txid) := false;
    completed(txid) := ok;
    failed(txid) := ~ok;
    if ok {
        # A used transaction is a pending or completed transaction that
        # wrote the value that we read. There should be exactly one, since
        # no two puts write the same value.
        used(T,txid) := (pending(T) | completed(T)) & value(T) = data;
        # Require every get has a corresponding put
        assert exists T. used(T,txid);
        # After we add a used arc, we need to update the rules
        call update_hb
    }
}


relation old_hb(T:txid_t,U:txid_t)

action update_hb_step returns(changed:bool) = {
    old_hb(T,U) := hb(T,U);
    # Transitivity rule
    hb(T,U) := hb(T,U) | exists V. hb(T,V) & hb(V,U);
    # Use/def rule #1
    hb(R,Z) := hb(R,Z) | exists W. hb(W,Z) & used(W,R) & is_put(Z);
    # Use/def rule #2
    hb(Z,W) := hb(Z,W) | exists R. hb(Z,R) & used(W,R) & is_put(Z);
    changed := ~forall T,U. (hb(T,U) <-> old_hb(T,U));
}

action update_hb = {
    # Update the rules util fixed point
    var changed := true;
    while changed {
        changed := update_hb_step;
    };
    assert ~hb(T,T);
}

interpret data_t -> int
interpret txid_t -> bv[2]
