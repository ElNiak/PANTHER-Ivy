#include "s3_test.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <winsock2.h>
#include <WS2tcpip.h>
#include <io.h>
#define isatty _isatty
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <unistd.h>
#define _open open
#define _dup2 dup2
#endif
#include <string.h>
#include <stdio.h>
#include <string>
#if __cplusplus < 201103L
#else
#include <cstdint>
#endif
typedef s3_test ivy_class;
std::ofstream __ivy_out;
std::ofstream __ivy_modelfile;
void __ivy_exit(int code){exit(code);}

class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
    virtual void bind() {}
    virtual bool running() {return fdes() >= 0;}
    virtual ~reader() {}
};

class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
    virtual ~timer() {}
};

#ifdef _WIN32
DWORD WINAPI ReaderThreadFunction( LPVOID lpParam ) 
{
    reader *cr = (reader *) lpParam;
    cr->bind();
    while (true)
        cr->read();
    return 0;
} 

DWORD WINAPI TimerThreadFunction( LPVOID lpParam ) 
{
    timer *cr = (timer *) lpParam;
    while (true) {
        int ms = cr->ms_delay();
        Sleep(ms);
        cr->timeout(ms);
    }
    return 0;
} 
#else
void * _thread_reader(void *rdr_void) {
    reader *rdr = (reader *) rdr_void;
    rdr->bind();
    while(rdr->running()) {
        rdr->read();
    }
    delete rdr;
    return 0; // just to stop warning
}

void * _thread_timer( void *tmr_void ) 
{
    timer *tmr = (timer *) tmr_void;
    while (true) {
        int ms = tmr->ms_delay();
        struct timespec ts;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = (ms % 1000) * 1000000;
        nanosleep(&ts,NULL);
        tmr->timeout(ms);
    }
    return 0;
} 
#endif 

std::vector<reader *> threads;
std::vector<reader *> readers;
std::vector<timer *> timers;
bool initializing = false;

void s3_test::install_reader(reader *r) {
    readers.push_back(r);
    if (!::initializing)
        r->bind();
}

void s3_test::install_thread(reader *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ReaderThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(h);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_reader, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      

void s3_test::install_timer(timer *r) {
    timers.push_back(r);
}

#ifdef _WIN32
    void s3_test::__lock() { WaitForSingleObject(mutex,INFINITE); }
    void s3_test::__unlock() { ReleaseMutex(mutex); }
#else
    void s3_test::__lock() { pthread_mutex_lock(&mutex); }
    void s3_test::__unlock() { pthread_mutex_unlock(&mutex); }
#endif
struct thunk___GetObject__response_GetObjectOutput{
    s3_test *__ivy;
    thunk___GetObject__response_GetObjectOutput(s3_test *__ivy): __ivy(__ivy){}
    void operator()(s3_test::_GetObjectOutput val) const {
        __ivy->_GetObject__response_GetObjectOutput(val);
    }
};
struct thunk___PutObject__response_PutObjectOutput{
    s3_test *__ivy;
    thunk___PutObject__response_PutObjectOutput(s3_test *__ivy): __ivy(__ivy){}
    void operator()(s3_test::_PutObjectOutput val) const {
        __ivy->_PutObject__response_PutObjectOutput(val);
    }
};

#include <string>
#include <vector>
#include <sstream>
#include <cstdlib>


using namespace hash_space;

inline z3::expr forall(const std::vector<z3::expr> &exprs, z3::expr const & b) {
    Z3_app *vars = new  Z3_app [exprs.size()];
    std::copy(exprs.begin(),exprs.end(),vars);
    Z3_ast r = Z3_mk_forall_const(b.ctx(), 0, exprs.size(), vars, 0, 0, b);
    b.check_error();
    delete[] vars;
    return z3::expr(b.ctx(), r);
}

class gen : public ivy_gen {

public:
    z3::context ctx;
    z3::solver slvr;
    z3::model model;

protected:
    gen(): slvr(ctx), model(ctx,(Z3_model)0) {}

    hash_map<std::string, z3::sort> enum_sorts;
    hash_map<Z3_sort, z3::func_decl_vector> enum_values;
    hash_map<std::string, z3::func_decl> decls_by_name;
    hash_map<Z3_symbol,int> enum_to_int;
    std::vector<Z3_symbol> sort_names;
    std::vector<Z3_sort> sorts;
    std::vector<Z3_symbol> decl_names;
    std::vector<Z3_func_decl> decls;
    std::vector<z3::expr> alits;


public:
    virtual bool generate(s3_test& obj)=0;
    virtual void execute(s3_test& obj)=0;
    virtual ~gen(){}

    z3::expr mk_apply_expr(const char *decl_name, unsigned num_args, const int *args){
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        return decl(arity,&expr_args[0]);
    }

    int eval(const z3::expr &apply_expr) {
        try {
            z3::expr foo = model.eval(apply_expr,true);
            // std::cout << apply_expr << " = " << foo << std::endl;
            if (foo.is_int()) {
                assert(foo.is_numeral());
                int v;
                if (Z3_get_numeral_int(ctx,foo,&v) != Z3_TRUE) {
                    std::cerr << "integer value from Z3 too large for machine int: " << foo << std::endl;
                    assert(false);
                }
                return v;
            }
            if (foo.is_bv()) {
                assert(foo.is_numeral());
                unsigned v;
                if (Z3_get_numeral_uint(ctx,foo,&v) != Z3_TRUE) {
                    std::cerr << "bit vector value from Z3 too large for machine int: " << foo << std::endl;
                    assert(false);
                }
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    __strlit eval_string(const z3::expr &apply_expr) {
        try {
            z3::expr foo = model.eval(apply_expr,true);
            assert(Z3_is_string(ctx,foo));
            return Z3_get_string(ctx,foo);
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    int eval_apply(const char *decl_name, unsigned num_args, const int *args) {
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        //        std::cout << "apply_expr: " << apply_expr << std::endl;
        try {
            z3::expr foo = model.eval(apply_expr,true);
            if (foo.is_bv() || foo.is_int()) {
                assert(foo.is_numeral());
                unsigned v;
                if (Z3_get_numeral_uint(ctx,foo,&v) != Z3_TRUE)
                    assert(false && "bit vector value too large for machine int");
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cerr << e << std::endl;
            throw e;
        }
    }

    int eval_apply(const char *decl_name) {
        return eval_apply(decl_name,0,(int *)0);
    }

    int eval_apply(const char *decl_name, int arg0) {
        return eval_apply(decl_name,1,&arg0);
    }
    
    int eval_apply(const char *decl_name, int arg0, int arg1) {
        int args[2] = {arg0,arg1};
        return eval_apply(decl_name,2,args);
    }

    int eval_apply(const char *decl_name, int arg0, int arg1, int arg2) {
        int args[3] = {arg0,arg1,arg2};
        return eval_apply(decl_name,3,args);
    }

    int eval_apply(const char *decl_name, int arg0, int arg1, int arg2, int arg3) {
        int args[4] = {arg0,arg1,arg2,arg3};
        return eval_apply(decl_name,4,args);
    }

    z3::expr apply(const char *decl_name, std::vector<z3::expr> &expr_args) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        unsigned arity = decl.arity();
        assert(arity == expr_args.size());
        return decl(arity,&expr_args[0]);
    }

    z3::expr apply(const char *decl_name) {
        std::vector<z3::expr> a;
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2, z3::expr arg3) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        a.push_back(arg3);
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2, z3::expr arg3, z3::expr arg4) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        a.push_back(arg3);
        a.push_back(arg4);
        return apply(decl_name,a);
    }

    z3::expr int_to_z3(const z3::sort &range, int64_t value) {
        if (range.is_bool())
            return ctx.bool_val((bool)value);
        if (range.is_bv())
            return ctx.bv_val((int)value,range.bv_size());
        if (range.is_int())
            return ctx.int_val((int)value);
        return enum_values.find(range)->second[(int)value]();
    }

    z3::expr int_to_z3(const z3::sort &range, const std::string& value) {
        return ctx.string_val(value);
    }

    unsigned sort_card(const z3::sort &range) {
        if (range.is_bool())
            return 2;
        if (range.is_bv())
            return 1 << range.bv_size();
        if (range.is_int())
            return 1;  // bogus -- we need a good way to randomize ints
        return enum_values.find(range)->second.size();
    }

    int set(const char *decl_name, unsigned num_args, const int *args, int value) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        z3::expr apply_expr = decl(arity,&expr_args[0]);
        z3::sort range = decl.range();
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        //        std::cout << "pred: " << pred << std::endl;
        slvr.add(pred);
        return 0;
    }

    int set(const char *decl_name, int value) {
        return set(decl_name,0,(int *)0,value);
    }

    int set(const char *decl_name, int arg0, int value) {
        return set(decl_name,1,&arg0,value);
    }
    
    int set(const char *decl_name, int arg0, int arg1, int value) {
        int args[2] = {arg0,arg1};
        return set(decl_name,2,args,value);
    }

    int set(const char *decl_name, int arg0, int arg1, int arg2, int value) {
        int args[3] = {arg0,arg1,arg2};
        return set(decl_name,3,args,value);
    }

    void add_alit(const z3::expr &pred){
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "pred: " << pred << std::endl;
        std::ostringstream ss;
        ss << "alit:" << alits.size();
        z3::expr alit = ctx.bool_const(ss.str().c_str());
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "alit: " << alit << std::endl;
        alits.push_back(alit);
        slvr.add(!alit || pred);
    }

    void randomize(const z3::expr &apply_expr) {
        z3::sort range = apply_expr.get_sort();
//        std::cout << apply_expr << " : " << range << std::endl;
        unsigned card = sort_card(range);
        int value = rand() % card;
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        add_alit(pred);
    }

    void randomize(const char *decl_name, unsigned num_args, const int *args) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        z3::sort range = decl.range();
        unsigned card = sort_card(range);
        int value = rand() % card;
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        add_alit(pred);
    }

    void randomize(const char *decl_name) {
        randomize(decl_name,0,(int *)0);
    }

    void randomize(const char *decl_name, int arg0) {
        randomize(decl_name,1,&arg0);
    }
    
    void randomize(const char *decl_name, int arg0, int arg1) {
        int args[2] = {arg0,arg1};
        randomize(decl_name,2,args);
    }

    void randomize(const char *decl_name, int arg0, int arg1, int arg2) {
        int args[3] = {arg0,arg1,arg2};
        randomize(decl_name,3,args);
    }

    void push(){
        slvr.push();
    }

    void pop(){
        slvr.pop();
    }

    z3::sort sort(const char *name) {
        if (std::string("bool") == name)
            return ctx.bool_sort();
        return enum_sorts.find(name)->second;
    }

    void mk_enum(const char *sort_name, unsigned num_values, char const * const * value_names) {
        z3::func_decl_vector cs(ctx), ts(ctx);
        z3::sort sort = ctx.enumeration_sort(sort_name, num_values, value_names, cs, ts);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
        enum_values.insert(std::pair<Z3_sort, z3::func_decl_vector>(sort,cs));
        sort_names.push_back(Z3_mk_string_symbol(ctx,sort_name));
        sorts.push_back(sort);
        for(unsigned i = 0; i < num_values; i++){
            Z3_symbol sym = Z3_mk_string_symbol(ctx,value_names[i]);
            decl_names.push_back(sym);
            decls.push_back(cs[i]);
            enum_to_int[sym] = i;
        }
    }

    void mk_bv(const char *sort_name, unsigned width) {
        z3::sort sort = ctx.bv_sort(width);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_int(const char *sort_name) {
        z3::sort sort = ctx.int_sort();
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_string(const char *sort_name) {
        z3::sort sort = ctx.string_sort();
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_sort(const char *sort_name) {
        Z3_symbol symb = Z3_mk_string_symbol(ctx,sort_name);
        z3::sort sort(ctx,Z3_mk_uninterpreted_sort(ctx, symb));
//        z3::sort sort = ctx.uninterpreted_sort(sort_name);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
        sort_names.push_back(symb);
        sorts.push_back(sort);
    }

    void mk_decl(const char *decl_name, unsigned arity, const char **domain_names, const char *range_name) {
        std::vector<z3::sort> domain;
        for (unsigned i = 0; i < arity; i++)
            domain.push_back(enum_sorts.find(domain_names[i])->second);
        std::string bool_name("Bool");
        z3::sort range = (range_name == bool_name) ? ctx.bool_sort() : enum_sorts.find(range_name)->second;   
        z3::func_decl decl = ctx.function(decl_name,arity,&domain[0],range);
        decl_names.push_back(Z3_mk_string_symbol(ctx,decl_name));
        decls.push_back(decl);
        decls_by_name.insert(std::pair<std::string, z3::func_decl>(decl_name,decl));
    }

    void mk_const(const char *const_name, const char *sort_name) {
        mk_decl(const_name,0,0,sort_name);
    }

    void add(const std::string &z3inp) {
        z3::expr fmla(ctx,Z3_parse_smtlib2_string(ctx, z3inp.c_str(), sort_names.size(), &sort_names[0], &sorts[0], decl_names.size(), &decl_names[0], &decls[0]));
        ctx.check_error();

        slvr.add(fmla);
    }

    bool solve() {
        // std::cout << alits.size();
        static bool show_model = true;
        if (__ivy_modelfile.is_open()) 
            __ivy_modelfile << "begin check:\n" << slvr << "end check:\n" << std::endl;
        while(true){
            if (__ivy_modelfile.is_open()) {
                __ivy_modelfile << "(check-sat"; 
                for (unsigned i = 0; i < alits.size(); i++)
                    __ivy_modelfile << " " << alits[i];
                __ivy_modelfile << ")" << std::endl;
            }
            z3::check_result res = slvr.check(alits.size(),&alits[0]);
            if (res != z3::unsat)
                break;
            z3::expr_vector core = slvr.unsat_core();
            if (core.size() == 0){
//                if (__ivy_modelfile.is_open()) 
//                    __ivy_modelfile << "begin unsat:\n" << slvr << "end unsat:\n" << std::endl;
                return false;
            }
            if (__ivy_modelfile.is_open()) 
                for (unsigned i = 0; i < core.size(); i++)
                    __ivy_modelfile << "core: " << core[i] << std::endl;
            unsigned idx = rand() % core.size();
            z3::expr to_delete = core[idx];
            if (__ivy_modelfile.is_open()) 
                __ivy_modelfile << "to delete: " << to_delete << std::endl;
            for (unsigned i = 0; i < alits.size(); i++)
                if (z3::eq(alits[i],to_delete)) {
                    alits[i] = alits.back();
                    alits.pop_back();
                    break;
                }
        }
        model = slvr.get_model();
        alits.clear();

        if(__ivy_modelfile.is_open()){
            __ivy_modelfile << "begin sat:\n" << slvr << "end sat:\n" << std::endl;
            __ivy_modelfile << model;
            __ivy_modelfile.flush();
        }

        return true;
    }

    int choose(int rng, const char *name){
        if (decls_by_name.find(name) == decls_by_name.end())
            return 0;
        return eval_apply(name);
    }
};

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#ifndef __fallthrough
#define __fallthrough
#endif

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}




struct ivy_value {
    int pos;
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct deser_err {
};

struct ivy_ser {
    virtual void  set(long long) = 0;
    virtual void  set(bool) = 0;
    virtual void  setn(long long inp, int len) = 0;
    virtual void  set(const std::string &) = 0;
    virtual void  open_list(int len) = 0;
    virtual void  close_list() = 0;
    virtual void  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual void  open_tag(int, const std::string &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual ~ivy_ser(){}
};
struct ivy_binary_ser : public ivy_ser {
    std::vector<char> res;
    void setn(long long inp, int len) {
        for (int i = len-1; i >= 0 ; i--)
            res.push_back((inp>>(8*i))&0xff);
    }
    void set(long long inp) {
        setn(inp,sizeof(long long));
    }
    void set(bool inp) {
        set((long long)inp);
    }
    void set(const std::string &inp) {
        for (unsigned i = 0; i < inp.size(); i++)
            res.push_back(inp[i]);
        res.push_back(0);
    }
    void open_list(int len) {
        set((long long)len);
    }
    void close_list() {}
    void open_list_elem() {}
    void close_list_elem() {}
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    virtual void  open_tag(int tag, const std::string &) {
        set((long long)tag);
    }
    virtual void  close_tag() {}
};

struct ivy_deser {
    virtual void  get(long long&) = 0;
    virtual void  get(std::string &) = 0;
    virtual void  getn(long long &res, int bytes) = 0;
    virtual void  open_list() = 0;
    virtual void  close_list() = 0;
    virtual bool  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual int   open_tag(const std::vector<std::string> &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual void  end() = 0;
    virtual ~ivy_deser(){}
};

struct ivy_binary_deser : public ivy_deser {
    std::vector<char> inp;
    int pos;
    std::vector<int> lenstack;
    ivy_binary_deser(const std::vector<char> &inp) : inp(inp),pos(0) {}
    virtual bool more(unsigned bytes) {return inp.size() >= pos + bytes;}
    virtual bool can_end() {return pos == inp.size();}
    void get(long long &res) {
       getn(res,8);
    }
    void getn(long long &res, int bytes) {
        if (!more(bytes))
            throw deser_err();
        res = 0;
        for (int i = 0; i < bytes; i++)
            res = (res << 8) | (((long long)inp[pos++]) & 0xff);
    }
    void get(std::string &res) {
        while (more(1) && inp[pos]) {
//            if (inp[pos] == '"')
//                throw deser_err();
            res.push_back(inp[pos++]);
        }
        if(!(more(1) && inp[pos] == 0))
            throw deser_err();
        pos++;
    }
    void open_list() {
        long long len;
        get(len);
        lenstack.push_back(len);
    }
    void close_list() {
        lenstack.pop_back();
    }
    bool open_list_elem() {
        return lenstack.back();
    }
    void close_list_elem() {
        lenstack.back()--;
    }
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    int open_tag(const std::vector<std::string> &tags) {
        long long res;
        get(res);
        if (res >= tags.size())
            throw deser_err();
        return res;
    }
    void end() {
        if (!can_end())
            throw deser_err();
    }
};
struct ivy_socket_deser : public ivy_binary_deser {
      int sock;
    public:
      ivy_socket_deser(int sock, const std::vector<char> &inp)
          : ivy_binary_deser(inp), sock(sock) {}
    virtual bool more(unsigned bytes) {
        while (inp.size() < pos + bytes) {
            int oldsize = inp.size();
            int get = pos + bytes - oldsize;
            get = (get < 1024) ? 1024 : get;
            inp.resize(oldsize + get);
            int newbytes;
	    if ((newbytes = read(sock,&inp[oldsize],get)) < 0)
		 { std::cerr << "recvfrom failed\n"; exit(1); }
            inp.resize(oldsize + newbytes);
            if (newbytes == 0)
                 return false;
        }
        return true;
    }
    virtual bool can_end() {return true;}
};

struct out_of_bounds {
    std::string txt;
    int pos;
    out_of_bounds(int _idx, int pos = 0) : pos(pos){
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s, int pos = 0) : txt(s), pos(pos) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <class T> T __lit(const char *);

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom == "true";
}

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
    // int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
long long _arg<long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    long long res;
    s  >> res;
//    long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned long long _arg<unsigned long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned long long res;
    s  >> res;
//    unsigned long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
unsigned _arg<unsigned>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    std::istringstream s(args[idx].atom.c_str());
    s.unsetf(std::ios::dec);
    s.unsetf(std::ios::hex);
    s.unsetf(std::ios::oct);
    unsigned res;
    s  >> res;
//    unsigned res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}


std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom;
}

template <class T> void __ser(ivy_ser &res, const T &inp);

template <>
void __ser<int>(ivy_ser &res, const int &inp) {
    res.set((long long)inp);
}

template <>
void __ser<long long>(ivy_ser &res, const long long &inp) {
    res.set(inp);
}

template <>
void __ser<unsigned long long>(ivy_ser &res, const unsigned long long &inp) {
    res.set((long long)inp);
}

template <>
void __ser<unsigned>(ivy_ser &res, const unsigned &inp) {
    res.set((long long)inp);
}

template <>
void __ser<bool>(ivy_ser &res, const bool &inp) {
    res.set(inp);
}

template <>
void __ser<std::vector<bool>::const_reference>(ivy_ser &res, const std::vector<bool>::const_reference &inp) {
    bool thing = inp;
    res.set(thing);
}

template <>
void __ser<__strlit>(ivy_ser &res, const __strlit &inp) {
    res.set(inp);
}

template <class T> void __deser(ivy_deser &inp, T &res);

template <>
void __deser<int>(ivy_deser &inp, int &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<long long>(ivy_deser &inp, long long &res) {
    inp.get(res);
}

template <>
void __deser<unsigned long long>(ivy_deser &inp, unsigned long long &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<unsigned>(ivy_deser &inp, unsigned &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<__strlit>(ivy_deser &inp, __strlit &res) {
    inp.get(res);
}

template <>
void __deser<bool>(ivy_deser &inp, bool &res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

void __deser(ivy_deser &inp, std::vector<bool>::reference res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

class gen;


template <class T> void __from_solver( gen &g, const  z3::expr &v, T &res);

template <>
void __from_solver<int>( gen &g, const  z3::expr &v, int &res) {
    res = g.eval(v);
}

template <>
void __from_solver<long long>( gen &g, const  z3::expr &v, long long &res) {
    res = g.eval(v);
}

template <>
void __from_solver<unsigned long long>( gen &g, const  z3::expr &v, unsigned long long &res) {
    res = g.eval(v);
}

template <>
void __from_solver<unsigned>( gen &g, const  z3::expr &v, unsigned &res) {
    res = g.eval(v);
}

template <>
void __from_solver<bool>( gen &g, const  z3::expr &v, bool &res) {
    res = g.eval(v);
}

template <>
void __from_solver<__strlit>( gen &g, const  z3::expr &v, __strlit &res) {
    res = g.eval_string(v);
}

template <class T>
class to_solver_class {
};

template <class T> z3::expr __to_solver( gen &g, const  z3::expr &v, T &val) {
    return to_solver_class<T>()(g,v,val);
}


template <>
z3::expr __to_solver<int>( gen &g, const  z3::expr &v, int &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<long long>( gen &g, const  z3::expr &v, long long &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<unsigned long long>( gen &g, const  z3::expr &v, unsigned long long &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<unsigned>( gen &g, const  z3::expr &v, unsigned &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<bool>( gen &g, const  z3::expr &v, bool &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<__strlit>( gen &g, const  z3::expr &v, __strlit &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    return v == g.int_to_z3(v.get_sort(),val);
}

template <class T>
class __random_string_class {
public:
    std::string operator()() {
        std::string res;
        res.push_back('a' + (rand() % 26)); // no empty strings for now
        while (rand() %2)
            res.push_back('a' + (rand() % 26));
        return res;
    }
};

template <class T> std::string __random_string(){
    return __random_string_class<T>()();
}

template <class T> void __randomize( gen &g, const  z3::expr &v);

template <>
void __randomize<int>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
void __randomize<long long>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
void __randomize<unsigned long long>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
void __randomize<unsigned>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
void __randomize<bool>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
        void __randomize<__strlit>( gen &g, const  z3::expr &apply_expr) {
    z3::sort range = apply_expr.get_sort();
    __strlit value = (rand() % 2) ? "a" : "b";
    z3::expr val_expr = g.int_to_z3(range,value);
    z3::expr pred = apply_expr == val_expr;
    g.add_alit(pred);
}

template<typename D, typename R>
class z3_thunk : public thunk<D,R> {
    public:
       virtual z3::expr to_z3(gen &g, const  z3::expr &v) = 0;
};

std::ostream &operator <<(std::ostream &s, const s3_test::_AbortIncompleteMultipartUpload &t);
template <>
s3_test::_AbortIncompleteMultipartUpload _arg<s3_test::_AbortIncompleteMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AbortIncompleteMultipartUpload>(ivy_ser &res, const s3_test::_AbortIncompleteMultipartUpload&);
template <>
void  __deser<s3_test::_AbortIncompleteMultipartUpload>(ivy_deser &inp, s3_test::_AbortIncompleteMultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlPolicy &t);
template <>
s3_test::_AccessControlPolicy _arg<s3_test::_AccessControlPolicy>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AccessControlPolicy>(ivy_ser &res, const s3_test::_AccessControlPolicy&);
template <>
void  __deser<s3_test::_AccessControlPolicy>(ivy_deser &inp, s3_test::_AccessControlPolicy &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlTranslation &t);
template <>
s3_test::_AccessControlTranslation _arg<s3_test::_AccessControlTranslation>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AccessControlTranslation>(ivy_ser &res, const s3_test::_AccessControlTranslation&);
template <>
void  __deser<s3_test::_AccessControlTranslation>(ivy_deser &inp, s3_test::_AccessControlTranslation &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsAndOperator &t);
template <>
s3_test::_AnalyticsAndOperator _arg<s3_test::_AnalyticsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsAndOperator>(ivy_ser &res, const s3_test::_AnalyticsAndOperator&);
template <>
void  __deser<s3_test::_AnalyticsAndOperator>(ivy_deser &inp, s3_test::_AnalyticsAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsConfiguration &t);
template <>
s3_test::_AnalyticsConfiguration _arg<s3_test::_AnalyticsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsConfiguration>(ivy_ser &res, const s3_test::_AnalyticsConfiguration&);
template <>
void  __deser<s3_test::_AnalyticsConfiguration>(ivy_deser &inp, s3_test::_AnalyticsConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsExportDestination &t);
template <>
s3_test::_AnalyticsExportDestination _arg<s3_test::_AnalyticsExportDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsExportDestination>(ivy_ser &res, const s3_test::_AnalyticsExportDestination&);
template <>
void  __deser<s3_test::_AnalyticsExportDestination>(ivy_deser &inp, s3_test::_AnalyticsExportDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsFilter &t);
template <>
s3_test::_AnalyticsFilter _arg<s3_test::_AnalyticsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsFilter>(ivy_ser &res, const s3_test::_AnalyticsFilter&);
template <>
void  __deser<s3_test::_AnalyticsFilter>(ivy_deser &inp, s3_test::_AnalyticsFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsS3BucketDestination &t);
template <>
s3_test::_AnalyticsS3BucketDestination _arg<s3_test::_AnalyticsS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_AnalyticsS3BucketDestination>(ivy_ser &res, const s3_test::_AnalyticsS3BucketDestination&);
template <>
void  __deser<s3_test::_AnalyticsS3BucketDestination>(ivy_deser &inp, s3_test::_AnalyticsS3BucketDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Bucket &t);
template <>
s3_test::_Bucket _arg<s3_test::_Bucket>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Bucket>(ivy_ser &res, const s3_test::_Bucket&);
template <>
void  __deser<s3_test::_Bucket>(ivy_deser &inp, s3_test::_Bucket &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_BucketLifecycleConfiguration &t);
template <>
s3_test::_BucketLifecycleConfiguration _arg<s3_test::_BucketLifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_BucketLifecycleConfiguration>(ivy_ser &res, const s3_test::_BucketLifecycleConfiguration&);
template <>
void  __deser<s3_test::_BucketLifecycleConfiguration>(ivy_deser &inp, s3_test::_BucketLifecycleConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CORSRule &t);
template <>
s3_test::_CORSRule _arg<s3_test::_CORSRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CORSRule>(ivy_ser &res, const s3_test::_CORSRule&);
template <>
void  __deser<s3_test::_CORSRule>(ivy_deser &inp, s3_test::_CORSRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVInput &t);
template <>
s3_test::_CSVInput _arg<s3_test::_CSVInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CSVInput>(ivy_ser &res, const s3_test::_CSVInput&);
template <>
void  __deser<s3_test::_CSVInput>(ivy_deser &inp, s3_test::_CSVInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVOutput &t);
template <>
s3_test::_CSVOutput _arg<s3_test::_CSVOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CSVOutput>(ivy_ser &res, const s3_test::_CSVOutput&);
template <>
void  __deser<s3_test::_CSVOutput>(ivy_deser &inp, s3_test::_CSVOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CommonPrefix &t);
template <>
s3_test::_CommonPrefix _arg<s3_test::_CommonPrefix>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CommonPrefix>(ivy_ser &res, const s3_test::_CommonPrefix&);
template <>
void  __deser<s3_test::_CommonPrefix>(ivy_deser &inp, s3_test::_CommonPrefix &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedMultipartUpload &t);
template <>
s3_test::_CompletedMultipartUpload _arg<s3_test::_CompletedMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CompletedMultipartUpload>(ivy_ser &res, const s3_test::_CompletedMultipartUpload&);
template <>
void  __deser<s3_test::_CompletedMultipartUpload>(ivy_deser &inp, s3_test::_CompletedMultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedPart &t);
template <>
s3_test::_CompletedPart _arg<s3_test::_CompletedPart>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CompletedPart>(ivy_ser &res, const s3_test::_CompletedPart&);
template <>
void  __deser<s3_test::_CompletedPart>(ivy_deser &inp, s3_test::_CompletedPart &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Condition &t);
template <>
s3_test::_Condition _arg<s3_test::_Condition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Condition>(ivy_ser &res, const s3_test::_Condition&);
template <>
void  __deser<s3_test::_Condition>(ivy_deser &inp, s3_test::_Condition &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_CreateBucketConfiguration &t);
template <>
s3_test::_CreateBucketConfiguration _arg<s3_test::_CreateBucketConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_CreateBucketConfiguration>(ivy_ser &res, const s3_test::_CreateBucketConfiguration&);
template <>
void  __deser<s3_test::_CreateBucketConfiguration>(ivy_deser &inp, s3_test::_CreateBucketConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DefaultRetention &t);
template <>
s3_test::_DefaultRetention _arg<s3_test::_DefaultRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DefaultRetention>(ivy_ser &res, const s3_test::_DefaultRetention&);
template <>
void  __deser<s3_test::_DefaultRetention>(ivy_deser &inp, s3_test::_DefaultRetention &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerEntry &t);
template <>
s3_test::_DeleteMarkerEntry _arg<s3_test::_DeleteMarkerEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeleteMarkerEntry>(ivy_ser &res, const s3_test::_DeleteMarkerEntry&);
template <>
void  __deser<s3_test::_DeleteMarkerEntry>(ivy_deser &inp, s3_test::_DeleteMarkerEntry &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerReplication &t);
template <>
s3_test::_DeleteMarkerReplication _arg<s3_test::_DeleteMarkerReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeleteMarkerReplication>(ivy_ser &res, const s3_test::_DeleteMarkerReplication&);
template <>
void  __deser<s3_test::_DeleteMarkerReplication>(ivy_deser &inp, s3_test::_DeleteMarkerReplication &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_DeletedObject &t);
template <>
s3_test::_DeletedObject _arg<s3_test::_DeletedObject>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_DeletedObject>(ivy_ser &res, const s3_test::_DeletedObject&);
template <>
void  __deser<s3_test::_DeletedObject>(ivy_deser &inp, s3_test::_DeletedObject &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Destination &t);
template <>
s3_test::_Destination _arg<s3_test::_Destination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Destination>(ivy_ser &res, const s3_test::_Destination&);
template <>
void  __deser<s3_test::_Destination>(ivy_deser &inp, s3_test::_Destination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Encryption &t);
template <>
s3_test::_Encryption _arg<s3_test::_Encryption>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Encryption>(ivy_ser &res, const s3_test::_Encryption&);
template <>
void  __deser<s3_test::_Encryption>(ivy_deser &inp, s3_test::_Encryption &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_EncryptionConfiguration &t);
template <>
s3_test::_EncryptionConfiguration _arg<s3_test::_EncryptionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_EncryptionConfiguration>(ivy_ser &res, const s3_test::_EncryptionConfiguration&);
template <>
void  __deser<s3_test::_EncryptionConfiguration>(ivy_deser &inp, s3_test::_EncryptionConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Error &t);
template <>
s3_test::_Error _arg<s3_test::_Error>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Error>(ivy_ser &res, const s3_test::_Error&);
template <>
void  __deser<s3_test::_Error>(ivy_deser &inp, s3_test::_Error &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ExistingObjectReplication &t);
template <>
s3_test::_ExistingObjectReplication _arg<s3_test::_ExistingObjectReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ExistingObjectReplication>(ivy_ser &res, const s3_test::_ExistingObjectReplication&);
template <>
void  __deser<s3_test::_ExistingObjectReplication>(ivy_deser &inp, s3_test::_ExistingObjectReplication &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_FilterRule &t);
template <>
s3_test::_FilterRule _arg<s3_test::_FilterRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_FilterRule>(ivy_ser &res, const s3_test::_FilterRule&);
template <>
void  __deser<s3_test::_FilterRule>(ivy_deser &inp, s3_test::_FilterRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectOutput &t);
template <>
s3_test::_GetObjectOutput _arg<s3_test::_GetObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GetObjectOutput>(ivy_ser &res, const s3_test::_GetObjectOutput&);
template <>
void  __deser<s3_test::_GetObjectOutput>(ivy_deser &inp, s3_test::_GetObjectOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectRequest &t);
template <>
s3_test::_GetObjectRequest _arg<s3_test::_GetObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GetObjectRequest>(ivy_ser &res, const s3_test::_GetObjectRequest&);
template <>
void  __deser<s3_test::_GetObjectRequest>(ivy_deser &inp, s3_test::_GetObjectRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_GlacierJobParameters &t);
template <>
s3_test::_GlacierJobParameters _arg<s3_test::_GlacierJobParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_GlacierJobParameters>(ivy_ser &res, const s3_test::_GlacierJobParameters&);
template <>
void  __deser<s3_test::_GlacierJobParameters>(ivy_deser &inp, s3_test::_GlacierJobParameters &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Grant &t);
template <>
s3_test::_Grant _arg<s3_test::_Grant>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Grant>(ivy_ser &res, const s3_test::_Grant&);
template <>
void  __deser<s3_test::_Grant>(ivy_deser &inp, s3_test::_Grant &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Grantee &t);
template <>
s3_test::_Grantee _arg<s3_test::_Grantee>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Grantee>(ivy_ser &res, const s3_test::_Grantee&);
template <>
void  __deser<s3_test::_Grantee>(ivy_deser &inp, s3_test::_Grantee &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Initiator &t);
template <>
s3_test::_Initiator _arg<s3_test::_Initiator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Initiator>(ivy_ser &res, const s3_test::_Initiator&);
template <>
void  __deser<s3_test::_Initiator>(ivy_deser &inp, s3_test::_Initiator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InputSerialization &t);
template <>
s3_test::_InputSerialization _arg<s3_test::_InputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InputSerialization>(ivy_ser &res, const s3_test::_InputSerialization&);
template <>
void  __deser<s3_test::_InputSerialization>(ivy_deser &inp, s3_test::_InputSerialization &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringAndOperator &t);
template <>
s3_test::_IntelligentTieringAndOperator _arg<s3_test::_IntelligentTieringAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringAndOperator>(ivy_ser &res, const s3_test::_IntelligentTieringAndOperator&);
template <>
void  __deser<s3_test::_IntelligentTieringAndOperator>(ivy_deser &inp, s3_test::_IntelligentTieringAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringConfiguration &t);
template <>
s3_test::_IntelligentTieringConfiguration _arg<s3_test::_IntelligentTieringConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringConfiguration>(ivy_ser &res, const s3_test::_IntelligentTieringConfiguration&);
template <>
void  __deser<s3_test::_IntelligentTieringConfiguration>(ivy_deser &inp, s3_test::_IntelligentTieringConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringFilter &t);
template <>
s3_test::_IntelligentTieringFilter _arg<s3_test::_IntelligentTieringFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_IntelligentTieringFilter>(ivy_ser &res, const s3_test::_IntelligentTieringFilter&);
template <>
void  __deser<s3_test::_IntelligentTieringFilter>(ivy_deser &inp, s3_test::_IntelligentTieringFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryConfiguration &t);
template <>
s3_test::_InventoryConfiguration _arg<s3_test::_InventoryConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryConfiguration>(ivy_ser &res, const s3_test::_InventoryConfiguration&);
template <>
void  __deser<s3_test::_InventoryConfiguration>(ivy_deser &inp, s3_test::_InventoryConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryDestination &t);
template <>
s3_test::_InventoryDestination _arg<s3_test::_InventoryDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryDestination>(ivy_ser &res, const s3_test::_InventoryDestination&);
template <>
void  __deser<s3_test::_InventoryDestination>(ivy_deser &inp, s3_test::_InventoryDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryEncryption &t);
template <>
s3_test::_InventoryEncryption _arg<s3_test::_InventoryEncryption>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryEncryption>(ivy_ser &res, const s3_test::_InventoryEncryption&);
template <>
void  __deser<s3_test::_InventoryEncryption>(ivy_deser &inp, s3_test::_InventoryEncryption &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryFilter &t);
template <>
s3_test::_InventoryFilter _arg<s3_test::_InventoryFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryFilter>(ivy_ser &res, const s3_test::_InventoryFilter&);
template <>
void  __deser<s3_test::_InventoryFilter>(ivy_deser &inp, s3_test::_InventoryFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryS3BucketDestination &t);
template <>
s3_test::_InventoryS3BucketDestination _arg<s3_test::_InventoryS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventoryS3BucketDestination>(ivy_ser &res, const s3_test::_InventoryS3BucketDestination&);
template <>
void  __deser<s3_test::_InventoryS3BucketDestination>(ivy_deser &inp, s3_test::_InventoryS3BucketDestination &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_InventorySchedule &t);
template <>
s3_test::_InventorySchedule _arg<s3_test::_InventorySchedule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_InventorySchedule>(ivy_ser &res, const s3_test::_InventorySchedule&);
template <>
void  __deser<s3_test::_InventorySchedule>(ivy_deser &inp, s3_test::_InventorySchedule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONInput &t);
template <>
s3_test::_JSONInput _arg<s3_test::_JSONInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_JSONInput>(ivy_ser &res, const s3_test::_JSONInput&);
template <>
void  __deser<s3_test::_JSONInput>(ivy_deser &inp, s3_test::_JSONInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONOutput &t);
template <>
s3_test::_JSONOutput _arg<s3_test::_JSONOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_JSONOutput>(ivy_ser &res, const s3_test::_JSONOutput&);
template <>
void  __deser<s3_test::_JSONOutput>(ivy_deser &inp, s3_test::_JSONOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LambdaFunctionConfiguration &t);
template <>
s3_test::_LambdaFunctionConfiguration _arg<s3_test::_LambdaFunctionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LambdaFunctionConfiguration>(ivy_ser &res, const s3_test::_LambdaFunctionConfiguration&);
template <>
void  __deser<s3_test::_LambdaFunctionConfiguration>(ivy_deser &inp, s3_test::_LambdaFunctionConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleConfiguration &t);
template <>
s3_test::_LifecycleConfiguration _arg<s3_test::_LifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleConfiguration>(ivy_ser &res, const s3_test::_LifecycleConfiguration&);
template <>
void  __deser<s3_test::_LifecycleConfiguration>(ivy_deser &inp, s3_test::_LifecycleConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleExpiration &t);
template <>
s3_test::_LifecycleExpiration _arg<s3_test::_LifecycleExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleExpiration>(ivy_ser &res, const s3_test::_LifecycleExpiration&);
template <>
void  __deser<s3_test::_LifecycleExpiration>(ivy_deser &inp, s3_test::_LifecycleExpiration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRule &t);
template <>
s3_test::_LifecycleRule _arg<s3_test::_LifecycleRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRule>(ivy_ser &res, const s3_test::_LifecycleRule&);
template <>
void  __deser<s3_test::_LifecycleRule>(ivy_deser &inp, s3_test::_LifecycleRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleAndOperator &t);
template <>
s3_test::_LifecycleRuleAndOperator _arg<s3_test::_LifecycleRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRuleAndOperator>(ivy_ser &res, const s3_test::_LifecycleRuleAndOperator&);
template <>
void  __deser<s3_test::_LifecycleRuleAndOperator>(ivy_deser &inp, s3_test::_LifecycleRuleAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleFilter &t);
template <>
s3_test::_LifecycleRuleFilter _arg<s3_test::_LifecycleRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_LifecycleRuleFilter>(ivy_ser &res, const s3_test::_LifecycleRuleFilter&);
template <>
void  __deser<s3_test::_LifecycleRuleFilter>(ivy_deser &inp, s3_test::_LifecycleRuleFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetadataEntry &t);
template <>
s3_test::_MetadataEntry _arg<s3_test::_MetadataEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetadataEntry>(ivy_ser &res, const s3_test::_MetadataEntry&);
template <>
void  __deser<s3_test::_MetadataEntry>(ivy_deser &inp, s3_test::_MetadataEntry &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Metrics &t);
template <>
s3_test::_Metrics _arg<s3_test::_Metrics>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Metrics>(ivy_ser &res, const s3_test::_Metrics&);
template <>
void  __deser<s3_test::_Metrics>(ivy_deser &inp, s3_test::_Metrics &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsAndOperator &t);
template <>
s3_test::_MetricsAndOperator _arg<s3_test::_MetricsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsAndOperator>(ivy_ser &res, const s3_test::_MetricsAndOperator&);
template <>
void  __deser<s3_test::_MetricsAndOperator>(ivy_deser &inp, s3_test::_MetricsAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsConfiguration &t);
template <>
s3_test::_MetricsConfiguration _arg<s3_test::_MetricsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsConfiguration>(ivy_ser &res, const s3_test::_MetricsConfiguration&);
template <>
void  __deser<s3_test::_MetricsConfiguration>(ivy_deser &inp, s3_test::_MetricsConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsFilter &t);
template <>
s3_test::_MetricsFilter _arg<s3_test::_MetricsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MetricsFilter>(ivy_ser &res, const s3_test::_MetricsFilter&);
template <>
void  __deser<s3_test::_MetricsFilter>(ivy_deser &inp, s3_test::_MetricsFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_MultipartUpload &t);
template <>
s3_test::_MultipartUpload _arg<s3_test::_MultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_MultipartUpload>(ivy_ser &res, const s3_test::_MultipartUpload&);
template <>
void  __deser<s3_test::_MultipartUpload>(ivy_deser &inp, s3_test::_MultipartUpload &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionExpiration &t);
template <>
s3_test::_NoncurrentVersionExpiration _arg<s3_test::_NoncurrentVersionExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NoncurrentVersionExpiration>(ivy_ser &res, const s3_test::_NoncurrentVersionExpiration&);
template <>
void  __deser<s3_test::_NoncurrentVersionExpiration>(ivy_deser &inp, s3_test::_NoncurrentVersionExpiration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionTransition &t);
template <>
s3_test::_NoncurrentVersionTransition _arg<s3_test::_NoncurrentVersionTransition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NoncurrentVersionTransition>(ivy_ser &res, const s3_test::_NoncurrentVersionTransition&);
template <>
void  __deser<s3_test::_NoncurrentVersionTransition>(ivy_deser &inp, s3_test::_NoncurrentVersionTransition &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_NotificationConfigurationFilter &t);
template <>
s3_test::_NotificationConfigurationFilter _arg<s3_test::_NotificationConfigurationFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_NotificationConfigurationFilter>(ivy_ser &res, const s3_test::_NotificationConfigurationFilter&);
template <>
void  __deser<s3_test::_NotificationConfigurationFilter>(ivy_deser &inp, s3_test::_NotificationConfigurationFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Object &t);
template <>
s3_test::_Object _arg<s3_test::_Object>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Object>(ivy_ser &res, const s3_test::_Object&);
template <>
void  __deser<s3_test::_Object>(ivy_deser &inp, s3_test::_Object &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectIdentifier &t);
template <>
s3_test::_ObjectIdentifier _arg<s3_test::_ObjectIdentifier>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectIdentifier>(ivy_ser &res, const s3_test::_ObjectIdentifier&);
template <>
void  __deser<s3_test::_ObjectIdentifier>(ivy_deser &inp, s3_test::_ObjectIdentifier &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockConfiguration &t);
template <>
s3_test::_ObjectLockConfiguration _arg<s3_test::_ObjectLockConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockConfiguration>(ivy_ser &res, const s3_test::_ObjectLockConfiguration&);
template <>
void  __deser<s3_test::_ObjectLockConfiguration>(ivy_deser &inp, s3_test::_ObjectLockConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockLegalHold &t);
template <>
s3_test::_ObjectLockLegalHold _arg<s3_test::_ObjectLockLegalHold>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockLegalHold>(ivy_ser &res, const s3_test::_ObjectLockLegalHold&);
template <>
void  __deser<s3_test::_ObjectLockLegalHold>(ivy_deser &inp, s3_test::_ObjectLockLegalHold &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRetention &t);
template <>
s3_test::_ObjectLockRetention _arg<s3_test::_ObjectLockRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockRetention>(ivy_ser &res, const s3_test::_ObjectLockRetention&);
template <>
void  __deser<s3_test::_ObjectLockRetention>(ivy_deser &inp, s3_test::_ObjectLockRetention &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRule &t);
template <>
s3_test::_ObjectLockRule _arg<s3_test::_ObjectLockRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectLockRule>(ivy_ser &res, const s3_test::_ObjectLockRule&);
template <>
void  __deser<s3_test::_ObjectLockRule>(ivy_deser &inp, s3_test::_ObjectLockRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectVersion &t);
template <>
s3_test::_ObjectVersion _arg<s3_test::_ObjectVersion>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ObjectVersion>(ivy_ser &res, const s3_test::_ObjectVersion&);
template <>
void  __deser<s3_test::_ObjectVersion>(ivy_deser &inp, s3_test::_ObjectVersion &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputLocation &t);
template <>
s3_test::_OutputLocation _arg<s3_test::_OutputLocation>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OutputLocation>(ivy_ser &res, const s3_test::_OutputLocation&);
template <>
void  __deser<s3_test::_OutputLocation>(ivy_deser &inp, s3_test::_OutputLocation &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputSerialization &t);
template <>
s3_test::_OutputSerialization _arg<s3_test::_OutputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OutputSerialization>(ivy_ser &res, const s3_test::_OutputSerialization&);
template <>
void  __deser<s3_test::_OutputSerialization>(ivy_deser &inp, s3_test::_OutputSerialization &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Owner &t);
template <>
s3_test::_Owner _arg<s3_test::_Owner>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Owner>(ivy_ser &res, const s3_test::_Owner&);
template <>
void  __deser<s3_test::_Owner>(ivy_deser &inp, s3_test::_Owner &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_OwnershipControlsRule &t);
template <>
s3_test::_OwnershipControlsRule _arg<s3_test::_OwnershipControlsRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_OwnershipControlsRule>(ivy_ser &res, const s3_test::_OwnershipControlsRule&);
template <>
void  __deser<s3_test::_OwnershipControlsRule>(ivy_deser &inp, s3_test::_OwnershipControlsRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ParquetInput &t);
template <>
s3_test::_ParquetInput _arg<s3_test::_ParquetInput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ParquetInput>(ivy_ser &res, const s3_test::_ParquetInput&);
template <>
void  __deser<s3_test::_ParquetInput>(ivy_deser &inp, s3_test::_ParquetInput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Part &t);
template <>
s3_test::_Part _arg<s3_test::_Part>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Part>(ivy_ser &res, const s3_test::_Part&);
template <>
void  __deser<s3_test::_Part>(ivy_deser &inp, s3_test::_Part &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectOutput &t);
template <>
s3_test::_PutObjectOutput _arg<s3_test::_PutObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_PutObjectOutput>(ivy_ser &res, const s3_test::_PutObjectOutput&);
template <>
void  __deser<s3_test::_PutObjectOutput>(ivy_deser &inp, s3_test::_PutObjectOutput &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectRequest &t);
template <>
s3_test::_PutObjectRequest _arg<s3_test::_PutObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_PutObjectRequest>(ivy_ser &res, const s3_test::_PutObjectRequest&);
template <>
void  __deser<s3_test::_PutObjectRequest>(ivy_deser &inp, s3_test::_PutObjectRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_QueueConfiguration &t);
template <>
s3_test::_QueueConfiguration _arg<s3_test::_QueueConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_QueueConfiguration>(ivy_ser &res, const s3_test::_QueueConfiguration&);
template <>
void  __deser<s3_test::_QueueConfiguration>(ivy_deser &inp, s3_test::_QueueConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Redirect &t);
template <>
s3_test::_Redirect _arg<s3_test::_Redirect>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Redirect>(ivy_ser &res, const s3_test::_Redirect&);
template <>
void  __deser<s3_test::_Redirect>(ivy_deser &inp, s3_test::_Redirect &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicaModifications &t);
template <>
s3_test::_ReplicaModifications _arg<s3_test::_ReplicaModifications>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicaModifications>(ivy_ser &res, const s3_test::_ReplicaModifications&);
template <>
void  __deser<s3_test::_ReplicaModifications>(ivy_deser &inp, s3_test::_ReplicaModifications &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRule &t);
template <>
s3_test::_ReplicationRule _arg<s3_test::_ReplicationRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRule>(ivy_ser &res, const s3_test::_ReplicationRule&);
template <>
void  __deser<s3_test::_ReplicationRule>(ivy_deser &inp, s3_test::_ReplicationRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleAndOperator &t);
template <>
s3_test::_ReplicationRuleAndOperator _arg<s3_test::_ReplicationRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRuleAndOperator>(ivy_ser &res, const s3_test::_ReplicationRuleAndOperator&);
template <>
void  __deser<s3_test::_ReplicationRuleAndOperator>(ivy_deser &inp, s3_test::_ReplicationRuleAndOperator &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleFilter &t);
template <>
s3_test::_ReplicationRuleFilter _arg<s3_test::_ReplicationRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationRuleFilter>(ivy_ser &res, const s3_test::_ReplicationRuleFilter&);
template <>
void  __deser<s3_test::_ReplicationRuleFilter>(ivy_deser &inp, s3_test::_ReplicationRuleFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTime &t);
template <>
s3_test::_ReplicationTime _arg<s3_test::_ReplicationTime>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationTime>(ivy_ser &res, const s3_test::_ReplicationTime&);
template <>
void  __deser<s3_test::_ReplicationTime>(ivy_deser &inp, s3_test::_ReplicationTime &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTimeValue &t);
template <>
s3_test::_ReplicationTimeValue _arg<s3_test::_ReplicationTimeValue>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ReplicationTimeValue>(ivy_ser &res, const s3_test::_ReplicationTimeValue&);
template <>
void  __deser<s3_test::_ReplicationTimeValue>(ivy_deser &inp, s3_test::_ReplicationTimeValue &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RequestProgress &t);
template <>
s3_test::_RequestProgress _arg<s3_test::_RequestProgress>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RequestProgress>(ivy_ser &res, const s3_test::_RequestProgress&);
template <>
void  __deser<s3_test::_RequestProgress>(ivy_deser &inp, s3_test::_RequestProgress &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RestoreRequest &t);
template <>
s3_test::_RestoreRequest _arg<s3_test::_RestoreRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RestoreRequest>(ivy_ser &res, const s3_test::_RestoreRequest&);
template <>
void  __deser<s3_test::_RestoreRequest>(ivy_deser &inp, s3_test::_RestoreRequest &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_RoutingRule &t);
template <>
s3_test::_RoutingRule _arg<s3_test::_RoutingRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_RoutingRule>(ivy_ser &res, const s3_test::_RoutingRule&);
template <>
void  __deser<s3_test::_RoutingRule>(ivy_deser &inp, s3_test::_RoutingRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Rule &t);
template <>
s3_test::_Rule _arg<s3_test::_Rule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Rule>(ivy_ser &res, const s3_test::_Rule&);
template <>
void  __deser<s3_test::_Rule>(ivy_deser &inp, s3_test::_Rule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_S3KeyFilter &t);
template <>
s3_test::_S3KeyFilter _arg<s3_test::_S3KeyFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_S3KeyFilter>(ivy_ser &res, const s3_test::_S3KeyFilter&);
template <>
void  __deser<s3_test::_S3KeyFilter>(ivy_deser &inp, s3_test::_S3KeyFilter &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_S3Location &t);
template <>
s3_test::_S3Location _arg<s3_test::_S3Location>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_S3Location>(ivy_ser &res, const s3_test::_S3Location&);
template <>
void  __deser<s3_test::_S3Location>(ivy_deser &inp, s3_test::_S3Location &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SSEKMS &t);
template <>
s3_test::_SSEKMS _arg<s3_test::_SSEKMS>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SSEKMS>(ivy_ser &res, const s3_test::_SSEKMS&);
template <>
void  __deser<s3_test::_SSEKMS>(ivy_deser &inp, s3_test::_SSEKMS &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SSES3 &t);
template <>
s3_test::_SSES3 _arg<s3_test::_SSES3>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SSES3>(ivy_ser &res, const s3_test::_SSES3&);
template <>
void  __deser<s3_test::_SSES3>(ivy_deser &inp, s3_test::_SSES3 &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ScanRange &t);
template <>
s3_test::_ScanRange _arg<s3_test::_ScanRange>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ScanRange>(ivy_ser &res, const s3_test::_ScanRange&);
template <>
void  __deser<s3_test::_ScanRange>(ivy_deser &inp, s3_test::_ScanRange &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SelectParameters &t);
template <>
s3_test::_SelectParameters _arg<s3_test::_SelectParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SelectParameters>(ivy_ser &res, const s3_test::_SelectParameters&);
template <>
void  __deser<s3_test::_SelectParameters>(ivy_deser &inp, s3_test::_SelectParameters &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionByDefault &t);
template <>
s3_test::_ServerSideEncryptionByDefault _arg<s3_test::_ServerSideEncryptionByDefault>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ServerSideEncryptionByDefault>(ivy_ser &res, const s3_test::_ServerSideEncryptionByDefault&);
template <>
void  __deser<s3_test::_ServerSideEncryptionByDefault>(ivy_deser &inp, s3_test::_ServerSideEncryptionByDefault &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionRule &t);
template <>
s3_test::_ServerSideEncryptionRule _arg<s3_test::_ServerSideEncryptionRule>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_ServerSideEncryptionRule>(ivy_ser &res, const s3_test::_ServerSideEncryptionRule&);
template <>
void  __deser<s3_test::_ServerSideEncryptionRule>(ivy_deser &inp, s3_test::_ServerSideEncryptionRule &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SourceSelectionCriteria &t);
template <>
s3_test::_SourceSelectionCriteria _arg<s3_test::_SourceSelectionCriteria>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SourceSelectionCriteria>(ivy_ser &res, const s3_test::_SourceSelectionCriteria&);
template <>
void  __deser<s3_test::_SourceSelectionCriteria>(ivy_deser &inp, s3_test::_SourceSelectionCriteria &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_SseKmsEncryptedObjects &t);
template <>
s3_test::_SseKmsEncryptedObjects _arg<s3_test::_SseKmsEncryptedObjects>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_SseKmsEncryptedObjects>(ivy_ser &res, const s3_test::_SseKmsEncryptedObjects&);
template <>
void  __deser<s3_test::_SseKmsEncryptedObjects>(ivy_deser &inp, s3_test::_SseKmsEncryptedObjects &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysis &t);
template <>
s3_test::_StorageClassAnalysis _arg<s3_test::_StorageClassAnalysis>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_StorageClassAnalysis>(ivy_ser &res, const s3_test::_StorageClassAnalysis&);
template <>
void  __deser<s3_test::_StorageClassAnalysis>(ivy_deser &inp, s3_test::_StorageClassAnalysis &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysisDataExport &t);
template <>
s3_test::_StorageClassAnalysisDataExport _arg<s3_test::_StorageClassAnalysisDataExport>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_StorageClassAnalysisDataExport>(ivy_ser &res, const s3_test::_StorageClassAnalysisDataExport&);
template <>
void  __deser<s3_test::_StorageClassAnalysisDataExport>(ivy_deser &inp, s3_test::_StorageClassAnalysisDataExport &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tag &t);
template <>
s3_test::_Tag _arg<s3_test::_Tag>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tag>(ivy_ser &res, const s3_test::_Tag&);
template <>
void  __deser<s3_test::_Tag>(ivy_deser &inp, s3_test::_Tag &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tagging &t);
template <>
s3_test::_Tagging _arg<s3_test::_Tagging>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tagging>(ivy_ser &res, const s3_test::_Tagging&);
template <>
void  __deser<s3_test::_Tagging>(ivy_deser &inp, s3_test::_Tagging &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_TargetGrant &t);
template <>
s3_test::_TargetGrant _arg<s3_test::_TargetGrant>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_TargetGrant>(ivy_ser &res, const s3_test::_TargetGrant&);
template <>
void  __deser<s3_test::_TargetGrant>(ivy_deser &inp, s3_test::_TargetGrant &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Tiering &t);
template <>
s3_test::_Tiering _arg<s3_test::_Tiering>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Tiering>(ivy_ser &res, const s3_test::_Tiering&);
template <>
void  __deser<s3_test::_Tiering>(ivy_deser &inp, s3_test::_Tiering &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_TopicConfiguration &t);
template <>
s3_test::_TopicConfiguration _arg<s3_test::_TopicConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_TopicConfiguration>(ivy_ser &res, const s3_test::_TopicConfiguration&);
template <>
void  __deser<s3_test::_TopicConfiguration>(ivy_deser &inp, s3_test::_TopicConfiguration &res);
std::ostream &operator <<(std::ostream &s, const s3_test::_Transition &t);
template <>
s3_test::_Transition _arg<s3_test::_Transition>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<s3_test::_Transition>(ivy_ser &res, const s3_test::_Transition&);
template <>
void  __deser<s3_test::_Transition>(ivy_deser &inp, s3_test::_Transition &res);
template <>
void __from_solver<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v, s3_test::_AbortIncompleteMultipartUpload &res);
template <>
z3::expr __to_solver<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v, s3_test::_AbortIncompleteMultipartUpload &val);
template <>
void __randomize<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v, s3_test::_AccessControlPolicy &res);
template <>
z3::expr __to_solver<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v, s3_test::_AccessControlPolicy &val);
template <>
void __randomize<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v, s3_test::_AccessControlTranslation &res);
template <>
z3::expr __to_solver<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v, s3_test::_AccessControlTranslation &val);
template <>
void __randomize<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v, s3_test::_AnalyticsAndOperator &res);
template <>
z3::expr __to_solver<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v, s3_test::_AnalyticsAndOperator &val);
template <>
void __randomize<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v, s3_test::_AnalyticsConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v, s3_test::_AnalyticsConfiguration &val);
template <>
void __randomize<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v, s3_test::_AnalyticsExportDestination &res);
template <>
z3::expr __to_solver<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v, s3_test::_AnalyticsExportDestination &val);
template <>
void __randomize<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v, s3_test::_AnalyticsFilter &res);
template <>
z3::expr __to_solver<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v, s3_test::_AnalyticsFilter &val);
template <>
void __randomize<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v, s3_test::_AnalyticsS3BucketDestination &res);
template <>
z3::expr __to_solver<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v, s3_test::_AnalyticsS3BucketDestination &val);
template <>
void __randomize<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Bucket>( gen &g, const  z3::expr &v, s3_test::_Bucket &res);
template <>
z3::expr __to_solver<s3_test::_Bucket>( gen &g, const  z3::expr &v, s3_test::_Bucket &val);
template <>
void __randomize<s3_test::_Bucket>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v, s3_test::_BucketLifecycleConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v, s3_test::_BucketLifecycleConfiguration &val);
template <>
void __randomize<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CORSRule>( gen &g, const  z3::expr &v, s3_test::_CORSRule &res);
template <>
z3::expr __to_solver<s3_test::_CORSRule>( gen &g, const  z3::expr &v, s3_test::_CORSRule &val);
template <>
void __randomize<s3_test::_CORSRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CSVInput>( gen &g, const  z3::expr &v, s3_test::_CSVInput &res);
template <>
z3::expr __to_solver<s3_test::_CSVInput>( gen &g, const  z3::expr &v, s3_test::_CSVInput &val);
template <>
void __randomize<s3_test::_CSVInput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CSVOutput>( gen &g, const  z3::expr &v, s3_test::_CSVOutput &res);
template <>
z3::expr __to_solver<s3_test::_CSVOutput>( gen &g, const  z3::expr &v, s3_test::_CSVOutput &val);
template <>
void __randomize<s3_test::_CSVOutput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v, s3_test::_CommonPrefix &res);
template <>
z3::expr __to_solver<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v, s3_test::_CommonPrefix &val);
template <>
void __randomize<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v, s3_test::_CompletedMultipartUpload &res);
template <>
z3::expr __to_solver<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v, s3_test::_CompletedMultipartUpload &val);
template <>
void __randomize<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CompletedPart>( gen &g, const  z3::expr &v, s3_test::_CompletedPart &res);
template <>
z3::expr __to_solver<s3_test::_CompletedPart>( gen &g, const  z3::expr &v, s3_test::_CompletedPart &val);
template <>
void __randomize<s3_test::_CompletedPart>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Condition>( gen &g, const  z3::expr &v, s3_test::_Condition &res);
template <>
z3::expr __to_solver<s3_test::_Condition>( gen &g, const  z3::expr &v, s3_test::_Condition &val);
template <>
void __randomize<s3_test::_Condition>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v, s3_test::_CreateBucketConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v, s3_test::_CreateBucketConfiguration &val);
template <>
void __randomize<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v, s3_test::_DefaultRetention &res);
template <>
z3::expr __to_solver<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v, s3_test::_DefaultRetention &val);
template <>
void __randomize<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v, s3_test::_DeleteMarkerEntry &res);
template <>
z3::expr __to_solver<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v, s3_test::_DeleteMarkerEntry &val);
template <>
void __randomize<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v, s3_test::_DeleteMarkerReplication &res);
template <>
z3::expr __to_solver<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v, s3_test::_DeleteMarkerReplication &val);
template <>
void __randomize<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_DeletedObject>( gen &g, const  z3::expr &v, s3_test::_DeletedObject &res);
template <>
z3::expr __to_solver<s3_test::_DeletedObject>( gen &g, const  z3::expr &v, s3_test::_DeletedObject &val);
template <>
void __randomize<s3_test::_DeletedObject>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Destination>( gen &g, const  z3::expr &v, s3_test::_Destination &res);
template <>
z3::expr __to_solver<s3_test::_Destination>( gen &g, const  z3::expr &v, s3_test::_Destination &val);
template <>
void __randomize<s3_test::_Destination>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Encryption>( gen &g, const  z3::expr &v, s3_test::_Encryption &res);
template <>
z3::expr __to_solver<s3_test::_Encryption>( gen &g, const  z3::expr &v, s3_test::_Encryption &val);
template <>
void __randomize<s3_test::_Encryption>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v, s3_test::_EncryptionConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v, s3_test::_EncryptionConfiguration &val);
template <>
void __randomize<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Error>( gen &g, const  z3::expr &v, s3_test::_Error &res);
template <>
z3::expr __to_solver<s3_test::_Error>( gen &g, const  z3::expr &v, s3_test::_Error &val);
template <>
void __randomize<s3_test::_Error>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v, s3_test::_ExistingObjectReplication &res);
template <>
z3::expr __to_solver<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v, s3_test::_ExistingObjectReplication &val);
template <>
void __randomize<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_FilterRule>( gen &g, const  z3::expr &v, s3_test::_FilterRule &res);
template <>
z3::expr __to_solver<s3_test::_FilterRule>( gen &g, const  z3::expr &v, s3_test::_FilterRule &val);
template <>
void __randomize<s3_test::_FilterRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v, s3_test::_GetObjectOutput &res);
template <>
z3::expr __to_solver<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v, s3_test::_GetObjectOutput &val);
template <>
void __randomize<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v, s3_test::_GetObjectRequest &res);
template <>
z3::expr __to_solver<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v, s3_test::_GetObjectRequest &val);
template <>
void __randomize<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v, s3_test::_GlacierJobParameters &res);
template <>
z3::expr __to_solver<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v, s3_test::_GlacierJobParameters &val);
template <>
void __randomize<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Grant>( gen &g, const  z3::expr &v, s3_test::_Grant &res);
template <>
z3::expr __to_solver<s3_test::_Grant>( gen &g, const  z3::expr &v, s3_test::_Grant &val);
template <>
void __randomize<s3_test::_Grant>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Grantee>( gen &g, const  z3::expr &v, s3_test::_Grantee &res);
template <>
z3::expr __to_solver<s3_test::_Grantee>( gen &g, const  z3::expr &v, s3_test::_Grantee &val);
template <>
void __randomize<s3_test::_Grantee>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Initiator>( gen &g, const  z3::expr &v, s3_test::_Initiator &res);
template <>
z3::expr __to_solver<s3_test::_Initiator>( gen &g, const  z3::expr &v, s3_test::_Initiator &val);
template <>
void __randomize<s3_test::_Initiator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InputSerialization>( gen &g, const  z3::expr &v, s3_test::_InputSerialization &res);
template <>
z3::expr __to_solver<s3_test::_InputSerialization>( gen &g, const  z3::expr &v, s3_test::_InputSerialization &val);
template <>
void __randomize<s3_test::_InputSerialization>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringAndOperator &res);
template <>
z3::expr __to_solver<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringAndOperator &val);
template <>
void __randomize<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringConfiguration &val);
template <>
void __randomize<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringFilter &res);
template <>
z3::expr __to_solver<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v, s3_test::_IntelligentTieringFilter &val);
template <>
void __randomize<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v, s3_test::_InventoryConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v, s3_test::_InventoryConfiguration &val);
template <>
void __randomize<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v, s3_test::_InventoryDestination &res);
template <>
z3::expr __to_solver<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v, s3_test::_InventoryDestination &val);
template <>
void __randomize<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v, s3_test::_InventoryEncryption &res);
template <>
z3::expr __to_solver<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v, s3_test::_InventoryEncryption &val);
template <>
void __randomize<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v, s3_test::_InventoryFilter &res);
template <>
z3::expr __to_solver<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v, s3_test::_InventoryFilter &val);
template <>
void __randomize<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v, s3_test::_InventoryS3BucketDestination &res);
template <>
z3::expr __to_solver<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v, s3_test::_InventoryS3BucketDestination &val);
template <>
void __randomize<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v, s3_test::_InventorySchedule &res);
template <>
z3::expr __to_solver<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v, s3_test::_InventorySchedule &val);
template <>
void __randomize<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_JSONInput>( gen &g, const  z3::expr &v, s3_test::_JSONInput &res);
template <>
z3::expr __to_solver<s3_test::_JSONInput>( gen &g, const  z3::expr &v, s3_test::_JSONInput &val);
template <>
void __randomize<s3_test::_JSONInput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_JSONOutput>( gen &g, const  z3::expr &v, s3_test::_JSONOutput &res);
template <>
z3::expr __to_solver<s3_test::_JSONOutput>( gen &g, const  z3::expr &v, s3_test::_JSONOutput &val);
template <>
void __randomize<s3_test::_JSONOutput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v, s3_test::_LambdaFunctionConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v, s3_test::_LambdaFunctionConfiguration &val);
template <>
void __randomize<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v, s3_test::_LifecycleConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v, s3_test::_LifecycleConfiguration &val);
template <>
void __randomize<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v, s3_test::_LifecycleExpiration &res);
template <>
z3::expr __to_solver<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v, s3_test::_LifecycleExpiration &val);
template <>
void __randomize<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v, s3_test::_LifecycleRule &res);
template <>
z3::expr __to_solver<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v, s3_test::_LifecycleRule &val);
template <>
void __randomize<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v, s3_test::_LifecycleRuleAndOperator &res);
template <>
z3::expr __to_solver<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v, s3_test::_LifecycleRuleAndOperator &val);
template <>
void __randomize<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v, s3_test::_LifecycleRuleFilter &res);
template <>
z3::expr __to_solver<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v, s3_test::_LifecycleRuleFilter &val);
template <>
void __randomize<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v, s3_test::_MetadataEntry &res);
template <>
z3::expr __to_solver<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v, s3_test::_MetadataEntry &val);
template <>
void __randomize<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Metrics>( gen &g, const  z3::expr &v, s3_test::_Metrics &res);
template <>
z3::expr __to_solver<s3_test::_Metrics>( gen &g, const  z3::expr &v, s3_test::_Metrics &val);
template <>
void __randomize<s3_test::_Metrics>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v, s3_test::_MetricsAndOperator &res);
template <>
z3::expr __to_solver<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v, s3_test::_MetricsAndOperator &val);
template <>
void __randomize<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v, s3_test::_MetricsConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v, s3_test::_MetricsConfiguration &val);
template <>
void __randomize<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v, s3_test::_MetricsFilter &res);
template <>
z3::expr __to_solver<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v, s3_test::_MetricsFilter &val);
template <>
void __randomize<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v, s3_test::_MultipartUpload &res);
template <>
z3::expr __to_solver<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v, s3_test::_MultipartUpload &val);
template <>
void __randomize<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v, s3_test::_NoncurrentVersionExpiration &res);
template <>
z3::expr __to_solver<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v, s3_test::_NoncurrentVersionExpiration &val);
template <>
void __randomize<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v, s3_test::_NoncurrentVersionTransition &res);
template <>
z3::expr __to_solver<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v, s3_test::_NoncurrentVersionTransition &val);
template <>
void __randomize<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v, s3_test::_NotificationConfigurationFilter &res);
template <>
z3::expr __to_solver<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v, s3_test::_NotificationConfigurationFilter &val);
template <>
void __randomize<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Object>( gen &g, const  z3::expr &v, s3_test::_Object &res);
template <>
z3::expr __to_solver<s3_test::_Object>( gen &g, const  z3::expr &v, s3_test::_Object &val);
template <>
void __randomize<s3_test::_Object>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v, s3_test::_ObjectIdentifier &res);
template <>
z3::expr __to_solver<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v, s3_test::_ObjectIdentifier &val);
template <>
void __randomize<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v, s3_test::_ObjectLockConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v, s3_test::_ObjectLockConfiguration &val);
template <>
void __randomize<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v, s3_test::_ObjectLockLegalHold &res);
template <>
z3::expr __to_solver<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v, s3_test::_ObjectLockLegalHold &val);
template <>
void __randomize<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v, s3_test::_ObjectLockRetention &res);
template <>
z3::expr __to_solver<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v, s3_test::_ObjectLockRetention &val);
template <>
void __randomize<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v, s3_test::_ObjectLockRule &res);
template <>
z3::expr __to_solver<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v, s3_test::_ObjectLockRule &val);
template <>
void __randomize<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v, s3_test::_ObjectVersion &res);
template <>
z3::expr __to_solver<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v, s3_test::_ObjectVersion &val);
template <>
void __randomize<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_OutputLocation>( gen &g, const  z3::expr &v, s3_test::_OutputLocation &res);
template <>
z3::expr __to_solver<s3_test::_OutputLocation>( gen &g, const  z3::expr &v, s3_test::_OutputLocation &val);
template <>
void __randomize<s3_test::_OutputLocation>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v, s3_test::_OutputSerialization &res);
template <>
z3::expr __to_solver<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v, s3_test::_OutputSerialization &val);
template <>
void __randomize<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Owner>( gen &g, const  z3::expr &v, s3_test::_Owner &res);
template <>
z3::expr __to_solver<s3_test::_Owner>( gen &g, const  z3::expr &v, s3_test::_Owner &val);
template <>
void __randomize<s3_test::_Owner>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v, s3_test::_OwnershipControlsRule &res);
template <>
z3::expr __to_solver<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v, s3_test::_OwnershipControlsRule &val);
template <>
void __randomize<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ParquetInput>( gen &g, const  z3::expr &v, s3_test::_ParquetInput &res);
template <>
z3::expr __to_solver<s3_test::_ParquetInput>( gen &g, const  z3::expr &v, s3_test::_ParquetInput &val);
template <>
void __randomize<s3_test::_ParquetInput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Part>( gen &g, const  z3::expr &v, s3_test::_Part &res);
template <>
z3::expr __to_solver<s3_test::_Part>( gen &g, const  z3::expr &v, s3_test::_Part &val);
template <>
void __randomize<s3_test::_Part>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v, s3_test::_PutObjectOutput &res);
template <>
z3::expr __to_solver<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v, s3_test::_PutObjectOutput &val);
template <>
void __randomize<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v, s3_test::_PutObjectRequest &res);
template <>
z3::expr __to_solver<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v, s3_test::_PutObjectRequest &val);
template <>
void __randomize<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v, s3_test::_QueueConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v, s3_test::_QueueConfiguration &val);
template <>
void __randomize<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Redirect>( gen &g, const  z3::expr &v, s3_test::_Redirect &res);
template <>
z3::expr __to_solver<s3_test::_Redirect>( gen &g, const  z3::expr &v, s3_test::_Redirect &val);
template <>
void __randomize<s3_test::_Redirect>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v, s3_test::_ReplicaModifications &res);
template <>
z3::expr __to_solver<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v, s3_test::_ReplicaModifications &val);
template <>
void __randomize<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v, s3_test::_ReplicationRule &res);
template <>
z3::expr __to_solver<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v, s3_test::_ReplicationRule &val);
template <>
void __randomize<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v, s3_test::_ReplicationRuleAndOperator &res);
template <>
z3::expr __to_solver<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v, s3_test::_ReplicationRuleAndOperator &val);
template <>
void __randomize<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v, s3_test::_ReplicationRuleFilter &res);
template <>
z3::expr __to_solver<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v, s3_test::_ReplicationRuleFilter &val);
template <>
void __randomize<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v, s3_test::_ReplicationTime &res);
template <>
z3::expr __to_solver<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v, s3_test::_ReplicationTime &val);
template <>
void __randomize<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v, s3_test::_ReplicationTimeValue &res);
template <>
z3::expr __to_solver<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v, s3_test::_ReplicationTimeValue &val);
template <>
void __randomize<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_RequestProgress>( gen &g, const  z3::expr &v, s3_test::_RequestProgress &res);
template <>
z3::expr __to_solver<s3_test::_RequestProgress>( gen &g, const  z3::expr &v, s3_test::_RequestProgress &val);
template <>
void __randomize<s3_test::_RequestProgress>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v, s3_test::_RestoreRequest &res);
template <>
z3::expr __to_solver<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v, s3_test::_RestoreRequest &val);
template <>
void __randomize<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_RoutingRule>( gen &g, const  z3::expr &v, s3_test::_RoutingRule &res);
template <>
z3::expr __to_solver<s3_test::_RoutingRule>( gen &g, const  z3::expr &v, s3_test::_RoutingRule &val);
template <>
void __randomize<s3_test::_RoutingRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Rule>( gen &g, const  z3::expr &v, s3_test::_Rule &res);
template <>
z3::expr __to_solver<s3_test::_Rule>( gen &g, const  z3::expr &v, s3_test::_Rule &val);
template <>
void __randomize<s3_test::_Rule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v, s3_test::_S3KeyFilter &res);
template <>
z3::expr __to_solver<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v, s3_test::_S3KeyFilter &val);
template <>
void __randomize<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_S3Location>( gen &g, const  z3::expr &v, s3_test::_S3Location &res);
template <>
z3::expr __to_solver<s3_test::_S3Location>( gen &g, const  z3::expr &v, s3_test::_S3Location &val);
template <>
void __randomize<s3_test::_S3Location>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_SSEKMS>( gen &g, const  z3::expr &v, s3_test::_SSEKMS &res);
template <>
z3::expr __to_solver<s3_test::_SSEKMS>( gen &g, const  z3::expr &v, s3_test::_SSEKMS &val);
template <>
void __randomize<s3_test::_SSEKMS>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_SSES3>( gen &g, const  z3::expr &v, s3_test::_SSES3 &res);
template <>
z3::expr __to_solver<s3_test::_SSES3>( gen &g, const  z3::expr &v, s3_test::_SSES3 &val);
template <>
void __randomize<s3_test::_SSES3>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ScanRange>( gen &g, const  z3::expr &v, s3_test::_ScanRange &res);
template <>
z3::expr __to_solver<s3_test::_ScanRange>( gen &g, const  z3::expr &v, s3_test::_ScanRange &val);
template <>
void __randomize<s3_test::_ScanRange>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_SelectParameters>( gen &g, const  z3::expr &v, s3_test::_SelectParameters &res);
template <>
z3::expr __to_solver<s3_test::_SelectParameters>( gen &g, const  z3::expr &v, s3_test::_SelectParameters &val);
template <>
void __randomize<s3_test::_SelectParameters>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v, s3_test::_ServerSideEncryptionByDefault &res);
template <>
z3::expr __to_solver<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v, s3_test::_ServerSideEncryptionByDefault &val);
template <>
void __randomize<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v, s3_test::_ServerSideEncryptionRule &res);
template <>
z3::expr __to_solver<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v, s3_test::_ServerSideEncryptionRule &val);
template <>
void __randomize<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v, s3_test::_SourceSelectionCriteria &res);
template <>
z3::expr __to_solver<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v, s3_test::_SourceSelectionCriteria &val);
template <>
void __randomize<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v, s3_test::_SseKmsEncryptedObjects &res);
template <>
z3::expr __to_solver<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v, s3_test::_SseKmsEncryptedObjects &val);
template <>
void __randomize<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v, s3_test::_StorageClassAnalysis &res);
template <>
z3::expr __to_solver<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v, s3_test::_StorageClassAnalysis &val);
template <>
void __randomize<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v, s3_test::_StorageClassAnalysisDataExport &res);
template <>
z3::expr __to_solver<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v, s3_test::_StorageClassAnalysisDataExport &val);
template <>
void __randomize<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Tag>( gen &g, const  z3::expr &v, s3_test::_Tag &res);
template <>
z3::expr __to_solver<s3_test::_Tag>( gen &g, const  z3::expr &v, s3_test::_Tag &val);
template <>
void __randomize<s3_test::_Tag>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Tagging>( gen &g, const  z3::expr &v, s3_test::_Tagging &res);
template <>
z3::expr __to_solver<s3_test::_Tagging>( gen &g, const  z3::expr &v, s3_test::_Tagging &val);
template <>
void __randomize<s3_test::_Tagging>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_TargetGrant>( gen &g, const  z3::expr &v, s3_test::_TargetGrant &res);
template <>
z3::expr __to_solver<s3_test::_TargetGrant>( gen &g, const  z3::expr &v, s3_test::_TargetGrant &val);
template <>
void __randomize<s3_test::_TargetGrant>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Tiering>( gen &g, const  z3::expr &v, s3_test::_Tiering &res);
template <>
z3::expr __to_solver<s3_test::_Tiering>( gen &g, const  z3::expr &v, s3_test::_Tiering &val);
template <>
void __randomize<s3_test::_Tiering>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v, s3_test::_TopicConfiguration &res);
template <>
z3::expr __to_solver<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v, s3_test::_TopicConfiguration &val);
template <>
void __randomize<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v);
template <>
void __from_solver<s3_test::_Transition>( gen &g, const  z3::expr &v, s3_test::_Transition &res);
template <>
z3::expr __to_solver<s3_test::_Transition>( gen &g, const  z3::expr &v, s3_test::_Transition &val);
template <>
void __randomize<s3_test::_Transition>( gen &g, const  z3::expr &v);
bool operator==(const s3_test::__tup__string__string &x, const s3_test::__tup__string__string &y){
    return x.arg0 == y.arg0 && x.arg1 == y.arg1;
}
bool operator==(const s3_test::__tup__unordered_map__string____string____string &x, const s3_test::__tup__unordered_map__string____string____string &y){
    return x.arg0 == y.arg0 && x.arg1 == y.arg1;
}

hash_space::hash_map<std::string,int> s3_test::string::x_to_bv_hash;
hash_space::hash_map<int,std::string> s3_test::string::bv_to_x_hash;
std::vector<std::string> s3_test::string::nonces;
int s3_test::string::next_bv = 0;

#ifdef Z3PP_H_
template <>
void __from_solver<s3_test::string>( gen &g, const  z3::expr &v, s3_test::string &res) {
    res = s3_test::string::bv_to_x(g.eval(v));
}
template <>
z3::expr __to_solver<s3_test::string>( gen &g, const  z3::expr &v, s3_test::string &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    return v == g.int_to_z3(v.get_sort(),s3_test::string::x_to_bv(val));
}
template <>
void __randomize<s3_test::string>( gen &g, const  z3::expr &apply_expr) {
    z3::sort range = apply_expr.get_sort();
    s3_test::string value;
    if (s3_test::string::bv_to_x_hash.size() == (1<<4)) {
        value = s3_test::string::bv_to_x(rand() % (1<<4));
    } else {
        if (s3_test::string::nonces.size() == 0) 
           for (int i = 0; i < 2; i++)
               s3_test::string::nonces.push_back(s3_test::string::random_x());
        value = s3_test::string::nonces[rand() % s3_test::string::nonces.size()];
    }
    z3::expr val_expr = g.int_to_z3(range,s3_test::string::x_to_bv(value));
    z3::expr pred = apply_expr == val_expr;
    g.add_alit(pred);
}

#endif

std::ostream &operator <<(std::ostream &s, const s3_test::string &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}
template <>
s3_test::string _arg<s3_test::string>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx);
    return args[idx].atom;
}
template <>
void __ser<s3_test::string>(ivy_ser &res, const s3_test::string &inp) {
    res.set(inp);
}
template <>
void __deser<s3_test::string>(ivy_deser &inp, s3_test::string &res) {
    std::string tmp;
    inp.get(tmp);
    res = tmp;
}
//std::string s3_test::string::random_x(){
//    return __random_string<s3_test::string>();
//}
        template <typename T>
        T __array_segment(const T &a, long long lo, long long hi) {
            T res;
            lo = (lo < 0) ? 0 : lo;
            hi = (hi > a.size()) ? a.size() : hi;
            if (hi > lo) {
                res.resize(hi-lo);
                std::copy(a.begin()+lo,a.begin()+hi,res.begin());
            }
            return res;
        }
        	    std::ostream &operator <<(std::ostream &s, const s3_test::blob &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::blob _arg<s3_test::blob>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::blob a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<unsigned>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::blob>(ivy_deser &inp, s3_test::blob &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::blob>(ivy_ser &res, const s3_test::blob &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::blob& val) {
	        z3::expr z3end = g.apply("blob.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("blob.value",z3val,g.int_to_z3(g.sort("blob.domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::blob>( gen &g, const  z3::expr &v,s3_test::blob &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("blob.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("blob.value",v,g.int_to_z3(g.sort("blob.domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::blob>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("blob.domain"),__sz);
                z3::expr pred =  g.apply("blob.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<unsigned>(g,g.apply("blob.value",v,g.int_to_z3(g.sort("blob.domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__string__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__string__ _arg<s3_test::option__string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__string__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::string>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__string__>(ivy_deser &inp, s3_test::option__string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__string__>(ivy_ser &res, const s3_test::option__string__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__string__& val) {
	        z3::expr z3end = g.apply("option[string].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[string].value",z3val,g.int_to_z3(g.sort("option[string].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__string__>( gen &g, const  z3::expr &v,s3_test::option__string__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[string].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[string].value",v,g.int_to_z3(g.sort("option[string].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__string__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[string].domain_t"),__sz);
                z3::expr pred =  g.apply("option[string].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::string>(g,g.apply("option[string].value",v,g.int_to_z3(g.sort("option[string].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Grant__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Grant__ _arg<s3_test::vector___Grant__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Grant__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Grant>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Grant__>(ivy_deser &inp, s3_test::vector___Grant__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Grant__>(ivy_ser &res, const s3_test::vector___Grant__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Grant__& val) {
	        z3::expr z3end = g.apply("vector[_Grant].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Grant].value",z3val,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Grant__>( gen &g, const  z3::expr &v,s3_test::vector___Grant__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Grant].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Grant].value",v,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Grant__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Grant].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Grant].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Grant>(g,g.apply("vector[_Grant].value",v,g.int_to_z3(g.sort("vector[_Grant].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Tag__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Tag__ _arg<s3_test::vector___Tag__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Tag__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tag>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Tag__>(ivy_deser &inp, s3_test::vector___Tag__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Tag__>(ivy_ser &res, const s3_test::vector___Tag__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Tag__& val) {
	        z3::expr z3end = g.apply("vector[_Tag].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Tag].value",z3val,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Tag__>( gen &g, const  z3::expr &v,s3_test::vector___Tag__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Tag].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Tag].value",v,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Tag__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Tag].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Tag].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tag>(g,g.apply("vector[_Tag].value",v,g.int_to_z3(g.sort("vector[_Tag].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AnalyticsFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AnalyticsFilter__ _arg<s3_test::option___AnalyticsFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AnalyticsFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AnalyticsFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AnalyticsFilter__>(ivy_deser &inp, s3_test::option___AnalyticsFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AnalyticsFilter__>(ivy_ser &res, const s3_test::option___AnalyticsFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AnalyticsFilter__& val) {
	        z3::expr z3end = g.apply("option[_AnalyticsFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AnalyticsFilter].value",z3val,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AnalyticsFilter__>( gen &g, const  z3::expr &v,s3_test::option___AnalyticsFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AnalyticsFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AnalyticsFilter].value",v,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AnalyticsFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AnalyticsFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AnalyticsFilter>(g,g.apply("option[_AnalyticsFilter].value",v,g.int_to_z3(g.sort("option[_AnalyticsFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleExpiration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleExpiration__ _arg<s3_test::option___LifecycleExpiration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleExpiration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleExpiration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleExpiration__>(ivy_deser &inp, s3_test::option___LifecycleExpiration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleExpiration__>(ivy_ser &res, const s3_test::option___LifecycleExpiration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleExpiration__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleExpiration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleExpiration].value",z3val,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleExpiration__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleExpiration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleExpiration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleExpiration].value",v,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleExpiration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleExpiration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleExpiration>(g,g.apply("option[_LifecycleExpiration].value",v,g.int_to_z3(g.sort("option[_LifecycleExpiration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleRuleFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleRuleFilter__ _arg<s3_test::option___LifecycleRuleFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleRuleFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleRuleFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleRuleFilter__>(ivy_deser &inp, s3_test::option___LifecycleRuleFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleRuleFilter__>(ivy_ser &res, const s3_test::option___LifecycleRuleFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleRuleFilter__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleRuleFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleRuleFilter].value",z3val,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleRuleFilter__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleRuleFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleRuleFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleRuleFilter].value",v,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleRuleFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleRuleFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleRuleFilter>(g,g.apply("option[_LifecycleRuleFilter].value",v,g.int_to_z3(g.sort("option[_LifecycleRuleFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Transition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Transition__ _arg<s3_test::vector___Transition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Transition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Transition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Transition__>(ivy_deser &inp, s3_test::vector___Transition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Transition__>(ivy_ser &res, const s3_test::vector___Transition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Transition__& val) {
	        z3::expr z3end = g.apply("vector[_Transition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Transition].value",z3val,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Transition__>( gen &g, const  z3::expr &v,s3_test::vector___Transition__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Transition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Transition].value",v,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Transition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Transition].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Transition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Transition>(g,g.apply("vector[_Transition].value",v,g.int_to_z3(g.sort("vector[_Transition].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___Transition____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___Transition____ _arg<s3_test::option__vector___Transition____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___Transition____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___Transition__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___Transition____>(ivy_deser &inp, s3_test::option__vector___Transition____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___Transition____>(ivy_ser &res, const s3_test::option__vector___Transition____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___Transition____& val) {
	        z3::expr z3end = g.apply("option[vector[_Transition]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_Transition]].value",z3val,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___Transition____>( gen &g, const  z3::expr &v,s3_test::option__vector___Transition____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_Transition]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_Transition]].value",v,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___Transition____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_Transition]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___Transition__>(g,g.apply("option[vector[_Transition]].value",v,g.int_to_z3(g.sort("option[vector[_Transition]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___NoncurrentVersionTransition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___NoncurrentVersionTransition__ _arg<s3_test::vector___NoncurrentVersionTransition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___NoncurrentVersionTransition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionTransition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___NoncurrentVersionTransition__>(ivy_deser &inp, s3_test::vector___NoncurrentVersionTransition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___NoncurrentVersionTransition__>(ivy_ser &res, const s3_test::vector___NoncurrentVersionTransition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___NoncurrentVersionTransition__& val) {
	        z3::expr z3end = g.apply("vector[_NoncurrentVersionTransition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_NoncurrentVersionTransition].value",z3val,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v,s3_test::vector___NoncurrentVersionTransition__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_NoncurrentVersionTransition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__sz);
                z3::expr pred =  g.apply("vector[_NoncurrentVersionTransition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionTransition>(g,g.apply("vector[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("vector[_NoncurrentVersionTransition].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___NoncurrentVersionTransition____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___NoncurrentVersionTransition____ _arg<s3_test::option__vector___NoncurrentVersionTransition____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___NoncurrentVersionTransition____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___NoncurrentVersionTransition__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___NoncurrentVersionTransition____>(ivy_deser &inp, s3_test::option__vector___NoncurrentVersionTransition____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___NoncurrentVersionTransition____>(ivy_ser &res, const s3_test::option__vector___NoncurrentVersionTransition____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___NoncurrentVersionTransition____& val) {
	        z3::expr z3end = g.apply("option[vector[_NoncurrentVersionTransition]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",z3val,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___NoncurrentVersionTransition____>( gen &g, const  z3::expr &v,s3_test::option__vector___NoncurrentVersionTransition____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",v,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___NoncurrentVersionTransition____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_NoncurrentVersionTransition]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___NoncurrentVersionTransition__>(g,g.apply("option[vector[_NoncurrentVersionTransition]].value",v,g.int_to_z3(g.sort("option[vector[_NoncurrentVersionTransition]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NoncurrentVersionExpiration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NoncurrentVersionExpiration__ _arg<s3_test::option___NoncurrentVersionExpiration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NoncurrentVersionExpiration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionExpiration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NoncurrentVersionExpiration__>(ivy_deser &inp, s3_test::option___NoncurrentVersionExpiration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NoncurrentVersionExpiration__>(ivy_ser &res, const s3_test::option___NoncurrentVersionExpiration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NoncurrentVersionExpiration__& val) {
	        z3::expr z3end = g.apply("option[_NoncurrentVersionExpiration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NoncurrentVersionExpiration].value",z3val,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NoncurrentVersionExpiration__>( gen &g, const  z3::expr &v,s3_test::option___NoncurrentVersionExpiration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NoncurrentVersionExpiration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NoncurrentVersionExpiration].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NoncurrentVersionExpiration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NoncurrentVersionExpiration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionExpiration>(g,g.apply("option[_NoncurrentVersionExpiration].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionExpiration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AbortIncompleteMultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AbortIncompleteMultipartUpload__ _arg<s3_test::option___AbortIncompleteMultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AbortIncompleteMultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AbortIncompleteMultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AbortIncompleteMultipartUpload__>(ivy_deser &inp, s3_test::option___AbortIncompleteMultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AbortIncompleteMultipartUpload__>(ivy_ser &res, const s3_test::option___AbortIncompleteMultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AbortIncompleteMultipartUpload__& val) {
	        z3::expr z3end = g.apply("option[_AbortIncompleteMultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].value",z3val,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AbortIncompleteMultipartUpload__>( gen &g, const  z3::expr &v,s3_test::option___AbortIncompleteMultipartUpload__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AbortIncompleteMultipartUpload].value",v,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AbortIncompleteMultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AbortIncompleteMultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AbortIncompleteMultipartUpload>(g,g.apply("option[_AbortIncompleteMultipartUpload].value",v,g.int_to_z3(g.sort("option[_AbortIncompleteMultipartUpload].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___LifecycleRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___LifecycleRule__ _arg<s3_test::vector___LifecycleRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___LifecycleRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___LifecycleRule__>(ivy_deser &inp, s3_test::vector___LifecycleRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___LifecycleRule__>(ivy_ser &res, const s3_test::vector___LifecycleRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___LifecycleRule__& val) {
	        z3::expr z3end = g.apply("vector[_LifecycleRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_LifecycleRule].value",z3val,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___LifecycleRule__>( gen &g, const  z3::expr &v,s3_test::vector___LifecycleRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_LifecycleRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_LifecycleRule].value",v,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___LifecycleRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_LifecycleRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleRule>(g,g.apply("vector[_LifecycleRule].value",v,g.int_to_z3(g.sort("vector[_LifecycleRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___TargetGrant__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___TargetGrant__ _arg<s3_test::vector___TargetGrant__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___TargetGrant__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_TargetGrant>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___TargetGrant__>(ivy_deser &inp, s3_test::vector___TargetGrant__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___TargetGrant__>(ivy_ser &res, const s3_test::vector___TargetGrant__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___TargetGrant__& val) {
	        z3::expr z3end = g.apply("vector[_TargetGrant].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_TargetGrant].value",z3val,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___TargetGrant__>( gen &g, const  z3::expr &v,s3_test::vector___TargetGrant__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_TargetGrant].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_TargetGrant].value",v,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___TargetGrant__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__sz);
                z3::expr pred =  g.apply("vector[_TargetGrant].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_TargetGrant>(g,g.apply("vector[_TargetGrant].value",v,g.int_to_z3(g.sort("vector[_TargetGrant].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___TargetGrant____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___TargetGrant____ _arg<s3_test::option__vector___TargetGrant____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___TargetGrant____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___TargetGrant__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___TargetGrant____>(ivy_deser &inp, s3_test::option__vector___TargetGrant____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___TargetGrant____>(ivy_ser &res, const s3_test::option__vector___TargetGrant____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___TargetGrant____& val) {
	        z3::expr z3end = g.apply("option[vector[_TargetGrant]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_TargetGrant]].value",z3val,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___TargetGrant____>( gen &g, const  z3::expr &v,s3_test::option__vector___TargetGrant____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_TargetGrant]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_TargetGrant]].value",v,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___TargetGrant____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_TargetGrant]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___TargetGrant__>(g,g.apply("option[vector[_TargetGrant]].value",v,g.int_to_z3(g.sort("option[vector[_TargetGrant]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector__string__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector__string__ _arg<s3_test::vector__string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector__string__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::string>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector__string__>(ivy_deser &inp, s3_test::vector__string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector__string__>(ivy_ser &res, const s3_test::vector__string__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector__string__& val) {
	        z3::expr z3end = g.apply("vector[string].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[string].value",z3val,g.int_to_z3(g.sort("vector[string].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector__string__>( gen &g, const  z3::expr &v,s3_test::vector__string__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[string].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[string].value",v,g.int_to_z3(g.sort("vector[string].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector__string__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[string].domain"),__sz);
                z3::expr pred =  g.apply("vector[string].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::string>(g,g.apply("vector[string].value",v,g.int_to_z3(g.sort("vector[string].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector__string____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector__string____ _arg<s3_test::option__vector__string____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector__string____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector__string__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector__string____>(ivy_deser &inp, s3_test::option__vector__string____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector__string____>(ivy_ser &res, const s3_test::option__vector__string____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector__string____& val) {
	        z3::expr z3end = g.apply("option[vector[string]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[string]].value",z3val,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector__string____>( gen &g, const  z3::expr &v,s3_test::option__vector__string____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[string]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[string]].value",v,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector__string____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[string]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[string]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector__string__>(g,g.apply("option[vector[string]].value",v,g.int_to_z3(g.sort("option[vector[string]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__integer__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__integer__ _arg<s3_test::option__integer__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__integer__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__integer__>(ivy_deser &inp, s3_test::option__integer__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__integer__>(ivy_ser &res, const s3_test::option__integer__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__integer__& val) {
	        z3::expr z3end = g.apply("option[integer].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[integer].value",z3val,g.int_to_z3(g.sort("option[integer].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__integer__>( gen &g, const  z3::expr &v,s3_test::option__integer__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[integer].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[integer].value",v,g.int_to_z3(g.sort("option[integer].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__integer__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[integer].domain_t"),__sz);
                z3::expr pred =  g.apply("option[integer].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[integer].value",v,g.int_to_z3(g.sort("option[integer].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CORSRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CORSRule__ _arg<s3_test::vector___CORSRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CORSRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CORSRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CORSRule__>(ivy_deser &inp, s3_test::vector___CORSRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CORSRule__>(ivy_ser &res, const s3_test::vector___CORSRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CORSRule__& val) {
	        z3::expr z3end = g.apply("vector[_CORSRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CORSRule].value",z3val,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CORSRule__>( gen &g, const  z3::expr &v,s3_test::vector___CORSRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CORSRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CORSRule].value",v,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CORSRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CORSRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CORSRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CORSRule>(g,g.apply("vector[_CORSRule].value",v,g.int_to_z3(g.sort("vector[_CORSRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CompletedPart__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CompletedPart__ _arg<s3_test::vector___CompletedPart__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CompletedPart__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CompletedPart>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CompletedPart__>(ivy_deser &inp, s3_test::vector___CompletedPart__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CompletedPart__>(ivy_ser &res, const s3_test::vector___CompletedPart__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CompletedPart__& val) {
	        z3::expr z3end = g.apply("vector[_CompletedPart].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CompletedPart].value",z3val,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CompletedPart__>( gen &g, const  z3::expr &v,s3_test::vector___CompletedPart__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CompletedPart].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CompletedPart].value",v,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CompletedPart__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CompletedPart].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CompletedPart>(g,g.apply("vector[_CompletedPart].value",v,g.int_to_z3(g.sort("vector[_CompletedPart].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___CompletedMultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___CompletedMultipartUpload__ _arg<s3_test::option___CompletedMultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___CompletedMultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CompletedMultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___CompletedMultipartUpload__>(ivy_deser &inp, s3_test::option___CompletedMultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___CompletedMultipartUpload__>(ivy_ser &res, const s3_test::option___CompletedMultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___CompletedMultipartUpload__& val) {
	        z3::expr z3end = g.apply("option[_CompletedMultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_CompletedMultipartUpload].value",z3val,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___CompletedMultipartUpload__>( gen &g, const  z3::expr &v,s3_test::option___CompletedMultipartUpload__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_CompletedMultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_CompletedMultipartUpload].value",v,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___CompletedMultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_CompletedMultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CompletedMultipartUpload>(g,g.apply("option[_CompletedMultipartUpload].value",v,g.int_to_z3(g.sort("option[_CompletedMultipartUpload].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__timestamp__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__timestamp__ _arg<s3_test::option__timestamp__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__timestamp__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__timestamp__>(ivy_deser &inp, s3_test::option__timestamp__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__timestamp__>(ivy_ser &res, const s3_test::option__timestamp__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__timestamp__& val) {
	        z3::expr z3end = g.apply("option[timestamp].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[timestamp].value",z3val,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__timestamp__>( gen &g, const  z3::expr &v,s3_test::option__timestamp__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[timestamp].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[timestamp].value",v,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__timestamp__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[timestamp].domain_t"),__sz);
                z3::expr pred =  g.apply("option[timestamp].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[timestamp].value",v,g.int_to_z3(g.sort("option[timestamp].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::unordered_map__string____string__ &a) {
	        s << '[';
		for (auto i = a.begin(); i != a.end(); ++i) {
		    if (i != a.begin())
		        s << ',';
		    s << '[' << i->first << ',' << i->second << ']';
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::unordered_map__string____string__ _arg<s3_test::unordered_map__string____string__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::unordered_map__string____string__ a;
	        for (unsigned i = 0; i < arg.fields.size(); i++) {
                    if (arg.fields[i].fields.size() != 2) 
	                throw out_of_bounds(idx);
		    a[_arg<s3_test::string>(arg.fields[i].fields,0,0)] = _arg<s3_test::string>(arg.fields[i].fields,1,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::unordered_map__string____string__>(ivy_deser &inp, s3_test::unordered_map__string____string__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
                    s3_test::string k;
                    s3_test::string v;
	            __deser(inp,k);
	            __deser(inp,v);
                    res[k] = v;
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::unordered_map__string____string__>(ivy_ser &res, const s3_test::unordered_map__string____string__ &inp) {
	        res.open_list(inp.size());
		for (auto i = inp.begin(); i != inp.end(); ++i) {
		    res.open_list_elem();
	            __ser(res,i->first);
	            __ser(res,i->second);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::unordered_map__string____string__& val) {

                z3::expr res = g.ctx.bool_val(true);
                z3::expr disj = g.ctx.bool_val(false);
                z3::expr v = g.ctx.constant("X",g.sort("string"));
                std::vector<z3::expr> __quants;
                __quants.push_back(v);
                for(typename s3_test::unordered_map__string____string__::iterator it=val.begin(), en = val.end(); it != en; it++){
                    z3::expr cond = __to_solver(g,v,it->first);
	            res = res && implies(cond,__to_solver(g,g.apply("unordered_map[string][string].maps",z3val,v),it->second));
                    disj = disj || cond;
                }
                res = res && forall(__quants,g.apply("unordered_map[string][string].contains",z3val,v) == disj);
                return res;
            }
            #endif        
		    std::ostream &operator <<(std::ostream &s, const s3_test::option__unordered_map__string____string____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__unordered_map__string____string____ _arg<s3_test::option__unordered_map__string____string____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__unordered_map__string____string____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::unordered_map__string____string__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__unordered_map__string____string____>(ivy_deser &inp, s3_test::option__unordered_map__string____string____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__unordered_map__string____string____>(ivy_ser &res, const s3_test::option__unordered_map__string____string____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__unordered_map__string____string____& val) {
	        z3::expr z3end = g.apply("option[unordered_map[string][string]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[unordered_map[string][string]].value",z3val,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__unordered_map__string____string____>( gen &g, const  z3::expr &v,s3_test::option__unordered_map__string____string____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[unordered_map[string][string]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[unordered_map[string][string]].value",v,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__unordered_map__string____string____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[unordered_map[string][string]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::unordered_map__string____string__>(g,g.apply("option[unordered_map[string][string]].value",v,g.int_to_z3(g.sort("option[unordered_map[string][string]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__bool__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__bool__ _arg<s3_test::option__bool__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__bool__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<bool>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__bool__>(ivy_deser &inp, s3_test::option__bool__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__bool__>(ivy_ser &res, const s3_test::option__bool__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__bool__& val) {
	        z3::expr z3end = g.apply("option[bool].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[bool].value",z3val,g.int_to_z3(g.sort("option[bool].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__bool__>( gen &g, const  z3::expr &v,s3_test::option__bool__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[bool].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[bool].value",v,g.int_to_z3(g.sort("option[bool].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__bool__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[bool].domain_t"),__sz);
                z3::expr pred =  g.apply("option[bool].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<bool>(g,g.apply("option[bool].value",v,g.int_to_z3(g.sort("option[bool].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___CreateBucketConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___CreateBucketConfiguration__ _arg<s3_test::option___CreateBucketConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___CreateBucketConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CreateBucketConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___CreateBucketConfiguration__>(ivy_deser &inp, s3_test::option___CreateBucketConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___CreateBucketConfiguration__>(ivy_ser &res, const s3_test::option___CreateBucketConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___CreateBucketConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_CreateBucketConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_CreateBucketConfiguration].value",z3val,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___CreateBucketConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___CreateBucketConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_CreateBucketConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_CreateBucketConfiguration].value",v,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___CreateBucketConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_CreateBucketConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CreateBucketConfiguration>(g,g.apply("option[_CreateBucketConfiguration].value",v,g.int_to_z3(g.sort("option[_CreateBucketConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ObjectIdentifier__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ObjectIdentifier__ _arg<s3_test::vector___ObjectIdentifier__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ObjectIdentifier__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectIdentifier>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ObjectIdentifier__>(ivy_deser &inp, s3_test::vector___ObjectIdentifier__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ObjectIdentifier__>(ivy_ser &res, const s3_test::vector___ObjectIdentifier__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ObjectIdentifier__& val) {
	        z3::expr z3end = g.apply("vector[_ObjectIdentifier].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ObjectIdentifier].value",z3val,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ObjectIdentifier__>( gen &g, const  z3::expr &v,s3_test::vector___ObjectIdentifier__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ObjectIdentifier].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ObjectIdentifier].value",v,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ObjectIdentifier__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ObjectIdentifier].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectIdentifier>(g,g.apply("vector[_ObjectIdentifier].value",v,g.int_to_z3(g.sort("vector[_ObjectIdentifier].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___DeletedObject__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___DeletedObject__ _arg<s3_test::vector___DeletedObject__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___DeletedObject__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeletedObject>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___DeletedObject__>(ivy_deser &inp, s3_test::vector___DeletedObject__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___DeletedObject__>(ivy_ser &res, const s3_test::vector___DeletedObject__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___DeletedObject__& val) {
	        z3::expr z3end = g.apply("vector[_DeletedObject].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_DeletedObject].value",z3val,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___DeletedObject__>( gen &g, const  z3::expr &v,s3_test::vector___DeletedObject__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_DeletedObject].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_DeletedObject].value",v,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___DeletedObject__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__sz);
                z3::expr pred =  g.apply("vector[_DeletedObject].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeletedObject>(g,g.apply("vector[_DeletedObject].value",v,g.int_to_z3(g.sort("vector[_DeletedObject].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Error__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Error__ _arg<s3_test::vector___Error__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Error__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Error>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Error__>(ivy_deser &inp, s3_test::vector___Error__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Error__>(ivy_ser &res, const s3_test::vector___Error__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Error__& val) {
	        z3::expr z3end = g.apply("vector[_Error].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Error].value",z3val,g.int_to_z3(g.sort("vector[_Error].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Error__>( gen &g, const  z3::expr &v,s3_test::vector___Error__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Error].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Error].value",v,g.int_to_z3(g.sort("vector[_Error].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Error__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Error].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Error].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Error>(g,g.apply("vector[_Error].value",v,g.int_to_z3(g.sort("vector[_Error].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationTimeValue__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationTimeValue__ _arg<s3_test::option___ReplicationTimeValue__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationTimeValue__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationTimeValue>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationTimeValue__>(ivy_deser &inp, s3_test::option___ReplicationTimeValue__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationTimeValue__>(ivy_ser &res, const s3_test::option___ReplicationTimeValue__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationTimeValue__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationTimeValue].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationTimeValue].value",z3val,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationTimeValue__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationTimeValue__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationTimeValue].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationTimeValue].value",v,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationTimeValue__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationTimeValue].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationTimeValue>(g,g.apply("option[_ReplicationTimeValue].value",v,g.int_to_z3(g.sort("option[_ReplicationTimeValue].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AccessControlTranslation__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AccessControlTranslation__ _arg<s3_test::option___AccessControlTranslation__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AccessControlTranslation__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AccessControlTranslation>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AccessControlTranslation__>(ivy_deser &inp, s3_test::option___AccessControlTranslation__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AccessControlTranslation__>(ivy_ser &res, const s3_test::option___AccessControlTranslation__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AccessControlTranslation__& val) {
	        z3::expr z3end = g.apply("option[_AccessControlTranslation].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AccessControlTranslation].value",z3val,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AccessControlTranslation__>( gen &g, const  z3::expr &v,s3_test::option___AccessControlTranslation__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AccessControlTranslation].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AccessControlTranslation].value",v,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AccessControlTranslation__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AccessControlTranslation].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AccessControlTranslation>(g,g.apply("option[_AccessControlTranslation].value",v,g.int_to_z3(g.sort("option[_AccessControlTranslation].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___EncryptionConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___EncryptionConfiguration__ _arg<s3_test::option___EncryptionConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___EncryptionConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_EncryptionConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___EncryptionConfiguration__>(ivy_deser &inp, s3_test::option___EncryptionConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___EncryptionConfiguration__>(ivy_ser &res, const s3_test::option___EncryptionConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___EncryptionConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_EncryptionConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_EncryptionConfiguration].value",z3val,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___EncryptionConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___EncryptionConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_EncryptionConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_EncryptionConfiguration].value",v,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___EncryptionConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_EncryptionConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_EncryptionConfiguration>(g,g.apply("option[_EncryptionConfiguration].value",v,g.int_to_z3(g.sort("option[_EncryptionConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationTime__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationTime__ _arg<s3_test::option___ReplicationTime__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationTime__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationTime>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationTime__>(ivy_deser &inp, s3_test::option___ReplicationTime__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationTime__>(ivy_ser &res, const s3_test::option___ReplicationTime__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationTime__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationTime].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationTime].value",z3val,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationTime__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationTime__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationTime].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationTime].value",v,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationTime__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationTime].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationTime>(g,g.apply("option[_ReplicationTime].value",v,g.int_to_z3(g.sort("option[_ReplicationTime].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Metrics__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Metrics__ _arg<s3_test::option___Metrics__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Metrics__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Metrics>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Metrics__>(ivy_deser &inp, s3_test::option___Metrics__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Metrics__>(ivy_ser &res, const s3_test::option___Metrics__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Metrics__& val) {
	        z3::expr z3end = g.apply("option[_Metrics].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Metrics].value",z3val,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Metrics__>( gen &g, const  z3::expr &v,s3_test::option___Metrics__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Metrics].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Metrics].value",v,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Metrics__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Metrics].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Metrics].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Metrics>(g,g.apply("option[_Metrics].value",v,g.int_to_z3(g.sort("option[_Metrics].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ServerSideEncryptionRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ServerSideEncryptionRule__ _arg<s3_test::vector___ServerSideEncryptionRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ServerSideEncryptionRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ServerSideEncryptionRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ServerSideEncryptionRule__>(ivy_deser &inp, s3_test::vector___ServerSideEncryptionRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ServerSideEncryptionRule__>(ivy_ser &res, const s3_test::vector___ServerSideEncryptionRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ServerSideEncryptionRule__& val) {
	        z3::expr z3end = g.apply("vector[_ServerSideEncryptionRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ServerSideEncryptionRule].value",z3val,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ServerSideEncryptionRule__>( gen &g, const  z3::expr &v,s3_test::vector___ServerSideEncryptionRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ServerSideEncryptionRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ServerSideEncryptionRule].value",v,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ServerSideEncryptionRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ServerSideEncryptionRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ServerSideEncryptionRule>(g,g.apply("vector[_ServerSideEncryptionRule].value",v,g.int_to_z3(g.sort("vector[_ServerSideEncryptionRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___IntelligentTieringFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___IntelligentTieringFilter__ _arg<s3_test::option___IntelligentTieringFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___IntelligentTieringFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_IntelligentTieringFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___IntelligentTieringFilter__>(ivy_deser &inp, s3_test::option___IntelligentTieringFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___IntelligentTieringFilter__>(ivy_ser &res, const s3_test::option___IntelligentTieringFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___IntelligentTieringFilter__& val) {
	        z3::expr z3end = g.apply("option[_IntelligentTieringFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_IntelligentTieringFilter].value",z3val,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___IntelligentTieringFilter__>( gen &g, const  z3::expr &v,s3_test::option___IntelligentTieringFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_IntelligentTieringFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_IntelligentTieringFilter].value",v,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___IntelligentTieringFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_IntelligentTieringFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_IntelligentTieringFilter>(g,g.apply("option[_IntelligentTieringFilter].value",v,g.int_to_z3(g.sort("option[_IntelligentTieringFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Tiering__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Tiering__ _arg<s3_test::vector___Tiering__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Tiering__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tiering>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Tiering__>(ivy_deser &inp, s3_test::vector___Tiering__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Tiering__>(ivy_ser &res, const s3_test::vector___Tiering__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Tiering__& val) {
	        z3::expr z3end = g.apply("vector[_Tiering].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Tiering].value",z3val,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Tiering__>( gen &g, const  z3::expr &v,s3_test::vector___Tiering__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Tiering].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Tiering].value",v,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Tiering__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Tiering].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Tiering].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tiering>(g,g.apply("vector[_Tiering].value",v,g.int_to_z3(g.sort("vector[_Tiering].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___InventoryEncryption__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___InventoryEncryption__ _arg<s3_test::option___InventoryEncryption__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___InventoryEncryption__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryEncryption>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___InventoryEncryption__>(ivy_deser &inp, s3_test::option___InventoryEncryption__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___InventoryEncryption__>(ivy_ser &res, const s3_test::option___InventoryEncryption__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___InventoryEncryption__& val) {
	        z3::expr z3end = g.apply("option[_InventoryEncryption].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_InventoryEncryption].value",z3val,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___InventoryEncryption__>( gen &g, const  z3::expr &v,s3_test::option___InventoryEncryption__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_InventoryEncryption].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_InventoryEncryption].value",v,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___InventoryEncryption__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_InventoryEncryption].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryEncryption>(g,g.apply("option[_InventoryEncryption].value",v,g.int_to_z3(g.sort("option[_InventoryEncryption].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___InventoryFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___InventoryFilter__ _arg<s3_test::option___InventoryFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___InventoryFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___InventoryFilter__>(ivy_deser &inp, s3_test::option___InventoryFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___InventoryFilter__>(ivy_ser &res, const s3_test::option___InventoryFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___InventoryFilter__& val) {
	        z3::expr z3end = g.apply("option[_InventoryFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_InventoryFilter].value",z3val,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___InventoryFilter__>( gen &g, const  z3::expr &v,s3_test::option___InventoryFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_InventoryFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_InventoryFilter].value",v,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___InventoryFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_InventoryFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryFilter>(g,g.apply("option[_InventoryFilter].value",v,g.int_to_z3(g.sort("option[_InventoryFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Transition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Transition__ _arg<s3_test::option___Transition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Transition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Transition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Transition__>(ivy_deser &inp, s3_test::option___Transition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Transition__>(ivy_ser &res, const s3_test::option___Transition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Transition__& val) {
	        z3::expr z3end = g.apply("option[_Transition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Transition].value",z3val,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Transition__>( gen &g, const  z3::expr &v,s3_test::option___Transition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Transition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Transition].value",v,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Transition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Transition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Transition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Transition>(g,g.apply("option[_Transition].value",v,g.int_to_z3(g.sort("option[_Transition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NoncurrentVersionTransition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NoncurrentVersionTransition__ _arg<s3_test::option___NoncurrentVersionTransition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NoncurrentVersionTransition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NoncurrentVersionTransition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NoncurrentVersionTransition__>(ivy_deser &inp, s3_test::option___NoncurrentVersionTransition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NoncurrentVersionTransition__>(ivy_ser &res, const s3_test::option___NoncurrentVersionTransition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NoncurrentVersionTransition__& val) {
	        z3::expr z3end = g.apply("option[_NoncurrentVersionTransition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NoncurrentVersionTransition].value",z3val,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v,s3_test::option___NoncurrentVersionTransition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NoncurrentVersionTransition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NoncurrentVersionTransition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NoncurrentVersionTransition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NoncurrentVersionTransition>(g,g.apply("option[_NoncurrentVersionTransition].value",v,g.int_to_z3(g.sort("option[_NoncurrentVersionTransition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Rule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Rule__ _arg<s3_test::vector___Rule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Rule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Rule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Rule__>(ivy_deser &inp, s3_test::vector___Rule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Rule__>(ivy_ser &res, const s3_test::vector___Rule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Rule__& val) {
	        z3::expr z3end = g.apply("vector[_Rule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Rule].value",z3val,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Rule__>( gen &g, const  z3::expr &v,s3_test::vector___Rule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Rule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Rule].value",v,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Rule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Rule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Rule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Rule>(g,g.apply("vector[_Rule].value",v,g.int_to_z3(g.sort("vector[_Rule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___MetricsFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___MetricsFilter__ _arg<s3_test::option___MetricsFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___MetricsFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetricsFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___MetricsFilter__>(ivy_deser &inp, s3_test::option___MetricsFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___MetricsFilter__>(ivy_ser &res, const s3_test::option___MetricsFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___MetricsFilter__& val) {
	        z3::expr z3end = g.apply("option[_MetricsFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_MetricsFilter].value",z3val,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___MetricsFilter__>( gen &g, const  z3::expr &v,s3_test::option___MetricsFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_MetricsFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_MetricsFilter].value",v,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___MetricsFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_MetricsFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetricsFilter>(g,g.apply("option[_MetricsFilter].value",v,g.int_to_z3(g.sort("option[_MetricsFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___OwnershipControlsRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___OwnershipControlsRule__ _arg<s3_test::vector___OwnershipControlsRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___OwnershipControlsRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_OwnershipControlsRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___OwnershipControlsRule__>(ivy_deser &inp, s3_test::vector___OwnershipControlsRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___OwnershipControlsRule__>(ivy_ser &res, const s3_test::vector___OwnershipControlsRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___OwnershipControlsRule__& val) {
	        z3::expr z3end = g.apply("vector[_OwnershipControlsRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_OwnershipControlsRule].value",z3val,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___OwnershipControlsRule__>( gen &g, const  z3::expr &v,s3_test::vector___OwnershipControlsRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_OwnershipControlsRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_OwnershipControlsRule].value",v,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___OwnershipControlsRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_OwnershipControlsRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_OwnershipControlsRule>(g,g.apply("vector[_OwnershipControlsRule].value",v,g.int_to_z3(g.sort("vector[_OwnershipControlsRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ReplicationRuleFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ReplicationRuleFilter__ _arg<s3_test::option___ReplicationRuleFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ReplicationRuleFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationRuleFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ReplicationRuleFilter__>(ivy_deser &inp, s3_test::option___ReplicationRuleFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ReplicationRuleFilter__>(ivy_ser &res, const s3_test::option___ReplicationRuleFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ReplicationRuleFilter__& val) {
	        z3::expr z3end = g.apply("option[_ReplicationRuleFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ReplicationRuleFilter].value",z3val,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ReplicationRuleFilter__>( gen &g, const  z3::expr &v,s3_test::option___ReplicationRuleFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ReplicationRuleFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ReplicationRuleFilter].value",v,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ReplicationRuleFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ReplicationRuleFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationRuleFilter>(g,g.apply("option[_ReplicationRuleFilter].value",v,g.int_to_z3(g.sort("option[_ReplicationRuleFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___SourceSelectionCriteria__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___SourceSelectionCriteria__ _arg<s3_test::option___SourceSelectionCriteria__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___SourceSelectionCriteria__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_SourceSelectionCriteria>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___SourceSelectionCriteria__>(ivy_deser &inp, s3_test::option___SourceSelectionCriteria__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___SourceSelectionCriteria__>(ivy_ser &res, const s3_test::option___SourceSelectionCriteria__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___SourceSelectionCriteria__& val) {
	        z3::expr z3end = g.apply("option[_SourceSelectionCriteria].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_SourceSelectionCriteria].value",z3val,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___SourceSelectionCriteria__>( gen &g, const  z3::expr &v,s3_test::option___SourceSelectionCriteria__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_SourceSelectionCriteria].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_SourceSelectionCriteria].value",v,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___SourceSelectionCriteria__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_SourceSelectionCriteria].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_SourceSelectionCriteria>(g,g.apply("option[_SourceSelectionCriteria].value",v,g.int_to_z3(g.sort("option[_SourceSelectionCriteria].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ExistingObjectReplication__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ExistingObjectReplication__ _arg<s3_test::option___ExistingObjectReplication__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ExistingObjectReplication__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ExistingObjectReplication>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ExistingObjectReplication__>(ivy_deser &inp, s3_test::option___ExistingObjectReplication__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ExistingObjectReplication__>(ivy_ser &res, const s3_test::option___ExistingObjectReplication__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ExistingObjectReplication__& val) {
	        z3::expr z3end = g.apply("option[_ExistingObjectReplication].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ExistingObjectReplication].value",z3val,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ExistingObjectReplication__>( gen &g, const  z3::expr &v,s3_test::option___ExistingObjectReplication__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ExistingObjectReplication].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ExistingObjectReplication].value",v,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ExistingObjectReplication__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ExistingObjectReplication].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ExistingObjectReplication>(g,g.apply("option[_ExistingObjectReplication].value",v,g.int_to_z3(g.sort("option[_ExistingObjectReplication].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___DeleteMarkerReplication__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___DeleteMarkerReplication__ _arg<s3_test::option___DeleteMarkerReplication__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___DeleteMarkerReplication__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeleteMarkerReplication>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___DeleteMarkerReplication__>(ivy_deser &inp, s3_test::option___DeleteMarkerReplication__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___DeleteMarkerReplication__>(ivy_ser &res, const s3_test::option___DeleteMarkerReplication__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___DeleteMarkerReplication__& val) {
	        z3::expr z3end = g.apply("option[_DeleteMarkerReplication].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_DeleteMarkerReplication].value",z3val,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___DeleteMarkerReplication__>( gen &g, const  z3::expr &v,s3_test::option___DeleteMarkerReplication__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_DeleteMarkerReplication].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_DeleteMarkerReplication].value",v,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___DeleteMarkerReplication__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_DeleteMarkerReplication].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeleteMarkerReplication>(g,g.apply("option[_DeleteMarkerReplication].value",v,g.int_to_z3(g.sort("option[_DeleteMarkerReplication].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ReplicationRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ReplicationRule__ _arg<s3_test::vector___ReplicationRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ReplicationRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ReplicationRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ReplicationRule__>(ivy_deser &inp, s3_test::vector___ReplicationRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ReplicationRule__>(ivy_ser &res, const s3_test::vector___ReplicationRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ReplicationRule__& val) {
	        z3::expr z3end = g.apply("vector[_ReplicationRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ReplicationRule].value",z3val,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ReplicationRule__>( gen &g, const  z3::expr &v,s3_test::vector___ReplicationRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ReplicationRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ReplicationRule].value",v,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ReplicationRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ReplicationRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ReplicationRule>(g,g.apply("vector[_ReplicationRule].value",v,g.int_to_z3(g.sort("vector[_ReplicationRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Condition__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Condition__ _arg<s3_test::option___Condition__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Condition__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Condition>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Condition__>(ivy_deser &inp, s3_test::option___Condition__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Condition__>(ivy_ser &res, const s3_test::option___Condition__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Condition__& val) {
	        z3::expr z3end = g.apply("option[_Condition].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Condition].value",z3val,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Condition__>( gen &g, const  z3::expr &v,s3_test::option___Condition__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Condition].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Condition].value",v,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Condition__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Condition].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Condition].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Condition>(g,g.apply("option[_Condition].value",v,g.int_to_z3(g.sort("option[_Condition].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___RoutingRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___RoutingRule__ _arg<s3_test::vector___RoutingRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___RoutingRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RoutingRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___RoutingRule__>(ivy_deser &inp, s3_test::vector___RoutingRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___RoutingRule__>(ivy_ser &res, const s3_test::vector___RoutingRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___RoutingRule__& val) {
	        z3::expr z3end = g.apply("vector[_RoutingRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_RoutingRule].value",z3val,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___RoutingRule__>( gen &g, const  z3::expr &v,s3_test::vector___RoutingRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_RoutingRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_RoutingRule].value",v,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___RoutingRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_RoutingRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RoutingRule>(g,g.apply("vector[_RoutingRule].value",v,g.int_to_z3(g.sort("vector[_RoutingRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___FilterRule__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___FilterRule__ _arg<s3_test::vector___FilterRule__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___FilterRule__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_FilterRule>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___FilterRule__>(ivy_deser &inp, s3_test::vector___FilterRule__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___FilterRule__>(ivy_ser &res, const s3_test::vector___FilterRule__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___FilterRule__& val) {
	        z3::expr z3end = g.apply("vector[_FilterRule].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_FilterRule].value",z3val,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___FilterRule__>( gen &g, const  z3::expr &v,s3_test::vector___FilterRule__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_FilterRule].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_FilterRule].value",v,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___FilterRule__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_FilterRule].domain"),__sz);
                z3::expr pred =  g.apply("vector[_FilterRule].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_FilterRule>(g,g.apply("vector[_FilterRule].value",v,g.int_to_z3(g.sort("vector[_FilterRule].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___NotificationConfigurationFilter__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___NotificationConfigurationFilter__ _arg<s3_test::option___NotificationConfigurationFilter__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___NotificationConfigurationFilter__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_NotificationConfigurationFilter>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___NotificationConfigurationFilter__>(ivy_deser &inp, s3_test::option___NotificationConfigurationFilter__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___NotificationConfigurationFilter__>(ivy_ser &res, const s3_test::option___NotificationConfigurationFilter__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___NotificationConfigurationFilter__& val) {
	        z3::expr z3end = g.apply("option[_NotificationConfigurationFilter].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_NotificationConfigurationFilter].value",z3val,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___NotificationConfigurationFilter__>( gen &g, const  z3::expr &v,s3_test::option___NotificationConfigurationFilter__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_NotificationConfigurationFilter].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_NotificationConfigurationFilter].value",v,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___NotificationConfigurationFilter__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_NotificationConfigurationFilter].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_NotificationConfigurationFilter>(g,g.apply("option[_NotificationConfigurationFilter].value",v,g.int_to_z3(g.sort("option[_NotificationConfigurationFilter].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___AnalyticsConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___AnalyticsConfiguration__ _arg<s3_test::vector___AnalyticsConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___AnalyticsConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AnalyticsConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___AnalyticsConfiguration__>(ivy_deser &inp, s3_test::vector___AnalyticsConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___AnalyticsConfiguration__>(ivy_ser &res, const s3_test::vector___AnalyticsConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___AnalyticsConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_AnalyticsConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_AnalyticsConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___AnalyticsConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___AnalyticsConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_AnalyticsConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_AnalyticsConfiguration].value",v,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___AnalyticsConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_AnalyticsConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AnalyticsConfiguration>(g,g.apply("vector[_AnalyticsConfiguration].value",v,g.int_to_z3(g.sort("vector[_AnalyticsConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___IntelligentTieringConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___IntelligentTieringConfiguration__ _arg<s3_test::vector___IntelligentTieringConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___IntelligentTieringConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_IntelligentTieringConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___IntelligentTieringConfiguration__>(ivy_deser &inp, s3_test::vector___IntelligentTieringConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___IntelligentTieringConfiguration__>(ivy_ser &res, const s3_test::vector___IntelligentTieringConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___IntelligentTieringConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_IntelligentTieringConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_IntelligentTieringConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___IntelligentTieringConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___IntelligentTieringConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_IntelligentTieringConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_IntelligentTieringConfiguration].value",v,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___IntelligentTieringConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_IntelligentTieringConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_IntelligentTieringConfiguration>(g,g.apply("vector[_IntelligentTieringConfiguration].value",v,g.int_to_z3(g.sort("vector[_IntelligentTieringConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___InventoryConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___InventoryConfiguration__ _arg<s3_test::vector___InventoryConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___InventoryConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_InventoryConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___InventoryConfiguration__>(ivy_deser &inp, s3_test::vector___InventoryConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___InventoryConfiguration__>(ivy_ser &res, const s3_test::vector___InventoryConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___InventoryConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_InventoryConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_InventoryConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___InventoryConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___InventoryConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_InventoryConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_InventoryConfiguration].value",v,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___InventoryConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_InventoryConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_InventoryConfiguration>(g,g.apply("vector[_InventoryConfiguration].value",v,g.int_to_z3(g.sort("vector[_InventoryConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MetricsConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MetricsConfiguration__ _arg<s3_test::vector___MetricsConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MetricsConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetricsConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MetricsConfiguration__>(ivy_deser &inp, s3_test::vector___MetricsConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MetricsConfiguration__>(ivy_ser &res, const s3_test::vector___MetricsConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MetricsConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_MetricsConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MetricsConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MetricsConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___MetricsConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MetricsConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MetricsConfiguration].value",v,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MetricsConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MetricsConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetricsConfiguration>(g,g.apply("vector[_MetricsConfiguration].value",v,g.int_to_z3(g.sort("vector[_MetricsConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Bucket__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Bucket__ _arg<s3_test::vector___Bucket__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Bucket__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Bucket>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Bucket__>(ivy_deser &inp, s3_test::vector___Bucket__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Bucket__>(ivy_ser &res, const s3_test::vector___Bucket__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Bucket__& val) {
	        z3::expr z3end = g.apply("vector[_Bucket].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Bucket].value",z3val,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Bucket__>( gen &g, const  z3::expr &v,s3_test::vector___Bucket__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Bucket].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Bucket].value",v,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Bucket__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Bucket].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Bucket].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Bucket>(g,g.apply("vector[_Bucket].value",v,g.int_to_z3(g.sort("vector[_Bucket].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MultipartUpload__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MultipartUpload__ _arg<s3_test::vector___MultipartUpload__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MultipartUpload__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MultipartUpload>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MultipartUpload__>(ivy_deser &inp, s3_test::vector___MultipartUpload__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MultipartUpload__>(ivy_ser &res, const s3_test::vector___MultipartUpload__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MultipartUpload__& val) {
	        z3::expr z3end = g.apply("vector[_MultipartUpload].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MultipartUpload].value",z3val,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MultipartUpload__>( gen &g, const  z3::expr &v,s3_test::vector___MultipartUpload__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MultipartUpload].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MultipartUpload].value",v,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MultipartUpload__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MultipartUpload].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MultipartUpload>(g,g.apply("vector[_MultipartUpload].value",v,g.int_to_z3(g.sort("vector[_MultipartUpload].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___CommonPrefix__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___CommonPrefix__ _arg<s3_test::vector___CommonPrefix__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___CommonPrefix__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_CommonPrefix>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___CommonPrefix__>(ivy_deser &inp, s3_test::vector___CommonPrefix__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___CommonPrefix__>(ivy_ser &res, const s3_test::vector___CommonPrefix__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___CommonPrefix__& val) {
	        z3::expr z3end = g.apply("vector[_CommonPrefix].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_CommonPrefix].value",z3val,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___CommonPrefix__>( gen &g, const  z3::expr &v,s3_test::vector___CommonPrefix__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_CommonPrefix].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_CommonPrefix].value",v,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___CommonPrefix__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__sz);
                z3::expr pred =  g.apply("vector[_CommonPrefix].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_CommonPrefix>(g,g.apply("vector[_CommonPrefix].value",v,g.int_to_z3(g.sort("vector[_CommonPrefix].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___ObjectVersion__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___ObjectVersion__ _arg<s3_test::vector___ObjectVersion__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___ObjectVersion__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectVersion>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___ObjectVersion__>(ivy_deser &inp, s3_test::vector___ObjectVersion__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___ObjectVersion__>(ivy_ser &res, const s3_test::vector___ObjectVersion__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___ObjectVersion__& val) {
	        z3::expr z3end = g.apply("vector[_ObjectVersion].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_ObjectVersion].value",z3val,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___ObjectVersion__>( gen &g, const  z3::expr &v,s3_test::vector___ObjectVersion__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_ObjectVersion].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_ObjectVersion].value",v,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___ObjectVersion__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__sz);
                z3::expr pred =  g.apply("vector[_ObjectVersion].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectVersion>(g,g.apply("vector[_ObjectVersion].value",v,g.int_to_z3(g.sort("vector[_ObjectVersion].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___DeleteMarkerEntry__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___DeleteMarkerEntry__ _arg<s3_test::vector___DeleteMarkerEntry__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___DeleteMarkerEntry__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_DeleteMarkerEntry>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___DeleteMarkerEntry__>(ivy_deser &inp, s3_test::vector___DeleteMarkerEntry__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___DeleteMarkerEntry__>(ivy_ser &res, const s3_test::vector___DeleteMarkerEntry__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___DeleteMarkerEntry__& val) {
	        z3::expr z3end = g.apply("vector[_DeleteMarkerEntry].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_DeleteMarkerEntry].value",z3val,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___DeleteMarkerEntry__>( gen &g, const  z3::expr &v,s3_test::vector___DeleteMarkerEntry__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_DeleteMarkerEntry].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_DeleteMarkerEntry].value",v,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___DeleteMarkerEntry__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__sz);
                z3::expr pred =  g.apply("vector[_DeleteMarkerEntry].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_DeleteMarkerEntry>(g,g.apply("vector[_DeleteMarkerEntry].value",v,g.int_to_z3(g.sort("vector[_DeleteMarkerEntry].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Object__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Object__ _arg<s3_test::vector___Object__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Object__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Object>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Object__>(ivy_deser &inp, s3_test::vector___Object__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Object__>(ivy_ser &res, const s3_test::vector___Object__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Object__& val) {
	        z3::expr z3end = g.apply("vector[_Object].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Object].value",z3val,g.int_to_z3(g.sort("vector[_Object].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Object__>( gen &g, const  z3::expr &v,s3_test::vector___Object__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Object].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Object].value",v,g.int_to_z3(g.sort("vector[_Object].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Object__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Object].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Object].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Object>(g,g.apply("vector[_Object].value",v,g.int_to_z3(g.sort("vector[_Object].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___Part__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___Part__ _arg<s3_test::vector___Part__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___Part__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Part>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___Part__>(ivy_deser &inp, s3_test::vector___Part__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___Part__>(ivy_ser &res, const s3_test::vector___Part__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___Part__& val) {
	        z3::expr z3end = g.apply("vector[_Part].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_Part].value",z3val,g.int_to_z3(g.sort("vector[_Part].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___Part__>( gen &g, const  z3::expr &v,s3_test::vector___Part__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_Part].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_Part].value",v,g.int_to_z3(g.sort("vector[_Part].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___Part__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_Part].domain"),__sz);
                z3::expr pred =  g.apply("vector[_Part].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Part>(g,g.apply("vector[_Part].value",v,g.int_to_z3(g.sort("vector[_Part].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___TopicConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___TopicConfiguration__ _arg<s3_test::vector___TopicConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___TopicConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_TopicConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___TopicConfiguration__>(ivy_deser &inp, s3_test::vector___TopicConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___TopicConfiguration__>(ivy_ser &res, const s3_test::vector___TopicConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___TopicConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_TopicConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_TopicConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___TopicConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___TopicConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_TopicConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_TopicConfiguration].value",v,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___TopicConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_TopicConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_TopicConfiguration>(g,g.apply("vector[_TopicConfiguration].value",v,g.int_to_z3(g.sort("vector[_TopicConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___QueueConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___QueueConfiguration__ _arg<s3_test::vector___QueueConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___QueueConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_QueueConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___QueueConfiguration__>(ivy_deser &inp, s3_test::vector___QueueConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___QueueConfiguration__>(ivy_ser &res, const s3_test::vector___QueueConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___QueueConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_QueueConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_QueueConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___QueueConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___QueueConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_QueueConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_QueueConfiguration].value",v,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___QueueConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_QueueConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_QueueConfiguration>(g,g.apply("vector[_QueueConfiguration].value",v,g.int_to_z3(g.sort("vector[_QueueConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___LambdaFunctionConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___LambdaFunctionConfiguration__ _arg<s3_test::vector___LambdaFunctionConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___LambdaFunctionConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LambdaFunctionConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___LambdaFunctionConfiguration__>(ivy_deser &inp, s3_test::vector___LambdaFunctionConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___LambdaFunctionConfiguration__>(ivy_ser &res, const s3_test::vector___LambdaFunctionConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___LambdaFunctionConfiguration__& val) {
	        z3::expr z3end = g.apply("vector[_LambdaFunctionConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_LambdaFunctionConfiguration].value",z3val,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___LambdaFunctionConfiguration__>( gen &g, const  z3::expr &v,s3_test::vector___LambdaFunctionConfiguration__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_LambdaFunctionConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_LambdaFunctionConfiguration].value",v,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___LambdaFunctionConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__sz);
                z3::expr pred =  g.apply("vector[_LambdaFunctionConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LambdaFunctionConfiguration>(g,g.apply("vector[_LambdaFunctionConfiguration].value",v,g.int_to_z3(g.sort("vector[_LambdaFunctionConfiguration].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Encryption__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Encryption__ _arg<s3_test::option___Encryption__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Encryption__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Encryption>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Encryption__>(ivy_deser &inp, s3_test::option___Encryption__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Encryption__>(ivy_ser &res, const s3_test::option___Encryption__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Encryption__& val) {
	        z3::expr z3end = g.apply("option[_Encryption].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Encryption].value",z3val,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Encryption__>( gen &g, const  z3::expr &v,s3_test::option___Encryption__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Encryption].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Encryption].value",v,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Encryption__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Encryption].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Encryption].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Encryption>(g,g.apply("option[_Encryption].value",v,g.int_to_z3(g.sort("option[_Encryption].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___Grant____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___Grant____ _arg<s3_test::option__vector___Grant____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___Grant____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___Grant__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___Grant____>(ivy_deser &inp, s3_test::option__vector___Grant____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___Grant____>(ivy_ser &res, const s3_test::option__vector___Grant____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___Grant____& val) {
	        z3::expr z3end = g.apply("option[vector[_Grant]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_Grant]].value",z3val,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___Grant____>( gen &g, const  z3::expr &v,s3_test::option__vector___Grant____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_Grant]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_Grant]].value",v,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___Grant____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_Grant]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___Grant__>(g,g.apply("option[vector[_Grant]].value",v,g.int_to_z3(g.sort("option[vector[_Grant]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___Tagging__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___Tagging__ _arg<s3_test::option___Tagging__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___Tagging__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_Tagging>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___Tagging__>(ivy_deser &inp, s3_test::option___Tagging__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___Tagging__>(ivy_ser &res, const s3_test::option___Tagging__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___Tagging__& val) {
	        z3::expr z3end = g.apply("option[_Tagging].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_Tagging].value",z3val,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___Tagging__>( gen &g, const  z3::expr &v,s3_test::option___Tagging__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_Tagging].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_Tagging].value",v,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___Tagging__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_Tagging].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_Tagging].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_Tagging>(g,g.apply("option[_Tagging].value",v,g.int_to_z3(g.sort("option[_Tagging].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::vector___MetadataEntry__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::vector___MetadataEntry__ _arg<s3_test::vector___MetadataEntry__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::vector___MetadataEntry__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_MetadataEntry>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::vector___MetadataEntry__>(ivy_deser &inp, s3_test::vector___MetadataEntry__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::vector___MetadataEntry__>(ivy_ser &res, const s3_test::vector___MetadataEntry__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::vector___MetadataEntry__& val) {
	        z3::expr z3end = g.apply("vector[_MetadataEntry].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[_MetadataEntry].value",z3val,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::vector___MetadataEntry__>( gen &g, const  z3::expr &v,s3_test::vector___MetadataEntry__ &res){
	        unsigned long long __end;
	        __from_solver(g,g.apply("vector[_MetadataEntry].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[_MetadataEntry].value",v,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::vector___MetadataEntry__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__sz);
                z3::expr pred =  g.apply("vector[_MetadataEntry].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_MetadataEntry>(g,g.apply("vector[_MetadataEntry].value",v,g.int_to_z3(g.sort("vector[_MetadataEntry].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__vector___MetadataEntry____ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__vector___MetadataEntry____ _arg<s3_test::option__vector___MetadataEntry____>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__vector___MetadataEntry____ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::vector___MetadataEntry__>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__vector___MetadataEntry____>(ivy_deser &inp, s3_test::option__vector___MetadataEntry____ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__vector___MetadataEntry____>(ivy_ser &res, const s3_test::option__vector___MetadataEntry____ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__vector___MetadataEntry____& val) {
	        z3::expr z3end = g.apply("option[vector[_MetadataEntry]].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[vector[_MetadataEntry]].value",z3val,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__vector___MetadataEntry____>( gen &g, const  z3::expr &v,s3_test::option__vector___MetadataEntry____ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[vector[_MetadataEntry]].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[vector[_MetadataEntry]].value",v,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__vector___MetadataEntry____>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__sz);
                z3::expr pred =  g.apply("option[vector[_MetadataEntry]].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::vector___MetadataEntry__>(g,g.apply("option[vector[_MetadataEntry]].value",v,g.int_to_z3(g.sort("option[vector[_MetadataEntry]].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___AccessControlPolicy__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___AccessControlPolicy__ _arg<s3_test::option___AccessControlPolicy__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___AccessControlPolicy__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_AccessControlPolicy>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___AccessControlPolicy__>(ivy_deser &inp, s3_test::option___AccessControlPolicy__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___AccessControlPolicy__>(ivy_ser &res, const s3_test::option___AccessControlPolicy__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___AccessControlPolicy__& val) {
	        z3::expr z3end = g.apply("option[_AccessControlPolicy].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_AccessControlPolicy].value",z3val,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___AccessControlPolicy__>( gen &g, const  z3::expr &v,s3_test::option___AccessControlPolicy__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_AccessControlPolicy].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_AccessControlPolicy].value",v,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___AccessControlPolicy__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_AccessControlPolicy].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_AccessControlPolicy>(g,g.apply("option[_AccessControlPolicy].value",v,g.int_to_z3(g.sort("option[_AccessControlPolicy].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___BucketLifecycleConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___BucketLifecycleConfiguration__ _arg<s3_test::option___BucketLifecycleConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___BucketLifecycleConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_BucketLifecycleConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___BucketLifecycleConfiguration__>(ivy_deser &inp, s3_test::option___BucketLifecycleConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___BucketLifecycleConfiguration__>(ivy_ser &res, const s3_test::option___BucketLifecycleConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___BucketLifecycleConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_BucketLifecycleConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_BucketLifecycleConfiguration].value",z3val,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___BucketLifecycleConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___BucketLifecycleConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_BucketLifecycleConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_BucketLifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___BucketLifecycleConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_BucketLifecycleConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_BucketLifecycleConfiguration>(g,g.apply("option[_BucketLifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_BucketLifecycleConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___LifecycleConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___LifecycleConfiguration__ _arg<s3_test::option___LifecycleConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___LifecycleConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_LifecycleConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___LifecycleConfiguration__>(ivy_deser &inp, s3_test::option___LifecycleConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___LifecycleConfiguration__>(ivy_ser &res, const s3_test::option___LifecycleConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___LifecycleConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_LifecycleConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_LifecycleConfiguration].value",z3val,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___LifecycleConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___LifecycleConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_LifecycleConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_LifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___LifecycleConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_LifecycleConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_LifecycleConfiguration>(g,g.apply("option[_LifecycleConfiguration].value",v,g.int_to_z3(g.sort("option[_LifecycleConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockLegalHold__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockLegalHold__ _arg<s3_test::option___ObjectLockLegalHold__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockLegalHold__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockLegalHold>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockLegalHold__>(ivy_deser &inp, s3_test::option___ObjectLockLegalHold__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockLegalHold__>(ivy_ser &res, const s3_test::option___ObjectLockLegalHold__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockLegalHold__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockLegalHold].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockLegalHold].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockLegalHold__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockLegalHold__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockLegalHold].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockLegalHold].value",v,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockLegalHold__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockLegalHold].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockLegalHold>(g,g.apply("option[_ObjectLockLegalHold].value",v,g.int_to_z3(g.sort("option[_ObjectLockLegalHold].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockConfiguration__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockConfiguration__ _arg<s3_test::option___ObjectLockConfiguration__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockConfiguration__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockConfiguration>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockConfiguration__>(ivy_deser &inp, s3_test::option___ObjectLockConfiguration__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockConfiguration__>(ivy_ser &res, const s3_test::option___ObjectLockConfiguration__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockConfiguration__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockConfiguration].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockConfiguration].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockConfiguration__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockConfiguration__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockConfiguration].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockConfiguration].value",v,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockConfiguration__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockConfiguration].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockConfiguration>(g,g.apply("option[_ObjectLockConfiguration].value",v,g.int_to_z3(g.sort("option[_ObjectLockConfiguration].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__blob__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__blob__ _arg<s3_test::option__blob__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__blob__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::blob>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__blob__>(ivy_deser &inp, s3_test::option__blob__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__blob__>(ivy_ser &res, const s3_test::option__blob__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__blob__& val) {
	        z3::expr z3end = g.apply("option[blob].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[blob].value",z3val,g.int_to_z3(g.sort("option[blob].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__blob__>( gen &g, const  z3::expr &v,s3_test::option__blob__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[blob].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[blob].value",v,g.int_to_z3(g.sort("option[blob].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__blob__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[blob].domain_t"),__sz);
                z3::expr pred =  g.apply("option[blob].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::blob>(g,g.apply("option[blob].value",v,g.int_to_z3(g.sort("option[blob].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option__long__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option__long__ _arg<s3_test::option__long__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option__long__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option__long__>(ivy_deser &inp, s3_test::option__long__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option__long__>(ivy_ser &res, const s3_test::option__long__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option__long__& val) {
	        z3::expr z3end = g.apply("option[long].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[long].value",z3val,g.int_to_z3(g.sort("option[long].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option__long__>( gen &g, const  z3::expr &v,s3_test::option__long__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[long].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[long].value",v,g.int_to_z3(g.sort("option[long].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option__long__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[long].domain_t"),__sz);
                z3::expr pred =  g.apply("option[long].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("option[long].value",v,g.int_to_z3(g.sort("option[long].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ObjectLockRetention__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ObjectLockRetention__ _arg<s3_test::option___ObjectLockRetention__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ObjectLockRetention__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ObjectLockRetention>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ObjectLockRetention__>(ivy_deser &inp, s3_test::option___ObjectLockRetention__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ObjectLockRetention__>(ivy_ser &res, const s3_test::option___ObjectLockRetention__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ObjectLockRetention__& val) {
	        z3::expr z3end = g.apply("option[_ObjectLockRetention].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ObjectLockRetention].value",z3val,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ObjectLockRetention__>( gen &g, const  z3::expr &v,s3_test::option___ObjectLockRetention__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ObjectLockRetention].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ObjectLockRetention].value",v,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ObjectLockRetention__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ObjectLockRetention].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ObjectLockRetention>(g,g.apply("option[_ObjectLockRetention].value",v,g.int_to_z3(g.sort("option[_ObjectLockRetention].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___RestoreRequest__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___RestoreRequest__ _arg<s3_test::option___RestoreRequest__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___RestoreRequest__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RestoreRequest>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___RestoreRequest__>(ivy_deser &inp, s3_test::option___RestoreRequest__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___RestoreRequest__>(ivy_ser &res, const s3_test::option___RestoreRequest__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___RestoreRequest__& val) {
	        z3::expr z3end = g.apply("option[_RestoreRequest].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_RestoreRequest].value",z3val,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___RestoreRequest__>( gen &g, const  z3::expr &v,s3_test::option___RestoreRequest__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_RestoreRequest].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_RestoreRequest].value",v,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___RestoreRequest__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_RestoreRequest].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RestoreRequest>(g,g.apply("option[_RestoreRequest].value",v,g.int_to_z3(g.sort("option[_RestoreRequest].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___RequestProgress__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___RequestProgress__ _arg<s3_test::option___RequestProgress__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___RequestProgress__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_RequestProgress>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___RequestProgress__>(ivy_deser &inp, s3_test::option___RequestProgress__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___RequestProgress__>(ivy_ser &res, const s3_test::option___RequestProgress__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___RequestProgress__& val) {
	        z3::expr z3end = g.apply("option[_RequestProgress].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_RequestProgress].value",z3val,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___RequestProgress__>( gen &g, const  z3::expr &v,s3_test::option___RequestProgress__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_RequestProgress].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_RequestProgress].value",v,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___RequestProgress__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_RequestProgress].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_RequestProgress>(g,g.apply("option[_RequestProgress].value",v,g.int_to_z3(g.sort("option[_RequestProgress].domain_t"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const s3_test::option___ScanRange__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    s3_test::option___ScanRange__ _arg<s3_test::option___ScanRange__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        s3_test::option___ScanRange__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<s3_test::_ScanRange>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<s3_test::option___ScanRange__>(ivy_deser &inp, s3_test::option___ScanRange__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<s3_test::option___ScanRange__>(ivy_ser &res, const s3_test::option___ScanRange__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, s3_test::option___ScanRange__& val) {
	        z3::expr z3end = g.apply("option[_ScanRange].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("option[_ScanRange].value",z3val,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<s3_test::option___ScanRange__>( gen &g, const  z3::expr &v,s3_test::option___ScanRange__ &res){
	        unsigned __end;
	        __from_solver(g,g.apply("option[_ScanRange].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("option[_ScanRange].value",v,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<s3_test::option___ScanRange__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__sz);
                z3::expr pred =  g.apply("option[_ScanRange].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<s3_test::_ScanRange>(g,g.apply("option[_ScanRange].value",v,g.int_to_z3(g.sort("option[_ScanRange].domain_t"),__i)));
	    }
	    #endif

	#include <aws/core/Aws.h>
#include <aws/s3/S3Client.h>
#include <sstream>

std::shared_ptr<Aws::IOStream> blob_to_iostream(const s3_test::blob &data) {
    Aws::String s;
    s.insert(s.begin(),data.begin(),data.end());
    Aws::IOStream *x = new Aws::StringStream(s);
    std::shared_ptr<Aws::IOStream> y(x);
    return y;
}

Aws::Map<Aws::String, Aws::String> map_to_aws(s3_test::unordered_map__string____string__ map) {
    Aws::Map<Aws::String, Aws::String> res;
    for(auto it=map.begin(), en=map.end(); it != en; ++it){
        res[it->first.c_str()] = it->second.c_str();
    }
    return res;
}

#include <aws/s3/model/AbortMultipartUploadRequest.h>
#include <aws/s3/model/CompleteMultipartUploadRequest.h>
#include <aws/s3/model/CopyObjectRequest.h>
#include <aws/s3/model/CreateBucketRequest.h>
#include <aws/s3/model/CreateMultipartUploadRequest.h>
#include <aws/s3/model/DeleteBucketRequest.h>
#include <aws/s3/model/DeleteBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketCorsRequest.h>
#include <aws/s3/model/DeleteBucketEncryptionRequest.h>
#include <aws/s3/model/DeleteBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketLifecycleRequest.h>
#include <aws/s3/model/DeleteBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/DeleteBucketOwnershipControlsRequest.h>
#include <aws/s3/model/DeleteBucketPolicyRequest.h>
#include <aws/s3/model/DeleteBucketReplicationRequest.h>
#include <aws/s3/model/DeleteBucketTaggingRequest.h>
#include <aws/s3/model/DeleteBucketWebsiteRequest.h>
#include <aws/s3/model/DeleteObjectRequest.h>
#include <aws/s3/model/DeleteObjectTaggingRequest.h>
#include <aws/s3/model/DeleteObjectsRequest.h>
#include <aws/s3/model/DeletePublicAccessBlockRequest.h>
#include <aws/s3/model/GetBucketAccelerateConfigurationRequest.h>
#include <aws/s3/model/GetBucketAclRequest.h>
#include <aws/s3/model/GetBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/GetBucketCorsRequest.h>
#include <aws/s3/model/GetBucketEncryptionRequest.h>
#include <aws/s3/model/GetBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/GetBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/GetBucketLifecycleConfigurationRequest.h>
#include <aws/s3/model/GetBucketLocationRequest.h>
#include <aws/s3/model/GetBucketLoggingRequest.h>
#include <aws/s3/model/GetBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/GetBucketNotificationConfigurationRequest.h>
#include <aws/s3/model/GetBucketOwnershipControlsRequest.h>
#include <aws/s3/model/GetBucketPolicyRequest.h>
#include <aws/s3/model/GetBucketPolicyStatusRequest.h>
#include <aws/s3/model/GetBucketReplicationRequest.h>
#include <aws/s3/model/GetBucketRequestPaymentRequest.h>
#include <aws/s3/model/GetBucketTaggingRequest.h>
#include <aws/s3/model/GetBucketVersioningRequest.h>
#include <aws/s3/model/GetBucketWebsiteRequest.h>
#include <aws/s3/model/GetObjectRequest.h>
#include <aws/s3/model/GetObjectAclRequest.h>
#include <aws/s3/model/GetObjectLegalHoldRequest.h>
#include <aws/s3/model/GetObjectLockConfigurationRequest.h>
#include <aws/s3/model/GetObjectRetentionRequest.h>
#include <aws/s3/model/GetObjectTaggingRequest.h>
#include <aws/s3/model/GetObjectTorrentRequest.h>
#include <aws/s3/model/GetPublicAccessBlockRequest.h>
#include <aws/s3/model/HeadBucketRequest.h>
#include <aws/s3/model/HeadObjectRequest.h>
#include <aws/s3/model/ListBucketAnalyticsConfigurationsRequest.h>
#include <aws/s3/model/ListBucketIntelligentTieringConfigurationsRequest.h>
#include <aws/s3/model/ListBucketInventoryConfigurationsRequest.h>
#include <aws/s3/model/ListBucketMetricsConfigurationsRequest.h>
#include <aws/s3/model/ListMultipartUploadsRequest.h>
#include <aws/s3/model/ListObjectVersionsRequest.h>
#include <aws/s3/model/ListObjectsRequest.h>
#include <aws/s3/model/ListObjectsV2Request.h>
#include <aws/s3/model/ListPartsRequest.h>
#include <aws/s3/model/PutBucketAccelerateConfigurationRequest.h>
#include <aws/s3/model/PutBucketAclRequest.h>
#include <aws/s3/model/PutBucketAnalyticsConfigurationRequest.h>
#include <aws/s3/model/PutBucketCorsRequest.h>
#include <aws/s3/model/PutBucketEncryptionRequest.h>
#include <aws/s3/model/PutBucketIntelligentTieringConfigurationRequest.h>
#include <aws/s3/model/PutBucketInventoryConfigurationRequest.h>
#include <aws/s3/model/PutBucketLifecycleConfigurationRequest.h>
#include <aws/s3/model/PutBucketLoggingRequest.h>
#include <aws/s3/model/PutBucketMetricsConfigurationRequest.h>
#include <aws/s3/model/PutBucketNotificationConfigurationRequest.h>
#include <aws/s3/model/PutBucketOwnershipControlsRequest.h>
#include <aws/s3/model/PutBucketPolicyRequest.h>
#include <aws/s3/model/PutBucketReplicationRequest.h>
#include <aws/s3/model/PutBucketRequestPaymentRequest.h>
#include <aws/s3/model/PutBucketTaggingRequest.h>
#include <aws/s3/model/PutBucketVersioningRequest.h>
#include <aws/s3/model/PutBucketWebsiteRequest.h>
#include <aws/s3/model/PutObjectRequest.h>
#include <aws/s3/model/PutObjectAclRequest.h>
#include <aws/s3/model/PutObjectLegalHoldRequest.h>
#include <aws/s3/model/PutObjectLockConfigurationRequest.h>
#include <aws/s3/model/PutObjectRetentionRequest.h>
#include <aws/s3/model/PutObjectTaggingRequest.h>
#include <aws/s3/model/PutPublicAccessBlockRequest.h>
#include <aws/s3/model/RestoreObjectRequest.h>
#include <aws/s3/model/SelectObjectContentRequest.h>
#include <aws/s3/model/UploadPartRequest.h>
#include <aws/s3/model/UploadPartCopyRequest.h>
#include <aws/s3/model/WriteGetObjectResponseRequest.h>
int s3_test::___ivy_choose(int rng,const char *name,int id) {
        std::ostringstream ss;
        ss << name << ':' << id;;
        for (unsigned i = 0; i < ___ivy_stack.size(); i++)
            ss << ':' << ___ivy_stack[i];
        return ___ivy_gen->choose(rng,ss.str().c_str());
    }
unsigned s3_test::blob__value(const blob& a, unsigned long long i){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::blob__end(const blob& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::string s3_test::option__string____value(const option__string__& a, unsigned i){
    s3_test::string val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__string____end(const option__string__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Grant s3_test::vector___Grant____value(const vector___Grant__& a, unsigned long long i){
    s3_test::_Grant val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Grant____end(const vector___Grant__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tag s3_test::vector___Tag____value(const vector___Tag__& a, unsigned long long i){
    s3_test::_Tag val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Tag____end(const vector___Tag__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AnalyticsFilter s3_test::option___AnalyticsFilter____value(const option___AnalyticsFilter__& a, unsigned i){
    s3_test::_AnalyticsFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AnalyticsFilter____end(const option___AnalyticsFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleExpiration s3_test::option___LifecycleExpiration____value(const option___LifecycleExpiration__& a, unsigned i){
    s3_test::_LifecycleExpiration val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._ExpiredObjectDeleteMarker_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleExpiration____end(const option___LifecycleExpiration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleRuleFilter s3_test::option___LifecycleRuleFilter____value(const option___LifecycleRuleFilter__& a, unsigned i){
    s3_test::_LifecycleRuleFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleRuleFilter____end(const option___LifecycleRuleFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Transition s3_test::vector___Transition____value(const vector___Transition__& a, unsigned long long i){
    s3_test::_Transition val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Transition____end(const vector___Transition__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___Transition__ s3_test::option__vector___Transition______value(const option__vector___Transition____& a, unsigned i){
    s3_test::vector___Transition__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___Transition______end(const option__vector___Transition____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionTransition s3_test::vector___NoncurrentVersionTransition____value(const vector___NoncurrentVersionTransition__& a, unsigned long long i){
    s3_test::_NoncurrentVersionTransition val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___NoncurrentVersionTransition____end(const vector___NoncurrentVersionTransition__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___NoncurrentVersionTransition__ s3_test::option__vector___NoncurrentVersionTransition______value(const option__vector___NoncurrentVersionTransition____& a, unsigned i){
    s3_test::vector___NoncurrentVersionTransition__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___NoncurrentVersionTransition______end(const option__vector___NoncurrentVersionTransition____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionExpiration s3_test::option___NoncurrentVersionExpiration____value(const option___NoncurrentVersionExpiration__& a, unsigned i){
    s3_test::_NoncurrentVersionExpiration val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NoncurrentVersionExpiration____end(const option___NoncurrentVersionExpiration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AbortIncompleteMultipartUpload s3_test::option___AbortIncompleteMultipartUpload____value(const option___AbortIncompleteMultipartUpload__& a, unsigned i){
    s3_test::_AbortIncompleteMultipartUpload val;
    val._DaysAfterInitiation_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AbortIncompleteMultipartUpload____end(const option___AbortIncompleteMultipartUpload__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleRule s3_test::vector___LifecycleRule____value(const vector___LifecycleRule__& a, unsigned long long i){
    s3_test::_LifecycleRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___LifecycleRule____end(const vector___LifecycleRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_TargetGrant s3_test::vector___TargetGrant____value(const vector___TargetGrant__& a, unsigned long long i){
    s3_test::_TargetGrant val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___TargetGrant____end(const vector___TargetGrant__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___TargetGrant__ s3_test::option__vector___TargetGrant______value(const option__vector___TargetGrant____& a, unsigned i){
    s3_test::vector___TargetGrant__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___TargetGrant______end(const option__vector___TargetGrant____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::string s3_test::vector__string____value(const vector__string__& a, unsigned long long i){
    s3_test::string val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector__string____end(const vector__string__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector__string__ s3_test::option__vector__string______value(const option__vector__string____& a, unsigned i){
    s3_test::vector__string__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector__string______end(const option__vector__string____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__integer____value(const option__integer__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__integer____end(const option__integer__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CORSRule s3_test::vector___CORSRule____value(const vector___CORSRule__& a, unsigned long long i){
    s3_test::_CORSRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CORSRule____end(const vector___CORSRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CompletedPart s3_test::vector___CompletedPart____value(const vector___CompletedPart__& a, unsigned long long i){
    s3_test::_CompletedPart val;
    val._PartNumber_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CompletedPart____end(const vector___CompletedPart__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CompletedMultipartUpload s3_test::option___CompletedMultipartUpload____value(const option___CompletedMultipartUpload__& a, unsigned i){
    s3_test::_CompletedMultipartUpload val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___CompletedMultipartUpload____end(const option___CompletedMultipartUpload__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__timestamp____value(const option__timestamp__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__timestamp____end(const option__timestamp__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::unordered_map__string____string__ s3_test::option__unordered_map__string____string______value(const option__unordered_map__string____string____& a, unsigned i){
    s3_test::unordered_map__string____string__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__unordered_map__string____string______end(const option__unordered_map__string____string____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
bool s3_test::option__bool____value(const option__bool__& a, unsigned i){
    bool val;
    val = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__bool____end(const option__bool__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CreateBucketConfiguration s3_test::option___CreateBucketConfiguration____value(const option___CreateBucketConfiguration__& a, unsigned i){
    s3_test::_CreateBucketConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___CreateBucketConfiguration____end(const option___CreateBucketConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectIdentifier s3_test::vector___ObjectIdentifier____value(const vector___ObjectIdentifier__& a, unsigned long long i){
    s3_test::_ObjectIdentifier val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ObjectIdentifier____end(const vector___ObjectIdentifier__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeletedObject s3_test::vector___DeletedObject____value(const vector___DeletedObject__& a, unsigned long long i){
    s3_test::_DeletedObject val;
    val._DeleteMarker_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___DeletedObject____end(const vector___DeletedObject__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Error s3_test::vector___Error____value(const vector___Error__& a, unsigned long long i){
    s3_test::_Error val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Error____end(const vector___Error__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationTimeValue s3_test::option___ReplicationTimeValue____value(const option___ReplicationTimeValue__& a, unsigned i){
    s3_test::_ReplicationTimeValue val;
    val._Minutes_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationTimeValue____end(const option___ReplicationTimeValue__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AccessControlTranslation s3_test::option___AccessControlTranslation____value(const option___AccessControlTranslation__& a, unsigned i){
    s3_test::_AccessControlTranslation val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AccessControlTranslation____end(const option___AccessControlTranslation__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_EncryptionConfiguration s3_test::option___EncryptionConfiguration____value(const option___EncryptionConfiguration__& a, unsigned i){
    s3_test::_EncryptionConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___EncryptionConfiguration____end(const option___EncryptionConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationTime s3_test::option___ReplicationTime____value(const option___ReplicationTime__& a, unsigned i){
    s3_test::_ReplicationTime val;
    val._Time_._Minutes_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationTime____end(const option___ReplicationTime__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Metrics s3_test::option___Metrics____value(const option___Metrics__& a, unsigned i){
    s3_test::_Metrics val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Metrics____end(const option___Metrics__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ServerSideEncryptionRule s3_test::vector___ServerSideEncryptionRule____value(const vector___ServerSideEncryptionRule__& a, unsigned long long i){
    s3_test::_ServerSideEncryptionRule val;
    val._BucketKeyEnabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ServerSideEncryptionRule____end(const vector___ServerSideEncryptionRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_IntelligentTieringFilter s3_test::option___IntelligentTieringFilter____value(const option___IntelligentTieringFilter__& a, unsigned i){
    s3_test::_IntelligentTieringFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___IntelligentTieringFilter____end(const option___IntelligentTieringFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tiering s3_test::vector___Tiering____value(const vector___Tiering__& a, unsigned long long i){
    s3_test::_Tiering val;
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Tiering____end(const vector___Tiering__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryEncryption s3_test::option___InventoryEncryption____value(const option___InventoryEncryption__& a, unsigned i){
    s3_test::_InventoryEncryption val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___InventoryEncryption____end(const option___InventoryEncryption__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryFilter s3_test::option___InventoryFilter____value(const option___InventoryFilter__& a, unsigned i){
    s3_test::_InventoryFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___InventoryFilter____end(const option___InventoryFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Transition s3_test::option___Transition____value(const option___Transition__& a, unsigned i){
    s3_test::_Transition val;
    val._Date_ = (int)___ivy_choose(0,"ret:val",0);
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Transition____end(const option___Transition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NoncurrentVersionTransition s3_test::option___NoncurrentVersionTransition____value(const option___NoncurrentVersionTransition__& a, unsigned i){
    s3_test::_NoncurrentVersionTransition val;
    val._NoncurrentDays_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NoncurrentVersionTransition____end(const option___NoncurrentVersionTransition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Rule s3_test::vector___Rule____value(const vector___Rule__& a, unsigned long long i){
    s3_test::_Rule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Rule____end(const vector___Rule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetricsFilter s3_test::option___MetricsFilter____value(const option___MetricsFilter__& a, unsigned i){
    s3_test::_MetricsFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___MetricsFilter____end(const option___MetricsFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_OwnershipControlsRule s3_test::vector___OwnershipControlsRule____value(const vector___OwnershipControlsRule__& a, unsigned long long i){
    s3_test::_OwnershipControlsRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___OwnershipControlsRule____end(const vector___OwnershipControlsRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationRuleFilter s3_test::option___ReplicationRuleFilter____value(const option___ReplicationRuleFilter__& a, unsigned i){
    s3_test::_ReplicationRuleFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ReplicationRuleFilter____end(const option___ReplicationRuleFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_SourceSelectionCriteria s3_test::option___SourceSelectionCriteria____value(const option___SourceSelectionCriteria__& a, unsigned i){
    s3_test::_SourceSelectionCriteria val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___SourceSelectionCriteria____end(const option___SourceSelectionCriteria__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ExistingObjectReplication s3_test::option___ExistingObjectReplication____value(const option___ExistingObjectReplication__& a, unsigned i){
    s3_test::_ExistingObjectReplication val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ExistingObjectReplication____end(const option___ExistingObjectReplication__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeleteMarkerReplication s3_test::option___DeleteMarkerReplication____value(const option___DeleteMarkerReplication__& a, unsigned i){
    s3_test::_DeleteMarkerReplication val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___DeleteMarkerReplication____end(const option___DeleteMarkerReplication__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ReplicationRule s3_test::vector___ReplicationRule____value(const vector___ReplicationRule__& a, unsigned long long i){
    s3_test::_ReplicationRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ReplicationRule____end(const vector___ReplicationRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Condition s3_test::option___Condition____value(const option___Condition__& a, unsigned i){
    s3_test::_Condition val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Condition____end(const option___Condition__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RoutingRule s3_test::vector___RoutingRule____value(const vector___RoutingRule__& a, unsigned long long i){
    s3_test::_RoutingRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___RoutingRule____end(const vector___RoutingRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_FilterRule s3_test::vector___FilterRule____value(const vector___FilterRule__& a, unsigned long long i){
    s3_test::_FilterRule val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___FilterRule____end(const vector___FilterRule__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_NotificationConfigurationFilter s3_test::option___NotificationConfigurationFilter____value(const option___NotificationConfigurationFilter__& a, unsigned i){
    s3_test::_NotificationConfigurationFilter val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___NotificationConfigurationFilter____end(const option___NotificationConfigurationFilter__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AnalyticsConfiguration s3_test::vector___AnalyticsConfiguration____value(const vector___AnalyticsConfiguration__& a, unsigned long long i){
    s3_test::_AnalyticsConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___AnalyticsConfiguration____end(const vector___AnalyticsConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_IntelligentTieringConfiguration s3_test::vector___IntelligentTieringConfiguration____value(const vector___IntelligentTieringConfiguration__& a, unsigned long long i){
    s3_test::_IntelligentTieringConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___IntelligentTieringConfiguration____end(const vector___IntelligentTieringConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_InventoryConfiguration s3_test::vector___InventoryConfiguration____value(const vector___InventoryConfiguration__& a, unsigned long long i){
    s3_test::_InventoryConfiguration val;
    val._IsEnabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___InventoryConfiguration____end(const vector___InventoryConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetricsConfiguration s3_test::vector___MetricsConfiguration____value(const vector___MetricsConfiguration__& a, unsigned long long i){
    s3_test::_MetricsConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MetricsConfiguration____end(const vector___MetricsConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Bucket s3_test::vector___Bucket____value(const vector___Bucket__& a, unsigned long long i){
    s3_test::_Bucket val;
    val._CreationDate_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Bucket____end(const vector___Bucket__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MultipartUpload s3_test::vector___MultipartUpload____value(const vector___MultipartUpload__& a, unsigned long long i){
    s3_test::_MultipartUpload val;
    val._Initiated_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MultipartUpload____end(const vector___MultipartUpload__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_CommonPrefix s3_test::vector___CommonPrefix____value(const vector___CommonPrefix__& a, unsigned long long i){
    s3_test::_CommonPrefix val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___CommonPrefix____end(const vector___CommonPrefix__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectVersion s3_test::vector___ObjectVersion____value(const vector___ObjectVersion__& a, unsigned long long i){
    s3_test::_ObjectVersion val;
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val._IsLatest_ = (bool)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___ObjectVersion____end(const vector___ObjectVersion__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_DeleteMarkerEntry s3_test::vector___DeleteMarkerEntry____value(const vector___DeleteMarkerEntry__& a, unsigned long long i){
    s3_test::_DeleteMarkerEntry val;
    val._IsLatest_ = (bool)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___DeleteMarkerEntry____end(const vector___DeleteMarkerEntry__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Object s3_test::vector___Object____value(const vector___Object__& a, unsigned long long i){
    s3_test::_Object val;
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Object____end(const vector___Object__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Part s3_test::vector___Part____value(const vector___Part__& a, unsigned long long i){
    s3_test::_Part val;
    val._PartNumber_ = (int)___ivy_choose(0,"ret:val",0);
    val._LastModified_ = (int)___ivy_choose(0,"ret:val",0);
    val._Size_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___Part____end(const vector___Part__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_TopicConfiguration s3_test::vector___TopicConfiguration____value(const vector___TopicConfiguration__& a, unsigned long long i){
    s3_test::_TopicConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___TopicConfiguration____end(const vector___TopicConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_QueueConfiguration s3_test::vector___QueueConfiguration____value(const vector___QueueConfiguration__& a, unsigned long long i){
    s3_test::_QueueConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___QueueConfiguration____end(const vector___QueueConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LambdaFunctionConfiguration s3_test::vector___LambdaFunctionConfiguration____value(const vector___LambdaFunctionConfiguration__& a, unsigned long long i){
    s3_test::_LambdaFunctionConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___LambdaFunctionConfiguration____end(const vector___LambdaFunctionConfiguration__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Encryption s3_test::option___Encryption____value(const option___Encryption__& a, unsigned i){
    s3_test::_Encryption val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Encryption____end(const option___Encryption__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___Grant__ s3_test::option__vector___Grant______value(const option__vector___Grant____& a, unsigned i){
    s3_test::vector___Grant__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___Grant______end(const option__vector___Grant____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_Tagging s3_test::option___Tagging____value(const option___Tagging__& a, unsigned i){
    s3_test::_Tagging val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___Tagging____end(const option___Tagging__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_MetadataEntry s3_test::vector___MetadataEntry____value(const vector___MetadataEntry__& a, unsigned long long i){
    s3_test::_MetadataEntry val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned long long s3_test::vector___MetadataEntry____end(const vector___MetadataEntry__& a){
    unsigned long long val;
    val = (unsigned long long)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::vector___MetadataEntry__ s3_test::option__vector___MetadataEntry______value(const option__vector___MetadataEntry____& a, unsigned i){
    s3_test::vector___MetadataEntry__ val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__vector___MetadataEntry______end(const option__vector___MetadataEntry____& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_AccessControlPolicy s3_test::option___AccessControlPolicy____value(const option___AccessControlPolicy__& a, unsigned i){
    s3_test::_AccessControlPolicy val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___AccessControlPolicy____end(const option___AccessControlPolicy__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_BucketLifecycleConfiguration s3_test::option___BucketLifecycleConfiguration____value(const option___BucketLifecycleConfiguration__& a, unsigned i){
    s3_test::_BucketLifecycleConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___BucketLifecycleConfiguration____end(const option___BucketLifecycleConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_LifecycleConfiguration s3_test::option___LifecycleConfiguration____value(const option___LifecycleConfiguration__& a, unsigned i){
    s3_test::_LifecycleConfiguration val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___LifecycleConfiguration____end(const option___LifecycleConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockLegalHold s3_test::option___ObjectLockLegalHold____value(const option___ObjectLockLegalHold__& a, unsigned i){
    s3_test::_ObjectLockLegalHold val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockLegalHold____end(const option___ObjectLockLegalHold__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockConfiguration s3_test::option___ObjectLockConfiguration____value(const option___ObjectLockConfiguration__& a, unsigned i){
    s3_test::_ObjectLockConfiguration val;
    val._Rule_._DefaultRetention_._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._Rule_._DefaultRetention_._Years_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockConfiguration____end(const option___ObjectLockConfiguration__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::blob s3_test::option__blob____value(const option__blob__& a, unsigned i){
    s3_test::blob val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__blob____end(const option__blob__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int s3_test::option__long____value(const option__long__& a, unsigned i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option__long____end(const option__long__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ObjectLockRetention s3_test::option___ObjectLockRetention____value(const option___ObjectLockRetention__& a, unsigned i){
    s3_test::_ObjectLockRetention val;
    val._RetainUntilDate_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ObjectLockRetention____end(const option___ObjectLockRetention__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RestoreRequest s3_test::option___RestoreRequest____value(const option___RestoreRequest__& a, unsigned i){
    s3_test::_RestoreRequest val;
    val._Days_ = (int)___ivy_choose(0,"ret:val",0);
    val._SelectParameters_._InputSerialization_._CSV_._AllowQuotedRecordDelimiter_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___RestoreRequest____end(const option___RestoreRequest__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_RequestProgress s3_test::option___RequestProgress____value(const option___RequestProgress__& a, unsigned i){
    s3_test::_RequestProgress val;
    val._Enabled_ = (bool)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___RequestProgress____end(const option___RequestProgress__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
s3_test::_ScanRange s3_test::option___ScanRange____value(const option___ScanRange__& a, unsigned i){
    s3_test::_ScanRange val;
    val._Start_ = (int)___ivy_choose(0,"ret:val",0);
    val._End_ = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
unsigned s3_test::option___ScanRange____end(const option___ScanRange__& a){
    unsigned val;
    val = (unsigned)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
void s3_test::_PutObject__request(const _PutObjectRequest& input){
    {
    
        Aws::Client::ClientConfiguration config;
        Aws::S3::S3Client s3_client(config);
        Aws::S3::Model::PutObjectRequest request;
        if (input._ACL_.size()) {
            request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
        }
        if (input._Body_.size()) {
            request.SetBody(blob_to_iostream(input._Body_[0]));
        }
        request.SetBucket(input._Bucket_.c_str());
        if (input._CacheControl_.size()) {
            request.SetCacheControl(input._CacheControl_[0].c_str());
        }
        if (input._ContentDisposition_.size()) {
            request.SetContentDisposition(input._ContentDisposition_[0].c_str());
        }
        if (input._ContentEncoding_.size()) {
            request.SetContentEncoding(input._ContentEncoding_[0].c_str());
        }
        if (input._ContentLanguage_.size()) {
            request.SetContentLanguage(input._ContentLanguage_[0].c_str());
        }
        if (input._ContentLength_.size()) {
            request.SetContentLength(input._ContentLength_[0]);
        }
        if (input._ContentMD5_.size()) {
            request.SetContentMD5(input._ContentMD5_[0].c_str());
        }
        if (input._ContentType_.size()) {
            request.SetContentType(input._ContentType_[0].c_str());
        }
        if (input._Expires_.size()) {
            request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
        }
        if (input._GrantFullControl_.size()) {
            request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
        }
        if (input._GrantRead_.size()) {
            request.SetGrantRead(input._GrantRead_[0].c_str());
        }
        if (input._GrantReadACP_.size()) {
            request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
        }
        if (input._GrantWriteACP_.size()) {
            request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
        }
        request.SetKey(input._Key_.c_str());
        if (input._Metadata_.size()) {
            request.SetMetadata(map_to_aws(input._Metadata_[0]));
        }
        if (input._ServerSideEncryption_.size()) {
            request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
        }
        if (input._StorageClass_.size()) {
            request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
        }
        if (input._WebsiteRedirectLocation_.size()) {
            request.SetWebsiteRedirectLocation(input._WebsiteRedirectLocation_[0].c_str());
        }
        if (input._SSECustomerAlgorithm_.size()) {
            request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
        }
        if (input._SSECustomerKey_.size()) {
            request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
        }
        if (input._SSECustomerKeyMD5_.size()) {
            request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
        }
        if (input._SSEKMSKeyId_.size()) {
            request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
        }
        if (input._SSEKMSEncryptionContext_.size()) {
            request.SetSSEKMSEncryptionContext(input._SSEKMSEncryptionContext_[0].c_str());
        }
        if (input._BucketKeyEnabled_.size()) {
            request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
        }
        if (input._RequestPayer_.size()) {
            request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
        }
        if (input._Tagging_.size()) {
            request.SetTagging(input._Tagging_[0].c_str());
        }
        if (input._ObjectLockMode_.size()) {
            request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
        }
        if (input._ObjectLockRetainUntilDate_.size()) {
            request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
        }
        if (input._ObjectLockLegalHoldStatus_.size()) {
            request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
        }
        if (input._ExpectedBucketOwner_.size()) {
            request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
        }
        Aws::S3::Model::PutObjectOutcome outcome = s3_client.PutObject(request);
        if (outcome.IsSuccess()) {
            auto result = outcome.GetResultWithOwnership();
            _PutObjectOutput res;
            res._Expiration_ = result.GetExpiration().c_str();
            res._ETag_ = result.GetETag().c_str();
            res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
            res._VersionId_ = result.GetVersionId().c_str();
            res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
            res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
            res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
            res._SSEKMSEncryptionContext_ = result.GetSSEKMSEncryptionContext().c_str();
            res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
            res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
            thunk___PutObject__response_PutObjectOutput(this)(res);
        }
    }
}
void s3_test::ext__get(s3_test::string bucket, s3_test::string key){
    {
        ivy_assume((bucket == the_bucket), "s3_test.ivy: line 36");
        ivy_assume((key == the_key), "s3_test.ivy: line 37");
        ivy_assume(present[s3_test::__tup__string__string(bucket,key)], "s3_test.ivy: line 38");
        {
            _GetObjectRequest loc__req;
            {
                loc__req._Bucket_ = bucket;
                loc__req._Key_ = key;
                ___ivy_stack.push_back(295);
                _GetObject__request(loc__req);
                ___ivy_stack.pop_back();
            }
        }
    }
}
            struct __thunk__0 : z3_thunk<s3_test::__tup__string__string,bool>{
                __thunk__0()  {
                }
                bool operator()(const s3_test::__tup__string__string &arg){
                    return false;
                }
                z3::expr to_z3(gen &g, const z3::expr &v){
                    z3::expr res = v == g.int_to_z3(g.sort("bool"),(int)(false));
                    return res;
                }
            };
void s3_test::__init(){
    {
        {
            present = hash_thunk<s3_test::__tup__string__string,bool>(new __thunk__0());
            the_bucket = "kenmcm-tmp1";
            the_key = "testkey";
        }
    }
}
void s3_test::_GetObject__response_GetObjectOutput(const _GetObjectOutput& val){
    __ivy_out  << "< _GetObject.response_GetObjectOutput" << "(" << val << ")" << std::endl;
    {
        ivy_assert(present[s3_test::__tup__string__string(the_bucket,the_key)], "s3_test.ivy: line 42");
        ivy_assert((contents[s3_test::__tup__string__string(the_bucket,the_key)] == val._Body_), "s3_test.ivy: line 43");
        ___ivy_stack.push_back(296);
        imp___GetObject__response_GetObjectOutput(val);
        ___ivy_stack.pop_back();
    }
}
void s3_test::imp___GetObject__response_GetObjectOutput(const _GetObjectOutput& val){
    {
    }
}
void s3_test::_GetObject__request(const _GetObjectRequest& input){
    {
    
        Aws::Client::ClientConfiguration config;
        Aws::S3::S3Client s3_client(config);
        Aws::S3::Model::GetObjectRequest request;
        request.SetBucket(input._Bucket_.c_str());
        if (input._IfMatch_.size()) {
            request.SetIfMatch(input._IfMatch_[0].c_str());
        }
        if (input._IfModifiedSince_.size()) {
            request.SetIfModifiedSince(Aws::Utils::DateTime((int64_t)input._IfModifiedSince_[0]));
        }
        if (input._IfNoneMatch_.size()) {
            request.SetIfNoneMatch(input._IfNoneMatch_[0].c_str());
        }
        if (input._IfUnmodifiedSince_.size()) {
            request.SetIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._IfUnmodifiedSince_[0]));
        }
        request.SetKey(input._Key_.c_str());
        if (input._Range_.size()) {
            request.SetRange(input._Range_[0].c_str());
        }
        if (input._ResponseCacheControl_.size()) {
            request.SetResponseCacheControl(input._ResponseCacheControl_[0].c_str());
        }
        if (input._ResponseContentDisposition_.size()) {
            request.SetResponseContentDisposition(input._ResponseContentDisposition_[0].c_str());
        }
        if (input._ResponseContentEncoding_.size()) {
            request.SetResponseContentEncoding(input._ResponseContentEncoding_[0].c_str());
        }
        if (input._ResponseContentLanguage_.size()) {
            request.SetResponseContentLanguage(input._ResponseContentLanguage_[0].c_str());
        }
        if (input._ResponseContentType_.size()) {
            request.SetResponseContentType(input._ResponseContentType_[0].c_str());
        }
        if (input._ResponseExpires_.size()) {
            request.SetResponseExpires(Aws::Utils::DateTime((int64_t)input._ResponseExpires_[0]));
        }
        if (input._VersionId_.size()) {
            request.SetVersionId(input._VersionId_[0].c_str());
        }
        if (input._SSECustomerAlgorithm_.size()) {
            request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
        }
        if (input._SSECustomerKey_.size()) {
            request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
        }
        if (input._SSECustomerKeyMD5_.size()) {
            request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
        }
        if (input._RequestPayer_.size()) {
            request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
        }
        if (input._PartNumber_.size()) {
            request.SetPartNumber(input._PartNumber_[0]);
        }
        if (input._ExpectedBucketOwner_.size()) {
            request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
        }
        Aws::S3::Model::GetObjectOutcome outcome = s3_client.GetObject(request);
        if (outcome.IsSuccess()) {
            auto result = outcome.GetResultWithOwnership();
            _GetObjectOutput res;
            res._Body_.insert(res._Body_.end(), std::istream_iterator<char>(result.GetBody()),std::istream_iterator<char>{});
            res._DeleteMarker_ = result.GetDeleteMarker();
            res._AcceptRanges_ = result.GetAcceptRanges().c_str();
            res._Expiration_ = result.GetExpiration().c_str();
            res._Restore_ = result.GetRestore().c_str();
            res._LastModified_ = result.GetLastModified().Millis();
            res._ContentLength_ = result.GetContentLength();
            res._ETag_ = result.GetETag().c_str();
            res._MissingMeta_ = result.GetMissingMeta();
            res._VersionId_ = result.GetVersionId().c_str();
            res._CacheControl_ = result.GetCacheControl().c_str();
            res._ContentDisposition_ = result.GetContentDisposition().c_str();
            res._ContentEncoding_ = result.GetContentEncoding().c_str();
            res._ContentLanguage_ = result.GetContentLanguage().c_str();
            res._ContentRange_ = result.GetContentRange().c_str();
            res._ContentType_ = result.GetContentType().c_str();
            res._Expires_ = result.GetExpires().Millis();
            res._WebsiteRedirectLocation_ = result.GetWebsiteRedirectLocation().c_str();
            res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
            for (auto it = result.GetMetadata().begin(), en = result.GetMetadata().end(); it != en; ++it) { res._Metadata_[it->first.c_str()] = it->second.c_str(); }
            res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
            res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
            res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
            res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
            res._StorageClass_ = Aws::S3::Model::StorageClassMapper::GetNameForStorageClass(result.GetStorageClass()).c_str();
            res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
            res._ReplicationStatus_ = Aws::S3::Model::ReplicationStatusMapper::GetNameForReplicationStatus(result.GetReplicationStatus()).c_str();
            res._PartsCount_ = result.GetPartsCount();
            res._TagCount_ = result.GetTagCount();
            res._ObjectLockMode_ = Aws::S3::Model::ObjectLockModeMapper::GetNameForObjectLockMode(result.GetObjectLockMode()).c_str();
            res._ObjectLockRetainUntilDate_ = result.GetObjectLockRetainUntilDate().Millis();
            res._ObjectLockLegalHoldStatus_ = Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetNameForObjectLockLegalHoldStatus(result.GetObjectLockLegalHoldStatus()).c_str();
            thunk___GetObject__response_GetObjectOutput(this)(res);
        }
    }
}
void s3_test::imp___PutObject__response_PutObjectOutput(const _PutObjectOutput& val){
    {
    }
}
void s3_test::ext__put(s3_test::string bucket, s3_test::string key, blob data){
    {
        ivy_assume((bucket == the_bucket), "s3_test.ivy: line 47");
        ivy_assume((key == the_key), "s3_test.ivy: line 48");
        present[s3_test::__tup__string__string(bucket,key)] = true;
        contents[s3_test::__tup__string__string(bucket,key)] = data;
        {
            _PutObjectRequest loc__req;
            {
                loc__req._Bucket_ = bucket;
                loc__req._Key_ = key;
                ___ivy_stack.push_back(297);
                option__blob____append(loc__req._Body_, data);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(298);
                _PutObject__request(loc__req);
                ___ivy_stack.pop_back();
            }
        }
    }
}
void s3_test::option__blob____append(option__blob__& a, const blob& v){
    {

        a.push_back(v);
    }
}
void s3_test::_PutObject__response_PutObjectOutput(const _PutObjectOutput& val){
    __ivy_out  << "< _PutObject.response_PutObjectOutput" << "(" << val << ")" << std::endl;
    ___ivy_stack.push_back(299);
    imp___PutObject__response_PutObjectOutput(val);
    ___ivy_stack.pop_back();
}
void s3_test::__tick(int __timeout){
}
s3_test::s3_test(){
#ifdef _WIN32
mutex = CreateMutex(NULL,FALSE,NULL);
#else
pthread_mutex_init(&mutex,NULL);
#endif
__lock();
    __CARD__option__vector___NoncurrentVersionTransition______domain_t = 2;
    __CARD__vector___TargetGrant____domain = 0;
    __CARD__option___ReplicationTime____domain_t = 2;
    __CARD__vector___ReplicationRule____domain = 0;
    __CARD__byte = 256;
    __CARD__option__long____domain_t = 2;
    __CARD__option___AbortIncompleteMultipartUpload____domain_t = 2;
    __CARD__option___InventoryEncryption____domain_t = 2;
    __CARD__long = 0;
    __CARD__vector___Object____domain = 0;
    __CARD__option___NoncurrentVersionExpiration____domain_t = 2;
    __CARD__vector___ObjectVersion____domain = 0;
    __CARD__option___RequestProgress____domain_t = 2;
    __CARD__option___NoncurrentVersionTransition____domain_t = 2;
    __CARD__option___Transition____domain_t = 2;
    __CARD__option___NotificationConfigurationFilter____domain_t = 2;
    __CARD__vector__string____domain = 0;
    __CARD__option___ObjectLockRetention____domain_t = 2;
    __CARD__option___MetricsFilter____domain_t = 2;
    __CARD__string = 0;
    __CARD__vector___NoncurrentVersionTransition____domain = 0;
    __CARD__timestamp = 0;
    __CARD__vector___RoutingRule____domain = 0;
    __CARD__option___ReplicationTimeValue____domain_t = 2;
    __CARD__vector___CORSRule____domain = 0;
    __CARD__vector___DeletedObject____domain = 0;
    __CARD__integer = 0;
    __CARD__vector___Bucket____domain = 0;
    __CARD__option__vector___TargetGrant______domain_t = 2;
    __CARD__vector___ObjectIdentifier____domain = 0;
    __CARD__vector___Grant____domain = 0;
    __CARD__option__vector__string______domain_t = 2;
    __CARD__vector___CompletedPart____domain = 0;
    __CARD__vector___FilterRule____domain = 0;
    __CARD__option___LifecycleRuleFilter____domain_t = 2;
    __CARD__option__unordered_map__string____string______domain_t = 2;
    __CARD__option___CompletedMultipartUpload____domain_t = 2;
    __CARD__vector___TopicConfiguration____domain = 0;
    __CARD__vector___Tiering____domain = 0;
    __CARD__vector___DeleteMarkerEntry____domain = 0;
    __CARD__option___BucketLifecycleConfiguration____domain_t = 2;
    __CARD__vector___MultipartUpload____domain = 0;
    __CARD__option___EncryptionConfiguration____domain_t = 2;
    __CARD__option___SourceSelectionCriteria____domain_t = 2;
    __CARD__option___LifecycleExpiration____domain_t = 2;
    __CARD__option___CreateBucketConfiguration____domain_t = 2;
    __CARD__option__vector___Transition______domain_t = 2;
    __CARD__vector___LambdaFunctionConfiguration____domain = 0;
    __CARD__vector___ServerSideEncryptionRule____domain = 0;
    __CARD__vector___MetricsConfiguration____domain = 0;
    __CARD__option__string____domain_t = 2;
    __CARD__vector___IntelligentTieringConfiguration____domain = 0;
    __CARD__option___ObjectLockLegalHold____domain_t = 2;
    __CARD__vector___Part____domain = 0;
    __CARD__blob__domain = 0;
    __CARD__option___Condition____domain_t = 2;
    __CARD__vector___CommonPrefix____domain = 0;
    __CARD__option___LifecycleConfiguration____domain_t = 2;
    __CARD__option__integer____domain_t = 2;
    __CARD__option___AccessControlPolicy____domain_t = 2;
    __CARD__vector___Error____domain = 0;
    __CARD__vector___Transition____domain = 0;
    __CARD__option___AccessControlTranslation____domain_t = 2;
    __CARD__vector___MetadataEntry____domain = 0;
    __CARD__vector___OwnershipControlsRule____domain = 0;
    __CARD__option___Tagging____domain_t = 2;
    __CARD__option___DeleteMarkerReplication____domain_t = 2;
    __CARD__option___ScanRange____domain_t = 2;
    __CARD__option__bool____domain_t = 2;
    __CARD__option___Encryption____domain_t = 2;
    __CARD__option___ExistingObjectReplication____domain_t = 2;
    __CARD__option___Metrics____domain_t = 2;
    __CARD__option__blob____domain_t = 2;
    __CARD__option___IntelligentTieringFilter____domain_t = 2;
    __CARD__vector___Rule____domain = 0;
    __CARD__option__vector___Grant______domain_t = 2;
    __CARD__option___ReplicationRuleFilter____domain_t = 2;
    __CARD__vector___InventoryConfiguration____domain = 0;
    __CARD__option__vector___MetadataEntry______domain_t = 2;
    __CARD__option___RestoreRequest____domain_t = 2;
    __CARD__option__timestamp____domain_t = 2;
    __CARD__option___ObjectLockConfiguration____domain_t = 2;
    __CARD__vector___LifecycleRule____domain = 0;
    __CARD__option___AnalyticsFilter____domain_t = 2;
    __CARD__vector___QueueConfiguration____domain = 0;
    __CARD__vector___AnalyticsConfiguration____domain = 0;
    __CARD__option___InventoryFilter____domain_t = 2;
    __CARD__vector___Tag____domain = 0;
    {
        Aws::SDKOptions options;
        Aws::InitAPI(options);
    }
}
s3_test::~s3_test(){
    __lock(); // otherwise, thread may die holding lock!
    for (unsigned i = 0; i < thread_ids.size(); i++){
#ifdef _WIN32
       // No idea how to cancel a thread on Windows. We just suspend it
       // so it can't cause any harm as we destruct this object.
       SuspendThread(thread_ids[i]);
#else
        pthread_cancel(thread_ids[i]);
        pthread_join(thread_ids[i],NULL);
#endif
    }
    __unlock();
}

class init_gen : public gen {
public:
    init_gen();
    bool generate(s3_test&);
    void execute(s3_test&){}
};
init_gen::init_gen(){
mk_sort("_FilterRule");
mk_sort("_Destination");
    mk_bv("option[_ReplicationTime].domain_t",1);
mk_sort("_LifecycleExpiration");
    mk_int("vector[_ReplicationRule].domain");
mk_sort("vector[_DeleteMarkerEntry]");
mk_sort("vector[_DeletedObject]");
mk_sort("vector[_ObjectVersion]");
mk_sort("_InputSerialization");
    mk_bv("option[_InventoryEncryption].domain_t",1);
    mk_bv("option[_NoncurrentVersionExpiration].domain_t",1);
    mk_bv("option[_RequestProgress].domain_t",1);
mk_sort("_OutputLocation");
mk_sort("_ReplicationRuleFilter");
mk_sort("_SSES3");
    mk_bv("option[_LifecycleExpiration].domain_t",1);
mk_sort("_ObjectLockConfiguration");
    enum_sorts.insert(std::pair<std::string, z3::sort>("string",s3_test::string::z3_sort(ctx)));
mk_sort("_Redirect");
mk_sort("_ObjectLockLegalHold");
mk_sort("option[_InventoryEncryption]");
mk_sort("option[vector[_NoncurrentVersionTransition]]");
mk_sort("_Transition");
    mk_int("vector[_FilterRule].domain");
mk_sort("_LifecycleRuleAndOperator");
    mk_int("vector[_DeleteMarkerEntry].domain");
    mk_bv("option[_LifecycleRuleFilter].domain_t",1);
mk_sort("_SSEKMS");
    mk_bv("option[_EncryptionConfiguration].domain_t",1);
mk_sort("_SelectParameters");
    mk_bv("option[_RestoreRequest].domain_t",1);
mk_sort("unordered_map[string][string]");
mk_sort("_AnalyticsExportDestination");
mk_sort("vector[_Grant]");
    mk_bv("option[_Condition].domain_t",1);
mk_sort("_DeleteMarkerEntry");
mk_sort("option[_Encryption]");
mk_sort("option[_NoncurrentVersionTransition]");
    mk_bv("option[integer].domain_t",1);
mk_sort("_Encryption");
    mk_int("vector[_MetadataEntry].domain");
    mk_bv("option[_Tagging].domain_t",1);
mk_sort("vector[_LifecycleRule]");
    mk_bv("option[bool].domain_t",1);
mk_sort("_Condition");
mk_sort("option[_NotificationConfigurationFilter]");
mk_sort("vector[_ObjectIdentifier]");
    mk_bv("option[_IntelligentTieringFilter].domain_t",1);
mk_sort("option[_CompletedMultipartUpload]");
mk_sort("_ObjectVersion");
mk_sort("_ServerSideEncryptionByDefault");
mk_sort("_Tiering");
mk_sort("option[_InventoryFilter]");
mk_sort("option[string]");
    mk_bv("option[_InventoryFilter].domain_t",1);
    mk_int("vector[_Tag].domain");
mk_sort("_JSONInput");
mk_sort("_OutputSerialization");
mk_sort("option[_EncryptionConfiguration]");
mk_sort("option[bool]");
mk_sort("_IntelligentTieringConfiguration");
    mk_bv("byte",8);
mk_sort("option[_NoncurrentVersionExpiration]");
    mk_int("vector[_ObjectVersion].domain");
mk_sort("_MetricsFilter");
    mk_bv("option[_NoncurrentVersionTransition].domain_t",1);
    mk_bv("option[_Transition].domain_t",1);
    mk_bv("option[_ObjectLockRetention].domain_t",1);
mk_sort("_StorageClassAnalysis");
mk_sort("_BucketLifecycleConfiguration");
mk_sort("_Error");
    mk_int("vector[_NoncurrentVersionTransition].domain");
    mk_bv("option[_CreateBucketConfiguration].domain_t",1);
mk_sort("_Tag");
    mk_bv("option[_ReplicationTimeValue].domain_t",1);
mk_sort("_Bucket");
mk_sort("vector[_NoncurrentVersionTransition]");
mk_sort("_DeletedObject");
    mk_int("vector[_Bucket].domain");
mk_sort("option[unordered_map[string][string]]");
mk_sort("_AnalyticsAndOperator");
mk_sort("_CreateBucketConfiguration");
mk_sort("option[_IntelligentTieringFilter]");
mk_sort("_ReplicationTime");
    mk_int("vector[string].domain");
mk_sort("option[vector[_MetadataEntry]]");
    mk_int("vector[_MultipartUpload].domain");
mk_sort("_AnalyticsFilter");
mk_sort("_Grant");
mk_sort("_S3KeyFilter");
mk_sort("_MultipartUpload");
mk_sort("option[_Metrics]");
mk_sort("_ObjectLockRule");
    mk_int("vector[_ServerSideEncryptionRule].domain");
    mk_int("vector[_MetricsConfiguration].domain");
    mk_bv("option[string].domain_t",1);
mk_sort("_DeleteMarkerReplication");
mk_sort("_RestoreRequest");
    mk_int("vector[_TargetGrant].domain");
mk_sort("vector[_AnalyticsConfiguration]");
mk_sort("option[_RestoreRequest]");
    mk_bv("option[_ObjectLockLegalHold].domain_t",1);
mk_sort("option[_Tagging]");
    mk_int("vector[_LambdaFunctionConfiguration].domain");
mk_sort("option[_DeleteMarkerReplication]");
mk_sort("option[_Condition]");
mk_sort("vector[string]");
    mk_int("vector[_OwnershipControlsRule].domain");
    mk_int("blob.domain");
mk_sort("vector[_FilterRule]");
    mk_bv("option[blob].domain_t",1);
mk_sort("_IntelligentTieringAndOperator");
mk_sort("vector[_QueueConfiguration]");
mk_sort("_GetObjectOutput");
mk_sort("_LifecycleRuleFilter");
mk_sort("_IntelligentTieringFilter");
    mk_bv("option[_ObjectLockConfiguration].domain_t",1);
mk_sort("option[_ScanRange]");
    mk_int("vector[_QueueConfiguration].domain");
mk_sort("_PutObjectOutput");
mk_sort("vector[_InventoryConfiguration]");
mk_sort("_Metrics");
    mk_bv("option[vector[_NoncurrentVersionTransition]].domain_t",1);
mk_sort("vector[_Bucket]");
mk_sort("_StorageClassAnalysisDataExport");
mk_sort("vector[_CORSRule]");
mk_sort("_AnalyticsConfiguration");
mk_sort("_CompletedMultipartUpload");
mk_sort("_ReplicaModifications");
    mk_bv("option[_AbortIncompleteMultipartUpload].domain_t",1);
mk_sort("vector[_ReplicationRule]");
    mk_int("vector[_Object].domain");
mk_sort("option[_AbortIncompleteMultipartUpload]");
mk_sort("option[_LifecycleConfiguration]");
mk_sort("blob");
mk_sort("vector[_Object]");
    mk_bv("option[_NotificationConfigurationFilter].domain_t",1);
mk_sort("option[_ObjectLockRetention]");
    mk_bv("option[_MetricsFilter].domain_t",1);
mk_sort("_Tagging");
    mk_int("timestamp");
mk_sort("_Initiator");
mk_sort("option[_AnalyticsFilter]");
mk_sort("_RoutingRule");
    mk_int("vector[_CORSRule].domain");
mk_sort("_DefaultRetention");
mk_sort("_GetObjectRequest");
mk_sort("_CompletedPart");
    mk_int("integer");
mk_sort("option[_Transition]");
    mk_bv("option[vector[_TargetGrant]].domain_t",1);
    mk_int("vector[_Grant].domain");
    mk_bv("option[vector[string]].domain_t",1);
mk_sort("_ReplicationTimeValue");
    mk_bv("option[unordered_map[string][string]].domain_t",1);
mk_sort("_MetricsAndOperator");
mk_sort("_NoncurrentVersionTransition");
mk_sort("option[_LifecycleExpiration]");
mk_sort("_LifecycleConfiguration");
mk_sort("vector[_Tiering]");
mk_sort("option[_ObjectLockLegalHold]");
mk_sort("option[_AccessControlTranslation]");
mk_sort("_Rule");
mk_sort("vector[_Rule]");
mk_sort("_InventoryEncryption");
mk_sort("_CommonPrefix");
    mk_int("vector[_Part].domain");
    mk_bv("option[_CompletedMultipartUpload].domain_t",1);
mk_sort("_InventoryS3BucketDestination");
mk_sort("_ReplicationRuleAndOperator");
    mk_bv("option[_AccessControlPolicy].domain_t",1);
    mk_int("vector[_Error].domain");
    mk_int("vector[_Transition].domain");
mk_sort("option[vector[_TargetGrant]]");
mk_sort("_PutObjectRequest");
mk_sort("_InventoryConfiguration");
mk_sort("vector[_MetadataEntry]");
    mk_bv("option[_Encryption].domain_t",1);
    mk_int("vector[_Tiering].domain");
    mk_bv("option[_DeleteMarkerReplication].domain_t",1);
mk_sort("option[vector[_Transition]]");
mk_sort("_NoncurrentVersionExpiration");
mk_sort("_ObjectLockRetention");
mk_sort("vector[_Part]");
mk_sort("vector[_Error]");
mk_sort("_NotificationConfigurationFilter");
mk_sort("_RequestProgress");
mk_sort("_JSONOutput");
mk_sort("_ObjectIdentifier");
mk_sort("vector[_TargetGrant]");
mk_sort("_S3Location");
mk_sort("_TopicConfiguration");
mk_sort("vector[_RoutingRule]");
    mk_bv("option[timestamp].domain_t",1);
mk_sort("_QueueConfiguration");
mk_sort("option[_AccessControlPolicy]");
mk_sort("_ReplicationRule");
mk_sort("vector[_ServerSideEncryptionRule]");
    mk_int("vector[_LifecycleRule].domain");
mk_sort("vector[_MetricsConfiguration]");
mk_sort("vector[_OwnershipControlsRule]");
mk_sort("_TargetGrant");
mk_sort("option[long]");
mk_sort("option[vector[_Grant]]");
mk_sort("_MetricsConfiguration");
    mk_bv("option[long].domain_t",1);
    mk_int("long");
mk_sort("option[_ReplicationTime]");
mk_sort("option[_SourceSelectionCriteria]");
mk_sort("_ExistingObjectReplication");
mk_sort("_AccessControlTranslation");
mk_sort("_GlacierJobParameters");
mk_sort("vector[_MultipartUpload]");
mk_sort("_ServerSideEncryptionRule");
    mk_int("vector[_InventoryConfiguration].domain");
mk_sort("_InventoryDestination");
    mk_int("vector[_RoutingRule].domain");
mk_sort("_AbortIncompleteMultipartUpload");
mk_sort("option[_ReplicationRuleFilter]");
    mk_int("vector[_DeletedObject].domain");
    mk_bv("option[_ReplicationRuleFilter].domain_t",1);
mk_sort("_InventorySchedule");
mk_sort("_Grantee");
    mk_int("vector[_ObjectIdentifier].domain");
mk_sort("option[_MetricsFilter]");
    mk_int("vector[_CompletedPart].domain");
mk_sort("_Part");
mk_sort("option[blob]");
mk_sort("_Object");
mk_sort("_CSVOutput");
    mk_int("vector[_TopicConfiguration].domain");
mk_sort("option[_ExistingObjectReplication]");
mk_sort("option[_BucketLifecycleConfiguration]");
mk_sort("option[_RequestProgress]");
mk_sort("_AccessControlPolicy");
    mk_bv("option[_BucketLifecycleConfiguration].domain_t",1);
mk_sort("_ParquetInput");
mk_sort("_MetadataEntry");
mk_sort("_LifecycleRule");
mk_sort("option[integer]");
    mk_bv("option[_SourceSelectionCriteria].domain_t",1);
    mk_int("vector[_IntelligentTieringConfiguration].domain");
mk_sort("_CSVInput");
mk_sort("_CORSRule");
mk_sort("option[_CreateBucketConfiguration]");
mk_sort("option[_ReplicationTimeValue]");
    mk_int("vector[_CommonPrefix].domain");
    mk_bv("option[_LifecycleConfiguration].domain_t",1);
mk_sort("vector[_Tag]");
mk_sort("option[vector[string]]");
mk_sort("_OwnershipControlsRule");
    mk_bv("option[_AccessControlTranslation].domain_t",1);
mk_sort("vector[_CommonPrefix]");
mk_sort("_SourceSelectionCriteria");
mk_sort("vector[_LambdaFunctionConfiguration]");
    mk_bv("option[_ScanRange].domain_t",1);
mk_sort("_LambdaFunctionConfiguration");
mk_sort("option[_ObjectLockConfiguration]");
    mk_bv("option[_AnalyticsFilter].domain_t",1);
    mk_bv("option[_ExistingObjectReplication].domain_t",1);
    mk_bv("option[_Metrics].domain_t",1);
mk_sort("_Owner");
    mk_bv("option[vector[_Transition]].domain_t",1);
mk_sort("vector[_CompletedPart]");
    mk_int("vector[_Rule].domain");
    mk_bv("option[vector[_Grant]].domain_t",1);
mk_sort("_ScanRange");
    mk_bv("option[vector[_MetadataEntry]].domain_t",1);
mk_sort("_EncryptionConfiguration");
mk_sort("option[_LifecycleRuleFilter]");
mk_sort("_AnalyticsS3BucketDestination");
mk_sort("vector[_Transition]");
mk_sort("vector[_TopicConfiguration]");
mk_sort("vector[_IntelligentTieringConfiguration]");
    mk_int("vector[_AnalyticsConfiguration].domain");
mk_sort("_InventoryFilter");
mk_sort("option[timestamp]");
mk_sort("_SseKmsEncryptedObjects");
    const char *_PutObjectRequest___ContentType__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentType_",1,_PutObjectRequest___ContentType__domain,"option[string]");
    const char *_SourceSelectionCriteria___ReplicaModifications__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._ReplicaModifications_",1,_SourceSelectionCriteria___ReplicaModifications__domain,"_ReplicaModifications");
    const char *_PutObjectRequest___Bucket__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Bucket_",1,_PutObjectRequest___Bucket__domain,"string");
    const char *_Bucket___CreationDate__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._CreationDate_",1,_Bucket___CreationDate__domain,"timestamp");
    const char *_InventoryConfiguration___IsEnabled__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IsEnabled_",1,_InventoryConfiguration___IsEnabled__domain,"Bool");
    const char *_Destination___StorageClass__domain[1] = {"_Destination"};
    mk_decl("_Destination._StorageClass_",1,_Destination___StorageClass__domain,"option[string]");
    const char *option__long____value_domain[2] = {"option[long]","option[long].domain_t"};
    mk_decl("option[long].value",2,option__long____value_domain,"long");
    const char *_CORSRule___AllowedOrigins__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedOrigins_",1,_CORSRule___AllowedOrigins__domain,"vector[string]");
    const char *_ObjectVersion___Size__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Size_",1,_ObjectVersion___Size__domain,"integer");
    const char *_SSEKMS___KeyId__domain[1] = {"_SSEKMS"};
    mk_decl("_SSEKMS._KeyId_",1,_SSEKMS___KeyId__domain,"string");
    const char *_FilterRule___Name__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Name_",1,_FilterRule___Name__domain,"string");
    const char *option__vector___Grant______value_domain[2] = {"option[vector[_Grant]]","option[vector[_Grant]].domain_t"};
    mk_decl("option[vector[_Grant]].value",2,option__vector___Grant______value_domain,"vector[_Grant]");
    const char *_PutObjectRequest___ObjectLockMode__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockMode_",1,_PutObjectRequest___ObjectLockMode__domain,"option[string]");
    const char *option___ObjectLockConfiguration____value_domain[2] = {"option[_ObjectLockConfiguration]","option[_ObjectLockConfiguration].domain_t"};
    mk_decl("option[_ObjectLockConfiguration].value",2,option___ObjectLockConfiguration____value_domain,"_ObjectLockConfiguration");
    const char *vector___Object____value_domain[2] = {"vector[_Object]","vector[_Object].domain"};
    mk_decl("vector[_Object].value",2,vector___Object____value_domain,"_Object");
    const char *vector___IntelligentTieringConfiguration____end_domain[1] = {"vector[_IntelligentTieringConfiguration]"};
    mk_decl("vector[_IntelligentTieringConfiguration].end",1,vector___IntelligentTieringConfiguration____end_domain,"vector[_IntelligentTieringConfiguration].domain");
    const char *_InventoryS3BucketDestination___Prefix__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Prefix_",1,_InventoryS3BucketDestination___Prefix__domain,"option[string]");
    const char *_DefaultRetention___Days__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Days_",1,_DefaultRetention___Days__domain,"integer");
    const char *_Redirect___Protocol__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._Protocol_",1,_Redirect___Protocol__domain,"string");
    const char *_MetricsFilter___Prefix__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Prefix_",1,_MetricsFilter___Prefix__domain,"string");
    const char *_LifecycleRule___AbortIncompleteMultipartUpload__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._AbortIncompleteMultipartUpload_",1,_LifecycleRule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *_InventoryConfiguration___OptionalFields__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._OptionalFields_",1,_InventoryConfiguration___OptionalFields__domain,"option[vector[string]]");
    const char *_PutObjectRequest___SSEKMSKeyId__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSKeyId_",1,_PutObjectRequest___SSEKMSKeyId__domain,"option[string]");
    const char *vector___Rule____end_domain[1] = {"vector[_Rule]"};
    mk_decl("vector[_Rule].end",1,vector___Rule____end_domain,"vector[_Rule].domain");
    const char *vector___MetadataEntry____end_domain[1] = {"vector[_MetadataEntry]"};
    mk_decl("vector[_MetadataEntry].end",1,vector___MetadataEntry____end_domain,"vector[_MetadataEntry].domain");
    const char *vector___DeletedObject____value_domain[2] = {"vector[_DeletedObject]","vector[_DeletedObject].domain"};
    mk_decl("vector[_DeletedObject].value",2,vector___DeletedObject____value_domain,"_DeletedObject");
    const char *_LambdaFunctionConfiguration___Id__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Id_",1,_LambdaFunctionConfiguration___Id__domain,"option[string]");
    const char *option___MetricsFilter____value_domain[2] = {"option[_MetricsFilter]","option[_MetricsFilter].domain_t"};
    mk_decl("option[_MetricsFilter].value",2,option___MetricsFilter____value_domain,"_MetricsFilter");
    const char *_CSVOutput___QuoteCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteCharacter_",1,_CSVOutput___QuoteCharacter__domain,"string");
    const char *_NoncurrentVersionTransition___StorageClass__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._StorageClass_",1,_NoncurrentVersionTransition___StorageClass__domain,"string");
    mk_const("the_key","string");
    const char *_OutputLocation___S3__domain[1] = {"_OutputLocation"};
    mk_decl("_OutputLocation._S3_",1,_OutputLocation___S3__domain,"_S3Location");
    const char *_MetadataEntry___Value__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Value_",1,_MetadataEntry___Value__domain,"string");
    const char *vector___Bucket____end_domain[1] = {"vector[_Bucket]"};
    mk_decl("vector[_Bucket].end",1,vector___Bucket____end_domain,"vector[_Bucket].domain");
    const char *_Metrics___Status__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._Status_",1,_Metrics___Status__domain,"string");
    const char *vector___LifecycleRule____value_domain[2] = {"vector[_LifecycleRule]","vector[_LifecycleRule].domain"};
    mk_decl("vector[_LifecycleRule].value",2,vector___LifecycleRule____value_domain,"_LifecycleRule");
    const char *option___SourceSelectionCriteria____value_domain[2] = {"option[_SourceSelectionCriteria]","option[_SourceSelectionCriteria].domain_t"};
    mk_decl("option[_SourceSelectionCriteria].value",2,option___SourceSelectionCriteria____value_domain,"_SourceSelectionCriteria");
    const char *_SelectParameters___InputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._InputSerialization_",1,_SelectParameters___InputSerialization__domain,"_InputSerialization");
    const char *option___NoncurrentVersionExpiration____value_domain[2] = {"option[_NoncurrentVersionExpiration]","option[_NoncurrentVersionExpiration].domain_t"};
    mk_decl("option[_NoncurrentVersionExpiration].value",2,option___NoncurrentVersionExpiration____value_domain,"_NoncurrentVersionExpiration");
    const char *_LambdaFunctionConfiguration___Filter__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Filter_",1,_LambdaFunctionConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_Redirect___ReplaceKeyWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyWith_",1,_Redirect___ReplaceKeyWith__domain,"string");
    const char *option___Metrics____value_domain[2] = {"option[_Metrics]","option[_Metrics].domain_t"};
    mk_decl("option[_Metrics].value",2,option___Metrics____value_domain,"_Metrics");
    const char *_CORSRule___ExposeHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ExposeHeaders_",1,_CORSRule___ExposeHeaders__domain,"option[vector[string]]");
    const char *_ServerSideEncryptionRule___BucketKeyEnabled__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._BucketKeyEnabled_",1,_ServerSideEncryptionRule___BucketKeyEnabled__domain,"Bool");
    const char *_PutObjectRequest___ContentEncoding__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentEncoding_",1,_PutObjectRequest___ContentEncoding__domain,"option[string]");
    const char *option___ObjectLockLegalHold____end_domain[1] = {"option[_ObjectLockLegalHold]"};
    mk_decl("option[_ObjectLockLegalHold].end",1,option___ObjectLockLegalHold____end_domain,"option[_ObjectLockLegalHold].domain_t");
    const char *_AnalyticsConfiguration___Id__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Id_",1,_AnalyticsConfiguration___Id__domain,"string");
    const char *vector__string____value_domain[2] = {"vector[string]","vector[string].domain"};
    mk_decl("vector[string].value",2,vector__string____value_domain,"string");
    const char *_ObjectVersion___IsLatest__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._IsLatest_",1,_ObjectVersion___IsLatest__domain,"Bool");
    const char *_GetObjectOutput___SSECustomerKeyMD5__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerKeyMD5_",1,_GetObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_GetObjectOutput___SSEKMSKeyId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSEKMSKeyId_",1,_GetObjectOutput___SSEKMSKeyId__domain,"string");
    const char *vector___ReplicationRule____value_domain[2] = {"vector[_ReplicationRule]","vector[_ReplicationRule].domain"};
    mk_decl("vector[_ReplicationRule].value",2,vector___ReplicationRule____value_domain,"_ReplicationRule");
    const char *_IntelligentTieringConfiguration___Id__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Id_",1,_IntelligentTieringConfiguration___Id__domain,"string");
    const char *_ReplicationRule___ID__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ID_",1,_ReplicationRule___ID__domain,"option[string]");
    const char *option___RequestProgress____value_domain[2] = {"option[_RequestProgress]","option[_RequestProgress].domain_t"};
    mk_decl("option[_RequestProgress].value",2,option___RequestProgress____value_domain,"_RequestProgress");
    const char *_GetObjectOutput___AcceptRanges__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._AcceptRanges_",1,_GetObjectOutput___AcceptRanges__domain,"string");
    const char *_Part___ETag__domain[1] = {"_Part"};
    mk_decl("_Part._ETag_",1,_Part___ETag__domain,"string");
    const char *_Owner___ID__domain[1] = {"_Owner"};
    mk_decl("_Owner._ID_",1,_Owner___ID__domain,"string");
    const char *vector___TopicConfiguration____end_domain[1] = {"vector[_TopicConfiguration]"};
    mk_decl("vector[_TopicConfiguration].end",1,vector___TopicConfiguration____end_domain,"vector[_TopicConfiguration].domain");
    const char *_GetObjectRequest___Key__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Key_",1,_GetObjectRequest___Key__domain,"string");
    const char *option___LifecycleExpiration____value_domain[2] = {"option[_LifecycleExpiration]","option[_LifecycleExpiration].domain_t"};
    mk_decl("option[_LifecycleExpiration].value",2,option___LifecycleExpiration____value_domain,"_LifecycleExpiration");
    const char *_S3Location___CannedACL__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._CannedACL_",1,_S3Location___CannedACL__domain,"option[string]");
    const char *_InventoryS3BucketDestination___Encryption__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Encryption_",1,_InventoryS3BucketDestination___Encryption__domain,"option[_InventoryEncryption]");
    const char *_Destination___EncryptionConfiguration__domain[1] = {"_Destination"};
    mk_decl("_Destination._EncryptionConfiguration_",1,_Destination___EncryptionConfiguration__domain,"option[_EncryptionConfiguration]");
    const char *option___ReplicationTimeValue____value_domain[2] = {"option[_ReplicationTimeValue]","option[_ReplicationTimeValue].domain_t"};
    mk_decl("option[_ReplicationTimeValue].value",2,option___ReplicationTimeValue____value_domain,"_ReplicationTimeValue");
    const char *option__blob____end_domain[1] = {"option[blob]"};
    mk_decl("option[blob].end",1,option__blob____end_domain,"option[blob].domain_t");
    const char *option__vector___Transition______end_domain[1] = {"option[vector[_Transition]]"};
    mk_decl("option[vector[_Transition]].end",1,option__vector___Transition______end_domain,"option[vector[_Transition]].domain_t");
    const char *_GetObjectRequest___Range__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Range_",1,_GetObjectRequest___Range__domain,"option[string]");
    const char *_LifecycleRule___Status__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Status_",1,_LifecycleRule___Status__domain,"string");
    const char *option___InventoryFilter____value_domain[2] = {"option[_InventoryFilter]","option[_InventoryFilter].domain_t"};
    mk_decl("option[_InventoryFilter].value",2,option___InventoryFilter____value_domain,"_InventoryFilter");
    const char *_GetObjectOutput___ETag__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ETag_",1,_GetObjectOutput___ETag__domain,"string");
    const char *_LifecycleRuleFilter___And__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._And_",1,_LifecycleRuleFilter___And__domain,"_LifecycleRuleAndOperator");
    const char *_Tag___Key__domain[1] = {"_Tag"};
    mk_decl("_Tag._Key_",1,_Tag___Key__domain,"string");
    const char *_ObjectLockRetention___RetainUntilDate__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._RetainUntilDate_",1,_ObjectLockRetention___RetainUntilDate__domain,"timestamp");
    const char *option___ObjectLockRetention____value_domain[2] = {"option[_ObjectLockRetention]","option[_ObjectLockRetention].domain_t"};
    mk_decl("option[_ObjectLockRetention].value",2,option___ObjectLockRetention____value_domain,"_ObjectLockRetention");
    const char *_LambdaFunctionConfiguration___LambdaFunctionArn__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._LambdaFunctionArn_",1,_LambdaFunctionConfiguration___LambdaFunctionArn__domain,"string");
    const char *vector___RoutingRule____value_domain[2] = {"vector[_RoutingRule]","vector[_RoutingRule].domain"};
    mk_decl("vector[_RoutingRule].value",2,vector___RoutingRule____value_domain,"_RoutingRule");
    const char *_AnalyticsFilter___And__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._And_",1,_AnalyticsFilter___And__domain,"_AnalyticsAndOperator");
    const char *vector___CommonPrefix____end_domain[1] = {"vector[_CommonPrefix]"};
    mk_decl("vector[_CommonPrefix].end",1,vector___CommonPrefix____end_domain,"vector[_CommonPrefix].domain");
    const char *option__vector__string______end_domain[1] = {"option[vector[string]]"};
    mk_decl("option[vector[string]].end",1,option__vector__string______end_domain,"option[vector[string]].domain_t");
    const char *_S3Location___Encryption__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Encryption_",1,_S3Location___Encryption__domain,"option[_Encryption]");
    const char *_CompletedPart___PartNumber__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._PartNumber_",1,_CompletedPart___PartNumber__domain,"integer");
    const char *vector___AnalyticsConfiguration____value_domain[2] = {"vector[_AnalyticsConfiguration]","vector[_AnalyticsConfiguration].domain"};
    mk_decl("vector[_AnalyticsConfiguration].value",2,vector___AnalyticsConfiguration____value_domain,"_AnalyticsConfiguration");
    const char *_GetObjectRequest___PartNumber__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._PartNumber_",1,_GetObjectRequest___PartNumber__domain,"option[integer]");
    const char *_Grantee___EmailAddress__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._EmailAddress_",1,_Grantee___EmailAddress__domain,"option[string]");
    const char *_Tiering___AccessTier__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._AccessTier_",1,_Tiering___AccessTier__domain,"string");
    const char *_S3Location___StorageClass__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._StorageClass_",1,_S3Location___StorageClass__domain,"option[string]");
    const char *_AnalyticsAndOperator___Prefix__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Prefix_",1,_AnalyticsAndOperator___Prefix__domain,"string");
    const char *_ObjectLockConfiguration___ObjectLockEnabled__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._ObjectLockEnabled_",1,_ObjectLockConfiguration___ObjectLockEnabled__domain,"string");
    const char *option___Encryption____value_domain[2] = {"option[_Encryption]","option[_Encryption].domain_t"};
    mk_decl("option[_Encryption].value",2,option___Encryption____value_domain,"_Encryption");
    const char *_ReplicationRuleFilter___Tag__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Tag_",1,_ReplicationRuleFilter___Tag__domain,"_Tag");
    const char *_Error___Key__domain[1] = {"_Error"};
    mk_decl("_Error._Key_",1,_Error___Key__domain,"string");
    const char *_ObjectVersion___VersionId__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._VersionId_",1,_ObjectVersion___VersionId__domain,"string");
    const char *_RestoreRequest___Tier__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Tier_",1,_RestoreRequest___Tier__domain,"string");
    const char *_GetObjectOutput___ContentRange__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentRange_",1,_GetObjectOutput___ContentRange__domain,"string");
    const char *_DeletedObject___Key__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._Key_",1,_DeletedObject___Key__domain,"string");
    const char *option___LifecycleConfiguration____value_domain[2] = {"option[_LifecycleConfiguration]","option[_LifecycleConfiguration].domain_t"};
    mk_decl("option[_LifecycleConfiguration].value",2,option___LifecycleConfiguration____value_domain,"_LifecycleConfiguration");
    const char *_GetObjectRequest___ExpectedBucketOwner__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ExpectedBucketOwner_",1,_GetObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_LifecycleRule___NoncurrentVersionExpiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionExpiration_",1,_LifecycleRule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *option___CreateBucketConfiguration____value_domain[2] = {"option[_CreateBucketConfiguration]","option[_CreateBucketConfiguration].domain_t"};
    mk_decl("option[_CreateBucketConfiguration].value",2,option___CreateBucketConfiguration____value_domain,"_CreateBucketConfiguration");
    const char *vector___Tiering____end_domain[1] = {"vector[_Tiering]"};
    mk_decl("vector[_Tiering].end",1,vector___Tiering____end_domain,"vector[_Tiering].domain");
    const char *_NoncurrentVersionExpiration___NoncurrentDays__domain[1] = {"_NoncurrentVersionExpiration"};
    mk_decl("_NoncurrentVersionExpiration._NoncurrentDays_",1,_NoncurrentVersionExpiration___NoncurrentDays__domain,"integer");
    const char *_RequestProgress___Enabled__domain[1] = {"_RequestProgress"};
    mk_decl("_RequestProgress._Enabled_",1,_RequestProgress___Enabled__domain,"Bool");
    const char *_StorageClassAnalysis___DataExport__domain[1] = {"_StorageClassAnalysis"};
    mk_decl("_StorageClassAnalysis._DataExport_",1,_StorageClassAnalysis___DataExport__domain,"_StorageClassAnalysisDataExport");
    const char *option__string____end_domain[1] = {"option[string]"};
    mk_decl("option[string].end",1,option__string____end_domain,"option[string].domain_t");
    const char *_GetObjectRequest___SSECustomerKey__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKey_",1,_GetObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_SourceSelectionCriteria___SseKmsEncryptedObjects__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._SseKmsEncryptedObjects_",1,_SourceSelectionCriteria___SseKmsEncryptedObjects__domain,"_SseKmsEncryptedObjects");
    const char *vector___Part____end_domain[1] = {"vector[_Part]"};
    mk_decl("vector[_Part].end",1,vector___Part____end_domain,"vector[_Part].domain");
    const char *option___LifecycleConfiguration____end_domain[1] = {"option[_LifecycleConfiguration]"};
    mk_decl("option[_LifecycleConfiguration].end",1,option___LifecycleConfiguration____end_domain,"option[_LifecycleConfiguration].domain_t");
    const char *option___LifecycleRuleFilter____value_domain[2] = {"option[_LifecycleRuleFilter]","option[_LifecycleRuleFilter].domain_t"};
    mk_decl("option[_LifecycleRuleFilter].value",2,option___LifecycleRuleFilter____value_domain,"_LifecycleRuleFilter");
    const char *option___CompletedMultipartUpload____value_domain[2] = {"option[_CompletedMultipartUpload]","option[_CompletedMultipartUpload].domain_t"};
    mk_decl("option[_CompletedMultipartUpload].value",2,option___CompletedMultipartUpload____value_domain,"_CompletedMultipartUpload");
    const char *_CompletedMultipartUpload___Parts__domain[1] = {"_CompletedMultipartUpload"};
    mk_decl("_CompletedMultipartUpload._Parts_",1,_CompletedMultipartUpload___Parts__domain,"vector[_CompletedPart]");
    const char *_ReplicationRuleFilter___And__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._And_",1,_ReplicationRuleFilter___And__domain,"_ReplicationRuleAndOperator");
    const char *_GetObjectOutput___ObjectLockLegalHoldStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockLegalHoldStatus_",1,_GetObjectOutput___ObjectLockLegalHoldStatus__domain,"string");
    const char *_Object___LastModified__domain[1] = {"_Object"};
    mk_decl("_Object._LastModified_",1,_Object___LastModified__domain,"timestamp");
    const char *_PutObjectRequest___ContentDisposition__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentDisposition_",1,_PutObjectRequest___ContentDisposition__domain,"option[string]");
    const char *_Grant___Permission__domain[1] = {"_Grant"};
    mk_decl("_Grant._Permission_",1,_Grant___Permission__domain,"string");
    const char *_QueueConfiguration___QueueArn__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._QueueArn_",1,_QueueConfiguration___QueueArn__domain,"string");
    const char *_GetObjectOutput___ObjectLockRetainUntilDate__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockRetainUntilDate_",1,_GetObjectOutput___ObjectLockRetainUntilDate__domain,"timestamp");
    const char *option___SourceSelectionCriteria____end_domain[1] = {"option[_SourceSelectionCriteria]"};
    mk_decl("option[_SourceSelectionCriteria].end",1,option___SourceSelectionCriteria____end_domain,"option[_SourceSelectionCriteria].domain_t");
    const char *_ObjectVersion___LastModified__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._LastModified_",1,_ObjectVersion___LastModified__domain,"timestamp");
    const char *_TopicConfiguration___TopicArn__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._TopicArn_",1,_TopicConfiguration___TopicArn__domain,"string");
    const char *option___ExistingObjectReplication____end_domain[1] = {"option[_ExistingObjectReplication]"};
    mk_decl("option[_ExistingObjectReplication].end",1,option___ExistingObjectReplication____end_domain,"option[_ExistingObjectReplication].domain_t");
    const char *_GetObjectRequest___ResponseContentType__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentType_",1,_GetObjectRequest___ResponseContentType__domain,"option[string]");
    const char *vector___Tiering____value_domain[2] = {"vector[_Tiering]","vector[_Tiering].domain"};
    mk_decl("vector[_Tiering].value",2,vector___Tiering____value_domain,"_Tiering");
    const char *_RestoreRequest___Description__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Description_",1,_RestoreRequest___Description__domain,"string");
    const char *_ScanRange___End__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._End_",1,_ScanRange___End__domain,"long");
    const char *_PutObjectRequest___Tagging__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Tagging_",1,_PutObjectRequest___Tagging__domain,"option[string]");
    const char *vector___ServerSideEncryptionRule____value_domain[2] = {"vector[_ServerSideEncryptionRule]","vector[_ServerSideEncryptionRule].domain"};
    mk_decl("vector[_ServerSideEncryptionRule].value",2,vector___ServerSideEncryptionRule____value_domain,"_ServerSideEncryptionRule");
    const char *_PutObjectRequest___WebsiteRedirectLocation__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._WebsiteRedirectLocation_",1,_PutObjectRequest___WebsiteRedirectLocation__domain,"option[string]");
    const char *vector___Transition____value_domain[2] = {"vector[_Transition]","vector[_Transition].domain"};
    mk_decl("vector[_Transition].value",2,vector___Transition____value_domain,"_Transition");
    const char *_Rule___Prefix__domain[1] = {"_Rule"};
    mk_decl("_Rule._Prefix_",1,_Rule___Prefix__domain,"string");
    const char *option___Tagging____value_domain[2] = {"option[_Tagging]","option[_Tagging].domain_t"};
    mk_decl("option[_Tagging].value",2,option___Tagging____value_domain,"_Tagging");
    const char *option___AccessControlPolicy____end_domain[1] = {"option[_AccessControlPolicy]"};
    mk_decl("option[_AccessControlPolicy].end",1,option___AccessControlPolicy____end_domain,"option[_AccessControlPolicy].domain_t");
    const char *_TargetGrant___Grantee__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Grantee_",1,_TargetGrant___Grantee__domain,"_Grantee");
    const char *_Rule___NoncurrentVersionExpiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionExpiration_",1,_Rule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain[1] = {"_AbortIncompleteMultipartUpload"};
    mk_decl("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",1,_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain,"integer");
    const char *option__unordered_map__string____string______end_domain[1] = {"option[unordered_map[string][string]]"};
    mk_decl("option[unordered_map[string][string]].end",1,option__unordered_map__string____string______end_domain,"option[unordered_map[string][string]].domain_t");
    const char *_PutObjectOutput___RequestCharged__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._RequestCharged_",1,_PutObjectOutput___RequestCharged__domain,"string");
    const char *_InventoryEncryption___SSES3__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSES3_",1,_InventoryEncryption___SSES3__domain,"_SSES3");
    const char *_Redirect___HostName__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HostName_",1,_Redirect___HostName__domain,"string");
    const char *option___AnalyticsFilter____value_domain[2] = {"option[_AnalyticsFilter]","option[_AnalyticsFilter].domain_t"};
    mk_decl("option[_AnalyticsFilter].value",2,option___AnalyticsFilter____value_domain,"_AnalyticsFilter");
    const char *option___EncryptionConfiguration____value_domain[2] = {"option[_EncryptionConfiguration]","option[_EncryptionConfiguration].domain_t"};
    mk_decl("option[_EncryptionConfiguration].value",2,option___EncryptionConfiguration____value_domain,"_EncryptionConfiguration");
    const char *_Condition___KeyPrefixEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._KeyPrefixEquals_",1,_Condition___KeyPrefixEquals__domain,"string");
    const char *_GetObjectRequest___ResponseContentEncoding__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentEncoding_",1,_GetObjectRequest___ResponseContentEncoding__domain,"option[string]");
    const char *_CSVInput___AllowQuotedRecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._AllowQuotedRecordDelimiter_",1,_CSVInput___AllowQuotedRecordDelimiter__domain,"Bool");
    const char *option___RestoreRequest____end_domain[1] = {"option[_RestoreRequest]"};
    mk_decl("option[_RestoreRequest].end",1,option___RestoreRequest____end_domain,"option[_RestoreRequest].domain_t");
    const char *_JSONInput___Type__domain[1] = {"_JSONInput"};
    mk_decl("_JSONInput._Type_",1,_JSONInput___Type__domain,"string");
    const char *_LifecycleExpiration___Days__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Days_",1,_LifecycleExpiration___Days__domain,"integer");
    const char *_GetObjectOutput___ReplicationStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ReplicationStatus_",1,_GetObjectOutput___ReplicationStatus__domain,"string");
    const char *option__vector___NoncurrentVersionTransition______end_domain[1] = {"option[vector[_NoncurrentVersionTransition]]"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].end",1,option__vector___NoncurrentVersionTransition______end_domain,"option[vector[_NoncurrentVersionTransition]].domain_t");
    const char *_MultipartUpload___StorageClass__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._StorageClass_",1,_MultipartUpload___StorageClass__domain,"string");
    const char *_InventoryDestination___S3BucketDestination__domain[1] = {"_InventoryDestination"};
    mk_decl("_InventoryDestination._S3BucketDestination_",1,_InventoryDestination___S3BucketDestination__domain,"_InventoryS3BucketDestination");
    const char *option___NotificationConfigurationFilter____value_domain[2] = {"option[_NotificationConfigurationFilter]","option[_NotificationConfigurationFilter].domain_t"};
    mk_decl("option[_NotificationConfigurationFilter].value",2,option___NotificationConfigurationFilter____value_domain,"_NotificationConfigurationFilter");
    const char *option__blob____value_domain[2] = {"option[blob]","option[blob].domain_t"};
    mk_decl("option[blob].value",2,option__blob____value_domain,"blob");
    const char *_GetObjectOutput___ContentLanguage__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLanguage_",1,_GetObjectOutput___ContentLanguage__domain,"string");
    const char *_InventoryS3BucketDestination___AccountId__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._AccountId_",1,_InventoryS3BucketDestination___AccountId__domain,"option[string]");
    const char *_ReplicationRule___ExistingObjectReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ExistingObjectReplication_",1,_ReplicationRule___ExistingObjectReplication__domain,"option[_ExistingObjectReplication]");
    const char *_StorageClassAnalysisDataExport___Destination__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._Destination_",1,_StorageClassAnalysisDataExport___Destination__domain,"_AnalyticsExportDestination");
    const char *_RestoreRequest___Days__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Days_",1,_RestoreRequest___Days__domain,"integer");
    const char *_ObjectVersion___StorageClass__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._StorageClass_",1,_ObjectVersion___StorageClass__domain,"string");
    const char *_CSVInput___FileHeaderInfo__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FileHeaderInfo_",1,_CSVInput___FileHeaderInfo__domain,"string");
    const char *option___AccessControlPolicy____value_domain[2] = {"option[_AccessControlPolicy]","option[_AccessControlPolicy].domain_t"};
    mk_decl("option[_AccessControlPolicy].value",2,option___AccessControlPolicy____value_domain,"_AccessControlPolicy");
    const char *_LifecycleRule___Prefix__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Prefix_",1,_LifecycleRule___Prefix__domain,"option[string]");
    const char *option___InventoryEncryption____end_domain[1] = {"option[_InventoryEncryption]"};
    mk_decl("option[_InventoryEncryption].end",1,option___InventoryEncryption____end_domain,"option[_InventoryEncryption].domain_t");
    const char *_AnalyticsS3BucketDestination___Bucket__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Bucket_",1,_AnalyticsS3BucketDestination___Bucket__domain,"string");
    const char *_CORSRule___AllowedMethods__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedMethods_",1,_CORSRule___AllowedMethods__domain,"vector[string]");
    const char *_OutputSerialization___CSV__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._CSV_",1,_OutputSerialization___CSV__domain,"_CSVOutput");
    const char *_GetObjectRequest___SSECustomerKeyMD5__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKeyMD5_",1,_GetObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Destination___ReplicationTime__domain[1] = {"_Destination"};
    mk_decl("_Destination._ReplicationTime_",1,_Destination___ReplicationTime__domain,"option[_ReplicationTime]");
    const char *_Redirect___HttpRedirectCode__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HttpRedirectCode_",1,_Redirect___HttpRedirectCode__domain,"string");
    const char *_Encryption___KMSKeyId__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSKeyId_",1,_Encryption___KMSKeyId__domain,"option[string]");
    const char *_RestoreRequest___GlacierJobParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._GlacierJobParameters_",1,_RestoreRequest___GlacierJobParameters__domain,"_GlacierJobParameters");
    const char *_PutObjectOutput___ServerSideEncryption__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ServerSideEncryption_",1,_PutObjectOutput___ServerSideEncryption__domain,"string");
    const char *_CommonPrefix___Prefix__domain[1] = {"_CommonPrefix"};
    mk_decl("_CommonPrefix._Prefix_",1,_CommonPrefix___Prefix__domain,"string");
    const char *_InventoryConfiguration___Destination__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Destination_",1,_InventoryConfiguration___Destination__domain,"_InventoryDestination");
    const char *_DeletedObject___VersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._VersionId_",1,_DeletedObject___VersionId__domain,"string");
    const char *_S3Location___BucketName__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._BucketName_",1,_S3Location___BucketName__domain,"string");
    const char *_ReplicationTime___Time__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Time_",1,_ReplicationTime___Time__domain,"_ReplicationTimeValue");
    const char *_GetObjectOutput___Body__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Body_",1,_GetObjectOutput___Body__domain,"blob");
    const char *_TargetGrant___Permission__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Permission_",1,_TargetGrant___Permission__domain,"string");
    const char *_Grant___Grantee__domain[1] = {"_Grant"};
    mk_decl("_Grant._Grantee_",1,_Grant___Grantee__domain,"_Grantee");
    const char *option___AbortIncompleteMultipartUpload____value_domain[2] = {"option[_AbortIncompleteMultipartUpload]","option[_AbortIncompleteMultipartUpload].domain_t"};
    mk_decl("option[_AbortIncompleteMultipartUpload].value",2,option___AbortIncompleteMultipartUpload____value_domain,"_AbortIncompleteMultipartUpload");
    const char *option___Transition____value_domain[2] = {"option[_Transition]","option[_Transition].domain_t"};
    mk_decl("option[_Transition].value",2,option___Transition____value_domain,"_Transition");
    const char *vector___Tag____value_domain[2] = {"vector[_Tag]","vector[_Tag].domain"};
    mk_decl("vector[_Tag].value",2,vector___Tag____value_domain,"_Tag");
    const char *_GetObjectOutput___StorageClass__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._StorageClass_",1,_GetObjectOutput___StorageClass__domain,"string");
    const char *option___IntelligentTieringFilter____end_domain[1] = {"option[_IntelligentTieringFilter]"};
    mk_decl("option[_IntelligentTieringFilter].end",1,option___IntelligentTieringFilter____end_domain,"option[_IntelligentTieringFilter].domain_t");
    const char *_DeleteMarkerEntry___IsLatest__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._IsLatest_",1,_DeleteMarkerEntry___IsLatest__domain,"Bool");
    const char *vector___ObjectVersion____value_domain[2] = {"vector[_ObjectVersion]","vector[_ObjectVersion].domain"};
    mk_decl("vector[_ObjectVersion].value",2,vector___ObjectVersion____value_domain,"_ObjectVersion");
    const char *_S3Location___UserMetadata__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._UserMetadata_",1,_S3Location___UserMetadata__domain,"option[vector[_MetadataEntry]]");
    const char *_InventoryConfiguration___Filter__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Filter_",1,_InventoryConfiguration___Filter__domain,"option[_InventoryFilter]");
    const char *_AnalyticsFilter___Tag__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Tag_",1,_AnalyticsFilter___Tag__domain,"_Tag");
    const char *_ServerSideEncryptionByDefault___SSEAlgorithm__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._SSEAlgorithm_",1,_ServerSideEncryptionByDefault___SSEAlgorithm__domain,"string");
    const char *_GetObjectOutput___PartsCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._PartsCount_",1,_GetObjectOutput___PartsCount__domain,"integer");
    const char *_IntelligentTieringAndOperator___Tags__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Tags_",1,_IntelligentTieringAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___Bucket____value_domain[2] = {"vector[_Bucket]","vector[_Bucket].domain"};
    mk_decl("vector[_Bucket].value",2,vector___Bucket____value_domain,"_Bucket");
    const char *option__vector___Grant______end_domain[1] = {"option[vector[_Grant]]"};
    mk_decl("option[vector[_Grant]].end",1,option__vector___Grant______end_domain,"option[vector[_Grant]].domain_t");
    const char *_ObjectVersion___Key__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Key_",1,_ObjectVersion___Key__domain,"string");
    const char *option___AccessControlTranslation____end_domain[1] = {"option[_AccessControlTranslation]"};
    mk_decl("option[_AccessControlTranslation].end",1,option___AccessControlTranslation____end_domain,"option[_AccessControlTranslation].domain_t");
    const char *_CORSRule___AllowedHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedHeaders_",1,_CORSRule___AllowedHeaders__domain,"option[vector[string]]");
    const char *_InventoryS3BucketDestination___Bucket__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Bucket_",1,_InventoryS3BucketDestination___Bucket__domain,"string");
    const char *_NoncurrentVersionTransition___NoncurrentDays__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._NoncurrentDays_",1,_NoncurrentVersionTransition___NoncurrentDays__domain,"integer");
    const char *_PutObjectRequest___ACL__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ACL_",1,_PutObjectRequest___ACL__domain,"option[string]");
    const char *_CreateBucketConfiguration___LocationConstraint__domain[1] = {"_CreateBucketConfiguration"};
    mk_decl("_CreateBucketConfiguration._LocationConstraint_",1,_CreateBucketConfiguration___LocationConstraint__domain,"string");
    const char *_MetricsConfiguration___Id__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Id_",1,_MetricsConfiguration___Id__domain,"string");
    const char *_InventoryConfiguration___Schedule__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Schedule_",1,_InventoryConfiguration___Schedule__domain,"_InventorySchedule");
    const char *_InventoryConfiguration___IncludedObjectVersions__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IncludedObjectVersions_",1,_InventoryConfiguration___IncludedObjectVersions__domain,"string");
    const char *_Part___PartNumber__domain[1] = {"_Part"};
    mk_decl("_Part._PartNumber_",1,_Part___PartNumber__domain,"integer");
    const char *_DefaultRetention___Years__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Years_",1,_DefaultRetention___Years__domain,"integer");
    const char *_Error___VersionId__domain[1] = {"_Error"};
    mk_decl("_Error._VersionId_",1,_Error___VersionId__domain,"string");
    const char *_ReplicationRule___Prefix__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Prefix_",1,_ReplicationRule___Prefix__domain,"option[string]");
    const char *_CORSRule___MaxAgeSeconds__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._MaxAgeSeconds_",1,_CORSRule___MaxAgeSeconds__domain,"option[integer]");
    const char *_MetricsAndOperator___Prefix__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Prefix_",1,_MetricsAndOperator___Prefix__domain,"string");
    const char *_CSVOutput___QuoteFields__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteFields_",1,_CSVOutput___QuoteFields__domain,"string");
    const char *vector___ReplicationRule____end_domain[1] = {"vector[_ReplicationRule]"};
    mk_decl("vector[_ReplicationRule].end",1,vector___ReplicationRule____end_domain,"vector[_ReplicationRule].domain");
    const char *vector___DeleteMarkerEntry____value_domain[2] = {"vector[_DeleteMarkerEntry]","vector[_DeleteMarkerEntry].domain"};
    mk_decl("vector[_DeleteMarkerEntry].value",2,vector___DeleteMarkerEntry____value_domain,"_DeleteMarkerEntry");
    const char *_RestoreRequest___OutputLocation__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._OutputLocation_",1,_RestoreRequest___OutputLocation__domain,"_OutputLocation");
    const char *_Condition___HttpErrorCodeReturnedEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._HttpErrorCodeReturnedEquals_",1,_Condition___HttpErrorCodeReturnedEquals__domain,"string");
    const char *vector___InventoryConfiguration____end_domain[1] = {"vector[_InventoryConfiguration]"};
    mk_decl("vector[_InventoryConfiguration].end",1,vector___InventoryConfiguration____end_domain,"vector[_InventoryConfiguration].domain");
    const char *vector___CommonPrefix____value_domain[2] = {"vector[_CommonPrefix]","vector[_CommonPrefix].domain"};
    mk_decl("vector[_CommonPrefix].value",2,vector___CommonPrefix____value_domain,"_CommonPrefix");
    const char *_GetObjectOutput___LastModified__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._LastModified_",1,_GetObjectOutput___LastModified__domain,"timestamp");
    const char *_InputSerialization___JSON__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._JSON_",1,_InputSerialization___JSON__domain,"_JSONInput");
    const char *option__vector___MetadataEntry______end_domain[1] = {"option[vector[_MetadataEntry]]"};
    mk_decl("option[vector[_MetadataEntry]].end",1,option__vector___MetadataEntry______end_domain,"option[vector[_MetadataEntry]].domain_t");
    const char *_PutObjectRequest___ContentMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentMD5_",1,_PutObjectRequest___ContentMD5__domain,"option[string]");
    const char *_ObjectLockLegalHold___Status__domain[1] = {"_ObjectLockLegalHold"};
    mk_decl("_ObjectLockLegalHold._Status_",1,_ObjectLockLegalHold___Status__domain,"string");
    const char *option___LifecycleRuleFilter____end_domain[1] = {"option[_LifecycleRuleFilter]"};
    mk_decl("option[_LifecycleRuleFilter].end",1,option___LifecycleRuleFilter____end_domain,"option[_LifecycleRuleFilter].domain_t");
    const char *_StorageClassAnalysisDataExport___OutputSchemaVersion__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._OutputSchemaVersion_",1,_StorageClassAnalysisDataExport___OutputSchemaVersion__domain,"string");
    const char *option___Condition____value_domain[2] = {"option[_Condition]","option[_Condition].domain_t"};
    mk_decl("option[_Condition].value",2,option___Condition____value_domain,"_Condition");
    const char *option___DeleteMarkerReplication____value_domain[2] = {"option[_DeleteMarkerReplication]","option[_DeleteMarkerReplication].domain_t"};
    mk_decl("option[_DeleteMarkerReplication].value",2,option___DeleteMarkerReplication____value_domain,"_DeleteMarkerReplication");
    const char *vector___FilterRule____end_domain[1] = {"vector[_FilterRule]"};
    mk_decl("vector[_FilterRule].end",1,vector___FilterRule____end_domain,"vector[_FilterRule].domain");
    const char *_SelectParameters___OutputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._OutputSerialization_",1,_SelectParameters___OutputSerialization__domain,"_OutputSerialization");
    const char *_Grantee___DisplayName__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._DisplayName_",1,_Grantee___DisplayName__domain,"option[string]");
    const char *_GetObjectOutput___CacheControl__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._CacheControl_",1,_GetObjectOutput___CacheControl__domain,"string");
    const char *_S3Location___Tagging__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Tagging_",1,_S3Location___Tagging__domain,"option[_Tagging]");
    const char *option___ScanRange____end_domain[1] = {"option[_ScanRange]"};
    mk_decl("option[_ScanRange].end",1,option___ScanRange____end_domain,"option[_ScanRange].domain_t");
    const char *_LambdaFunctionConfiguration___Events__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Events_",1,_LambdaFunctionConfiguration___Events__domain,"vector[string]");
    const char *vector___LifecycleRule____end_domain[1] = {"vector[_LifecycleRule]"};
    mk_decl("vector[_LifecycleRule].end",1,vector___LifecycleRule____end_domain,"vector[_LifecycleRule].domain");
    const char *_SseKmsEncryptedObjects___Status__domain[1] = {"_SseKmsEncryptedObjects"};
    mk_decl("_SseKmsEncryptedObjects._Status_",1,_SseKmsEncryptedObjects___Status__domain,"string");
    const char *_InventoryFilter___Prefix__domain[1] = {"_InventoryFilter"};
    mk_decl("_InventoryFilter._Prefix_",1,_InventoryFilter___Prefix__domain,"string");
    const char *_ScanRange___Start__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._Start_",1,_ScanRange___Start__domain,"long");
    const char *_PutObjectRequest___BucketKeyEnabled__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._BucketKeyEnabled_",1,_PutObjectRequest___BucketKeyEnabled__domain,"option[bool]");
    const char *_MetadataEntry___Name__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Name_",1,_MetadataEntry___Name__domain,"string");
    const char *option___NotificationConfigurationFilter____end_domain[1] = {"option[_NotificationConfigurationFilter]"};
    mk_decl("option[_NotificationConfigurationFilter].end",1,option___NotificationConfigurationFilter____end_domain,"option[_NotificationConfigurationFilter].domain_t");
    const char *vector___FilterRule____value_domain[2] = {"vector[_FilterRule]","vector[_FilterRule].domain"};
    mk_decl("vector[_FilterRule].value",2,vector___FilterRule____value_domain,"_FilterRule");
    const char *_CSVInput___QuoteEscapeCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteEscapeCharacter_",1,_CSVInput___QuoteEscapeCharacter__domain,"string");
    const char *_CSVOutput___FieldDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._FieldDelimiter_",1,_CSVOutput___FieldDelimiter__domain,"string");
    const char *vector___NoncurrentVersionTransition____end_domain[1] = {"vector[_NoncurrentVersionTransition]"};
    mk_decl("vector[_NoncurrentVersionTransition].end",1,vector___NoncurrentVersionTransition____end_domain,"vector[_NoncurrentVersionTransition].domain");
    const char *option___IntelligentTieringFilter____value_domain[2] = {"option[_IntelligentTieringFilter]","option[_IntelligentTieringFilter].domain_t"};
    mk_decl("option[_IntelligentTieringFilter].value",2,option___IntelligentTieringFilter____value_domain,"_IntelligentTieringFilter");
    const char *_GetObjectRequest___RequestPayer__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._RequestPayer_",1,_GetObjectRequest___RequestPayer__domain,"option[string]");
    const char *_SelectParameters___Expression__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._Expression_",1,_SelectParameters___Expression__domain,"string");
    const char *_Error___Code__domain[1] = {"_Error"};
    mk_decl("_Error._Code_",1,_Error___Code__domain,"string");
    const char *_Grantee___Type__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._Type_",1,_Grantee___Type__domain,"string");
    const char *_LifecycleExpiration___ExpiredObjectDeleteMarker__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._ExpiredObjectDeleteMarker_",1,_LifecycleExpiration___ExpiredObjectDeleteMarker__domain,"Bool");
    const char *_InputSerialization___CSV__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CSV_",1,_InputSerialization___CSV__domain,"_CSVInput");
    const char *option___NoncurrentVersionExpiration____end_domain[1] = {"option[_NoncurrentVersionExpiration]"};
    mk_decl("option[_NoncurrentVersionExpiration].end",1,option___NoncurrentVersionExpiration____end_domain,"option[_NoncurrentVersionExpiration].domain_t");
    const char *_Rule___Transition__domain[1] = {"_Rule"};
    mk_decl("_Rule._Transition_",1,_Rule___Transition__domain,"option[_Transition]");
    const char *_AccessControlPolicy___Owner__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Owner_",1,_AccessControlPolicy___Owner__domain,"_Owner");
    const char *vector___OwnershipControlsRule____end_domain[1] = {"vector[_OwnershipControlsRule]"};
    mk_decl("vector[_OwnershipControlsRule].end",1,vector___OwnershipControlsRule____end_domain,"vector[_OwnershipControlsRule].domain");
    const char *_PutObjectRequest___SSECustomerAlgorithm__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerAlgorithm_",1,_PutObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_Transition___StorageClass__domain[1] = {"_Transition"};
    mk_decl("_Transition._StorageClass_",1,_Transition___StorageClass__domain,"string");
    const char *_Initiator___ID__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._ID_",1,_Initiator___ID__domain,"string");
    const char *_MetricsFilter___And__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._And_",1,_MetricsFilter___And__domain,"_MetricsAndOperator");
    const char *_PutObjectOutput___SSEKMSKeyId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSKeyId_",1,_PutObjectOutput___SSEKMSKeyId__domain,"string");
    const char *contents_domain[2] = {"string","string"};
    mk_decl("contents",2,contents_domain,"blob");
    const char *_AnalyticsFilter___Prefix__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Prefix_",1,_AnalyticsFilter___Prefix__domain,"string");
    const char *_AnalyticsS3BucketDestination___Prefix__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Prefix_",1,_AnalyticsS3BucketDestination___Prefix__domain,"option[string]");
    const char *_GetObjectOutput___Expiration__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expiration_",1,_GetObjectOutput___Expiration__domain,"string");
    const char *_PutObjectOutput___Expiration__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._Expiration_",1,_PutObjectOutput___Expiration__domain,"string");
    const char *_Transition___Days__domain[1] = {"_Transition"};
    mk_decl("_Transition._Days_",1,_Transition___Days__domain,"integer");
    const char *_LifecycleRuleFilter___Prefix__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Prefix_",1,_LifecycleRuleFilter___Prefix__domain,"string");
    const char *_BucketLifecycleConfiguration___Rules__domain[1] = {"_BucketLifecycleConfiguration"};
    mk_decl("_BucketLifecycleConfiguration._Rules_",1,_BucketLifecycleConfiguration___Rules__domain,"vector[_LifecycleRule]");
    const char *_MultipartUpload___Initiated__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiated_",1,_MultipartUpload___Initiated__domain,"timestamp");
    const char *_Metrics___EventThreshold__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._EventThreshold_",1,_Metrics___EventThreshold__domain,"option[_ReplicationTimeValue]");
    const char *_ObjectVersion___Owner__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Owner_",1,_ObjectVersion___Owner__domain,"_Owner");
    const char *_Rule___ID__domain[1] = {"_Rule"};
    mk_decl("_Rule._ID_",1,_Rule___ID__domain,"option[string]");
    const char *_PutObjectRequest___ServerSideEncryption__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ServerSideEncryption_",1,_PutObjectRequest___ServerSideEncryption__domain,"option[string]");
    const char *_PutObjectOutput___BucketKeyEnabled__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._BucketKeyEnabled_",1,_PutObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *_Object___Key__domain[1] = {"_Object"};
    mk_decl("_Object._Key_",1,_Object___Key__domain,"string");
    const char *option___ObjectLockRetention____end_domain[1] = {"option[_ObjectLockRetention]"};
    mk_decl("option[_ObjectLockRetention].end",1,option___ObjectLockRetention____end_domain,"option[_ObjectLockRetention].domain_t");
    const char *_CSVOutput___RecordDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._RecordDelimiter_",1,_CSVOutput___RecordDelimiter__domain,"string");
    const char *_Rule___AbortIncompleteMultipartUpload__domain[1] = {"_Rule"};
    mk_decl("_Rule._AbortIncompleteMultipartUpload_",1,_Rule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *vector___MultipartUpload____value_domain[2] = {"vector[_MultipartUpload]","vector[_MultipartUpload].domain"};
    mk_decl("vector[_MultipartUpload].value",2,vector___MultipartUpload____value_domain,"_MultipartUpload");
    const char *vector___CORSRule____value_domain[2] = {"vector[_CORSRule]","vector[_CORSRule].domain"};
    mk_decl("vector[_CORSRule].value",2,vector___CORSRule____value_domain,"_CORSRule");
    const char *option___AccessControlTranslation____value_domain[2] = {"option[_AccessControlTranslation]","option[_AccessControlTranslation].domain_t"};
    mk_decl("option[_AccessControlTranslation].value",2,option___AccessControlTranslation____value_domain,"_AccessControlTranslation");
    const char *_GetObjectRequest___SSECustomerAlgorithm__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerAlgorithm_",1,_GetObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_LifecycleRule___Filter__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Filter_",1,_LifecycleRule___Filter__domain,"option[_LifecycleRuleFilter]");
    const char *option__vector___MetadataEntry______value_domain[2] = {"option[vector[_MetadataEntry]]","option[vector[_MetadataEntry]].domain_t"};
    mk_decl("option[vector[_MetadataEntry]].value",2,option__vector___MetadataEntry______value_domain,"vector[_MetadataEntry]");
    const char *_GetObjectOutput___Metadata__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Metadata_",1,_GetObjectOutput___Metadata__domain,"unordered_map[string][string]");
    const char *_GetObjectRequest___ResponseContentDisposition__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentDisposition_",1,_GetObjectRequest___ResponseContentDisposition__domain,"option[string]");
    const char *_ReplicationRule___SourceSelectionCriteria__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._SourceSelectionCriteria_",1,_ReplicationRule___SourceSelectionCriteria__domain,"option[_SourceSelectionCriteria]");
    const char *_PutObjectOutput___SSEKMSEncryptionContext__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSEncryptionContext_",1,_PutObjectOutput___SSEKMSEncryptionContext__domain,"string");
    const char *_GetObjectRequest___ResponseCacheControl__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseCacheControl_",1,_GetObjectRequest___ResponseCacheControl__domain,"option[string]");
    const char *vector___CompletedPart____end_domain[1] = {"vector[_CompletedPart]"};
    mk_decl("vector[_CompletedPart].end",1,vector___CompletedPart____end_domain,"vector[_CompletedPart].domain");
    const char *option___ReplicationTime____end_domain[1] = {"option[_ReplicationTime]"};
    mk_decl("option[_ReplicationTime].end",1,option___ReplicationTime____end_domain,"option[_ReplicationTime].domain_t");
    const char *_DeletedObject___DeleteMarkerVersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarkerVersionId_",1,_DeletedObject___DeleteMarkerVersionId__domain,"string");
    const char *_Grantee___ID__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._ID_",1,_Grantee___ID__domain,"option[string]");
    const char *option___Condition____end_domain[1] = {"option[_Condition]"};
    mk_decl("option[_Condition].end",1,option___Condition____end_domain,"option[_Condition].domain_t");
    const char *_ObjectLockConfiguration___Rule__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._Rule_",1,_ObjectLockConfiguration___Rule__domain,"_ObjectLockRule");
    const char *vector___MetricsConfiguration____value_domain[2] = {"vector[_MetricsConfiguration]","vector[_MetricsConfiguration].domain"};
    mk_decl("vector[_MetricsConfiguration].value",2,vector___MetricsConfiguration____value_domain,"_MetricsConfiguration");
    const char *_AnalyticsS3BucketDestination___Format__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Format_",1,_AnalyticsS3BucketDestination___Format__domain,"string");
    const char *_AnalyticsAndOperator___Tags__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Tags_",1,_AnalyticsAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___DeletedObject____end_domain[1] = {"vector[_DeletedObject]"};
    mk_decl("vector[_DeletedObject].end",1,vector___DeletedObject____end_domain,"vector[_DeletedObject].domain");
    const char *option___CreateBucketConfiguration____end_domain[1] = {"option[_CreateBucketConfiguration]"};
    mk_decl("option[_CreateBucketConfiguration].end",1,option___CreateBucketConfiguration____end_domain,"option[_CreateBucketConfiguration].domain_t");
    const char *_GetObjectRequest___ResponseContentLanguage__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentLanguage_",1,_GetObjectRequest___ResponseContentLanguage__domain,"option[string]");
    const char *_MultipartUpload___UploadId__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._UploadId_",1,_MultipartUpload___UploadId__domain,"string");
    const char *_ReplicationRule___Status__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Status_",1,_ReplicationRule___Status__domain,"string");
    const char *_MultipartUpload___Initiator__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiator_",1,_MultipartUpload___Initiator__domain,"_Initiator");
    const char *_PutObjectOutput___SSECustomerAlgorithm__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerAlgorithm_",1,_PutObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *option__long____end_domain[1] = {"option[long]"};
    mk_decl("option[long].end",1,option__long____end_domain,"option[long].domain_t");
    const char *option___BucketLifecycleConfiguration____value_domain[2] = {"option[_BucketLifecycleConfiguration]","option[_BucketLifecycleConfiguration].domain_t"};
    mk_decl("option[_BucketLifecycleConfiguration].value",2,option___BucketLifecycleConfiguration____value_domain,"_BucketLifecycleConfiguration");
    const char *_InventorySchedule___Frequency__domain[1] = {"_InventorySchedule"};
    mk_decl("_InventorySchedule._Frequency_",1,_InventorySchedule___Frequency__domain,"string");
    const char *_Owner___DisplayName__domain[1] = {"_Owner"};
    mk_decl("_Owner._DisplayName_",1,_Owner___DisplayName__domain,"string");
    const char *_DeleteMarkerEntry___Key__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Key_",1,_DeleteMarkerEntry___Key__domain,"string");
    const char *_Tiering___Days__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._Days_",1,_Tiering___Days__domain,"integer");
    const char *option___NoncurrentVersionTransition____value_domain[2] = {"option[_NoncurrentVersionTransition]","option[_NoncurrentVersionTransition].domain_t"};
    mk_decl("option[_NoncurrentVersionTransition].value",2,option___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *_GetObjectOutput___ServerSideEncryption__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ServerSideEncryption_",1,_GetObjectOutput___ServerSideEncryption__domain,"string");
    const char *_PutObjectRequest___Expires__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Expires_",1,_PutObjectRequest___Expires__domain,"option[timestamp]");
    const char *option___BucketLifecycleConfiguration____end_domain[1] = {"option[_BucketLifecycleConfiguration]"};
    mk_decl("option[_BucketLifecycleConfiguration].end",1,option___BucketLifecycleConfiguration____end_domain,"option[_BucketLifecycleConfiguration].domain_t");
    const char *option___ReplicationTime____value_domain[2] = {"option[_ReplicationTime]","option[_ReplicationTime].domain_t"};
    mk_decl("option[_ReplicationTime].value",2,option___ReplicationTime____value_domain,"_ReplicationTime");
    const char *_InputSerialization___CompressionType__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CompressionType_",1,_InputSerialization___CompressionType__domain,"string");
    const char *_DeleteMarkerEntry___LastModified__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._LastModified_",1,_DeleteMarkerEntry___LastModified__domain,"timestamp");
    const char *_GetObjectRequest___IfMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfMatch_",1,_GetObjectRequest___IfMatch__domain,"option[string]");
    const char *_LifecycleRule___Expiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Expiration_",1,_LifecycleRule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *_ReplicationRule___Destination__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Destination_",1,_ReplicationRule___Destination__domain,"_Destination");
    const char *vector___DeleteMarkerEntry____end_domain[1] = {"vector[_DeleteMarkerEntry]"};
    mk_decl("vector[_DeleteMarkerEntry].end",1,vector___DeleteMarkerEntry____end_domain,"vector[_DeleteMarkerEntry].domain");
    const char *_InputSerialization___Parquet__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._Parquet_",1,_InputSerialization___Parquet__domain,"_ParquetInput");
    const char *_ObjectLockRule___DefaultRetention__domain[1] = {"_ObjectLockRule"};
    mk_decl("_ObjectLockRule._DefaultRetention_",1,_ObjectLockRule___DefaultRetention__domain,"_DefaultRetention");
    const char *option__timestamp____end_domain[1] = {"option[timestamp]"};
    mk_decl("option[timestamp].end",1,option__timestamp____end_domain,"option[timestamp].domain_t");
    const char *_GetObjectOutput___SSECustomerAlgorithm__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerAlgorithm_",1,_GetObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *_QueueConfiguration___Id__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Id_",1,_QueueConfiguration___Id__domain,"option[string]");
    const char *_Object___Size__domain[1] = {"_Object"};
    mk_decl("_Object._Size_",1,_Object___Size__domain,"integer");
    const char *option__integer____value_domain[2] = {"option[integer]","option[integer].domain_t"};
    mk_decl("option[integer].value",2,option__integer____value_domain,"integer");
    const char *blob__value_domain[2] = {"blob","blob.domain"};
    mk_decl("blob.value",2,blob__value_domain,"byte");
    const char *_DeleteMarkerEntry___VersionId__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._VersionId_",1,_DeleteMarkerEntry___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentLength__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLength_",1,_GetObjectOutput___ContentLength__domain,"long");
    const char *option__integer____end_domain[1] = {"option[integer]"};
    mk_decl("option[integer].end",1,option__integer____end_domain,"option[integer].domain_t");
    const char *_LifecycleRuleAndOperator___Tags__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Tags_",1,_LifecycleRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_GetObjectRequest___IfNoneMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfNoneMatch_",1,_GetObjectRequest___IfNoneMatch__domain,"option[string]");
    const char *_S3KeyFilter___FilterRules__domain[1] = {"_S3KeyFilter"};
    mk_decl("_S3KeyFilter._FilterRules_",1,_S3KeyFilter___FilterRules__domain,"vector[_FilterRule]");
    const char *option___ObjectLockLegalHold____value_domain[2] = {"option[_ObjectLockLegalHold]","option[_ObjectLockLegalHold].domain_t"};
    mk_decl("option[_ObjectLockLegalHold].value",2,option___ObjectLockLegalHold____value_domain,"_ObjectLockLegalHold");
    const char *option___EncryptionConfiguration____end_domain[1] = {"option[_EncryptionConfiguration]"};
    mk_decl("option[_EncryptionConfiguration].end",1,option___EncryptionConfiguration____end_domain,"option[_EncryptionConfiguration].domain_t");
    const char *_LifecycleExpiration___Date__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Date_",1,_LifecycleExpiration___Date__domain,"timestamp");
    const char *_PutObjectRequest___RequestPayer__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._RequestPayer_",1,_PutObjectRequest___RequestPayer__domain,"option[string]");
    const char *_PutObjectRequest___ContentLength__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLength_",1,_PutObjectRequest___ContentLength__domain,"option[long]");
    const char *_PutObjectRequest___ObjectLockLegalHoldStatus__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockLegalHoldStatus_",1,_PutObjectRequest___ObjectLockLegalHoldStatus__domain,"option[string]");
    const char *_CSVInput___RecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._RecordDelimiter_",1,_CSVInput___RecordDelimiter__domain,"string");
    const char *vector___Tag____end_domain[1] = {"vector[_Tag]"};
    mk_decl("vector[_Tag].end",1,vector___Tag____end_domain,"vector[_Tag].domain");
    const char *vector___Rule____value_domain[2] = {"vector[_Rule]","vector[_Rule].domain"};
    mk_decl("vector[_Rule].value",2,vector___Rule____value_domain,"_Rule");
    const char *_InventoryEncryption___SSEKMS__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSEKMS_",1,_InventoryEncryption___SSEKMS__domain,"_SSEKMS");
    const char *_Destination___Metrics__domain[1] = {"_Destination"};
    mk_decl("_Destination._Metrics_",1,_Destination___Metrics__domain,"option[_Metrics]");
    const char *_GetObjectOutput___RequestCharged__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._RequestCharged_",1,_GetObjectOutput___RequestCharged__domain,"string");
    const char *vector___Error____value_domain[2] = {"vector[_Error]","vector[_Error].domain"};
    mk_decl("vector[_Error].value",2,vector___Error____value_domain,"_Error");
    const char *blob__end_domain[1] = {"blob"};
    mk_decl("blob.end",1,blob__end_domain,"blob.domain");
    const char *_NotificationConfigurationFilter___Key__domain[1] = {"_NotificationConfigurationFilter"};
    mk_decl("_NotificationConfigurationFilter._Key_",1,_NotificationConfigurationFilter___Key__domain,"_S3KeyFilter");
    const char *option__vector___NoncurrentVersionTransition______value_domain[2] = {"option[vector[_NoncurrentVersionTransition]]","option[vector[_NoncurrentVersionTransition]].domain_t"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].value",2,option__vector___NoncurrentVersionTransition______value_domain,"vector[_NoncurrentVersionTransition]");
    const char *option___Metrics____end_domain[1] = {"option[_Metrics]"};
    mk_decl("option[_Metrics].end",1,option___Metrics____end_domain,"option[_Metrics].domain_t");
    const char *vector___LambdaFunctionConfiguration____value_domain[2] = {"vector[_LambdaFunctionConfiguration]","vector[_LambdaFunctionConfiguration].domain"};
    mk_decl("vector[_LambdaFunctionConfiguration].value",2,vector___LambdaFunctionConfiguration____value_domain,"_LambdaFunctionConfiguration");
    const char *_Error___Message__domain[1] = {"_Error"};
    mk_decl("_Error._Message_",1,_Error___Message__domain,"string");
    const char *option___Transition____end_domain[1] = {"option[_Transition]"};
    mk_decl("option[_Transition].end",1,option___Transition____end_domain,"option[_Transition].domain_t");
    const char *vector___RoutingRule____end_domain[1] = {"vector[_RoutingRule]"};
    mk_decl("vector[_RoutingRule].end",1,vector___RoutingRule____end_domain,"vector[_RoutingRule].domain");
    const char *_ReplicationRule___DeleteMarkerReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._DeleteMarkerReplication_",1,_ReplicationRule___DeleteMarkerReplication__domain,"option[_DeleteMarkerReplication]");
    const char *_DeletedObject___DeleteMarker__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarker_",1,_DeletedObject___DeleteMarker__domain,"Bool");
    const char *_PutObjectRequest___GrantRead__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantRead_",1,_PutObjectRequest___GrantRead__domain,"option[string]");
    const char *_AnalyticsConfiguration___Filter__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Filter_",1,_AnalyticsConfiguration___Filter__domain,"option[_AnalyticsFilter]");
    const char *vector___MetricsConfiguration____end_domain[1] = {"vector[_MetricsConfiguration]"};
    mk_decl("vector[_MetricsConfiguration].end",1,vector___MetricsConfiguration____end_domain,"vector[_MetricsConfiguration].domain");
    const char *_GetObjectOutput___DeleteMarker__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._DeleteMarker_",1,_GetObjectOutput___DeleteMarker__domain,"Bool");
    const char *_S3Location___AccessControlList__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._AccessControlList_",1,_S3Location___AccessControlList__domain,"option[vector[_Grant]]");
    const char *option__timestamp____value_domain[2] = {"option[timestamp]","option[timestamp].domain_t"};
    mk_decl("option[timestamp].value",2,option__timestamp____value_domain,"timestamp");
    const char *present_domain[2] = {"string","string"};
    mk_decl("present",2,present_domain,"Bool");
    const char *_CompletedPart___ETag__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._ETag_",1,_CompletedPart___ETag__domain,"string");
    const char *_InventoryConfiguration___Id__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Id_",1,_InventoryConfiguration___Id__domain,"string");
    const char *_Rule___Status__domain[1] = {"_Rule"};
    mk_decl("_Rule._Status_",1,_Rule___Status__domain,"string");
    const char *_PutObjectRequest___StorageClass__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._StorageClass_",1,_PutObjectRequest___StorageClass__domain,"option[string]");
    const char *unordered_map__string____string____maps_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].maps",2,unordered_map__string____string____maps_domain,"string");
    const char *_GetObjectOutput___TagCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._TagCount_",1,_GetObjectOutput___TagCount__domain,"integer");
    const char *vector___InventoryConfiguration____value_domain[2] = {"vector[_InventoryConfiguration]","vector[_InventoryConfiguration].domain"};
    mk_decl("vector[_InventoryConfiguration].value",2,vector___InventoryConfiguration____value_domain,"_InventoryConfiguration");
    const char *option___ObjectLockConfiguration____end_domain[1] = {"option[_ObjectLockConfiguration]"};
    mk_decl("option[_ObjectLockConfiguration].end",1,option___ObjectLockConfiguration____end_domain,"option[_ObjectLockConfiguration].domain_t");
    const char *_ExistingObjectReplication___Status__domain[1] = {"_ExistingObjectReplication"};
    mk_decl("_ExistingObjectReplication._Status_",1,_ExistingObjectReplication___Status__domain,"string");
    const char *_PutObjectRequest___SSEKMSEncryptionContext__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSEncryptionContext_",1,_PutObjectRequest___SSEKMSEncryptionContext__domain,"option[string]");
    const char *_SelectParameters___ExpressionType__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._ExpressionType_",1,_SelectParameters___ExpressionType__domain,"string");
    const char *_LifecycleConfiguration___Rules__domain[1] = {"_LifecycleConfiguration"};
    mk_decl("_LifecycleConfiguration._Rules_",1,_LifecycleConfiguration___Rules__domain,"vector[_Rule]");
    const char *_GetObjectOutput___ContentDisposition__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentDisposition_",1,_GetObjectOutput___ContentDisposition__domain,"string");
    const char *_LifecycleRuleFilter___Tag__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Tag_",1,_LifecycleRuleFilter___Tag__domain,"_Tag");
    const char *_GetObjectOutput___BucketKeyEnabled__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._BucketKeyEnabled_",1,_GetObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *option___AbortIncompleteMultipartUpload____end_domain[1] = {"option[_AbortIncompleteMultipartUpload]"};
    mk_decl("option[_AbortIncompleteMultipartUpload].end",1,option___AbortIncompleteMultipartUpload____end_domain,"option[_AbortIncompleteMultipartUpload].domain_t");
    const char *_PutObjectRequest___GrantWriteACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantWriteACP_",1,_PutObjectRequest___GrantWriteACP__domain,"option[string]");
    const char *option___ReplicationTimeValue____end_domain[1] = {"option[_ReplicationTimeValue]"};
    mk_decl("option[_ReplicationTimeValue].end",1,option___ReplicationTimeValue____end_domain,"option[_ReplicationTimeValue].domain_t");
    const char *_RestoreRequest___SelectParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._SelectParameters_",1,_RestoreRequest___SelectParameters__domain,"_SelectParameters");
    const char *option___LifecycleExpiration____end_domain[1] = {"option[_LifecycleExpiration]"};
    mk_decl("option[_LifecycleExpiration].end",1,option___LifecycleExpiration____end_domain,"option[_LifecycleExpiration].domain_t");
    const char *_Destination___Account__domain[1] = {"_Destination"};
    mk_decl("_Destination._Account_",1,_Destination___Account__domain,"option[string]");
    const char *vector___MultipartUpload____end_domain[1] = {"vector[_MultipartUpload]"};
    mk_decl("vector[_MultipartUpload].end",1,vector___MultipartUpload____end_domain,"vector[_MultipartUpload].domain");
    const char *_ObjectIdentifier___VersionId__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._VersionId_",1,_ObjectIdentifier___VersionId__domain,"option[string]");
    const char *_JSONOutput___RecordDelimiter__domain[1] = {"_JSONOutput"};
    mk_decl("_JSONOutput._RecordDelimiter_",1,_JSONOutput___RecordDelimiter__domain,"string");
    const char *_Destination___Bucket__domain[1] = {"_Destination"};
    mk_decl("_Destination._Bucket_",1,_Destination___Bucket__domain,"string");
    const char *option__vector___TargetGrant______end_domain[1] = {"option[vector[_TargetGrant]]"};
    mk_decl("option[vector[_TargetGrant]].end",1,option__vector___TargetGrant______end_domain,"option[vector[_TargetGrant]].domain_t");
    const char *_PutObjectRequest___Key__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Key_",1,_PutObjectRequest___Key__domain,"string");
    const char *_CORSRule___ID__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ID_",1,_CORSRule___ID__domain,"option[string]");
    const char *option___DeleteMarkerReplication____end_domain[1] = {"option[_DeleteMarkerReplication]"};
    mk_decl("option[_DeleteMarkerReplication].end",1,option___DeleteMarkerReplication____end_domain,"option[_DeleteMarkerReplication].domain_t");
    const char *_GetObjectOutput___ContentType__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentType_",1,_GetObjectOutput___ContentType__domain,"string");
    const char *_Rule___NoncurrentVersionTransition__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionTransition_",1,_Rule___NoncurrentVersionTransition__domain,"option[_NoncurrentVersionTransition]");
    const char *_ObjectLockRetention___Mode__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._Mode_",1,_ObjectLockRetention___Mode__domain,"string");
    const char *_Destination___AccessControlTranslation__domain[1] = {"_Destination"};
    mk_decl("_Destination._AccessControlTranslation_",1,_Destination___AccessControlTranslation__domain,"option[_AccessControlTranslation]");
    const char *_CSVInput___QuoteCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteCharacter_",1,_CSVInput___QuoteCharacter__domain,"string");
    const char *vector___Transition____end_domain[1] = {"vector[_Transition]"};
    mk_decl("vector[_Transition].end",1,vector___Transition____end_domain,"vector[_Transition].domain");
    const char *vector___CompletedPart____value_domain[2] = {"vector[_CompletedPart]","vector[_CompletedPart].domain"};
    mk_decl("vector[_CompletedPart].value",2,vector___CompletedPart____value_domain,"_CompletedPart");
    const char *_CSVInput___FieldDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FieldDelimiter_",1,_CSVInput___FieldDelimiter__domain,"string");
    const char *_GetObjectOutput___MissingMeta__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._MissingMeta_",1,_GetObjectOutput___MissingMeta__domain,"integer");
    const char *vector___Error____end_domain[1] = {"vector[_Error]"};
    mk_decl("vector[_Error].end",1,vector___Error____end_domain,"vector[_Error].domain");
    mk_const("_generating","Bool");
    const char *_Initiator___DisplayName__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._DisplayName_",1,_Initiator___DisplayName__domain,"string");
    const char *_TopicConfiguration___Id__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Id_",1,_TopicConfiguration___Id__domain,"option[string]");
    const char *_PutObjectRequest___ContentLanguage__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLanguage_",1,_PutObjectRequest___ContentLanguage__domain,"option[string]");
    const char *option__bool____end_domain[1] = {"option[bool]"};
    mk_decl("option[bool].end",1,option__bool____end_domain,"option[bool].domain_t");
    const char *_ServerSideEncryptionByDefault___KMSMasterKeyID__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._KMSMasterKeyID_",1,_ServerSideEncryptionByDefault___KMSMasterKeyID__domain,"option[string]");
    const char *option___ScanRange____value_domain[2] = {"option[_ScanRange]","option[_ScanRange].domain_t"};
    mk_decl("option[_ScanRange].value",2,option___ScanRange____value_domain,"_ScanRange");
    const char *option___ExistingObjectReplication____value_domain[2] = {"option[_ExistingObjectReplication]","option[_ExistingObjectReplication].domain_t"};
    mk_decl("option[_ExistingObjectReplication].value",2,option___ExistingObjectReplication____value_domain,"_ExistingObjectReplication");
    const char *_GetObjectRequest___ResponseExpires__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseExpires_",1,_GetObjectRequest___ResponseExpires__domain,"option[timestamp]");
    const char *vector___ObjectIdentifier____end_domain[1] = {"vector[_ObjectIdentifier]"};
    mk_decl("vector[_ObjectIdentifier].end",1,vector___ObjectIdentifier____end_domain,"vector[_ObjectIdentifier].domain");
    const char *_RestoreRequest___Type__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Type_",1,_RestoreRequest___Type__domain,"string");
    const char *_DeleteMarkerReplication___Status__domain[1] = {"_DeleteMarkerReplication"};
    mk_decl("_DeleteMarkerReplication._Status_",1,_DeleteMarkerReplication___Status__domain,"string");
    const char *option___ReplicationRuleFilter____end_domain[1] = {"option[_ReplicationRuleFilter]"};
    mk_decl("option[_ReplicationRuleFilter].end",1,option___ReplicationRuleFilter____end_domain,"option[_ReplicationRuleFilter].domain_t");
    const char *_RoutingRule___Condition__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Condition_",1,_RoutingRule___Condition__domain,"option[_Condition]");
    const char *_MetricsAndOperator___Tags__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Tags_",1,_MetricsAndOperator___Tags__domain,"vector[_Tag]");
    const char *option___RequestProgress____end_domain[1] = {"option[_RequestProgress]"};
    mk_decl("option[_RequestProgress].end",1,option___RequestProgress____end_domain,"option[_RequestProgress].domain_t");
    const char *_CSVInput___Comments__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._Comments_",1,_CSVInput___Comments__domain,"string");
    const char *_Part___Size__domain[1] = {"_Part"};
    mk_decl("_Part._Size_",1,_Part___Size__domain,"integer");
    const char *vector___ServerSideEncryptionRule____end_domain[1] = {"vector[_ServerSideEncryptionRule]"};
    mk_decl("vector[_ServerSideEncryptionRule].end",1,vector___ServerSideEncryptionRule____end_domain,"vector[_ServerSideEncryptionRule].domain");
    const char *vector___QueueConfiguration____end_domain[1] = {"vector[_QueueConfiguration]"};
    mk_decl("vector[_QueueConfiguration].end",1,vector___QueueConfiguration____end_domain,"vector[_QueueConfiguration].domain");
    const char *_PutObjectOutput___SSECustomerKeyMD5__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerKeyMD5_",1,_PutObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_OwnershipControlsRule___ObjectOwnership__domain[1] = {"_OwnershipControlsRule"};
    mk_decl("_OwnershipControlsRule._ObjectOwnership_",1,_OwnershipControlsRule___ObjectOwnership__domain,"string");
    const char *option___MetricsFilter____end_domain[1] = {"option[_MetricsFilter]"};
    mk_decl("option[_MetricsFilter].end",1,option___MetricsFilter____end_domain,"option[_MetricsFilter].domain_t");
    const char *_QueueConfiguration___Events__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Events_",1,_QueueConfiguration___Events__domain,"vector[string]");
    const char *_IntelligentTieringConfiguration___Tierings__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Tierings_",1,_IntelligentTieringConfiguration___Tierings__domain,"vector[_Tiering]");
    const char *option__bool____value_domain[2] = {"option[bool]","option[bool].domain_t"};
    mk_decl("option[bool].value",2,option__bool____value_domain,"Bool");
    const char *option___InventoryFilter____end_domain[1] = {"option[_InventoryFilter]"};
    mk_decl("option[_InventoryFilter].end",1,option___InventoryFilter____end_domain,"option[_InventoryFilter].domain_t");
    const char *_Grantee___URI__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._URI_",1,_Grantee___URI__domain,"option[string]");
    const char *_Encryption___KMSContext__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSContext_",1,_Encryption___KMSContext__domain,"option[string]");
    const char *vector___LambdaFunctionConfiguration____end_domain[1] = {"vector[_LambdaFunctionConfiguration]"};
    mk_decl("vector[_LambdaFunctionConfiguration].end",1,vector___LambdaFunctionConfiguration____end_domain,"vector[_LambdaFunctionConfiguration].domain");
    const char *_ReplicationTimeValue___Minutes__domain[1] = {"_ReplicationTimeValue"};
    mk_decl("_ReplicationTimeValue._Minutes_",1,_ReplicationTimeValue___Minutes__domain,"integer");
    const char *vector___AnalyticsConfiguration____end_domain[1] = {"vector[_AnalyticsConfiguration]"};
    mk_decl("vector[_AnalyticsConfiguration].end",1,vector___AnalyticsConfiguration____end_domain,"vector[_AnalyticsConfiguration].domain");
    const char *option__vector___TargetGrant______value_domain[2] = {"option[vector[_TargetGrant]]","option[vector[_TargetGrant]].domain_t"};
    mk_decl("option[vector[_TargetGrant]].value",2,option__vector___TargetGrant______value_domain,"vector[_TargetGrant]");
    const char *_PutObjectRequest___SSECustomerKey__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKey_",1,_PutObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_GetObjectRequest___IfUnmodifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfUnmodifiedSince_",1,_GetObjectRequest___IfUnmodifiedSince__domain,"option[timestamp]");
    const char *_S3Location___Prefix__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Prefix_",1,_S3Location___Prefix__domain,"string");
    const char *option___RestoreRequest____value_domain[2] = {"option[_RestoreRequest]","option[_RestoreRequest].domain_t"};
    mk_decl("option[_RestoreRequest].value",2,option___RestoreRequest____value_domain,"_RestoreRequest");
    const char *_EncryptionConfiguration___ReplicaKmsKeyID__domain[1] = {"_EncryptionConfiguration"};
    mk_decl("_EncryptionConfiguration._ReplicaKmsKeyID_",1,_EncryptionConfiguration___ReplicaKmsKeyID__domain,"string");
    const char *_Tag___Value__domain[1] = {"_Tag"};
    mk_decl("_Tag._Value_",1,_Tag___Value__domain,"string");
    const char *vector___TopicConfiguration____value_domain[2] = {"vector[_TopicConfiguration]","vector[_TopicConfiguration].domain"};
    mk_decl("vector[_TopicConfiguration].value",2,vector___TopicConfiguration____value_domain,"_TopicConfiguration");
    const char *_PutObjectRequest___Metadata__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Metadata_",1,_PutObjectRequest___Metadata__domain,"option[unordered_map[string][string]]");
    const char *vector___NoncurrentVersionTransition____value_domain[2] = {"vector[_NoncurrentVersionTransition]","vector[_NoncurrentVersionTransition].domain"};
    mk_decl("vector[_NoncurrentVersionTransition].value",2,vector___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *vector___Part____value_domain[2] = {"vector[_Part]","vector[_Part].domain"};
    mk_decl("vector[_Part].value",2,vector___Part____value_domain,"_Part");
    const char *vector___IntelligentTieringConfiguration____value_domain[2] = {"vector[_IntelligentTieringConfiguration]","vector[_IntelligentTieringConfiguration].domain"};
    mk_decl("vector[_IntelligentTieringConfiguration].value",2,vector___IntelligentTieringConfiguration____value_domain,"_IntelligentTieringConfiguration");
    const char *_FilterRule___Value__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Value_",1,_FilterRule___Value__domain,"string");
    const char *_LifecycleRule___NoncurrentVersionTransitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionTransitions_",1,_LifecycleRule___NoncurrentVersionTransitions__domain,"option[vector[_NoncurrentVersionTransition]]");
    const char *option__vector__string______value_domain[2] = {"option[vector[string]]","option[vector[string]].domain_t"};
    mk_decl("option[vector[string]].value",2,option__vector__string______value_domain,"vector[string]");
    const char *_ObjectIdentifier___Key__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._Key_",1,_ObjectIdentifier___Key__domain,"string");
    const char *_InventoryS3BucketDestination___Format__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Format_",1,_InventoryS3BucketDestination___Format__domain,"string");
    const char *_OutputSerialization___JSON__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._JSON_",1,_OutputSerialization___JSON__domain,"_JSONOutput");
    const char *vector___Object____end_domain[1] = {"vector[_Object]"};
    mk_decl("vector[_Object].end",1,vector___Object____end_domain,"vector[_Object].domain");
    const char *_MetricsFilter___Tag__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Tag_",1,_MetricsFilter___Tag__domain,"_Tag");
    const char *_ReplicaModifications___Status__domain[1] = {"_ReplicaModifications"};
    mk_decl("_ReplicaModifications._Status_",1,_ReplicaModifications___Status__domain,"string");
    const char *_AccessControlTranslation___Owner__domain[1] = {"_AccessControlTranslation"};
    mk_decl("_AccessControlTranslation._Owner_",1,_AccessControlTranslation___Owner__domain,"string");
    const char *_QueueConfiguration___Filter__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Filter_",1,_QueueConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_ObjectVersion___ETag__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._ETag_",1,_ObjectVersion___ETag__domain,"string");
    const char *_Transition___Date__domain[1] = {"_Transition"};
    mk_decl("_Transition._Date_",1,_Transition___Date__domain,"timestamp");
    const char *vector___TargetGrant____end_domain[1] = {"vector[_TargetGrant]"};
    mk_decl("vector[_TargetGrant].end",1,vector___TargetGrant____end_domain,"vector[_TargetGrant].domain");
    const char *vector___Grant____end_domain[1] = {"vector[_Grant]"};
    mk_decl("vector[_Grant].end",1,vector___Grant____end_domain,"vector[_Grant].domain");
    const char *_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",1,_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain,"_ServerSideEncryptionByDefault");
    const char *_AnalyticsExportDestination___S3BucketDestination__domain[1] = {"_AnalyticsExportDestination"};
    mk_decl("_AnalyticsExportDestination._S3BucketDestination_",1,_AnalyticsExportDestination___S3BucketDestination__domain,"_AnalyticsS3BucketDestination");
    const char *vector___QueueConfiguration____value_domain[2] = {"vector[_QueueConfiguration]","vector[_QueueConfiguration].domain"};
    mk_decl("vector[_QueueConfiguration].value",2,vector___QueueConfiguration____value_domain,"_QueueConfiguration");
    const char *_IntelligentTieringAndOperator___Prefix__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Prefix_",1,_IntelligentTieringAndOperator___Prefix__domain,"string");
    const char *option___InventoryEncryption____value_domain[2] = {"option[_InventoryEncryption]","option[_InventoryEncryption].domain_t"};
    mk_decl("option[_InventoryEncryption].value",2,option___InventoryEncryption____value_domain,"_InventoryEncryption");
    const char *option___CompletedMultipartUpload____end_domain[1] = {"option[_CompletedMultipartUpload]"};
    mk_decl("option[_CompletedMultipartUpload].end",1,option___CompletedMultipartUpload____end_domain,"option[_CompletedMultipartUpload].domain_t");
    const char *_MultipartUpload___Owner__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Owner_",1,_MultipartUpload___Owner__domain,"_Owner");
    const char *_RoutingRule___Redirect__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Redirect_",1,_RoutingRule___Redirect__domain,"_Redirect");
    const char *_ReplicationRuleAndOperator___Tags__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Tags_",1,_ReplicationRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_LifecycleRule___Transitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Transitions_",1,_LifecycleRule___Transitions__domain,"option[vector[_Transition]]");
    const char *_Part___LastModified__domain[1] = {"_Part"};
    mk_decl("_Part._LastModified_",1,_Part___LastModified__domain,"timestamp");
    const char *_GetObjectOutput___ObjectLockMode__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockMode_",1,_GetObjectOutput___ObjectLockMode__domain,"string");
    const char *vector___ObjectVersion____end_domain[1] = {"vector[_ObjectVersion]"};
    mk_decl("vector[_ObjectVersion].end",1,vector___ObjectVersion____end_domain,"vector[_ObjectVersion].domain");
    const char *_GetObjectOutput___WebsiteRedirectLocation__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._WebsiteRedirectLocation_",1,_GetObjectOutput___WebsiteRedirectLocation__domain,"string");
    const char *_AnalyticsS3BucketDestination___BucketAccountId__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._BucketAccountId_",1,_AnalyticsS3BucketDestination___BucketAccountId__domain,"option[string]");
    const char *vector___CORSRule____end_domain[1] = {"vector[_CORSRule]"};
    mk_decl("vector[_CORSRule].end",1,vector___CORSRule____end_domain,"vector[_CORSRule].domain");
    const char *_GetObjectRequest___Bucket__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Bucket_",1,_GetObjectRequest___Bucket__domain,"string");
    const char *_Object___ETag__domain[1] = {"_Object"};
    mk_decl("_Object._ETag_",1,_Object___ETag__domain,"string");
    const char *_Object___StorageClass__domain[1] = {"_Object"};
    mk_decl("_Object._StorageClass_",1,_Object___StorageClass__domain,"string");
    const char *_TopicConfiguration___Filter__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Filter_",1,_TopicConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_PutObjectRequest___ObjectLockRetainUntilDate__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockRetainUntilDate_",1,_PutObjectRequest___ObjectLockRetainUntilDate__domain,"option[timestamp]");
    const char *_Tagging___TagSet__domain[1] = {"_Tagging"};
    mk_decl("_Tagging._TagSet_",1,_Tagging___TagSet__domain,"vector[_Tag]");
    const char *_ReplicationRuleFilter___Prefix__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Prefix_",1,_ReplicationRuleFilter___Prefix__domain,"string");
    mk_const("the_bucket","string");
    const char *_PutObjectOutput___ETag__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ETag_",1,_PutObjectOutput___ETag__domain,"string");
    const char *_IntelligentTieringConfiguration___Status__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Status_",1,_IntelligentTieringConfiguration___Status__domain,"string");
    const char *_GetObjectOutput___VersionId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._VersionId_",1,_GetObjectOutput___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentEncoding__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentEncoding_",1,_GetObjectOutput___ContentEncoding__domain,"string");
    const char *option___AnalyticsFilter____end_domain[1] = {"option[_AnalyticsFilter]"};
    mk_decl("option[_AnalyticsFilter].end",1,option___AnalyticsFilter____end_domain,"option[_AnalyticsFilter].domain_t");
    const char *_IntelligentTieringFilter___And__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._And_",1,_IntelligentTieringFilter___And__domain,"_IntelligentTieringAndOperator");
    const char *_PutObjectRequest___ExpectedBucketOwner__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ExpectedBucketOwner_",1,_PutObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_PutObjectRequest___CacheControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._CacheControl_",1,_PutObjectRequest___CacheControl__domain,"option[string]");
    const char *vector___TargetGrant____value_domain[2] = {"vector[_TargetGrant]","vector[_TargetGrant].domain"};
    mk_decl("vector[_TargetGrant].value",2,vector___TargetGrant____value_domain,"_TargetGrant");
    const char *_ReplicationRule___Priority__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Priority_",1,_ReplicationRule___Priority__domain,"option[integer]");
    const char *option___NoncurrentVersionTransition____end_domain[1] = {"option[_NoncurrentVersionTransition]"};
    mk_decl("option[_NoncurrentVersionTransition].end",1,option___NoncurrentVersionTransition____end_domain,"option[_NoncurrentVersionTransition].domain_t");
    const char *_IntelligentTieringFilter___Prefix__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Prefix_",1,_IntelligentTieringFilter___Prefix__domain,"string");
    const char *_MetricsConfiguration___Filter__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Filter_",1,_MetricsConfiguration___Filter__domain,"option[_MetricsFilter]");
    const char *_GetObjectRequest___IfModifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfModifiedSince_",1,_GetObjectRequest___IfModifiedSince__domain,"option[timestamp]");
    const char *_PutObjectOutput___VersionId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._VersionId_",1,_PutObjectOutput___VersionId__domain,"string");
    const char *vector___OwnershipControlsRule____value_domain[2] = {"vector[_OwnershipControlsRule]","vector[_OwnershipControlsRule].domain"};
    mk_decl("vector[_OwnershipControlsRule].value",2,vector___OwnershipControlsRule____value_domain,"_OwnershipControlsRule");
    const char *_GlacierJobParameters___Tier__domain[1] = {"_GlacierJobParameters"};
    mk_decl("_GlacierJobParameters._Tier_",1,_GlacierJobParameters___Tier__domain,"string");
    const char *_PutObjectRequest___Body__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Body_",1,_PutObjectRequest___Body__domain,"option[blob]");
    const char *_ReplicationTime___Status__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Status_",1,_ReplicationTime___Status__domain,"string");
    const char *_LifecycleRuleAndOperator___Prefix__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Prefix_",1,_LifecycleRuleAndOperator___Prefix__domain,"string");
    const char *_GetObjectRequest___VersionId__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._VersionId_",1,_GetObjectRequest___VersionId__domain,"option[string]");
    const char *option___Tagging____end_domain[1] = {"option[_Tagging]"};
    mk_decl("option[_Tagging].end",1,option___Tagging____end_domain,"option[_Tagging].domain_t");
    const char *unordered_map__string____string____contains_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].contains",2,unordered_map__string____string____contains_domain,"Bool");
    const char *option__unordered_map__string____string______value_domain[2] = {"option[unordered_map[string][string]]","option[unordered_map[string][string]].domain_t"};
    mk_decl("option[unordered_map[string][string]].value",2,option__unordered_map__string____string______value_domain,"unordered_map[string][string]");
    const char *_DeleteMarkerEntry___Owner__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Owner_",1,_DeleteMarkerEntry___Owner__domain,"_Owner");
    const char *_AccessControlPolicy___Grants__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Grants_",1,_AccessControlPolicy___Grants__domain,"vector[_Grant]");
    const char *_GetObjectOutput___Restore__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Restore_",1,_GetObjectOutput___Restore__domain,"string");
    const char *option__vector___Transition______value_domain[2] = {"option[vector[_Transition]]","option[vector[_Transition]].domain_t"};
    mk_decl("option[vector[_Transition]].value",2,option__vector___Transition______value_domain,"vector[_Transition]");
    const char *vector__string____end_domain[1] = {"vector[string]"};
    mk_decl("vector[string].end",1,vector__string____end_domain,"vector[string].domain");
    const char *vector___MetadataEntry____value_domain[2] = {"vector[_MetadataEntry]","vector[_MetadataEntry].domain"};
    mk_decl("vector[_MetadataEntry].value",2,vector___MetadataEntry____value_domain,"_MetadataEntry");
    const char *_IntelligentTieringConfiguration___Filter__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Filter_",1,_IntelligentTieringConfiguration___Filter__domain,"option[_IntelligentTieringFilter]");
    const char *_IntelligentTieringFilter___Tag__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Tag_",1,_IntelligentTieringFilter___Tag__domain,"_Tag");
    const char *_PutObjectRequest___GrantFullControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantFullControl_",1,_PutObjectRequest___GrantFullControl__domain,"option[string]");
    const char *option___Encryption____end_domain[1] = {"option[_Encryption]"};
    mk_decl("option[_Encryption].end",1,option___Encryption____end_domain,"option[_Encryption].domain_t");
    const char *_CSVOutput___QuoteEscapeCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteEscapeCharacter_",1,_CSVOutput___QuoteEscapeCharacter__domain,"string");
    const char *_AnalyticsConfiguration___StorageClassAnalysis__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._StorageClassAnalysis_",1,_AnalyticsConfiguration___StorageClassAnalysis__domain,"_StorageClassAnalysis");
    const char *_Redirect___ReplaceKeyPrefixWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyPrefixWith_",1,_Redirect___ReplaceKeyPrefixWith__domain,"string");
    const char *_ReplicationRuleAndOperator___Prefix__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Prefix_",1,_ReplicationRuleAndOperator___Prefix__domain,"string");
    const char *option__string____value_domain[2] = {"option[string]","option[string].domain_t"};
    mk_decl("option[string].value",2,option__string____value_domain,"string");
    const char *_PutObjectRequest___SSECustomerKeyMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKeyMD5_",1,_PutObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Object___Owner__domain[1] = {"_Object"};
    mk_decl("_Object._Owner_",1,_Object___Owner__domain,"_Owner");
    const char *_MultipartUpload___Key__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Key_",1,_MultipartUpload___Key__domain,"string");
    const char *_Encryption___EncryptionType__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._EncryptionType_",1,_Encryption___EncryptionType__domain,"string");
    const char *_Rule___Expiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._Expiration_",1,_Rule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *vector___Grant____value_domain[2] = {"vector[_Grant]","vector[_Grant].domain"};
    mk_decl("vector[_Grant].value",2,vector___Grant____value_domain,"_Grant");
    const char *_TopicConfiguration___Events__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Events_",1,_TopicConfiguration___Events__domain,"vector[string]");
    const char *option___ReplicationRuleFilter____value_domain[2] = {"option[_ReplicationRuleFilter]","option[_ReplicationRuleFilter].domain_t"};
    mk_decl("option[_ReplicationRuleFilter].value",2,option___ReplicationRuleFilter____value_domain,"_ReplicationRuleFilter");
    const char *_PutObjectRequest___GrantReadACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantReadACP_",1,_PutObjectRequest___GrantReadACP__domain,"option[string]");
    const char *_Bucket___Name__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._Name_",1,_Bucket___Name__domain,"string");
    const char *_LifecycleRule___ID__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._ID_",1,_LifecycleRule___ID__domain,"option[string]");
    const char *_DefaultRetention___Mode__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Mode_",1,_DefaultRetention___Mode__domain,"string");
    const char *vector___ObjectIdentifier____value_domain[2] = {"vector[_ObjectIdentifier]","vector[_ObjectIdentifier].domain"};
    mk_decl("vector[_ObjectIdentifier].value",2,vector___ObjectIdentifier____value_domain,"_ObjectIdentifier");
    const char *_GetObjectOutput___Expires__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expires_",1,_GetObjectOutput___Expires__domain,"timestamp");
    const char *_ReplicationRule___Filter__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Filter_",1,_ReplicationRule___Filter__domain,"option[_ReplicationRuleFilter]");
    add("(assert (and\
      and\
    ))");
}
bool init_gen::generate(s3_test& obj) {
    s3_test::string::prepare();
    alits.clear();
    obj.the_key = (s3_test::string)((rand()%2) ? "a" : "b");
    struct __thunk__1 : z3_thunk<s3_test::__tup__string__string,s3_test::blob>{
        __thunk__1()  {
        }
        s3_test::blob operator()(const s3_test::__tup__string__string &arg){
            s3_test::blob __tmp0;
            return __tmp0;
        }
        z3::expr to_z3(gen &g, const z3::expr &v){
            s3_test::blob __tmp1;
            z3::expr res = __to_solver(g,v,__tmp1);
            return res;
        }
    };
    obj.contents = hash_thunk<s3_test::__tup__string__string,s3_test::blob>(new __thunk__1());
    struct __thunk__2 : z3_thunk<s3_test::__tup__string__string,bool>{
        __thunk__2()  {
        }
        bool operator()(const s3_test::__tup__string__string &arg){
            bool __tmp2;
    __tmp2 = (bool)___ivy_choose(0,"present",0);
            return __tmp2;
        }
        z3::expr to_z3(gen &g, const z3::expr &v){
            bool __tmp3;
    __tmp3 = (bool)___ivy_choose(0,"present",0);
            z3::expr res = v == g.int_to_z3(g.sort("bool"),(int)(__tmp3));
            return res;
        }
    };
    obj.present = hash_thunk<s3_test::__tup__string__string,bool>(new __thunk__2());
    struct __thunk__3 : z3_thunk<s3_test::__tup__unordered_map__string____string____string,s3_test::string>{
        __thunk__3()  {
        }
        s3_test::string operator()(const s3_test::__tup__unordered_map__string____string____string &arg){
            s3_test::string __tmp4;
            return __tmp4;
        }
        z3::expr to_z3(gen &g, const z3::expr &v){
            s3_test::string __tmp5;
            z3::expr res = __to_solver(g,v,__tmp5);
            return res;
        }
    };
    obj.unordered_map__string____string____maps = hash_thunk<s3_test::__tup__unordered_map__string____string____string,s3_test::string>(new __thunk__3());
    obj._generating = (bool)(rand() % 2);
    obj.the_bucket = (s3_test::string)((rand()%2) ? "a" : "b");
    struct __thunk__4 : z3_thunk<s3_test::__tup__unordered_map__string____string____string,bool>{
        __thunk__4()  {
        }
        bool operator()(const s3_test::__tup__unordered_map__string____string____string &arg){
            bool __tmp6;
    __tmp6 = (bool)___ivy_choose(0,"unordered_map[string][string].contains",0);
            return __tmp6;
        }
        z3::expr to_z3(gen &g, const z3::expr &v){
            bool __tmp7;
    __tmp7 = (bool)___ivy_choose(0,"unordered_map[string][string].contains",0);
            z3::expr res = v == g.int_to_z3(g.sort("bool"),(int)(__tmp7));
            return res;
        }
    };
    obj.unordered_map__string____string____contains = hash_thunk<s3_test::__tup__unordered_map__string____string____string,bool>(new __thunk__4());

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {

    }
s3_test::string::cleanup();

    obj.___ivy_gen = this;
    obj.__init();
    return __res;
}
class ext__get_gen : public gen {
  public:
    s3_test::string key;
    s3_test::string bucket;
    ext__get_gen();
    bool generate(s3_test&);
    void execute(s3_test&);
};
ext__get_gen::ext__get_gen(){
mk_sort("_FilterRule");
mk_sort("_Destination");
    mk_bv("option[_ReplicationTime].domain_t",1);
mk_sort("_LifecycleExpiration");
    mk_int("vector[_ReplicationRule].domain");
mk_sort("vector[_DeleteMarkerEntry]");
mk_sort("vector[_DeletedObject]");
mk_sort("vector[_ObjectVersion]");
mk_sort("_InputSerialization");
    mk_bv("option[_InventoryEncryption].domain_t",1);
    mk_bv("option[_NoncurrentVersionExpiration].domain_t",1);
    mk_bv("option[_RequestProgress].domain_t",1);
mk_sort("_OutputLocation");
mk_sort("_ReplicationRuleFilter");
mk_sort("_SSES3");
    mk_bv("option[_LifecycleExpiration].domain_t",1);
mk_sort("_ObjectLockConfiguration");
    enum_sorts.insert(std::pair<std::string, z3::sort>("string",s3_test::string::z3_sort(ctx)));
mk_sort("_Redirect");
mk_sort("_ObjectLockLegalHold");
mk_sort("option[_InventoryEncryption]");
mk_sort("option[vector[_NoncurrentVersionTransition]]");
mk_sort("_Transition");
    mk_int("vector[_FilterRule].domain");
mk_sort("_LifecycleRuleAndOperator");
    mk_int("vector[_DeleteMarkerEntry].domain");
    mk_bv("option[_LifecycleRuleFilter].domain_t",1);
mk_sort("_SSEKMS");
    mk_bv("option[_EncryptionConfiguration].domain_t",1);
mk_sort("_SelectParameters");
    mk_bv("option[_RestoreRequest].domain_t",1);
mk_sort("unordered_map[string][string]");
mk_sort("_AnalyticsExportDestination");
mk_sort("vector[_Grant]");
    mk_bv("option[_Condition].domain_t",1);
mk_sort("_DeleteMarkerEntry");
mk_sort("option[_Encryption]");
mk_sort("option[_NoncurrentVersionTransition]");
    mk_bv("option[integer].domain_t",1);
mk_sort("_Encryption");
    mk_int("vector[_MetadataEntry].domain");
    mk_bv("option[_Tagging].domain_t",1);
mk_sort("vector[_LifecycleRule]");
    mk_bv("option[bool].domain_t",1);
mk_sort("_Condition");
mk_sort("option[_NotificationConfigurationFilter]");
mk_sort("vector[_ObjectIdentifier]");
    mk_bv("option[_IntelligentTieringFilter].domain_t",1);
mk_sort("option[_CompletedMultipartUpload]");
mk_sort("_ObjectVersion");
mk_sort("_ServerSideEncryptionByDefault");
mk_sort("_Tiering");
mk_sort("option[_InventoryFilter]");
mk_sort("option[string]");
    mk_bv("option[_InventoryFilter].domain_t",1);
    mk_int("vector[_Tag].domain");
mk_sort("_JSONInput");
mk_sort("_OutputSerialization");
mk_sort("option[_EncryptionConfiguration]");
mk_sort("option[bool]");
mk_sort("_IntelligentTieringConfiguration");
    mk_bv("byte",8);
mk_sort("option[_NoncurrentVersionExpiration]");
    mk_int("vector[_ObjectVersion].domain");
mk_sort("_MetricsFilter");
    mk_bv("option[_NoncurrentVersionTransition].domain_t",1);
    mk_bv("option[_Transition].domain_t",1);
    mk_bv("option[_ObjectLockRetention].domain_t",1);
mk_sort("_StorageClassAnalysis");
mk_sort("_BucketLifecycleConfiguration");
mk_sort("_Error");
    mk_int("vector[_NoncurrentVersionTransition].domain");
    mk_bv("option[_CreateBucketConfiguration].domain_t",1);
mk_sort("_Tag");
    mk_bv("option[_ReplicationTimeValue].domain_t",1);
mk_sort("_Bucket");
mk_sort("vector[_NoncurrentVersionTransition]");
mk_sort("_DeletedObject");
    mk_int("vector[_Bucket].domain");
mk_sort("option[unordered_map[string][string]]");
mk_sort("_AnalyticsAndOperator");
mk_sort("_CreateBucketConfiguration");
mk_sort("option[_IntelligentTieringFilter]");
mk_sort("_ReplicationTime");
    mk_int("vector[string].domain");
mk_sort("option[vector[_MetadataEntry]]");
    mk_int("vector[_MultipartUpload].domain");
mk_sort("_AnalyticsFilter");
mk_sort("_Grant");
mk_sort("_S3KeyFilter");
mk_sort("_MultipartUpload");
mk_sort("option[_Metrics]");
mk_sort("_ObjectLockRule");
    mk_int("vector[_ServerSideEncryptionRule].domain");
    mk_int("vector[_MetricsConfiguration].domain");
    mk_bv("option[string].domain_t",1);
mk_sort("_DeleteMarkerReplication");
mk_sort("_RestoreRequest");
    mk_int("vector[_TargetGrant].domain");
mk_sort("vector[_AnalyticsConfiguration]");
mk_sort("option[_RestoreRequest]");
    mk_bv("option[_ObjectLockLegalHold].domain_t",1);
mk_sort("option[_Tagging]");
    mk_int("vector[_LambdaFunctionConfiguration].domain");
mk_sort("option[_DeleteMarkerReplication]");
mk_sort("option[_Condition]");
mk_sort("vector[string]");
    mk_int("vector[_OwnershipControlsRule].domain");
    mk_int("blob.domain");
mk_sort("vector[_FilterRule]");
    mk_bv("option[blob].domain_t",1);
mk_sort("_IntelligentTieringAndOperator");
mk_sort("vector[_QueueConfiguration]");
mk_sort("_GetObjectOutput");
mk_sort("_LifecycleRuleFilter");
mk_sort("_IntelligentTieringFilter");
    mk_bv("option[_ObjectLockConfiguration].domain_t",1);
mk_sort("option[_ScanRange]");
    mk_int("vector[_QueueConfiguration].domain");
mk_sort("_PutObjectOutput");
mk_sort("vector[_InventoryConfiguration]");
mk_sort("_Metrics");
    mk_bv("option[vector[_NoncurrentVersionTransition]].domain_t",1);
mk_sort("vector[_Bucket]");
mk_sort("_StorageClassAnalysisDataExport");
mk_sort("vector[_CORSRule]");
mk_sort("_AnalyticsConfiguration");
mk_sort("_CompletedMultipartUpload");
mk_sort("_ReplicaModifications");
    mk_bv("option[_AbortIncompleteMultipartUpload].domain_t",1);
mk_sort("vector[_ReplicationRule]");
    mk_int("vector[_Object].domain");
mk_sort("option[_AbortIncompleteMultipartUpload]");
mk_sort("option[_LifecycleConfiguration]");
mk_sort("blob");
mk_sort("vector[_Object]");
    mk_bv("option[_NotificationConfigurationFilter].domain_t",1);
mk_sort("option[_ObjectLockRetention]");
    mk_bv("option[_MetricsFilter].domain_t",1);
mk_sort("_Tagging");
    mk_int("timestamp");
mk_sort("_Initiator");
mk_sort("option[_AnalyticsFilter]");
mk_sort("_RoutingRule");
    mk_int("vector[_CORSRule].domain");
mk_sort("_DefaultRetention");
mk_sort("_GetObjectRequest");
mk_sort("_CompletedPart");
    mk_int("integer");
mk_sort("option[_Transition]");
    mk_bv("option[vector[_TargetGrant]].domain_t",1);
    mk_int("vector[_Grant].domain");
    mk_bv("option[vector[string]].domain_t",1);
mk_sort("_ReplicationTimeValue");
    mk_bv("option[unordered_map[string][string]].domain_t",1);
mk_sort("_MetricsAndOperator");
mk_sort("_NoncurrentVersionTransition");
mk_sort("option[_LifecycleExpiration]");
mk_sort("_LifecycleConfiguration");
mk_sort("vector[_Tiering]");
mk_sort("option[_ObjectLockLegalHold]");
mk_sort("option[_AccessControlTranslation]");
mk_sort("_Rule");
mk_sort("vector[_Rule]");
mk_sort("_InventoryEncryption");
mk_sort("_CommonPrefix");
    mk_int("vector[_Part].domain");
    mk_bv("option[_CompletedMultipartUpload].domain_t",1);
mk_sort("_InventoryS3BucketDestination");
mk_sort("_ReplicationRuleAndOperator");
    mk_bv("option[_AccessControlPolicy].domain_t",1);
    mk_int("vector[_Error].domain");
    mk_int("vector[_Transition].domain");
mk_sort("option[vector[_TargetGrant]]");
mk_sort("_PutObjectRequest");
mk_sort("_InventoryConfiguration");
mk_sort("vector[_MetadataEntry]");
    mk_bv("option[_Encryption].domain_t",1);
    mk_int("vector[_Tiering].domain");
    mk_bv("option[_DeleteMarkerReplication].domain_t",1);
mk_sort("option[vector[_Transition]]");
mk_sort("_NoncurrentVersionExpiration");
mk_sort("_ObjectLockRetention");
mk_sort("vector[_Part]");
mk_sort("vector[_Error]");
mk_sort("_NotificationConfigurationFilter");
mk_sort("_RequestProgress");
mk_sort("_JSONOutput");
mk_sort("_ObjectIdentifier");
mk_sort("vector[_TargetGrant]");
mk_sort("_S3Location");
mk_sort("_TopicConfiguration");
mk_sort("vector[_RoutingRule]");
    mk_bv("option[timestamp].domain_t",1);
mk_sort("_QueueConfiguration");
mk_sort("option[_AccessControlPolicy]");
mk_sort("_ReplicationRule");
mk_sort("vector[_ServerSideEncryptionRule]");
    mk_int("vector[_LifecycleRule].domain");
mk_sort("vector[_MetricsConfiguration]");
mk_sort("vector[_OwnershipControlsRule]");
mk_sort("_TargetGrant");
mk_sort("option[long]");
mk_sort("option[vector[_Grant]]");
mk_sort("_MetricsConfiguration");
    mk_bv("option[long].domain_t",1);
    mk_int("long");
mk_sort("option[_ReplicationTime]");
mk_sort("option[_SourceSelectionCriteria]");
mk_sort("_ExistingObjectReplication");
mk_sort("_AccessControlTranslation");
mk_sort("_GlacierJobParameters");
mk_sort("vector[_MultipartUpload]");
mk_sort("_ServerSideEncryptionRule");
    mk_int("vector[_InventoryConfiguration].domain");
mk_sort("_InventoryDestination");
    mk_int("vector[_RoutingRule].domain");
mk_sort("_AbortIncompleteMultipartUpload");
mk_sort("option[_ReplicationRuleFilter]");
    mk_int("vector[_DeletedObject].domain");
    mk_bv("option[_ReplicationRuleFilter].domain_t",1);
mk_sort("_InventorySchedule");
mk_sort("_Grantee");
    mk_int("vector[_ObjectIdentifier].domain");
mk_sort("option[_MetricsFilter]");
    mk_int("vector[_CompletedPart].domain");
mk_sort("_Part");
mk_sort("option[blob]");
mk_sort("_Object");
mk_sort("_CSVOutput");
    mk_int("vector[_TopicConfiguration].domain");
mk_sort("option[_ExistingObjectReplication]");
mk_sort("option[_BucketLifecycleConfiguration]");
mk_sort("option[_RequestProgress]");
mk_sort("_AccessControlPolicy");
    mk_bv("option[_BucketLifecycleConfiguration].domain_t",1);
mk_sort("_ParquetInput");
mk_sort("_MetadataEntry");
mk_sort("_LifecycleRule");
mk_sort("option[integer]");
    mk_bv("option[_SourceSelectionCriteria].domain_t",1);
    mk_int("vector[_IntelligentTieringConfiguration].domain");
mk_sort("_CSVInput");
mk_sort("_CORSRule");
mk_sort("option[_CreateBucketConfiguration]");
mk_sort("option[_ReplicationTimeValue]");
    mk_int("vector[_CommonPrefix].domain");
    mk_bv("option[_LifecycleConfiguration].domain_t",1);
mk_sort("vector[_Tag]");
mk_sort("option[vector[string]]");
mk_sort("_OwnershipControlsRule");
    mk_bv("option[_AccessControlTranslation].domain_t",1);
mk_sort("vector[_CommonPrefix]");
mk_sort("_SourceSelectionCriteria");
mk_sort("vector[_LambdaFunctionConfiguration]");
    mk_bv("option[_ScanRange].domain_t",1);
mk_sort("_LambdaFunctionConfiguration");
mk_sort("option[_ObjectLockConfiguration]");
    mk_bv("option[_AnalyticsFilter].domain_t",1);
    mk_bv("option[_ExistingObjectReplication].domain_t",1);
    mk_bv("option[_Metrics].domain_t",1);
mk_sort("_Owner");
    mk_bv("option[vector[_Transition]].domain_t",1);
mk_sort("vector[_CompletedPart]");
    mk_int("vector[_Rule].domain");
    mk_bv("option[vector[_Grant]].domain_t",1);
mk_sort("_ScanRange");
    mk_bv("option[vector[_MetadataEntry]].domain_t",1);
mk_sort("_EncryptionConfiguration");
mk_sort("option[_LifecycleRuleFilter]");
mk_sort("_AnalyticsS3BucketDestination");
mk_sort("vector[_Transition]");
mk_sort("vector[_TopicConfiguration]");
mk_sort("vector[_IntelligentTieringConfiguration]");
    mk_int("vector[_AnalyticsConfiguration].domain");
mk_sort("_InventoryFilter");
mk_sort("option[timestamp]");
mk_sort("_SseKmsEncryptedObjects");
    const char *_PutObjectRequest___ContentType__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentType_",1,_PutObjectRequest___ContentType__domain,"option[string]");
    const char *_SourceSelectionCriteria___ReplicaModifications__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._ReplicaModifications_",1,_SourceSelectionCriteria___ReplicaModifications__domain,"_ReplicaModifications");
    const char *_PutObjectRequest___Bucket__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Bucket_",1,_PutObjectRequest___Bucket__domain,"string");
    const char *_Bucket___CreationDate__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._CreationDate_",1,_Bucket___CreationDate__domain,"timestamp");
    const char *_InventoryConfiguration___IsEnabled__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IsEnabled_",1,_InventoryConfiguration___IsEnabled__domain,"Bool");
    const char *_Destination___StorageClass__domain[1] = {"_Destination"};
    mk_decl("_Destination._StorageClass_",1,_Destination___StorageClass__domain,"option[string]");
    const char *option__long____value_domain[2] = {"option[long]","option[long].domain_t"};
    mk_decl("option[long].value",2,option__long____value_domain,"long");
    const char *_CORSRule___AllowedOrigins__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedOrigins_",1,_CORSRule___AllowedOrigins__domain,"vector[string]");
    const char *_ObjectVersion___Size__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Size_",1,_ObjectVersion___Size__domain,"integer");
    const char *_SSEKMS___KeyId__domain[1] = {"_SSEKMS"};
    mk_decl("_SSEKMS._KeyId_",1,_SSEKMS___KeyId__domain,"string");
    const char *_FilterRule___Name__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Name_",1,_FilterRule___Name__domain,"string");
    const char *option__vector___Grant______value_domain[2] = {"option[vector[_Grant]]","option[vector[_Grant]].domain_t"};
    mk_decl("option[vector[_Grant]].value",2,option__vector___Grant______value_domain,"vector[_Grant]");
    const char *_PutObjectRequest___ObjectLockMode__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockMode_",1,_PutObjectRequest___ObjectLockMode__domain,"option[string]");
    const char *option___ObjectLockConfiguration____value_domain[2] = {"option[_ObjectLockConfiguration]","option[_ObjectLockConfiguration].domain_t"};
    mk_decl("option[_ObjectLockConfiguration].value",2,option___ObjectLockConfiguration____value_domain,"_ObjectLockConfiguration");
    const char *vector___Object____value_domain[2] = {"vector[_Object]","vector[_Object].domain"};
    mk_decl("vector[_Object].value",2,vector___Object____value_domain,"_Object");
    const char *vector___IntelligentTieringConfiguration____end_domain[1] = {"vector[_IntelligentTieringConfiguration]"};
    mk_decl("vector[_IntelligentTieringConfiguration].end",1,vector___IntelligentTieringConfiguration____end_domain,"vector[_IntelligentTieringConfiguration].domain");
    const char *_InventoryS3BucketDestination___Prefix__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Prefix_",1,_InventoryS3BucketDestination___Prefix__domain,"option[string]");
    const char *_DefaultRetention___Days__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Days_",1,_DefaultRetention___Days__domain,"integer");
    const char *_Redirect___Protocol__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._Protocol_",1,_Redirect___Protocol__domain,"string");
    const char *_MetricsFilter___Prefix__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Prefix_",1,_MetricsFilter___Prefix__domain,"string");
    const char *_LifecycleRule___AbortIncompleteMultipartUpload__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._AbortIncompleteMultipartUpload_",1,_LifecycleRule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *_InventoryConfiguration___OptionalFields__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._OptionalFields_",1,_InventoryConfiguration___OptionalFields__domain,"option[vector[string]]");
    const char *_PutObjectRequest___SSEKMSKeyId__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSKeyId_",1,_PutObjectRequest___SSEKMSKeyId__domain,"option[string]");
    const char *vector___Rule____end_domain[1] = {"vector[_Rule]"};
    mk_decl("vector[_Rule].end",1,vector___Rule____end_domain,"vector[_Rule].domain");
    const char *vector___MetadataEntry____end_domain[1] = {"vector[_MetadataEntry]"};
    mk_decl("vector[_MetadataEntry].end",1,vector___MetadataEntry____end_domain,"vector[_MetadataEntry].domain");
    const char *vector___DeletedObject____value_domain[2] = {"vector[_DeletedObject]","vector[_DeletedObject].domain"};
    mk_decl("vector[_DeletedObject].value",2,vector___DeletedObject____value_domain,"_DeletedObject");
    const char *_LambdaFunctionConfiguration___Id__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Id_",1,_LambdaFunctionConfiguration___Id__domain,"option[string]");
    const char *option___MetricsFilter____value_domain[2] = {"option[_MetricsFilter]","option[_MetricsFilter].domain_t"};
    mk_decl("option[_MetricsFilter].value",2,option___MetricsFilter____value_domain,"_MetricsFilter");
    const char *_CSVOutput___QuoteCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteCharacter_",1,_CSVOutput___QuoteCharacter__domain,"string");
    const char *_NoncurrentVersionTransition___StorageClass__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._StorageClass_",1,_NoncurrentVersionTransition___StorageClass__domain,"string");
    mk_const("the_key","string");
    const char *_OutputLocation___S3__domain[1] = {"_OutputLocation"};
    mk_decl("_OutputLocation._S3_",1,_OutputLocation___S3__domain,"_S3Location");
    const char *_MetadataEntry___Value__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Value_",1,_MetadataEntry___Value__domain,"string");
    const char *vector___Bucket____end_domain[1] = {"vector[_Bucket]"};
    mk_decl("vector[_Bucket].end",1,vector___Bucket____end_domain,"vector[_Bucket].domain");
    const char *_Metrics___Status__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._Status_",1,_Metrics___Status__domain,"string");
    const char *vector___LifecycleRule____value_domain[2] = {"vector[_LifecycleRule]","vector[_LifecycleRule].domain"};
    mk_decl("vector[_LifecycleRule].value",2,vector___LifecycleRule____value_domain,"_LifecycleRule");
    const char *option___SourceSelectionCriteria____value_domain[2] = {"option[_SourceSelectionCriteria]","option[_SourceSelectionCriteria].domain_t"};
    mk_decl("option[_SourceSelectionCriteria].value",2,option___SourceSelectionCriteria____value_domain,"_SourceSelectionCriteria");
    const char *_SelectParameters___InputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._InputSerialization_",1,_SelectParameters___InputSerialization__domain,"_InputSerialization");
    const char *option___NoncurrentVersionExpiration____value_domain[2] = {"option[_NoncurrentVersionExpiration]","option[_NoncurrentVersionExpiration].domain_t"};
    mk_decl("option[_NoncurrentVersionExpiration].value",2,option___NoncurrentVersionExpiration____value_domain,"_NoncurrentVersionExpiration");
    const char *_LambdaFunctionConfiguration___Filter__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Filter_",1,_LambdaFunctionConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_Redirect___ReplaceKeyWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyWith_",1,_Redirect___ReplaceKeyWith__domain,"string");
    const char *option___Metrics____value_domain[2] = {"option[_Metrics]","option[_Metrics].domain_t"};
    mk_decl("option[_Metrics].value",2,option___Metrics____value_domain,"_Metrics");
    const char *_CORSRule___ExposeHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ExposeHeaders_",1,_CORSRule___ExposeHeaders__domain,"option[vector[string]]");
    const char *_ServerSideEncryptionRule___BucketKeyEnabled__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._BucketKeyEnabled_",1,_ServerSideEncryptionRule___BucketKeyEnabled__domain,"Bool");
    const char *_PutObjectRequest___ContentEncoding__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentEncoding_",1,_PutObjectRequest___ContentEncoding__domain,"option[string]");
    const char *option___ObjectLockLegalHold____end_domain[1] = {"option[_ObjectLockLegalHold]"};
    mk_decl("option[_ObjectLockLegalHold].end",1,option___ObjectLockLegalHold____end_domain,"option[_ObjectLockLegalHold].domain_t");
    const char *_AnalyticsConfiguration___Id__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Id_",1,_AnalyticsConfiguration___Id__domain,"string");
    const char *vector__string____value_domain[2] = {"vector[string]","vector[string].domain"};
    mk_decl("vector[string].value",2,vector__string____value_domain,"string");
    const char *_ObjectVersion___IsLatest__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._IsLatest_",1,_ObjectVersion___IsLatest__domain,"Bool");
    const char *_GetObjectOutput___SSECustomerKeyMD5__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerKeyMD5_",1,_GetObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_GetObjectOutput___SSEKMSKeyId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSEKMSKeyId_",1,_GetObjectOutput___SSEKMSKeyId__domain,"string");
    const char *vector___ReplicationRule____value_domain[2] = {"vector[_ReplicationRule]","vector[_ReplicationRule].domain"};
    mk_decl("vector[_ReplicationRule].value",2,vector___ReplicationRule____value_domain,"_ReplicationRule");
    const char *_IntelligentTieringConfiguration___Id__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Id_",1,_IntelligentTieringConfiguration___Id__domain,"string");
    const char *_ReplicationRule___ID__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ID_",1,_ReplicationRule___ID__domain,"option[string]");
    const char *option___RequestProgress____value_domain[2] = {"option[_RequestProgress]","option[_RequestProgress].domain_t"};
    mk_decl("option[_RequestProgress].value",2,option___RequestProgress____value_domain,"_RequestProgress");
    const char *_GetObjectOutput___AcceptRanges__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._AcceptRanges_",1,_GetObjectOutput___AcceptRanges__domain,"string");
    const char *_Part___ETag__domain[1] = {"_Part"};
    mk_decl("_Part._ETag_",1,_Part___ETag__domain,"string");
    const char *_Owner___ID__domain[1] = {"_Owner"};
    mk_decl("_Owner._ID_",1,_Owner___ID__domain,"string");
    const char *vector___TopicConfiguration____end_domain[1] = {"vector[_TopicConfiguration]"};
    mk_decl("vector[_TopicConfiguration].end",1,vector___TopicConfiguration____end_domain,"vector[_TopicConfiguration].domain");
    const char *_GetObjectRequest___Key__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Key_",1,_GetObjectRequest___Key__domain,"string");
    const char *option___LifecycleExpiration____value_domain[2] = {"option[_LifecycleExpiration]","option[_LifecycleExpiration].domain_t"};
    mk_decl("option[_LifecycleExpiration].value",2,option___LifecycleExpiration____value_domain,"_LifecycleExpiration");
    const char *_S3Location___CannedACL__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._CannedACL_",1,_S3Location___CannedACL__domain,"option[string]");
    const char *_InventoryS3BucketDestination___Encryption__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Encryption_",1,_InventoryS3BucketDestination___Encryption__domain,"option[_InventoryEncryption]");
    const char *_Destination___EncryptionConfiguration__domain[1] = {"_Destination"};
    mk_decl("_Destination._EncryptionConfiguration_",1,_Destination___EncryptionConfiguration__domain,"option[_EncryptionConfiguration]");
    const char *option___ReplicationTimeValue____value_domain[2] = {"option[_ReplicationTimeValue]","option[_ReplicationTimeValue].domain_t"};
    mk_decl("option[_ReplicationTimeValue].value",2,option___ReplicationTimeValue____value_domain,"_ReplicationTimeValue");
    const char *option__blob____end_domain[1] = {"option[blob]"};
    mk_decl("option[blob].end",1,option__blob____end_domain,"option[blob].domain_t");
    const char *option__vector___Transition______end_domain[1] = {"option[vector[_Transition]]"};
    mk_decl("option[vector[_Transition]].end",1,option__vector___Transition______end_domain,"option[vector[_Transition]].domain_t");
    const char *_GetObjectRequest___Range__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Range_",1,_GetObjectRequest___Range__domain,"option[string]");
    const char *_LifecycleRule___Status__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Status_",1,_LifecycleRule___Status__domain,"string");
    const char *option___InventoryFilter____value_domain[2] = {"option[_InventoryFilter]","option[_InventoryFilter].domain_t"};
    mk_decl("option[_InventoryFilter].value",2,option___InventoryFilter____value_domain,"_InventoryFilter");
    const char *_GetObjectOutput___ETag__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ETag_",1,_GetObjectOutput___ETag__domain,"string");
    const char *_LifecycleRuleFilter___And__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._And_",1,_LifecycleRuleFilter___And__domain,"_LifecycleRuleAndOperator");
    const char *_Tag___Key__domain[1] = {"_Tag"};
    mk_decl("_Tag._Key_",1,_Tag___Key__domain,"string");
    const char *_ObjectLockRetention___RetainUntilDate__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._RetainUntilDate_",1,_ObjectLockRetention___RetainUntilDate__domain,"timestamp");
    const char *option___ObjectLockRetention____value_domain[2] = {"option[_ObjectLockRetention]","option[_ObjectLockRetention].domain_t"};
    mk_decl("option[_ObjectLockRetention].value",2,option___ObjectLockRetention____value_domain,"_ObjectLockRetention");
    const char *_LambdaFunctionConfiguration___LambdaFunctionArn__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._LambdaFunctionArn_",1,_LambdaFunctionConfiguration___LambdaFunctionArn__domain,"string");
    const char *vector___RoutingRule____value_domain[2] = {"vector[_RoutingRule]","vector[_RoutingRule].domain"};
    mk_decl("vector[_RoutingRule].value",2,vector___RoutingRule____value_domain,"_RoutingRule");
    const char *_AnalyticsFilter___And__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._And_",1,_AnalyticsFilter___And__domain,"_AnalyticsAndOperator");
    const char *vector___CommonPrefix____end_domain[1] = {"vector[_CommonPrefix]"};
    mk_decl("vector[_CommonPrefix].end",1,vector___CommonPrefix____end_domain,"vector[_CommonPrefix].domain");
    const char *option__vector__string______end_domain[1] = {"option[vector[string]]"};
    mk_decl("option[vector[string]].end",1,option__vector__string______end_domain,"option[vector[string]].domain_t");
    const char *_S3Location___Encryption__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Encryption_",1,_S3Location___Encryption__domain,"option[_Encryption]");
    const char *_CompletedPart___PartNumber__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._PartNumber_",1,_CompletedPart___PartNumber__domain,"integer");
    const char *vector___AnalyticsConfiguration____value_domain[2] = {"vector[_AnalyticsConfiguration]","vector[_AnalyticsConfiguration].domain"};
    mk_decl("vector[_AnalyticsConfiguration].value",2,vector___AnalyticsConfiguration____value_domain,"_AnalyticsConfiguration");
    const char *_GetObjectRequest___PartNumber__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._PartNumber_",1,_GetObjectRequest___PartNumber__domain,"option[integer]");
    const char *_Grantee___EmailAddress__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._EmailAddress_",1,_Grantee___EmailAddress__domain,"option[string]");
    const char *_Tiering___AccessTier__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._AccessTier_",1,_Tiering___AccessTier__domain,"string");
    const char *_S3Location___StorageClass__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._StorageClass_",1,_S3Location___StorageClass__domain,"option[string]");
    const char *_AnalyticsAndOperator___Prefix__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Prefix_",1,_AnalyticsAndOperator___Prefix__domain,"string");
    const char *_ObjectLockConfiguration___ObjectLockEnabled__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._ObjectLockEnabled_",1,_ObjectLockConfiguration___ObjectLockEnabled__domain,"string");
    const char *option___Encryption____value_domain[2] = {"option[_Encryption]","option[_Encryption].domain_t"};
    mk_decl("option[_Encryption].value",2,option___Encryption____value_domain,"_Encryption");
    const char *_ReplicationRuleFilter___Tag__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Tag_",1,_ReplicationRuleFilter___Tag__domain,"_Tag");
    const char *_Error___Key__domain[1] = {"_Error"};
    mk_decl("_Error._Key_",1,_Error___Key__domain,"string");
    const char *_ObjectVersion___VersionId__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._VersionId_",1,_ObjectVersion___VersionId__domain,"string");
    const char *_RestoreRequest___Tier__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Tier_",1,_RestoreRequest___Tier__domain,"string");
    const char *_GetObjectOutput___ContentRange__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentRange_",1,_GetObjectOutput___ContentRange__domain,"string");
    const char *_DeletedObject___Key__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._Key_",1,_DeletedObject___Key__domain,"string");
    const char *option___LifecycleConfiguration____value_domain[2] = {"option[_LifecycleConfiguration]","option[_LifecycleConfiguration].domain_t"};
    mk_decl("option[_LifecycleConfiguration].value",2,option___LifecycleConfiguration____value_domain,"_LifecycleConfiguration");
    const char *_GetObjectRequest___ExpectedBucketOwner__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ExpectedBucketOwner_",1,_GetObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_LifecycleRule___NoncurrentVersionExpiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionExpiration_",1,_LifecycleRule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *option___CreateBucketConfiguration____value_domain[2] = {"option[_CreateBucketConfiguration]","option[_CreateBucketConfiguration].domain_t"};
    mk_decl("option[_CreateBucketConfiguration].value",2,option___CreateBucketConfiguration____value_domain,"_CreateBucketConfiguration");
    const char *vector___Tiering____end_domain[1] = {"vector[_Tiering]"};
    mk_decl("vector[_Tiering].end",1,vector___Tiering____end_domain,"vector[_Tiering].domain");
    const char *_NoncurrentVersionExpiration___NoncurrentDays__domain[1] = {"_NoncurrentVersionExpiration"};
    mk_decl("_NoncurrentVersionExpiration._NoncurrentDays_",1,_NoncurrentVersionExpiration___NoncurrentDays__domain,"integer");
    const char *_RequestProgress___Enabled__domain[1] = {"_RequestProgress"};
    mk_decl("_RequestProgress._Enabled_",1,_RequestProgress___Enabled__domain,"Bool");
    const char *_StorageClassAnalysis___DataExport__domain[1] = {"_StorageClassAnalysis"};
    mk_decl("_StorageClassAnalysis._DataExport_",1,_StorageClassAnalysis___DataExport__domain,"_StorageClassAnalysisDataExport");
    const char *option__string____end_domain[1] = {"option[string]"};
    mk_decl("option[string].end",1,option__string____end_domain,"option[string].domain_t");
    const char *_GetObjectRequest___SSECustomerKey__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKey_",1,_GetObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_SourceSelectionCriteria___SseKmsEncryptedObjects__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._SseKmsEncryptedObjects_",1,_SourceSelectionCriteria___SseKmsEncryptedObjects__domain,"_SseKmsEncryptedObjects");
    const char *vector___Part____end_domain[1] = {"vector[_Part]"};
    mk_decl("vector[_Part].end",1,vector___Part____end_domain,"vector[_Part].domain");
    const char *option___LifecycleConfiguration____end_domain[1] = {"option[_LifecycleConfiguration]"};
    mk_decl("option[_LifecycleConfiguration].end",1,option___LifecycleConfiguration____end_domain,"option[_LifecycleConfiguration].domain_t");
    const char *option___LifecycleRuleFilter____value_domain[2] = {"option[_LifecycleRuleFilter]","option[_LifecycleRuleFilter].domain_t"};
    mk_decl("option[_LifecycleRuleFilter].value",2,option___LifecycleRuleFilter____value_domain,"_LifecycleRuleFilter");
    const char *option___CompletedMultipartUpload____value_domain[2] = {"option[_CompletedMultipartUpload]","option[_CompletedMultipartUpload].domain_t"};
    mk_decl("option[_CompletedMultipartUpload].value",2,option___CompletedMultipartUpload____value_domain,"_CompletedMultipartUpload");
    const char *_CompletedMultipartUpload___Parts__domain[1] = {"_CompletedMultipartUpload"};
    mk_decl("_CompletedMultipartUpload._Parts_",1,_CompletedMultipartUpload___Parts__domain,"vector[_CompletedPart]");
    const char *_ReplicationRuleFilter___And__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._And_",1,_ReplicationRuleFilter___And__domain,"_ReplicationRuleAndOperator");
    const char *_GetObjectOutput___ObjectLockLegalHoldStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockLegalHoldStatus_",1,_GetObjectOutput___ObjectLockLegalHoldStatus__domain,"string");
    const char *_Object___LastModified__domain[1] = {"_Object"};
    mk_decl("_Object._LastModified_",1,_Object___LastModified__domain,"timestamp");
    const char *_PutObjectRequest___ContentDisposition__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentDisposition_",1,_PutObjectRequest___ContentDisposition__domain,"option[string]");
    const char *_Grant___Permission__domain[1] = {"_Grant"};
    mk_decl("_Grant._Permission_",1,_Grant___Permission__domain,"string");
    const char *_QueueConfiguration___QueueArn__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._QueueArn_",1,_QueueConfiguration___QueueArn__domain,"string");
    const char *_GetObjectOutput___ObjectLockRetainUntilDate__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockRetainUntilDate_",1,_GetObjectOutput___ObjectLockRetainUntilDate__domain,"timestamp");
    const char *option___SourceSelectionCriteria____end_domain[1] = {"option[_SourceSelectionCriteria]"};
    mk_decl("option[_SourceSelectionCriteria].end",1,option___SourceSelectionCriteria____end_domain,"option[_SourceSelectionCriteria].domain_t");
    const char *_ObjectVersion___LastModified__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._LastModified_",1,_ObjectVersion___LastModified__domain,"timestamp");
    const char *_TopicConfiguration___TopicArn__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._TopicArn_",1,_TopicConfiguration___TopicArn__domain,"string");
    const char *option___ExistingObjectReplication____end_domain[1] = {"option[_ExistingObjectReplication]"};
    mk_decl("option[_ExistingObjectReplication].end",1,option___ExistingObjectReplication____end_domain,"option[_ExistingObjectReplication].domain_t");
    const char *_GetObjectRequest___ResponseContentType__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentType_",1,_GetObjectRequest___ResponseContentType__domain,"option[string]");
    const char *vector___Tiering____value_domain[2] = {"vector[_Tiering]","vector[_Tiering].domain"};
    mk_decl("vector[_Tiering].value",2,vector___Tiering____value_domain,"_Tiering");
    const char *_RestoreRequest___Description__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Description_",1,_RestoreRequest___Description__domain,"string");
    const char *_ScanRange___End__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._End_",1,_ScanRange___End__domain,"long");
    const char *_PutObjectRequest___Tagging__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Tagging_",1,_PutObjectRequest___Tagging__domain,"option[string]");
    const char *vector___ServerSideEncryptionRule____value_domain[2] = {"vector[_ServerSideEncryptionRule]","vector[_ServerSideEncryptionRule].domain"};
    mk_decl("vector[_ServerSideEncryptionRule].value",2,vector___ServerSideEncryptionRule____value_domain,"_ServerSideEncryptionRule");
    const char *_PutObjectRequest___WebsiteRedirectLocation__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._WebsiteRedirectLocation_",1,_PutObjectRequest___WebsiteRedirectLocation__domain,"option[string]");
    const char *vector___Transition____value_domain[2] = {"vector[_Transition]","vector[_Transition].domain"};
    mk_decl("vector[_Transition].value",2,vector___Transition____value_domain,"_Transition");
    const char *_Rule___Prefix__domain[1] = {"_Rule"};
    mk_decl("_Rule._Prefix_",1,_Rule___Prefix__domain,"string");
    const char *option___Tagging____value_domain[2] = {"option[_Tagging]","option[_Tagging].domain_t"};
    mk_decl("option[_Tagging].value",2,option___Tagging____value_domain,"_Tagging");
    const char *option___AccessControlPolicy____end_domain[1] = {"option[_AccessControlPolicy]"};
    mk_decl("option[_AccessControlPolicy].end",1,option___AccessControlPolicy____end_domain,"option[_AccessControlPolicy].domain_t");
    const char *_TargetGrant___Grantee__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Grantee_",1,_TargetGrant___Grantee__domain,"_Grantee");
    const char *_Rule___NoncurrentVersionExpiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionExpiration_",1,_Rule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain[1] = {"_AbortIncompleteMultipartUpload"};
    mk_decl("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",1,_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain,"integer");
    const char *option__unordered_map__string____string______end_domain[1] = {"option[unordered_map[string][string]]"};
    mk_decl("option[unordered_map[string][string]].end",1,option__unordered_map__string____string______end_domain,"option[unordered_map[string][string]].domain_t");
    const char *_PutObjectOutput___RequestCharged__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._RequestCharged_",1,_PutObjectOutput___RequestCharged__domain,"string");
    const char *_InventoryEncryption___SSES3__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSES3_",1,_InventoryEncryption___SSES3__domain,"_SSES3");
    const char *_Redirect___HostName__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HostName_",1,_Redirect___HostName__domain,"string");
    const char *option___AnalyticsFilter____value_domain[2] = {"option[_AnalyticsFilter]","option[_AnalyticsFilter].domain_t"};
    mk_decl("option[_AnalyticsFilter].value",2,option___AnalyticsFilter____value_domain,"_AnalyticsFilter");
    const char *option___EncryptionConfiguration____value_domain[2] = {"option[_EncryptionConfiguration]","option[_EncryptionConfiguration].domain_t"};
    mk_decl("option[_EncryptionConfiguration].value",2,option___EncryptionConfiguration____value_domain,"_EncryptionConfiguration");
    const char *_Condition___KeyPrefixEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._KeyPrefixEquals_",1,_Condition___KeyPrefixEquals__domain,"string");
    const char *_GetObjectRequest___ResponseContentEncoding__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentEncoding_",1,_GetObjectRequest___ResponseContentEncoding__domain,"option[string]");
    const char *_CSVInput___AllowQuotedRecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._AllowQuotedRecordDelimiter_",1,_CSVInput___AllowQuotedRecordDelimiter__domain,"Bool");
    const char *option___RestoreRequest____end_domain[1] = {"option[_RestoreRequest]"};
    mk_decl("option[_RestoreRequest].end",1,option___RestoreRequest____end_domain,"option[_RestoreRequest].domain_t");
    const char *_JSONInput___Type__domain[1] = {"_JSONInput"};
    mk_decl("_JSONInput._Type_",1,_JSONInput___Type__domain,"string");
    const char *_LifecycleExpiration___Days__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Days_",1,_LifecycleExpiration___Days__domain,"integer");
    const char *_GetObjectOutput___ReplicationStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ReplicationStatus_",1,_GetObjectOutput___ReplicationStatus__domain,"string");
    const char *option__vector___NoncurrentVersionTransition______end_domain[1] = {"option[vector[_NoncurrentVersionTransition]]"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].end",1,option__vector___NoncurrentVersionTransition______end_domain,"option[vector[_NoncurrentVersionTransition]].domain_t");
    const char *_MultipartUpload___StorageClass__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._StorageClass_",1,_MultipartUpload___StorageClass__domain,"string");
    const char *_InventoryDestination___S3BucketDestination__domain[1] = {"_InventoryDestination"};
    mk_decl("_InventoryDestination._S3BucketDestination_",1,_InventoryDestination___S3BucketDestination__domain,"_InventoryS3BucketDestination");
    const char *option___NotificationConfigurationFilter____value_domain[2] = {"option[_NotificationConfigurationFilter]","option[_NotificationConfigurationFilter].domain_t"};
    mk_decl("option[_NotificationConfigurationFilter].value",2,option___NotificationConfigurationFilter____value_domain,"_NotificationConfigurationFilter");
    const char *option__blob____value_domain[2] = {"option[blob]","option[blob].domain_t"};
    mk_decl("option[blob].value",2,option__blob____value_domain,"blob");
    const char *_GetObjectOutput___ContentLanguage__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLanguage_",1,_GetObjectOutput___ContentLanguage__domain,"string");
    const char *_InventoryS3BucketDestination___AccountId__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._AccountId_",1,_InventoryS3BucketDestination___AccountId__domain,"option[string]");
    const char *_ReplicationRule___ExistingObjectReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ExistingObjectReplication_",1,_ReplicationRule___ExistingObjectReplication__domain,"option[_ExistingObjectReplication]");
    const char *_StorageClassAnalysisDataExport___Destination__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._Destination_",1,_StorageClassAnalysisDataExport___Destination__domain,"_AnalyticsExportDestination");
    const char *_RestoreRequest___Days__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Days_",1,_RestoreRequest___Days__domain,"integer");
    const char *_ObjectVersion___StorageClass__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._StorageClass_",1,_ObjectVersion___StorageClass__domain,"string");
    const char *_CSVInput___FileHeaderInfo__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FileHeaderInfo_",1,_CSVInput___FileHeaderInfo__domain,"string");
    const char *option___AccessControlPolicy____value_domain[2] = {"option[_AccessControlPolicy]","option[_AccessControlPolicy].domain_t"};
    mk_decl("option[_AccessControlPolicy].value",2,option___AccessControlPolicy____value_domain,"_AccessControlPolicy");
    const char *_LifecycleRule___Prefix__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Prefix_",1,_LifecycleRule___Prefix__domain,"option[string]");
    const char *option___InventoryEncryption____end_domain[1] = {"option[_InventoryEncryption]"};
    mk_decl("option[_InventoryEncryption].end",1,option___InventoryEncryption____end_domain,"option[_InventoryEncryption].domain_t");
    const char *_AnalyticsS3BucketDestination___Bucket__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Bucket_",1,_AnalyticsS3BucketDestination___Bucket__domain,"string");
    const char *_CORSRule___AllowedMethods__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedMethods_",1,_CORSRule___AllowedMethods__domain,"vector[string]");
    const char *_OutputSerialization___CSV__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._CSV_",1,_OutputSerialization___CSV__domain,"_CSVOutput");
    const char *_GetObjectRequest___SSECustomerKeyMD5__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKeyMD5_",1,_GetObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Destination___ReplicationTime__domain[1] = {"_Destination"};
    mk_decl("_Destination._ReplicationTime_",1,_Destination___ReplicationTime__domain,"option[_ReplicationTime]");
    const char *_Redirect___HttpRedirectCode__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HttpRedirectCode_",1,_Redirect___HttpRedirectCode__domain,"string");
    const char *_Encryption___KMSKeyId__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSKeyId_",1,_Encryption___KMSKeyId__domain,"option[string]");
    const char *_RestoreRequest___GlacierJobParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._GlacierJobParameters_",1,_RestoreRequest___GlacierJobParameters__domain,"_GlacierJobParameters");
    const char *_PutObjectOutput___ServerSideEncryption__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ServerSideEncryption_",1,_PutObjectOutput___ServerSideEncryption__domain,"string");
    const char *_CommonPrefix___Prefix__domain[1] = {"_CommonPrefix"};
    mk_decl("_CommonPrefix._Prefix_",1,_CommonPrefix___Prefix__domain,"string");
    const char *_InventoryConfiguration___Destination__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Destination_",1,_InventoryConfiguration___Destination__domain,"_InventoryDestination");
    const char *_DeletedObject___VersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._VersionId_",1,_DeletedObject___VersionId__domain,"string");
    const char *_S3Location___BucketName__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._BucketName_",1,_S3Location___BucketName__domain,"string");
    const char *_ReplicationTime___Time__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Time_",1,_ReplicationTime___Time__domain,"_ReplicationTimeValue");
    const char *_GetObjectOutput___Body__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Body_",1,_GetObjectOutput___Body__domain,"blob");
    const char *_TargetGrant___Permission__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Permission_",1,_TargetGrant___Permission__domain,"string");
    const char *_Grant___Grantee__domain[1] = {"_Grant"};
    mk_decl("_Grant._Grantee_",1,_Grant___Grantee__domain,"_Grantee");
    const char *option___AbortIncompleteMultipartUpload____value_domain[2] = {"option[_AbortIncompleteMultipartUpload]","option[_AbortIncompleteMultipartUpload].domain_t"};
    mk_decl("option[_AbortIncompleteMultipartUpload].value",2,option___AbortIncompleteMultipartUpload____value_domain,"_AbortIncompleteMultipartUpload");
    const char *option___Transition____value_domain[2] = {"option[_Transition]","option[_Transition].domain_t"};
    mk_decl("option[_Transition].value",2,option___Transition____value_domain,"_Transition");
    const char *vector___Tag____value_domain[2] = {"vector[_Tag]","vector[_Tag].domain"};
    mk_decl("vector[_Tag].value",2,vector___Tag____value_domain,"_Tag");
    const char *_GetObjectOutput___StorageClass__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._StorageClass_",1,_GetObjectOutput___StorageClass__domain,"string");
    const char *option___IntelligentTieringFilter____end_domain[1] = {"option[_IntelligentTieringFilter]"};
    mk_decl("option[_IntelligentTieringFilter].end",1,option___IntelligentTieringFilter____end_domain,"option[_IntelligentTieringFilter].domain_t");
    const char *_DeleteMarkerEntry___IsLatest__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._IsLatest_",1,_DeleteMarkerEntry___IsLatest__domain,"Bool");
    const char *vector___ObjectVersion____value_domain[2] = {"vector[_ObjectVersion]","vector[_ObjectVersion].domain"};
    mk_decl("vector[_ObjectVersion].value",2,vector___ObjectVersion____value_domain,"_ObjectVersion");
    const char *_S3Location___UserMetadata__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._UserMetadata_",1,_S3Location___UserMetadata__domain,"option[vector[_MetadataEntry]]");
    const char *_InventoryConfiguration___Filter__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Filter_",1,_InventoryConfiguration___Filter__domain,"option[_InventoryFilter]");
    const char *_AnalyticsFilter___Tag__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Tag_",1,_AnalyticsFilter___Tag__domain,"_Tag");
    const char *_ServerSideEncryptionByDefault___SSEAlgorithm__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._SSEAlgorithm_",1,_ServerSideEncryptionByDefault___SSEAlgorithm__domain,"string");
    const char *_GetObjectOutput___PartsCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._PartsCount_",1,_GetObjectOutput___PartsCount__domain,"integer");
    const char *_IntelligentTieringAndOperator___Tags__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Tags_",1,_IntelligentTieringAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___Bucket____value_domain[2] = {"vector[_Bucket]","vector[_Bucket].domain"};
    mk_decl("vector[_Bucket].value",2,vector___Bucket____value_domain,"_Bucket");
    const char *option__vector___Grant______end_domain[1] = {"option[vector[_Grant]]"};
    mk_decl("option[vector[_Grant]].end",1,option__vector___Grant______end_domain,"option[vector[_Grant]].domain_t");
    const char *_ObjectVersion___Key__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Key_",1,_ObjectVersion___Key__domain,"string");
    const char *option___AccessControlTranslation____end_domain[1] = {"option[_AccessControlTranslation]"};
    mk_decl("option[_AccessControlTranslation].end",1,option___AccessControlTranslation____end_domain,"option[_AccessControlTranslation].domain_t");
    const char *_CORSRule___AllowedHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedHeaders_",1,_CORSRule___AllowedHeaders__domain,"option[vector[string]]");
    const char *_InventoryS3BucketDestination___Bucket__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Bucket_",1,_InventoryS3BucketDestination___Bucket__domain,"string");
    const char *_NoncurrentVersionTransition___NoncurrentDays__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._NoncurrentDays_",1,_NoncurrentVersionTransition___NoncurrentDays__domain,"integer");
    const char *_PutObjectRequest___ACL__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ACL_",1,_PutObjectRequest___ACL__domain,"option[string]");
    const char *_CreateBucketConfiguration___LocationConstraint__domain[1] = {"_CreateBucketConfiguration"};
    mk_decl("_CreateBucketConfiguration._LocationConstraint_",1,_CreateBucketConfiguration___LocationConstraint__domain,"string");
    const char *_MetricsConfiguration___Id__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Id_",1,_MetricsConfiguration___Id__domain,"string");
    const char *_InventoryConfiguration___Schedule__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Schedule_",1,_InventoryConfiguration___Schedule__domain,"_InventorySchedule");
    const char *_InventoryConfiguration___IncludedObjectVersions__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IncludedObjectVersions_",1,_InventoryConfiguration___IncludedObjectVersions__domain,"string");
    const char *_Part___PartNumber__domain[1] = {"_Part"};
    mk_decl("_Part._PartNumber_",1,_Part___PartNumber__domain,"integer");
    const char *_DefaultRetention___Years__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Years_",1,_DefaultRetention___Years__domain,"integer");
    const char *_Error___VersionId__domain[1] = {"_Error"};
    mk_decl("_Error._VersionId_",1,_Error___VersionId__domain,"string");
    const char *_ReplicationRule___Prefix__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Prefix_",1,_ReplicationRule___Prefix__domain,"option[string]");
    const char *_CORSRule___MaxAgeSeconds__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._MaxAgeSeconds_",1,_CORSRule___MaxAgeSeconds__domain,"option[integer]");
    const char *_MetricsAndOperator___Prefix__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Prefix_",1,_MetricsAndOperator___Prefix__domain,"string");
    const char *_CSVOutput___QuoteFields__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteFields_",1,_CSVOutput___QuoteFields__domain,"string");
    const char *vector___ReplicationRule____end_domain[1] = {"vector[_ReplicationRule]"};
    mk_decl("vector[_ReplicationRule].end",1,vector___ReplicationRule____end_domain,"vector[_ReplicationRule].domain");
    const char *vector___DeleteMarkerEntry____value_domain[2] = {"vector[_DeleteMarkerEntry]","vector[_DeleteMarkerEntry].domain"};
    mk_decl("vector[_DeleteMarkerEntry].value",2,vector___DeleteMarkerEntry____value_domain,"_DeleteMarkerEntry");
    const char *_RestoreRequest___OutputLocation__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._OutputLocation_",1,_RestoreRequest___OutputLocation__domain,"_OutputLocation");
    const char *_Condition___HttpErrorCodeReturnedEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._HttpErrorCodeReturnedEquals_",1,_Condition___HttpErrorCodeReturnedEquals__domain,"string");
    const char *vector___InventoryConfiguration____end_domain[1] = {"vector[_InventoryConfiguration]"};
    mk_decl("vector[_InventoryConfiguration].end",1,vector___InventoryConfiguration____end_domain,"vector[_InventoryConfiguration].domain");
    const char *vector___CommonPrefix____value_domain[2] = {"vector[_CommonPrefix]","vector[_CommonPrefix].domain"};
    mk_decl("vector[_CommonPrefix].value",2,vector___CommonPrefix____value_domain,"_CommonPrefix");
    const char *_GetObjectOutput___LastModified__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._LastModified_",1,_GetObjectOutput___LastModified__domain,"timestamp");
    const char *_InputSerialization___JSON__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._JSON_",1,_InputSerialization___JSON__domain,"_JSONInput");
    const char *option__vector___MetadataEntry______end_domain[1] = {"option[vector[_MetadataEntry]]"};
    mk_decl("option[vector[_MetadataEntry]].end",1,option__vector___MetadataEntry______end_domain,"option[vector[_MetadataEntry]].domain_t");
    const char *_PutObjectRequest___ContentMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentMD5_",1,_PutObjectRequest___ContentMD5__domain,"option[string]");
    const char *_ObjectLockLegalHold___Status__domain[1] = {"_ObjectLockLegalHold"};
    mk_decl("_ObjectLockLegalHold._Status_",1,_ObjectLockLegalHold___Status__domain,"string");
    const char *option___LifecycleRuleFilter____end_domain[1] = {"option[_LifecycleRuleFilter]"};
    mk_decl("option[_LifecycleRuleFilter].end",1,option___LifecycleRuleFilter____end_domain,"option[_LifecycleRuleFilter].domain_t");
    const char *_StorageClassAnalysisDataExport___OutputSchemaVersion__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._OutputSchemaVersion_",1,_StorageClassAnalysisDataExport___OutputSchemaVersion__domain,"string");
    const char *option___Condition____value_domain[2] = {"option[_Condition]","option[_Condition].domain_t"};
    mk_decl("option[_Condition].value",2,option___Condition____value_domain,"_Condition");
    const char *option___DeleteMarkerReplication____value_domain[2] = {"option[_DeleteMarkerReplication]","option[_DeleteMarkerReplication].domain_t"};
    mk_decl("option[_DeleteMarkerReplication].value",2,option___DeleteMarkerReplication____value_domain,"_DeleteMarkerReplication");
    const char *vector___FilterRule____end_domain[1] = {"vector[_FilterRule]"};
    mk_decl("vector[_FilterRule].end",1,vector___FilterRule____end_domain,"vector[_FilterRule].domain");
    const char *_SelectParameters___OutputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._OutputSerialization_",1,_SelectParameters___OutputSerialization__domain,"_OutputSerialization");
    const char *_Grantee___DisplayName__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._DisplayName_",1,_Grantee___DisplayName__domain,"option[string]");
    const char *_GetObjectOutput___CacheControl__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._CacheControl_",1,_GetObjectOutput___CacheControl__domain,"string");
    const char *_S3Location___Tagging__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Tagging_",1,_S3Location___Tagging__domain,"option[_Tagging]");
    const char *option___ScanRange____end_domain[1] = {"option[_ScanRange]"};
    mk_decl("option[_ScanRange].end",1,option___ScanRange____end_domain,"option[_ScanRange].domain_t");
    const char *_LambdaFunctionConfiguration___Events__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Events_",1,_LambdaFunctionConfiguration___Events__domain,"vector[string]");
    const char *vector___LifecycleRule____end_domain[1] = {"vector[_LifecycleRule]"};
    mk_decl("vector[_LifecycleRule].end",1,vector___LifecycleRule____end_domain,"vector[_LifecycleRule].domain");
    const char *_SseKmsEncryptedObjects___Status__domain[1] = {"_SseKmsEncryptedObjects"};
    mk_decl("_SseKmsEncryptedObjects._Status_",1,_SseKmsEncryptedObjects___Status__domain,"string");
    const char *_InventoryFilter___Prefix__domain[1] = {"_InventoryFilter"};
    mk_decl("_InventoryFilter._Prefix_",1,_InventoryFilter___Prefix__domain,"string");
    const char *_ScanRange___Start__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._Start_",1,_ScanRange___Start__domain,"long");
    const char *_PutObjectRequest___BucketKeyEnabled__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._BucketKeyEnabled_",1,_PutObjectRequest___BucketKeyEnabled__domain,"option[bool]");
    const char *_MetadataEntry___Name__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Name_",1,_MetadataEntry___Name__domain,"string");
    const char *option___NotificationConfigurationFilter____end_domain[1] = {"option[_NotificationConfigurationFilter]"};
    mk_decl("option[_NotificationConfigurationFilter].end",1,option___NotificationConfigurationFilter____end_domain,"option[_NotificationConfigurationFilter].domain_t");
    const char *vector___FilterRule____value_domain[2] = {"vector[_FilterRule]","vector[_FilterRule].domain"};
    mk_decl("vector[_FilterRule].value",2,vector___FilterRule____value_domain,"_FilterRule");
    const char *_CSVInput___QuoteEscapeCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteEscapeCharacter_",1,_CSVInput___QuoteEscapeCharacter__domain,"string");
    const char *_CSVOutput___FieldDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._FieldDelimiter_",1,_CSVOutput___FieldDelimiter__domain,"string");
    const char *vector___NoncurrentVersionTransition____end_domain[1] = {"vector[_NoncurrentVersionTransition]"};
    mk_decl("vector[_NoncurrentVersionTransition].end",1,vector___NoncurrentVersionTransition____end_domain,"vector[_NoncurrentVersionTransition].domain");
    const char *option___IntelligentTieringFilter____value_domain[2] = {"option[_IntelligentTieringFilter]","option[_IntelligentTieringFilter].domain_t"};
    mk_decl("option[_IntelligentTieringFilter].value",2,option___IntelligentTieringFilter____value_domain,"_IntelligentTieringFilter");
    const char *_GetObjectRequest___RequestPayer__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._RequestPayer_",1,_GetObjectRequest___RequestPayer__domain,"option[string]");
    const char *_SelectParameters___Expression__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._Expression_",1,_SelectParameters___Expression__domain,"string");
    const char *_Error___Code__domain[1] = {"_Error"};
    mk_decl("_Error._Code_",1,_Error___Code__domain,"string");
    const char *_Grantee___Type__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._Type_",1,_Grantee___Type__domain,"string");
    const char *_LifecycleExpiration___ExpiredObjectDeleteMarker__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._ExpiredObjectDeleteMarker_",1,_LifecycleExpiration___ExpiredObjectDeleteMarker__domain,"Bool");
    const char *_InputSerialization___CSV__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CSV_",1,_InputSerialization___CSV__domain,"_CSVInput");
    const char *option___NoncurrentVersionExpiration____end_domain[1] = {"option[_NoncurrentVersionExpiration]"};
    mk_decl("option[_NoncurrentVersionExpiration].end",1,option___NoncurrentVersionExpiration____end_domain,"option[_NoncurrentVersionExpiration].domain_t");
    const char *_Rule___Transition__domain[1] = {"_Rule"};
    mk_decl("_Rule._Transition_",1,_Rule___Transition__domain,"option[_Transition]");
    const char *_AccessControlPolicy___Owner__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Owner_",1,_AccessControlPolicy___Owner__domain,"_Owner");
    const char *vector___OwnershipControlsRule____end_domain[1] = {"vector[_OwnershipControlsRule]"};
    mk_decl("vector[_OwnershipControlsRule].end",1,vector___OwnershipControlsRule____end_domain,"vector[_OwnershipControlsRule].domain");
    const char *_PutObjectRequest___SSECustomerAlgorithm__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerAlgorithm_",1,_PutObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_Transition___StorageClass__domain[1] = {"_Transition"};
    mk_decl("_Transition._StorageClass_",1,_Transition___StorageClass__domain,"string");
    const char *_Initiator___ID__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._ID_",1,_Initiator___ID__domain,"string");
    const char *_MetricsFilter___And__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._And_",1,_MetricsFilter___And__domain,"_MetricsAndOperator");
    const char *_PutObjectOutput___SSEKMSKeyId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSKeyId_",1,_PutObjectOutput___SSEKMSKeyId__domain,"string");
    const char *contents_domain[2] = {"string","string"};
    mk_decl("contents",2,contents_domain,"blob");
    const char *_AnalyticsFilter___Prefix__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Prefix_",1,_AnalyticsFilter___Prefix__domain,"string");
    const char *_AnalyticsS3BucketDestination___Prefix__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Prefix_",1,_AnalyticsS3BucketDestination___Prefix__domain,"option[string]");
    const char *_GetObjectOutput___Expiration__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expiration_",1,_GetObjectOutput___Expiration__domain,"string");
    const char *_PutObjectOutput___Expiration__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._Expiration_",1,_PutObjectOutput___Expiration__domain,"string");
    const char *_Transition___Days__domain[1] = {"_Transition"};
    mk_decl("_Transition._Days_",1,_Transition___Days__domain,"integer");
    const char *_LifecycleRuleFilter___Prefix__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Prefix_",1,_LifecycleRuleFilter___Prefix__domain,"string");
    const char *_BucketLifecycleConfiguration___Rules__domain[1] = {"_BucketLifecycleConfiguration"};
    mk_decl("_BucketLifecycleConfiguration._Rules_",1,_BucketLifecycleConfiguration___Rules__domain,"vector[_LifecycleRule]");
    const char *_MultipartUpload___Initiated__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiated_",1,_MultipartUpload___Initiated__domain,"timestamp");
    const char *_Metrics___EventThreshold__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._EventThreshold_",1,_Metrics___EventThreshold__domain,"option[_ReplicationTimeValue]");
    const char *_ObjectVersion___Owner__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Owner_",1,_ObjectVersion___Owner__domain,"_Owner");
    const char *_Rule___ID__domain[1] = {"_Rule"};
    mk_decl("_Rule._ID_",1,_Rule___ID__domain,"option[string]");
    const char *_PutObjectRequest___ServerSideEncryption__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ServerSideEncryption_",1,_PutObjectRequest___ServerSideEncryption__domain,"option[string]");
    const char *_PutObjectOutput___BucketKeyEnabled__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._BucketKeyEnabled_",1,_PutObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *_Object___Key__domain[1] = {"_Object"};
    mk_decl("_Object._Key_",1,_Object___Key__domain,"string");
    const char *option___ObjectLockRetention____end_domain[1] = {"option[_ObjectLockRetention]"};
    mk_decl("option[_ObjectLockRetention].end",1,option___ObjectLockRetention____end_domain,"option[_ObjectLockRetention].domain_t");
    const char *_CSVOutput___RecordDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._RecordDelimiter_",1,_CSVOutput___RecordDelimiter__domain,"string");
    const char *_Rule___AbortIncompleteMultipartUpload__domain[1] = {"_Rule"};
    mk_decl("_Rule._AbortIncompleteMultipartUpload_",1,_Rule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *vector___MultipartUpload____value_domain[2] = {"vector[_MultipartUpload]","vector[_MultipartUpload].domain"};
    mk_decl("vector[_MultipartUpload].value",2,vector___MultipartUpload____value_domain,"_MultipartUpload");
    const char *vector___CORSRule____value_domain[2] = {"vector[_CORSRule]","vector[_CORSRule].domain"};
    mk_decl("vector[_CORSRule].value",2,vector___CORSRule____value_domain,"_CORSRule");
    const char *option___AccessControlTranslation____value_domain[2] = {"option[_AccessControlTranslation]","option[_AccessControlTranslation].domain_t"};
    mk_decl("option[_AccessControlTranslation].value",2,option___AccessControlTranslation____value_domain,"_AccessControlTranslation");
    const char *_GetObjectRequest___SSECustomerAlgorithm__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerAlgorithm_",1,_GetObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_LifecycleRule___Filter__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Filter_",1,_LifecycleRule___Filter__domain,"option[_LifecycleRuleFilter]");
    const char *option__vector___MetadataEntry______value_domain[2] = {"option[vector[_MetadataEntry]]","option[vector[_MetadataEntry]].domain_t"};
    mk_decl("option[vector[_MetadataEntry]].value",2,option__vector___MetadataEntry______value_domain,"vector[_MetadataEntry]");
    const char *_GetObjectOutput___Metadata__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Metadata_",1,_GetObjectOutput___Metadata__domain,"unordered_map[string][string]");
    const char *_GetObjectRequest___ResponseContentDisposition__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentDisposition_",1,_GetObjectRequest___ResponseContentDisposition__domain,"option[string]");
    const char *_ReplicationRule___SourceSelectionCriteria__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._SourceSelectionCriteria_",1,_ReplicationRule___SourceSelectionCriteria__domain,"option[_SourceSelectionCriteria]");
    const char *_PutObjectOutput___SSEKMSEncryptionContext__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSEncryptionContext_",1,_PutObjectOutput___SSEKMSEncryptionContext__domain,"string");
    const char *_GetObjectRequest___ResponseCacheControl__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseCacheControl_",1,_GetObjectRequest___ResponseCacheControl__domain,"option[string]");
    const char *vector___CompletedPart____end_domain[1] = {"vector[_CompletedPart]"};
    mk_decl("vector[_CompletedPart].end",1,vector___CompletedPart____end_domain,"vector[_CompletedPart].domain");
    const char *option___ReplicationTime____end_domain[1] = {"option[_ReplicationTime]"};
    mk_decl("option[_ReplicationTime].end",1,option___ReplicationTime____end_domain,"option[_ReplicationTime].domain_t");
    const char *_DeletedObject___DeleteMarkerVersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarkerVersionId_",1,_DeletedObject___DeleteMarkerVersionId__domain,"string");
    const char *_Grantee___ID__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._ID_",1,_Grantee___ID__domain,"option[string]");
    const char *option___Condition____end_domain[1] = {"option[_Condition]"};
    mk_decl("option[_Condition].end",1,option___Condition____end_domain,"option[_Condition].domain_t");
    const char *_ObjectLockConfiguration___Rule__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._Rule_",1,_ObjectLockConfiguration___Rule__domain,"_ObjectLockRule");
    const char *vector___MetricsConfiguration____value_domain[2] = {"vector[_MetricsConfiguration]","vector[_MetricsConfiguration].domain"};
    mk_decl("vector[_MetricsConfiguration].value",2,vector___MetricsConfiguration____value_domain,"_MetricsConfiguration");
    const char *_AnalyticsS3BucketDestination___Format__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Format_",1,_AnalyticsS3BucketDestination___Format__domain,"string");
    const char *_AnalyticsAndOperator___Tags__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Tags_",1,_AnalyticsAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___DeletedObject____end_domain[1] = {"vector[_DeletedObject]"};
    mk_decl("vector[_DeletedObject].end",1,vector___DeletedObject____end_domain,"vector[_DeletedObject].domain");
    const char *option___CreateBucketConfiguration____end_domain[1] = {"option[_CreateBucketConfiguration]"};
    mk_decl("option[_CreateBucketConfiguration].end",1,option___CreateBucketConfiguration____end_domain,"option[_CreateBucketConfiguration].domain_t");
    const char *_GetObjectRequest___ResponseContentLanguage__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentLanguage_",1,_GetObjectRequest___ResponseContentLanguage__domain,"option[string]");
    const char *_MultipartUpload___UploadId__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._UploadId_",1,_MultipartUpload___UploadId__domain,"string");
    const char *_ReplicationRule___Status__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Status_",1,_ReplicationRule___Status__domain,"string");
    const char *_MultipartUpload___Initiator__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiator_",1,_MultipartUpload___Initiator__domain,"_Initiator");
    const char *_PutObjectOutput___SSECustomerAlgorithm__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerAlgorithm_",1,_PutObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *option__long____end_domain[1] = {"option[long]"};
    mk_decl("option[long].end",1,option__long____end_domain,"option[long].domain_t");
    const char *option___BucketLifecycleConfiguration____value_domain[2] = {"option[_BucketLifecycleConfiguration]","option[_BucketLifecycleConfiguration].domain_t"};
    mk_decl("option[_BucketLifecycleConfiguration].value",2,option___BucketLifecycleConfiguration____value_domain,"_BucketLifecycleConfiguration");
    const char *_InventorySchedule___Frequency__domain[1] = {"_InventorySchedule"};
    mk_decl("_InventorySchedule._Frequency_",1,_InventorySchedule___Frequency__domain,"string");
    const char *_Owner___DisplayName__domain[1] = {"_Owner"};
    mk_decl("_Owner._DisplayName_",1,_Owner___DisplayName__domain,"string");
    const char *_DeleteMarkerEntry___Key__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Key_",1,_DeleteMarkerEntry___Key__domain,"string");
    const char *_Tiering___Days__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._Days_",1,_Tiering___Days__domain,"integer");
    const char *option___NoncurrentVersionTransition____value_domain[2] = {"option[_NoncurrentVersionTransition]","option[_NoncurrentVersionTransition].domain_t"};
    mk_decl("option[_NoncurrentVersionTransition].value",2,option___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *_GetObjectOutput___ServerSideEncryption__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ServerSideEncryption_",1,_GetObjectOutput___ServerSideEncryption__domain,"string");
    const char *_PutObjectRequest___Expires__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Expires_",1,_PutObjectRequest___Expires__domain,"option[timestamp]");
    const char *option___BucketLifecycleConfiguration____end_domain[1] = {"option[_BucketLifecycleConfiguration]"};
    mk_decl("option[_BucketLifecycleConfiguration].end",1,option___BucketLifecycleConfiguration____end_domain,"option[_BucketLifecycleConfiguration].domain_t");
    const char *option___ReplicationTime____value_domain[2] = {"option[_ReplicationTime]","option[_ReplicationTime].domain_t"};
    mk_decl("option[_ReplicationTime].value",2,option___ReplicationTime____value_domain,"_ReplicationTime");
    const char *_InputSerialization___CompressionType__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CompressionType_",1,_InputSerialization___CompressionType__domain,"string");
    const char *_DeleteMarkerEntry___LastModified__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._LastModified_",1,_DeleteMarkerEntry___LastModified__domain,"timestamp");
    const char *_GetObjectRequest___IfMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfMatch_",1,_GetObjectRequest___IfMatch__domain,"option[string]");
    const char *_LifecycleRule___Expiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Expiration_",1,_LifecycleRule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *_ReplicationRule___Destination__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Destination_",1,_ReplicationRule___Destination__domain,"_Destination");
    const char *vector___DeleteMarkerEntry____end_domain[1] = {"vector[_DeleteMarkerEntry]"};
    mk_decl("vector[_DeleteMarkerEntry].end",1,vector___DeleteMarkerEntry____end_domain,"vector[_DeleteMarkerEntry].domain");
    const char *_InputSerialization___Parquet__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._Parquet_",1,_InputSerialization___Parquet__domain,"_ParquetInput");
    const char *_ObjectLockRule___DefaultRetention__domain[1] = {"_ObjectLockRule"};
    mk_decl("_ObjectLockRule._DefaultRetention_",1,_ObjectLockRule___DefaultRetention__domain,"_DefaultRetention");
    const char *option__timestamp____end_domain[1] = {"option[timestamp]"};
    mk_decl("option[timestamp].end",1,option__timestamp____end_domain,"option[timestamp].domain_t");
    const char *_GetObjectOutput___SSECustomerAlgorithm__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerAlgorithm_",1,_GetObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *_QueueConfiguration___Id__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Id_",1,_QueueConfiguration___Id__domain,"option[string]");
    const char *_Object___Size__domain[1] = {"_Object"};
    mk_decl("_Object._Size_",1,_Object___Size__domain,"integer");
    const char *option__integer____value_domain[2] = {"option[integer]","option[integer].domain_t"};
    mk_decl("option[integer].value",2,option__integer____value_domain,"integer");
    const char *blob__value_domain[2] = {"blob","blob.domain"};
    mk_decl("blob.value",2,blob__value_domain,"byte");
    const char *_DeleteMarkerEntry___VersionId__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._VersionId_",1,_DeleteMarkerEntry___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentLength__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLength_",1,_GetObjectOutput___ContentLength__domain,"long");
    const char *option__integer____end_domain[1] = {"option[integer]"};
    mk_decl("option[integer].end",1,option__integer____end_domain,"option[integer].domain_t");
    const char *_LifecycleRuleAndOperator___Tags__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Tags_",1,_LifecycleRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_GetObjectRequest___IfNoneMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfNoneMatch_",1,_GetObjectRequest___IfNoneMatch__domain,"option[string]");
    const char *_S3KeyFilter___FilterRules__domain[1] = {"_S3KeyFilter"};
    mk_decl("_S3KeyFilter._FilterRules_",1,_S3KeyFilter___FilterRules__domain,"vector[_FilterRule]");
    const char *option___ObjectLockLegalHold____value_domain[2] = {"option[_ObjectLockLegalHold]","option[_ObjectLockLegalHold].domain_t"};
    mk_decl("option[_ObjectLockLegalHold].value",2,option___ObjectLockLegalHold____value_domain,"_ObjectLockLegalHold");
    const char *option___EncryptionConfiguration____end_domain[1] = {"option[_EncryptionConfiguration]"};
    mk_decl("option[_EncryptionConfiguration].end",1,option___EncryptionConfiguration____end_domain,"option[_EncryptionConfiguration].domain_t");
    const char *_LifecycleExpiration___Date__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Date_",1,_LifecycleExpiration___Date__domain,"timestamp");
    const char *_PutObjectRequest___RequestPayer__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._RequestPayer_",1,_PutObjectRequest___RequestPayer__domain,"option[string]");
    const char *_PutObjectRequest___ContentLength__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLength_",1,_PutObjectRequest___ContentLength__domain,"option[long]");
    const char *_PutObjectRequest___ObjectLockLegalHoldStatus__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockLegalHoldStatus_",1,_PutObjectRequest___ObjectLockLegalHoldStatus__domain,"option[string]");
    const char *_CSVInput___RecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._RecordDelimiter_",1,_CSVInput___RecordDelimiter__domain,"string");
    const char *vector___Tag____end_domain[1] = {"vector[_Tag]"};
    mk_decl("vector[_Tag].end",1,vector___Tag____end_domain,"vector[_Tag].domain");
    const char *vector___Rule____value_domain[2] = {"vector[_Rule]","vector[_Rule].domain"};
    mk_decl("vector[_Rule].value",2,vector___Rule____value_domain,"_Rule");
    const char *_InventoryEncryption___SSEKMS__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSEKMS_",1,_InventoryEncryption___SSEKMS__domain,"_SSEKMS");
    const char *_Destination___Metrics__domain[1] = {"_Destination"};
    mk_decl("_Destination._Metrics_",1,_Destination___Metrics__domain,"option[_Metrics]");
    const char *_GetObjectOutput___RequestCharged__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._RequestCharged_",1,_GetObjectOutput___RequestCharged__domain,"string");
    const char *vector___Error____value_domain[2] = {"vector[_Error]","vector[_Error].domain"};
    mk_decl("vector[_Error].value",2,vector___Error____value_domain,"_Error");
    const char *blob__end_domain[1] = {"blob"};
    mk_decl("blob.end",1,blob__end_domain,"blob.domain");
    const char *_NotificationConfigurationFilter___Key__domain[1] = {"_NotificationConfigurationFilter"};
    mk_decl("_NotificationConfigurationFilter._Key_",1,_NotificationConfigurationFilter___Key__domain,"_S3KeyFilter");
    const char *option__vector___NoncurrentVersionTransition______value_domain[2] = {"option[vector[_NoncurrentVersionTransition]]","option[vector[_NoncurrentVersionTransition]].domain_t"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].value",2,option__vector___NoncurrentVersionTransition______value_domain,"vector[_NoncurrentVersionTransition]");
    const char *option___Metrics____end_domain[1] = {"option[_Metrics]"};
    mk_decl("option[_Metrics].end",1,option___Metrics____end_domain,"option[_Metrics].domain_t");
    const char *vector___LambdaFunctionConfiguration____value_domain[2] = {"vector[_LambdaFunctionConfiguration]","vector[_LambdaFunctionConfiguration].domain"};
    mk_decl("vector[_LambdaFunctionConfiguration].value",2,vector___LambdaFunctionConfiguration____value_domain,"_LambdaFunctionConfiguration");
    const char *_Error___Message__domain[1] = {"_Error"};
    mk_decl("_Error._Message_",1,_Error___Message__domain,"string");
    const char *option___Transition____end_domain[1] = {"option[_Transition]"};
    mk_decl("option[_Transition].end",1,option___Transition____end_domain,"option[_Transition].domain_t");
    const char *vector___RoutingRule____end_domain[1] = {"vector[_RoutingRule]"};
    mk_decl("vector[_RoutingRule].end",1,vector___RoutingRule____end_domain,"vector[_RoutingRule].domain");
    const char *_ReplicationRule___DeleteMarkerReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._DeleteMarkerReplication_",1,_ReplicationRule___DeleteMarkerReplication__domain,"option[_DeleteMarkerReplication]");
    const char *_DeletedObject___DeleteMarker__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarker_",1,_DeletedObject___DeleteMarker__domain,"Bool");
    const char *_PutObjectRequest___GrantRead__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantRead_",1,_PutObjectRequest___GrantRead__domain,"option[string]");
    const char *_AnalyticsConfiguration___Filter__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Filter_",1,_AnalyticsConfiguration___Filter__domain,"option[_AnalyticsFilter]");
    const char *vector___MetricsConfiguration____end_domain[1] = {"vector[_MetricsConfiguration]"};
    mk_decl("vector[_MetricsConfiguration].end",1,vector___MetricsConfiguration____end_domain,"vector[_MetricsConfiguration].domain");
    const char *_GetObjectOutput___DeleteMarker__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._DeleteMarker_",1,_GetObjectOutput___DeleteMarker__domain,"Bool");
    const char *_S3Location___AccessControlList__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._AccessControlList_",1,_S3Location___AccessControlList__domain,"option[vector[_Grant]]");
    const char *option__timestamp____value_domain[2] = {"option[timestamp]","option[timestamp].domain_t"};
    mk_decl("option[timestamp].value",2,option__timestamp____value_domain,"timestamp");
    const char *present_domain[2] = {"string","string"};
    mk_decl("present",2,present_domain,"Bool");
    const char *_CompletedPart___ETag__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._ETag_",1,_CompletedPart___ETag__domain,"string");
    const char *_InventoryConfiguration___Id__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Id_",1,_InventoryConfiguration___Id__domain,"string");
    const char *_Rule___Status__domain[1] = {"_Rule"};
    mk_decl("_Rule._Status_",1,_Rule___Status__domain,"string");
    const char *_PutObjectRequest___StorageClass__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._StorageClass_",1,_PutObjectRequest___StorageClass__domain,"option[string]");
    const char *unordered_map__string____string____maps_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].maps",2,unordered_map__string____string____maps_domain,"string");
    const char *_GetObjectOutput___TagCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._TagCount_",1,_GetObjectOutput___TagCount__domain,"integer");
    const char *vector___InventoryConfiguration____value_domain[2] = {"vector[_InventoryConfiguration]","vector[_InventoryConfiguration].domain"};
    mk_decl("vector[_InventoryConfiguration].value",2,vector___InventoryConfiguration____value_domain,"_InventoryConfiguration");
    const char *option___ObjectLockConfiguration____end_domain[1] = {"option[_ObjectLockConfiguration]"};
    mk_decl("option[_ObjectLockConfiguration].end",1,option___ObjectLockConfiguration____end_domain,"option[_ObjectLockConfiguration].domain_t");
    const char *_ExistingObjectReplication___Status__domain[1] = {"_ExistingObjectReplication"};
    mk_decl("_ExistingObjectReplication._Status_",1,_ExistingObjectReplication___Status__domain,"string");
    const char *_PutObjectRequest___SSEKMSEncryptionContext__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSEncryptionContext_",1,_PutObjectRequest___SSEKMSEncryptionContext__domain,"option[string]");
    const char *_SelectParameters___ExpressionType__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._ExpressionType_",1,_SelectParameters___ExpressionType__domain,"string");
    const char *_LifecycleConfiguration___Rules__domain[1] = {"_LifecycleConfiguration"};
    mk_decl("_LifecycleConfiguration._Rules_",1,_LifecycleConfiguration___Rules__domain,"vector[_Rule]");
    const char *_GetObjectOutput___ContentDisposition__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentDisposition_",1,_GetObjectOutput___ContentDisposition__domain,"string");
    const char *_LifecycleRuleFilter___Tag__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Tag_",1,_LifecycleRuleFilter___Tag__domain,"_Tag");
    const char *_GetObjectOutput___BucketKeyEnabled__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._BucketKeyEnabled_",1,_GetObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *option___AbortIncompleteMultipartUpload____end_domain[1] = {"option[_AbortIncompleteMultipartUpload]"};
    mk_decl("option[_AbortIncompleteMultipartUpload].end",1,option___AbortIncompleteMultipartUpload____end_domain,"option[_AbortIncompleteMultipartUpload].domain_t");
    const char *_PutObjectRequest___GrantWriteACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantWriteACP_",1,_PutObjectRequest___GrantWriteACP__domain,"option[string]");
    const char *option___ReplicationTimeValue____end_domain[1] = {"option[_ReplicationTimeValue]"};
    mk_decl("option[_ReplicationTimeValue].end",1,option___ReplicationTimeValue____end_domain,"option[_ReplicationTimeValue].domain_t");
    const char *_RestoreRequest___SelectParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._SelectParameters_",1,_RestoreRequest___SelectParameters__domain,"_SelectParameters");
    const char *option___LifecycleExpiration____end_domain[1] = {"option[_LifecycleExpiration]"};
    mk_decl("option[_LifecycleExpiration].end",1,option___LifecycleExpiration____end_domain,"option[_LifecycleExpiration].domain_t");
    const char *_Destination___Account__domain[1] = {"_Destination"};
    mk_decl("_Destination._Account_",1,_Destination___Account__domain,"option[string]");
    const char *vector___MultipartUpload____end_domain[1] = {"vector[_MultipartUpload]"};
    mk_decl("vector[_MultipartUpload].end",1,vector___MultipartUpload____end_domain,"vector[_MultipartUpload].domain");
    const char *_ObjectIdentifier___VersionId__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._VersionId_",1,_ObjectIdentifier___VersionId__domain,"option[string]");
    const char *_JSONOutput___RecordDelimiter__domain[1] = {"_JSONOutput"};
    mk_decl("_JSONOutput._RecordDelimiter_",1,_JSONOutput___RecordDelimiter__domain,"string");
    const char *_Destination___Bucket__domain[1] = {"_Destination"};
    mk_decl("_Destination._Bucket_",1,_Destination___Bucket__domain,"string");
    const char *option__vector___TargetGrant______end_domain[1] = {"option[vector[_TargetGrant]]"};
    mk_decl("option[vector[_TargetGrant]].end",1,option__vector___TargetGrant______end_domain,"option[vector[_TargetGrant]].domain_t");
    const char *_PutObjectRequest___Key__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Key_",1,_PutObjectRequest___Key__domain,"string");
    const char *_CORSRule___ID__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ID_",1,_CORSRule___ID__domain,"option[string]");
    const char *option___DeleteMarkerReplication____end_domain[1] = {"option[_DeleteMarkerReplication]"};
    mk_decl("option[_DeleteMarkerReplication].end",1,option___DeleteMarkerReplication____end_domain,"option[_DeleteMarkerReplication].domain_t");
    const char *_GetObjectOutput___ContentType__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentType_",1,_GetObjectOutput___ContentType__domain,"string");
    const char *_Rule___NoncurrentVersionTransition__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionTransition_",1,_Rule___NoncurrentVersionTransition__domain,"option[_NoncurrentVersionTransition]");
    const char *_ObjectLockRetention___Mode__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._Mode_",1,_ObjectLockRetention___Mode__domain,"string");
    const char *_Destination___AccessControlTranslation__domain[1] = {"_Destination"};
    mk_decl("_Destination._AccessControlTranslation_",1,_Destination___AccessControlTranslation__domain,"option[_AccessControlTranslation]");
    const char *_CSVInput___QuoteCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteCharacter_",1,_CSVInput___QuoteCharacter__domain,"string");
    const char *vector___Transition____end_domain[1] = {"vector[_Transition]"};
    mk_decl("vector[_Transition].end",1,vector___Transition____end_domain,"vector[_Transition].domain");
    const char *vector___CompletedPart____value_domain[2] = {"vector[_CompletedPart]","vector[_CompletedPart].domain"};
    mk_decl("vector[_CompletedPart].value",2,vector___CompletedPart____value_domain,"_CompletedPart");
    const char *_CSVInput___FieldDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FieldDelimiter_",1,_CSVInput___FieldDelimiter__domain,"string");
    const char *_GetObjectOutput___MissingMeta__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._MissingMeta_",1,_GetObjectOutput___MissingMeta__domain,"integer");
    const char *vector___Error____end_domain[1] = {"vector[_Error]"};
    mk_decl("vector[_Error].end",1,vector___Error____end_domain,"vector[_Error].domain");
    mk_const("_generating","Bool");
    const char *_Initiator___DisplayName__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._DisplayName_",1,_Initiator___DisplayName__domain,"string");
    const char *_TopicConfiguration___Id__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Id_",1,_TopicConfiguration___Id__domain,"option[string]");
    const char *_PutObjectRequest___ContentLanguage__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLanguage_",1,_PutObjectRequest___ContentLanguage__domain,"option[string]");
    const char *option__bool____end_domain[1] = {"option[bool]"};
    mk_decl("option[bool].end",1,option__bool____end_domain,"option[bool].domain_t");
    const char *_ServerSideEncryptionByDefault___KMSMasterKeyID__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._KMSMasterKeyID_",1,_ServerSideEncryptionByDefault___KMSMasterKeyID__domain,"option[string]");
    const char *option___ScanRange____value_domain[2] = {"option[_ScanRange]","option[_ScanRange].domain_t"};
    mk_decl("option[_ScanRange].value",2,option___ScanRange____value_domain,"_ScanRange");
    const char *option___ExistingObjectReplication____value_domain[2] = {"option[_ExistingObjectReplication]","option[_ExistingObjectReplication].domain_t"};
    mk_decl("option[_ExistingObjectReplication].value",2,option___ExistingObjectReplication____value_domain,"_ExistingObjectReplication");
    const char *_GetObjectRequest___ResponseExpires__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseExpires_",1,_GetObjectRequest___ResponseExpires__domain,"option[timestamp]");
    const char *vector___ObjectIdentifier____end_domain[1] = {"vector[_ObjectIdentifier]"};
    mk_decl("vector[_ObjectIdentifier].end",1,vector___ObjectIdentifier____end_domain,"vector[_ObjectIdentifier].domain");
    const char *_RestoreRequest___Type__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Type_",1,_RestoreRequest___Type__domain,"string");
    const char *_DeleteMarkerReplication___Status__domain[1] = {"_DeleteMarkerReplication"};
    mk_decl("_DeleteMarkerReplication._Status_",1,_DeleteMarkerReplication___Status__domain,"string");
    const char *option___ReplicationRuleFilter____end_domain[1] = {"option[_ReplicationRuleFilter]"};
    mk_decl("option[_ReplicationRuleFilter].end",1,option___ReplicationRuleFilter____end_domain,"option[_ReplicationRuleFilter].domain_t");
    const char *_RoutingRule___Condition__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Condition_",1,_RoutingRule___Condition__domain,"option[_Condition]");
    const char *_MetricsAndOperator___Tags__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Tags_",1,_MetricsAndOperator___Tags__domain,"vector[_Tag]");
    const char *option___RequestProgress____end_domain[1] = {"option[_RequestProgress]"};
    mk_decl("option[_RequestProgress].end",1,option___RequestProgress____end_domain,"option[_RequestProgress].domain_t");
    const char *_CSVInput___Comments__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._Comments_",1,_CSVInput___Comments__domain,"string");
    const char *_Part___Size__domain[1] = {"_Part"};
    mk_decl("_Part._Size_",1,_Part___Size__domain,"integer");
    const char *vector___ServerSideEncryptionRule____end_domain[1] = {"vector[_ServerSideEncryptionRule]"};
    mk_decl("vector[_ServerSideEncryptionRule].end",1,vector___ServerSideEncryptionRule____end_domain,"vector[_ServerSideEncryptionRule].domain");
    const char *vector___QueueConfiguration____end_domain[1] = {"vector[_QueueConfiguration]"};
    mk_decl("vector[_QueueConfiguration].end",1,vector___QueueConfiguration____end_domain,"vector[_QueueConfiguration].domain");
    const char *_PutObjectOutput___SSECustomerKeyMD5__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerKeyMD5_",1,_PutObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_OwnershipControlsRule___ObjectOwnership__domain[1] = {"_OwnershipControlsRule"};
    mk_decl("_OwnershipControlsRule._ObjectOwnership_",1,_OwnershipControlsRule___ObjectOwnership__domain,"string");
    const char *option___MetricsFilter____end_domain[1] = {"option[_MetricsFilter]"};
    mk_decl("option[_MetricsFilter].end",1,option___MetricsFilter____end_domain,"option[_MetricsFilter].domain_t");
    const char *_QueueConfiguration___Events__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Events_",1,_QueueConfiguration___Events__domain,"vector[string]");
    const char *_IntelligentTieringConfiguration___Tierings__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Tierings_",1,_IntelligentTieringConfiguration___Tierings__domain,"vector[_Tiering]");
    const char *option__bool____value_domain[2] = {"option[bool]","option[bool].domain_t"};
    mk_decl("option[bool].value",2,option__bool____value_domain,"Bool");
    const char *option___InventoryFilter____end_domain[1] = {"option[_InventoryFilter]"};
    mk_decl("option[_InventoryFilter].end",1,option___InventoryFilter____end_domain,"option[_InventoryFilter].domain_t");
    const char *_Grantee___URI__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._URI_",1,_Grantee___URI__domain,"option[string]");
    const char *_Encryption___KMSContext__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSContext_",1,_Encryption___KMSContext__domain,"option[string]");
    const char *vector___LambdaFunctionConfiguration____end_domain[1] = {"vector[_LambdaFunctionConfiguration]"};
    mk_decl("vector[_LambdaFunctionConfiguration].end",1,vector___LambdaFunctionConfiguration____end_domain,"vector[_LambdaFunctionConfiguration].domain");
    const char *_ReplicationTimeValue___Minutes__domain[1] = {"_ReplicationTimeValue"};
    mk_decl("_ReplicationTimeValue._Minutes_",1,_ReplicationTimeValue___Minutes__domain,"integer");
    const char *vector___AnalyticsConfiguration____end_domain[1] = {"vector[_AnalyticsConfiguration]"};
    mk_decl("vector[_AnalyticsConfiguration].end",1,vector___AnalyticsConfiguration____end_domain,"vector[_AnalyticsConfiguration].domain");
    const char *option__vector___TargetGrant______value_domain[2] = {"option[vector[_TargetGrant]]","option[vector[_TargetGrant]].domain_t"};
    mk_decl("option[vector[_TargetGrant]].value",2,option__vector___TargetGrant______value_domain,"vector[_TargetGrant]");
    const char *_PutObjectRequest___SSECustomerKey__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKey_",1,_PutObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_GetObjectRequest___IfUnmodifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfUnmodifiedSince_",1,_GetObjectRequest___IfUnmodifiedSince__domain,"option[timestamp]");
    const char *_S3Location___Prefix__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Prefix_",1,_S3Location___Prefix__domain,"string");
    const char *option___RestoreRequest____value_domain[2] = {"option[_RestoreRequest]","option[_RestoreRequest].domain_t"};
    mk_decl("option[_RestoreRequest].value",2,option___RestoreRequest____value_domain,"_RestoreRequest");
    const char *_EncryptionConfiguration___ReplicaKmsKeyID__domain[1] = {"_EncryptionConfiguration"};
    mk_decl("_EncryptionConfiguration._ReplicaKmsKeyID_",1,_EncryptionConfiguration___ReplicaKmsKeyID__domain,"string");
    const char *_Tag___Value__domain[1] = {"_Tag"};
    mk_decl("_Tag._Value_",1,_Tag___Value__domain,"string");
    const char *vector___TopicConfiguration____value_domain[2] = {"vector[_TopicConfiguration]","vector[_TopicConfiguration].domain"};
    mk_decl("vector[_TopicConfiguration].value",2,vector___TopicConfiguration____value_domain,"_TopicConfiguration");
    const char *_PutObjectRequest___Metadata__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Metadata_",1,_PutObjectRequest___Metadata__domain,"option[unordered_map[string][string]]");
    const char *vector___NoncurrentVersionTransition____value_domain[2] = {"vector[_NoncurrentVersionTransition]","vector[_NoncurrentVersionTransition].domain"};
    mk_decl("vector[_NoncurrentVersionTransition].value",2,vector___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *vector___Part____value_domain[2] = {"vector[_Part]","vector[_Part].domain"};
    mk_decl("vector[_Part].value",2,vector___Part____value_domain,"_Part");
    const char *vector___IntelligentTieringConfiguration____value_domain[2] = {"vector[_IntelligentTieringConfiguration]","vector[_IntelligentTieringConfiguration].domain"};
    mk_decl("vector[_IntelligentTieringConfiguration].value",2,vector___IntelligentTieringConfiguration____value_domain,"_IntelligentTieringConfiguration");
    const char *_FilterRule___Value__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Value_",1,_FilterRule___Value__domain,"string");
    const char *_LifecycleRule___NoncurrentVersionTransitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionTransitions_",1,_LifecycleRule___NoncurrentVersionTransitions__domain,"option[vector[_NoncurrentVersionTransition]]");
    const char *option__vector__string______value_domain[2] = {"option[vector[string]]","option[vector[string]].domain_t"};
    mk_decl("option[vector[string]].value",2,option__vector__string______value_domain,"vector[string]");
    const char *_ObjectIdentifier___Key__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._Key_",1,_ObjectIdentifier___Key__domain,"string");
    const char *_InventoryS3BucketDestination___Format__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Format_",1,_InventoryS3BucketDestination___Format__domain,"string");
    const char *_OutputSerialization___JSON__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._JSON_",1,_OutputSerialization___JSON__domain,"_JSONOutput");
    const char *vector___Object____end_domain[1] = {"vector[_Object]"};
    mk_decl("vector[_Object].end",1,vector___Object____end_domain,"vector[_Object].domain");
    const char *_MetricsFilter___Tag__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Tag_",1,_MetricsFilter___Tag__domain,"_Tag");
    const char *_ReplicaModifications___Status__domain[1] = {"_ReplicaModifications"};
    mk_decl("_ReplicaModifications._Status_",1,_ReplicaModifications___Status__domain,"string");
    const char *_AccessControlTranslation___Owner__domain[1] = {"_AccessControlTranslation"};
    mk_decl("_AccessControlTranslation._Owner_",1,_AccessControlTranslation___Owner__domain,"string");
    const char *_QueueConfiguration___Filter__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Filter_",1,_QueueConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_ObjectVersion___ETag__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._ETag_",1,_ObjectVersion___ETag__domain,"string");
    const char *_Transition___Date__domain[1] = {"_Transition"};
    mk_decl("_Transition._Date_",1,_Transition___Date__domain,"timestamp");
    const char *vector___TargetGrant____end_domain[1] = {"vector[_TargetGrant]"};
    mk_decl("vector[_TargetGrant].end",1,vector___TargetGrant____end_domain,"vector[_TargetGrant].domain");
    const char *vector___Grant____end_domain[1] = {"vector[_Grant]"};
    mk_decl("vector[_Grant].end",1,vector___Grant____end_domain,"vector[_Grant].domain");
    const char *_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",1,_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain,"_ServerSideEncryptionByDefault");
    const char *_AnalyticsExportDestination___S3BucketDestination__domain[1] = {"_AnalyticsExportDestination"};
    mk_decl("_AnalyticsExportDestination._S3BucketDestination_",1,_AnalyticsExportDestination___S3BucketDestination__domain,"_AnalyticsS3BucketDestination");
    const char *vector___QueueConfiguration____value_domain[2] = {"vector[_QueueConfiguration]","vector[_QueueConfiguration].domain"};
    mk_decl("vector[_QueueConfiguration].value",2,vector___QueueConfiguration____value_domain,"_QueueConfiguration");
    const char *_IntelligentTieringAndOperator___Prefix__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Prefix_",1,_IntelligentTieringAndOperator___Prefix__domain,"string");
    const char *option___InventoryEncryption____value_domain[2] = {"option[_InventoryEncryption]","option[_InventoryEncryption].domain_t"};
    mk_decl("option[_InventoryEncryption].value",2,option___InventoryEncryption____value_domain,"_InventoryEncryption");
    const char *option___CompletedMultipartUpload____end_domain[1] = {"option[_CompletedMultipartUpload]"};
    mk_decl("option[_CompletedMultipartUpload].end",1,option___CompletedMultipartUpload____end_domain,"option[_CompletedMultipartUpload].domain_t");
    const char *_MultipartUpload___Owner__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Owner_",1,_MultipartUpload___Owner__domain,"_Owner");
    const char *_RoutingRule___Redirect__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Redirect_",1,_RoutingRule___Redirect__domain,"_Redirect");
    const char *_ReplicationRuleAndOperator___Tags__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Tags_",1,_ReplicationRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_LifecycleRule___Transitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Transitions_",1,_LifecycleRule___Transitions__domain,"option[vector[_Transition]]");
    const char *_Part___LastModified__domain[1] = {"_Part"};
    mk_decl("_Part._LastModified_",1,_Part___LastModified__domain,"timestamp");
    const char *_GetObjectOutput___ObjectLockMode__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockMode_",1,_GetObjectOutput___ObjectLockMode__domain,"string");
    const char *vector___ObjectVersion____end_domain[1] = {"vector[_ObjectVersion]"};
    mk_decl("vector[_ObjectVersion].end",1,vector___ObjectVersion____end_domain,"vector[_ObjectVersion].domain");
    const char *_GetObjectOutput___WebsiteRedirectLocation__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._WebsiteRedirectLocation_",1,_GetObjectOutput___WebsiteRedirectLocation__domain,"string");
    const char *_AnalyticsS3BucketDestination___BucketAccountId__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._BucketAccountId_",1,_AnalyticsS3BucketDestination___BucketAccountId__domain,"option[string]");
    const char *vector___CORSRule____end_domain[1] = {"vector[_CORSRule]"};
    mk_decl("vector[_CORSRule].end",1,vector___CORSRule____end_domain,"vector[_CORSRule].domain");
    const char *_GetObjectRequest___Bucket__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Bucket_",1,_GetObjectRequest___Bucket__domain,"string");
    const char *_Object___ETag__domain[1] = {"_Object"};
    mk_decl("_Object._ETag_",1,_Object___ETag__domain,"string");
    const char *_Object___StorageClass__domain[1] = {"_Object"};
    mk_decl("_Object._StorageClass_",1,_Object___StorageClass__domain,"string");
    const char *_TopicConfiguration___Filter__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Filter_",1,_TopicConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_PutObjectRequest___ObjectLockRetainUntilDate__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockRetainUntilDate_",1,_PutObjectRequest___ObjectLockRetainUntilDate__domain,"option[timestamp]");
    const char *_Tagging___TagSet__domain[1] = {"_Tagging"};
    mk_decl("_Tagging._TagSet_",1,_Tagging___TagSet__domain,"vector[_Tag]");
    const char *_ReplicationRuleFilter___Prefix__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Prefix_",1,_ReplicationRuleFilter___Prefix__domain,"string");
    mk_const("the_bucket","string");
    const char *_PutObjectOutput___ETag__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ETag_",1,_PutObjectOutput___ETag__domain,"string");
    const char *_IntelligentTieringConfiguration___Status__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Status_",1,_IntelligentTieringConfiguration___Status__domain,"string");
    const char *_GetObjectOutput___VersionId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._VersionId_",1,_GetObjectOutput___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentEncoding__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentEncoding_",1,_GetObjectOutput___ContentEncoding__domain,"string");
    const char *option___AnalyticsFilter____end_domain[1] = {"option[_AnalyticsFilter]"};
    mk_decl("option[_AnalyticsFilter].end",1,option___AnalyticsFilter____end_domain,"option[_AnalyticsFilter].domain_t");
    const char *_IntelligentTieringFilter___And__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._And_",1,_IntelligentTieringFilter___And__domain,"_IntelligentTieringAndOperator");
    const char *_PutObjectRequest___ExpectedBucketOwner__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ExpectedBucketOwner_",1,_PutObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_PutObjectRequest___CacheControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._CacheControl_",1,_PutObjectRequest___CacheControl__domain,"option[string]");
    const char *vector___TargetGrant____value_domain[2] = {"vector[_TargetGrant]","vector[_TargetGrant].domain"};
    mk_decl("vector[_TargetGrant].value",2,vector___TargetGrant____value_domain,"_TargetGrant");
    const char *_ReplicationRule___Priority__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Priority_",1,_ReplicationRule___Priority__domain,"option[integer]");
    const char *option___NoncurrentVersionTransition____end_domain[1] = {"option[_NoncurrentVersionTransition]"};
    mk_decl("option[_NoncurrentVersionTransition].end",1,option___NoncurrentVersionTransition____end_domain,"option[_NoncurrentVersionTransition].domain_t");
    const char *_IntelligentTieringFilter___Prefix__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Prefix_",1,_IntelligentTieringFilter___Prefix__domain,"string");
    const char *_MetricsConfiguration___Filter__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Filter_",1,_MetricsConfiguration___Filter__domain,"option[_MetricsFilter]");
    const char *_GetObjectRequest___IfModifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfModifiedSince_",1,_GetObjectRequest___IfModifiedSince__domain,"option[timestamp]");
    const char *_PutObjectOutput___VersionId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._VersionId_",1,_PutObjectOutput___VersionId__domain,"string");
    const char *vector___OwnershipControlsRule____value_domain[2] = {"vector[_OwnershipControlsRule]","vector[_OwnershipControlsRule].domain"};
    mk_decl("vector[_OwnershipControlsRule].value",2,vector___OwnershipControlsRule____value_domain,"_OwnershipControlsRule");
    const char *_GlacierJobParameters___Tier__domain[1] = {"_GlacierJobParameters"};
    mk_decl("_GlacierJobParameters._Tier_",1,_GlacierJobParameters___Tier__domain,"string");
    const char *_PutObjectRequest___Body__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Body_",1,_PutObjectRequest___Body__domain,"option[blob]");
    const char *_ReplicationTime___Status__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Status_",1,_ReplicationTime___Status__domain,"string");
    const char *_LifecycleRuleAndOperator___Prefix__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Prefix_",1,_LifecycleRuleAndOperator___Prefix__domain,"string");
    const char *_GetObjectRequest___VersionId__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._VersionId_",1,_GetObjectRequest___VersionId__domain,"option[string]");
    const char *option___Tagging____end_domain[1] = {"option[_Tagging]"};
    mk_decl("option[_Tagging].end",1,option___Tagging____end_domain,"option[_Tagging].domain_t");
    const char *unordered_map__string____string____contains_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].contains",2,unordered_map__string____string____contains_domain,"Bool");
    const char *option__unordered_map__string____string______value_domain[2] = {"option[unordered_map[string][string]]","option[unordered_map[string][string]].domain_t"};
    mk_decl("option[unordered_map[string][string]].value",2,option__unordered_map__string____string______value_domain,"unordered_map[string][string]");
    const char *_DeleteMarkerEntry___Owner__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Owner_",1,_DeleteMarkerEntry___Owner__domain,"_Owner");
    const char *_AccessControlPolicy___Grants__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Grants_",1,_AccessControlPolicy___Grants__domain,"vector[_Grant]");
    const char *_GetObjectOutput___Restore__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Restore_",1,_GetObjectOutput___Restore__domain,"string");
    const char *option__vector___Transition______value_domain[2] = {"option[vector[_Transition]]","option[vector[_Transition]].domain_t"};
    mk_decl("option[vector[_Transition]].value",2,option__vector___Transition______value_domain,"vector[_Transition]");
    const char *vector__string____end_domain[1] = {"vector[string]"};
    mk_decl("vector[string].end",1,vector__string____end_domain,"vector[string].domain");
    const char *vector___MetadataEntry____value_domain[2] = {"vector[_MetadataEntry]","vector[_MetadataEntry].domain"};
    mk_decl("vector[_MetadataEntry].value",2,vector___MetadataEntry____value_domain,"_MetadataEntry");
    const char *_IntelligentTieringConfiguration___Filter__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Filter_",1,_IntelligentTieringConfiguration___Filter__domain,"option[_IntelligentTieringFilter]");
    const char *_IntelligentTieringFilter___Tag__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Tag_",1,_IntelligentTieringFilter___Tag__domain,"_Tag");
    const char *_PutObjectRequest___GrantFullControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantFullControl_",1,_PutObjectRequest___GrantFullControl__domain,"option[string]");
    const char *option___Encryption____end_domain[1] = {"option[_Encryption]"};
    mk_decl("option[_Encryption].end",1,option___Encryption____end_domain,"option[_Encryption].domain_t");
    const char *_CSVOutput___QuoteEscapeCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteEscapeCharacter_",1,_CSVOutput___QuoteEscapeCharacter__domain,"string");
    const char *_AnalyticsConfiguration___StorageClassAnalysis__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._StorageClassAnalysis_",1,_AnalyticsConfiguration___StorageClassAnalysis__domain,"_StorageClassAnalysis");
    const char *_Redirect___ReplaceKeyPrefixWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyPrefixWith_",1,_Redirect___ReplaceKeyPrefixWith__domain,"string");
    const char *_ReplicationRuleAndOperator___Prefix__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Prefix_",1,_ReplicationRuleAndOperator___Prefix__domain,"string");
    const char *option__string____value_domain[2] = {"option[string]","option[string].domain_t"};
    mk_decl("option[string].value",2,option__string____value_domain,"string");
    const char *_PutObjectRequest___SSECustomerKeyMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKeyMD5_",1,_PutObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Object___Owner__domain[1] = {"_Object"};
    mk_decl("_Object._Owner_",1,_Object___Owner__domain,"_Owner");
    const char *_MultipartUpload___Key__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Key_",1,_MultipartUpload___Key__domain,"string");
    const char *_Encryption___EncryptionType__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._EncryptionType_",1,_Encryption___EncryptionType__domain,"string");
    const char *_Rule___Expiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._Expiration_",1,_Rule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *vector___Grant____value_domain[2] = {"vector[_Grant]","vector[_Grant].domain"};
    mk_decl("vector[_Grant].value",2,vector___Grant____value_domain,"_Grant");
    const char *_TopicConfiguration___Events__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Events_",1,_TopicConfiguration___Events__domain,"vector[string]");
    const char *option___ReplicationRuleFilter____value_domain[2] = {"option[_ReplicationRuleFilter]","option[_ReplicationRuleFilter].domain_t"};
    mk_decl("option[_ReplicationRuleFilter].value",2,option___ReplicationRuleFilter____value_domain,"_ReplicationRuleFilter");
    const char *_PutObjectRequest___GrantReadACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantReadACP_",1,_PutObjectRequest___GrantReadACP__domain,"option[string]");
    const char *_Bucket___Name__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._Name_",1,_Bucket___Name__domain,"string");
    const char *_LifecycleRule___ID__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._ID_",1,_LifecycleRule___ID__domain,"option[string]");
    const char *_DefaultRetention___Mode__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Mode_",1,_DefaultRetention___Mode__domain,"string");
    const char *vector___ObjectIdentifier____value_domain[2] = {"vector[_ObjectIdentifier]","vector[_ObjectIdentifier].domain"};
    mk_decl("vector[_ObjectIdentifier].value",2,vector___ObjectIdentifier____value_domain,"_ObjectIdentifier");
    const char *_GetObjectOutput___Expires__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expires_",1,_GetObjectOutput___Expires__domain,"timestamp");
    const char *_ReplicationRule___Filter__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Filter_",1,_ReplicationRule___Filter__domain,"option[_ReplicationRuleFilter]");
    mk_const("__fml:key","string");
    mk_const("__fml:bucket","string");
    add("(assert (and (= |__fml:bucket| the_bucket) "
"     (= |__fml:key| the_key) "
"     (present |__fml:bucket| |__fml:key|)))");
}
bool ext__get_gen::generate(s3_test& obj) {
    push();
    s3_test::string::prepare();
    slvr.add(__to_solver(*this,apply("the_key"),obj.the_key));
{
        std::vector<z3::expr> __quants;;
        __quants.push_back(ctx.constant("X__0",sort("string")));;
        __quants.push_back(ctx.constant("X__1",sort("string")));;
        slvr.add(forall(__quants,__to_solver(*this,apply("present",ctx.constant("X__0",sort("string")),ctx.constant("X__1",sort("string"))),obj.present)));
    }
    slvr.add(__to_solver(*this,apply("the_bucket"),obj.the_bucket));
    alits.clear();
    __randomize<s3_test::string>(*this,apply("__fml:key"));
    __randomize<s3_test::string>(*this,apply("__fml:bucket"));

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
                __from_solver<s3_test::string>(*this,apply("__fml:key"),key);
                __from_solver<s3_test::string>(*this,apply("__fml:bucket"),bucket);

    }s3_test::string::cleanup();

    pop();
    obj.___ivy_gen = this;
    return __res;
}
void ext__get_gen::execute(s3_test& obj){
    __ivy_out << "> get(" << bucket << ","  << key << ")" << std::endl;
    obj.ext__get(bucket,key);
}
class ext__put_gen : public gen {
  public:
    s3_test::string key;
    s3_test::blob data;
    s3_test::string bucket;
    ext__put_gen();
    bool generate(s3_test&);
    void execute(s3_test&);
};
ext__put_gen::ext__put_gen(){
mk_sort("_FilterRule");
mk_sort("_Destination");
    mk_bv("option[_ReplicationTime].domain_t",1);
mk_sort("_LifecycleExpiration");
    mk_int("vector[_ReplicationRule].domain");
mk_sort("vector[_DeleteMarkerEntry]");
mk_sort("vector[_DeletedObject]");
mk_sort("vector[_ObjectVersion]");
mk_sort("_InputSerialization");
    mk_bv("option[_InventoryEncryption].domain_t",1);
    mk_bv("option[_NoncurrentVersionExpiration].domain_t",1);
    mk_bv("option[_RequestProgress].domain_t",1);
mk_sort("_OutputLocation");
mk_sort("_ReplicationRuleFilter");
mk_sort("_SSES3");
    mk_bv("option[_LifecycleExpiration].domain_t",1);
mk_sort("_ObjectLockConfiguration");
    enum_sorts.insert(std::pair<std::string, z3::sort>("string",s3_test::string::z3_sort(ctx)));
mk_sort("_Redirect");
mk_sort("_ObjectLockLegalHold");
mk_sort("option[_InventoryEncryption]");
mk_sort("option[vector[_NoncurrentVersionTransition]]");
mk_sort("_Transition");
    mk_int("vector[_FilterRule].domain");
mk_sort("_LifecycleRuleAndOperator");
    mk_int("vector[_DeleteMarkerEntry].domain");
    mk_bv("option[_LifecycleRuleFilter].domain_t",1);
mk_sort("_SSEKMS");
    mk_bv("option[_EncryptionConfiguration].domain_t",1);
mk_sort("_SelectParameters");
    mk_bv("option[_RestoreRequest].domain_t",1);
mk_sort("unordered_map[string][string]");
mk_sort("_AnalyticsExportDestination");
mk_sort("vector[_Grant]");
    mk_bv("option[_Condition].domain_t",1);
mk_sort("_DeleteMarkerEntry");
mk_sort("option[_Encryption]");
mk_sort("option[_NoncurrentVersionTransition]");
    mk_bv("option[integer].domain_t",1);
mk_sort("_Encryption");
    mk_int("vector[_MetadataEntry].domain");
    mk_bv("option[_Tagging].domain_t",1);
mk_sort("vector[_LifecycleRule]");
    mk_bv("option[bool].domain_t",1);
mk_sort("_Condition");
mk_sort("option[_NotificationConfigurationFilter]");
mk_sort("vector[_ObjectIdentifier]");
    mk_bv("option[_IntelligentTieringFilter].domain_t",1);
mk_sort("option[_CompletedMultipartUpload]");
mk_sort("_ObjectVersion");
mk_sort("_ServerSideEncryptionByDefault");
mk_sort("_Tiering");
mk_sort("option[_InventoryFilter]");
mk_sort("option[string]");
    mk_bv("option[_InventoryFilter].domain_t",1);
    mk_int("vector[_Tag].domain");
mk_sort("_JSONInput");
mk_sort("_OutputSerialization");
mk_sort("option[_EncryptionConfiguration]");
mk_sort("option[bool]");
mk_sort("_IntelligentTieringConfiguration");
    mk_bv("byte",8);
mk_sort("option[_NoncurrentVersionExpiration]");
    mk_int("vector[_ObjectVersion].domain");
mk_sort("_MetricsFilter");
    mk_bv("option[_NoncurrentVersionTransition].domain_t",1);
    mk_bv("option[_Transition].domain_t",1);
    mk_bv("option[_ObjectLockRetention].domain_t",1);
mk_sort("_StorageClassAnalysis");
mk_sort("_BucketLifecycleConfiguration");
mk_sort("_Error");
    mk_int("vector[_NoncurrentVersionTransition].domain");
    mk_bv("option[_CreateBucketConfiguration].domain_t",1);
mk_sort("_Tag");
    mk_bv("option[_ReplicationTimeValue].domain_t",1);
mk_sort("_Bucket");
mk_sort("vector[_NoncurrentVersionTransition]");
mk_sort("_DeletedObject");
    mk_int("vector[_Bucket].domain");
mk_sort("option[unordered_map[string][string]]");
mk_sort("_AnalyticsAndOperator");
mk_sort("_CreateBucketConfiguration");
mk_sort("option[_IntelligentTieringFilter]");
mk_sort("_ReplicationTime");
    mk_int("vector[string].domain");
mk_sort("option[vector[_MetadataEntry]]");
    mk_int("vector[_MultipartUpload].domain");
mk_sort("_AnalyticsFilter");
mk_sort("_Grant");
mk_sort("_S3KeyFilter");
mk_sort("_MultipartUpload");
mk_sort("option[_Metrics]");
mk_sort("_ObjectLockRule");
    mk_int("vector[_ServerSideEncryptionRule].domain");
    mk_int("vector[_MetricsConfiguration].domain");
    mk_bv("option[string].domain_t",1);
mk_sort("_DeleteMarkerReplication");
mk_sort("_RestoreRequest");
    mk_int("vector[_TargetGrant].domain");
mk_sort("vector[_AnalyticsConfiguration]");
mk_sort("option[_RestoreRequest]");
    mk_bv("option[_ObjectLockLegalHold].domain_t",1);
mk_sort("option[_Tagging]");
    mk_int("vector[_LambdaFunctionConfiguration].domain");
mk_sort("option[_DeleteMarkerReplication]");
mk_sort("option[_Condition]");
mk_sort("vector[string]");
    mk_int("vector[_OwnershipControlsRule].domain");
    mk_int("blob.domain");
mk_sort("vector[_FilterRule]");
    mk_bv("option[blob].domain_t",1);
mk_sort("_IntelligentTieringAndOperator");
mk_sort("vector[_QueueConfiguration]");
mk_sort("_GetObjectOutput");
mk_sort("_LifecycleRuleFilter");
mk_sort("_IntelligentTieringFilter");
    mk_bv("option[_ObjectLockConfiguration].domain_t",1);
mk_sort("option[_ScanRange]");
    mk_int("vector[_QueueConfiguration].domain");
mk_sort("_PutObjectOutput");
mk_sort("vector[_InventoryConfiguration]");
mk_sort("_Metrics");
    mk_bv("option[vector[_NoncurrentVersionTransition]].domain_t",1);
mk_sort("vector[_Bucket]");
mk_sort("_StorageClassAnalysisDataExport");
mk_sort("vector[_CORSRule]");
mk_sort("_AnalyticsConfiguration");
mk_sort("_CompletedMultipartUpload");
mk_sort("_ReplicaModifications");
    mk_bv("option[_AbortIncompleteMultipartUpload].domain_t",1);
mk_sort("vector[_ReplicationRule]");
    mk_int("vector[_Object].domain");
mk_sort("option[_AbortIncompleteMultipartUpload]");
mk_sort("option[_LifecycleConfiguration]");
mk_sort("blob");
mk_sort("vector[_Object]");
    mk_bv("option[_NotificationConfigurationFilter].domain_t",1);
mk_sort("option[_ObjectLockRetention]");
    mk_bv("option[_MetricsFilter].domain_t",1);
mk_sort("_Tagging");
    mk_int("timestamp");
mk_sort("_Initiator");
mk_sort("option[_AnalyticsFilter]");
mk_sort("_RoutingRule");
    mk_int("vector[_CORSRule].domain");
mk_sort("_DefaultRetention");
mk_sort("_GetObjectRequest");
mk_sort("_CompletedPart");
    mk_int("integer");
mk_sort("option[_Transition]");
    mk_bv("option[vector[_TargetGrant]].domain_t",1);
    mk_int("vector[_Grant].domain");
    mk_bv("option[vector[string]].domain_t",1);
mk_sort("_ReplicationTimeValue");
    mk_bv("option[unordered_map[string][string]].domain_t",1);
mk_sort("_MetricsAndOperator");
mk_sort("_NoncurrentVersionTransition");
mk_sort("option[_LifecycleExpiration]");
mk_sort("_LifecycleConfiguration");
mk_sort("vector[_Tiering]");
mk_sort("option[_ObjectLockLegalHold]");
mk_sort("option[_AccessControlTranslation]");
mk_sort("_Rule");
mk_sort("vector[_Rule]");
mk_sort("_InventoryEncryption");
mk_sort("_CommonPrefix");
    mk_int("vector[_Part].domain");
    mk_bv("option[_CompletedMultipartUpload].domain_t",1);
mk_sort("_InventoryS3BucketDestination");
mk_sort("_ReplicationRuleAndOperator");
    mk_bv("option[_AccessControlPolicy].domain_t",1);
    mk_int("vector[_Error].domain");
    mk_int("vector[_Transition].domain");
mk_sort("option[vector[_TargetGrant]]");
mk_sort("_PutObjectRequest");
mk_sort("_InventoryConfiguration");
mk_sort("vector[_MetadataEntry]");
    mk_bv("option[_Encryption].domain_t",1);
    mk_int("vector[_Tiering].domain");
    mk_bv("option[_DeleteMarkerReplication].domain_t",1);
mk_sort("option[vector[_Transition]]");
mk_sort("_NoncurrentVersionExpiration");
mk_sort("_ObjectLockRetention");
mk_sort("vector[_Part]");
mk_sort("vector[_Error]");
mk_sort("_NotificationConfigurationFilter");
mk_sort("_RequestProgress");
mk_sort("_JSONOutput");
mk_sort("_ObjectIdentifier");
mk_sort("vector[_TargetGrant]");
mk_sort("_S3Location");
mk_sort("_TopicConfiguration");
mk_sort("vector[_RoutingRule]");
    mk_bv("option[timestamp].domain_t",1);
mk_sort("_QueueConfiguration");
mk_sort("option[_AccessControlPolicy]");
mk_sort("_ReplicationRule");
mk_sort("vector[_ServerSideEncryptionRule]");
    mk_int("vector[_LifecycleRule].domain");
mk_sort("vector[_MetricsConfiguration]");
mk_sort("vector[_OwnershipControlsRule]");
mk_sort("_TargetGrant");
mk_sort("option[long]");
mk_sort("option[vector[_Grant]]");
mk_sort("_MetricsConfiguration");
    mk_bv("option[long].domain_t",1);
    mk_int("long");
mk_sort("option[_ReplicationTime]");
mk_sort("option[_SourceSelectionCriteria]");
mk_sort("_ExistingObjectReplication");
mk_sort("_AccessControlTranslation");
mk_sort("_GlacierJobParameters");
mk_sort("vector[_MultipartUpload]");
mk_sort("_ServerSideEncryptionRule");
    mk_int("vector[_InventoryConfiguration].domain");
mk_sort("_InventoryDestination");
    mk_int("vector[_RoutingRule].domain");
mk_sort("_AbortIncompleteMultipartUpload");
mk_sort("option[_ReplicationRuleFilter]");
    mk_int("vector[_DeletedObject].domain");
    mk_bv("option[_ReplicationRuleFilter].domain_t",1);
mk_sort("_InventorySchedule");
mk_sort("_Grantee");
    mk_int("vector[_ObjectIdentifier].domain");
mk_sort("option[_MetricsFilter]");
    mk_int("vector[_CompletedPart].domain");
mk_sort("_Part");
mk_sort("option[blob]");
mk_sort("_Object");
mk_sort("_CSVOutput");
    mk_int("vector[_TopicConfiguration].domain");
mk_sort("option[_ExistingObjectReplication]");
mk_sort("option[_BucketLifecycleConfiguration]");
mk_sort("option[_RequestProgress]");
mk_sort("_AccessControlPolicy");
    mk_bv("option[_BucketLifecycleConfiguration].domain_t",1);
mk_sort("_ParquetInput");
mk_sort("_MetadataEntry");
mk_sort("_LifecycleRule");
mk_sort("option[integer]");
    mk_bv("option[_SourceSelectionCriteria].domain_t",1);
    mk_int("vector[_IntelligentTieringConfiguration].domain");
mk_sort("_CSVInput");
mk_sort("_CORSRule");
mk_sort("option[_CreateBucketConfiguration]");
mk_sort("option[_ReplicationTimeValue]");
    mk_int("vector[_CommonPrefix].domain");
    mk_bv("option[_LifecycleConfiguration].domain_t",1);
mk_sort("vector[_Tag]");
mk_sort("option[vector[string]]");
mk_sort("_OwnershipControlsRule");
    mk_bv("option[_AccessControlTranslation].domain_t",1);
mk_sort("vector[_CommonPrefix]");
mk_sort("_SourceSelectionCriteria");
mk_sort("vector[_LambdaFunctionConfiguration]");
    mk_bv("option[_ScanRange].domain_t",1);
mk_sort("_LambdaFunctionConfiguration");
mk_sort("option[_ObjectLockConfiguration]");
    mk_bv("option[_AnalyticsFilter].domain_t",1);
    mk_bv("option[_ExistingObjectReplication].domain_t",1);
    mk_bv("option[_Metrics].domain_t",1);
mk_sort("_Owner");
    mk_bv("option[vector[_Transition]].domain_t",1);
mk_sort("vector[_CompletedPart]");
    mk_int("vector[_Rule].domain");
    mk_bv("option[vector[_Grant]].domain_t",1);
mk_sort("_ScanRange");
    mk_bv("option[vector[_MetadataEntry]].domain_t",1);
mk_sort("_EncryptionConfiguration");
mk_sort("option[_LifecycleRuleFilter]");
mk_sort("_AnalyticsS3BucketDestination");
mk_sort("vector[_Transition]");
mk_sort("vector[_TopicConfiguration]");
mk_sort("vector[_IntelligentTieringConfiguration]");
    mk_int("vector[_AnalyticsConfiguration].domain");
mk_sort("_InventoryFilter");
mk_sort("option[timestamp]");
mk_sort("_SseKmsEncryptedObjects");
    const char *_PutObjectRequest___ContentType__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentType_",1,_PutObjectRequest___ContentType__domain,"option[string]");
    const char *_SourceSelectionCriteria___ReplicaModifications__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._ReplicaModifications_",1,_SourceSelectionCriteria___ReplicaModifications__domain,"_ReplicaModifications");
    const char *_PutObjectRequest___Bucket__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Bucket_",1,_PutObjectRequest___Bucket__domain,"string");
    const char *_Bucket___CreationDate__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._CreationDate_",1,_Bucket___CreationDate__domain,"timestamp");
    const char *_InventoryConfiguration___IsEnabled__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IsEnabled_",1,_InventoryConfiguration___IsEnabled__domain,"Bool");
    const char *_Destination___StorageClass__domain[1] = {"_Destination"};
    mk_decl("_Destination._StorageClass_",1,_Destination___StorageClass__domain,"option[string]");
    const char *option__long____value_domain[2] = {"option[long]","option[long].domain_t"};
    mk_decl("option[long].value",2,option__long____value_domain,"long");
    const char *_CORSRule___AllowedOrigins__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedOrigins_",1,_CORSRule___AllowedOrigins__domain,"vector[string]");
    const char *_ObjectVersion___Size__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Size_",1,_ObjectVersion___Size__domain,"integer");
    const char *_SSEKMS___KeyId__domain[1] = {"_SSEKMS"};
    mk_decl("_SSEKMS._KeyId_",1,_SSEKMS___KeyId__domain,"string");
    const char *_FilterRule___Name__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Name_",1,_FilterRule___Name__domain,"string");
    const char *option__vector___Grant______value_domain[2] = {"option[vector[_Grant]]","option[vector[_Grant]].domain_t"};
    mk_decl("option[vector[_Grant]].value",2,option__vector___Grant______value_domain,"vector[_Grant]");
    const char *_PutObjectRequest___ObjectLockMode__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockMode_",1,_PutObjectRequest___ObjectLockMode__domain,"option[string]");
    const char *option___ObjectLockConfiguration____value_domain[2] = {"option[_ObjectLockConfiguration]","option[_ObjectLockConfiguration].domain_t"};
    mk_decl("option[_ObjectLockConfiguration].value",2,option___ObjectLockConfiguration____value_domain,"_ObjectLockConfiguration");
    const char *vector___Object____value_domain[2] = {"vector[_Object]","vector[_Object].domain"};
    mk_decl("vector[_Object].value",2,vector___Object____value_domain,"_Object");
    const char *vector___IntelligentTieringConfiguration____end_domain[1] = {"vector[_IntelligentTieringConfiguration]"};
    mk_decl("vector[_IntelligentTieringConfiguration].end",1,vector___IntelligentTieringConfiguration____end_domain,"vector[_IntelligentTieringConfiguration].domain");
    const char *_InventoryS3BucketDestination___Prefix__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Prefix_",1,_InventoryS3BucketDestination___Prefix__domain,"option[string]");
    const char *_DefaultRetention___Days__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Days_",1,_DefaultRetention___Days__domain,"integer");
    const char *_Redirect___Protocol__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._Protocol_",1,_Redirect___Protocol__domain,"string");
    const char *_MetricsFilter___Prefix__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Prefix_",1,_MetricsFilter___Prefix__domain,"string");
    const char *_LifecycleRule___AbortIncompleteMultipartUpload__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._AbortIncompleteMultipartUpload_",1,_LifecycleRule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *_InventoryConfiguration___OptionalFields__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._OptionalFields_",1,_InventoryConfiguration___OptionalFields__domain,"option[vector[string]]");
    const char *_PutObjectRequest___SSEKMSKeyId__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSKeyId_",1,_PutObjectRequest___SSEKMSKeyId__domain,"option[string]");
    const char *vector___Rule____end_domain[1] = {"vector[_Rule]"};
    mk_decl("vector[_Rule].end",1,vector___Rule____end_domain,"vector[_Rule].domain");
    const char *vector___MetadataEntry____end_domain[1] = {"vector[_MetadataEntry]"};
    mk_decl("vector[_MetadataEntry].end",1,vector___MetadataEntry____end_domain,"vector[_MetadataEntry].domain");
    const char *vector___DeletedObject____value_domain[2] = {"vector[_DeletedObject]","vector[_DeletedObject].domain"};
    mk_decl("vector[_DeletedObject].value",2,vector___DeletedObject____value_domain,"_DeletedObject");
    const char *_LambdaFunctionConfiguration___Id__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Id_",1,_LambdaFunctionConfiguration___Id__domain,"option[string]");
    const char *option___MetricsFilter____value_domain[2] = {"option[_MetricsFilter]","option[_MetricsFilter].domain_t"};
    mk_decl("option[_MetricsFilter].value",2,option___MetricsFilter____value_domain,"_MetricsFilter");
    const char *_CSVOutput___QuoteCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteCharacter_",1,_CSVOutput___QuoteCharacter__domain,"string");
    const char *_NoncurrentVersionTransition___StorageClass__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._StorageClass_",1,_NoncurrentVersionTransition___StorageClass__domain,"string");
    mk_const("the_key","string");
    const char *_OutputLocation___S3__domain[1] = {"_OutputLocation"};
    mk_decl("_OutputLocation._S3_",1,_OutputLocation___S3__domain,"_S3Location");
    const char *_MetadataEntry___Value__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Value_",1,_MetadataEntry___Value__domain,"string");
    const char *vector___Bucket____end_domain[1] = {"vector[_Bucket]"};
    mk_decl("vector[_Bucket].end",1,vector___Bucket____end_domain,"vector[_Bucket].domain");
    const char *_Metrics___Status__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._Status_",1,_Metrics___Status__domain,"string");
    const char *vector___LifecycleRule____value_domain[2] = {"vector[_LifecycleRule]","vector[_LifecycleRule].domain"};
    mk_decl("vector[_LifecycleRule].value",2,vector___LifecycleRule____value_domain,"_LifecycleRule");
    const char *option___SourceSelectionCriteria____value_domain[2] = {"option[_SourceSelectionCriteria]","option[_SourceSelectionCriteria].domain_t"};
    mk_decl("option[_SourceSelectionCriteria].value",2,option___SourceSelectionCriteria____value_domain,"_SourceSelectionCriteria");
    const char *_SelectParameters___InputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._InputSerialization_",1,_SelectParameters___InputSerialization__domain,"_InputSerialization");
    const char *option___NoncurrentVersionExpiration____value_domain[2] = {"option[_NoncurrentVersionExpiration]","option[_NoncurrentVersionExpiration].domain_t"};
    mk_decl("option[_NoncurrentVersionExpiration].value",2,option___NoncurrentVersionExpiration____value_domain,"_NoncurrentVersionExpiration");
    const char *_LambdaFunctionConfiguration___Filter__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Filter_",1,_LambdaFunctionConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_Redirect___ReplaceKeyWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyWith_",1,_Redirect___ReplaceKeyWith__domain,"string");
    const char *option___Metrics____value_domain[2] = {"option[_Metrics]","option[_Metrics].domain_t"};
    mk_decl("option[_Metrics].value",2,option___Metrics____value_domain,"_Metrics");
    const char *_CORSRule___ExposeHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ExposeHeaders_",1,_CORSRule___ExposeHeaders__domain,"option[vector[string]]");
    const char *_ServerSideEncryptionRule___BucketKeyEnabled__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._BucketKeyEnabled_",1,_ServerSideEncryptionRule___BucketKeyEnabled__domain,"Bool");
    const char *_PutObjectRequest___ContentEncoding__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentEncoding_",1,_PutObjectRequest___ContentEncoding__domain,"option[string]");
    const char *option___ObjectLockLegalHold____end_domain[1] = {"option[_ObjectLockLegalHold]"};
    mk_decl("option[_ObjectLockLegalHold].end",1,option___ObjectLockLegalHold____end_domain,"option[_ObjectLockLegalHold].domain_t");
    const char *_AnalyticsConfiguration___Id__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Id_",1,_AnalyticsConfiguration___Id__domain,"string");
    const char *vector__string____value_domain[2] = {"vector[string]","vector[string].domain"};
    mk_decl("vector[string].value",2,vector__string____value_domain,"string");
    const char *_ObjectVersion___IsLatest__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._IsLatest_",1,_ObjectVersion___IsLatest__domain,"Bool");
    const char *_GetObjectOutput___SSECustomerKeyMD5__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerKeyMD5_",1,_GetObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_GetObjectOutput___SSEKMSKeyId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSEKMSKeyId_",1,_GetObjectOutput___SSEKMSKeyId__domain,"string");
    const char *vector___ReplicationRule____value_domain[2] = {"vector[_ReplicationRule]","vector[_ReplicationRule].domain"};
    mk_decl("vector[_ReplicationRule].value",2,vector___ReplicationRule____value_domain,"_ReplicationRule");
    const char *_IntelligentTieringConfiguration___Id__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Id_",1,_IntelligentTieringConfiguration___Id__domain,"string");
    const char *_ReplicationRule___ID__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ID_",1,_ReplicationRule___ID__domain,"option[string]");
    const char *option___RequestProgress____value_domain[2] = {"option[_RequestProgress]","option[_RequestProgress].domain_t"};
    mk_decl("option[_RequestProgress].value",2,option___RequestProgress____value_domain,"_RequestProgress");
    const char *_GetObjectOutput___AcceptRanges__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._AcceptRanges_",1,_GetObjectOutput___AcceptRanges__domain,"string");
    const char *_Part___ETag__domain[1] = {"_Part"};
    mk_decl("_Part._ETag_",1,_Part___ETag__domain,"string");
    const char *_Owner___ID__domain[1] = {"_Owner"};
    mk_decl("_Owner._ID_",1,_Owner___ID__domain,"string");
    const char *vector___TopicConfiguration____end_domain[1] = {"vector[_TopicConfiguration]"};
    mk_decl("vector[_TopicConfiguration].end",1,vector___TopicConfiguration____end_domain,"vector[_TopicConfiguration].domain");
    const char *_GetObjectRequest___Key__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Key_",1,_GetObjectRequest___Key__domain,"string");
    const char *option___LifecycleExpiration____value_domain[2] = {"option[_LifecycleExpiration]","option[_LifecycleExpiration].domain_t"};
    mk_decl("option[_LifecycleExpiration].value",2,option___LifecycleExpiration____value_domain,"_LifecycleExpiration");
    const char *_S3Location___CannedACL__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._CannedACL_",1,_S3Location___CannedACL__domain,"option[string]");
    const char *_InventoryS3BucketDestination___Encryption__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Encryption_",1,_InventoryS3BucketDestination___Encryption__domain,"option[_InventoryEncryption]");
    const char *_Destination___EncryptionConfiguration__domain[1] = {"_Destination"};
    mk_decl("_Destination._EncryptionConfiguration_",1,_Destination___EncryptionConfiguration__domain,"option[_EncryptionConfiguration]");
    const char *option___ReplicationTimeValue____value_domain[2] = {"option[_ReplicationTimeValue]","option[_ReplicationTimeValue].domain_t"};
    mk_decl("option[_ReplicationTimeValue].value",2,option___ReplicationTimeValue____value_domain,"_ReplicationTimeValue");
    const char *option__blob____end_domain[1] = {"option[blob]"};
    mk_decl("option[blob].end",1,option__blob____end_domain,"option[blob].domain_t");
    const char *option__vector___Transition______end_domain[1] = {"option[vector[_Transition]]"};
    mk_decl("option[vector[_Transition]].end",1,option__vector___Transition______end_domain,"option[vector[_Transition]].domain_t");
    const char *_GetObjectRequest___Range__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Range_",1,_GetObjectRequest___Range__domain,"option[string]");
    const char *_LifecycleRule___Status__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Status_",1,_LifecycleRule___Status__domain,"string");
    const char *option___InventoryFilter____value_domain[2] = {"option[_InventoryFilter]","option[_InventoryFilter].domain_t"};
    mk_decl("option[_InventoryFilter].value",2,option___InventoryFilter____value_domain,"_InventoryFilter");
    const char *_GetObjectOutput___ETag__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ETag_",1,_GetObjectOutput___ETag__domain,"string");
    const char *_LifecycleRuleFilter___And__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._And_",1,_LifecycleRuleFilter___And__domain,"_LifecycleRuleAndOperator");
    const char *_Tag___Key__domain[1] = {"_Tag"};
    mk_decl("_Tag._Key_",1,_Tag___Key__domain,"string");
    const char *_ObjectLockRetention___RetainUntilDate__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._RetainUntilDate_",1,_ObjectLockRetention___RetainUntilDate__domain,"timestamp");
    const char *option___ObjectLockRetention____value_domain[2] = {"option[_ObjectLockRetention]","option[_ObjectLockRetention].domain_t"};
    mk_decl("option[_ObjectLockRetention].value",2,option___ObjectLockRetention____value_domain,"_ObjectLockRetention");
    const char *_LambdaFunctionConfiguration___LambdaFunctionArn__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._LambdaFunctionArn_",1,_LambdaFunctionConfiguration___LambdaFunctionArn__domain,"string");
    const char *vector___RoutingRule____value_domain[2] = {"vector[_RoutingRule]","vector[_RoutingRule].domain"};
    mk_decl("vector[_RoutingRule].value",2,vector___RoutingRule____value_domain,"_RoutingRule");
    const char *_AnalyticsFilter___And__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._And_",1,_AnalyticsFilter___And__domain,"_AnalyticsAndOperator");
    const char *vector___CommonPrefix____end_domain[1] = {"vector[_CommonPrefix]"};
    mk_decl("vector[_CommonPrefix].end",1,vector___CommonPrefix____end_domain,"vector[_CommonPrefix].domain");
    const char *option__vector__string______end_domain[1] = {"option[vector[string]]"};
    mk_decl("option[vector[string]].end",1,option__vector__string______end_domain,"option[vector[string]].domain_t");
    const char *_S3Location___Encryption__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Encryption_",1,_S3Location___Encryption__domain,"option[_Encryption]");
    const char *_CompletedPart___PartNumber__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._PartNumber_",1,_CompletedPart___PartNumber__domain,"integer");
    const char *vector___AnalyticsConfiguration____value_domain[2] = {"vector[_AnalyticsConfiguration]","vector[_AnalyticsConfiguration].domain"};
    mk_decl("vector[_AnalyticsConfiguration].value",2,vector___AnalyticsConfiguration____value_domain,"_AnalyticsConfiguration");
    const char *_GetObjectRequest___PartNumber__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._PartNumber_",1,_GetObjectRequest___PartNumber__domain,"option[integer]");
    const char *_Grantee___EmailAddress__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._EmailAddress_",1,_Grantee___EmailAddress__domain,"option[string]");
    const char *_Tiering___AccessTier__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._AccessTier_",1,_Tiering___AccessTier__domain,"string");
    const char *_S3Location___StorageClass__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._StorageClass_",1,_S3Location___StorageClass__domain,"option[string]");
    const char *_AnalyticsAndOperator___Prefix__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Prefix_",1,_AnalyticsAndOperator___Prefix__domain,"string");
    const char *_ObjectLockConfiguration___ObjectLockEnabled__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._ObjectLockEnabled_",1,_ObjectLockConfiguration___ObjectLockEnabled__domain,"string");
    const char *option___Encryption____value_domain[2] = {"option[_Encryption]","option[_Encryption].domain_t"};
    mk_decl("option[_Encryption].value",2,option___Encryption____value_domain,"_Encryption");
    const char *_ReplicationRuleFilter___Tag__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Tag_",1,_ReplicationRuleFilter___Tag__domain,"_Tag");
    const char *_Error___Key__domain[1] = {"_Error"};
    mk_decl("_Error._Key_",1,_Error___Key__domain,"string");
    const char *_ObjectVersion___VersionId__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._VersionId_",1,_ObjectVersion___VersionId__domain,"string");
    const char *_RestoreRequest___Tier__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Tier_",1,_RestoreRequest___Tier__domain,"string");
    const char *_GetObjectOutput___ContentRange__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentRange_",1,_GetObjectOutput___ContentRange__domain,"string");
    const char *_DeletedObject___Key__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._Key_",1,_DeletedObject___Key__domain,"string");
    const char *option___LifecycleConfiguration____value_domain[2] = {"option[_LifecycleConfiguration]","option[_LifecycleConfiguration].domain_t"};
    mk_decl("option[_LifecycleConfiguration].value",2,option___LifecycleConfiguration____value_domain,"_LifecycleConfiguration");
    const char *_GetObjectRequest___ExpectedBucketOwner__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ExpectedBucketOwner_",1,_GetObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_LifecycleRule___NoncurrentVersionExpiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionExpiration_",1,_LifecycleRule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *option___CreateBucketConfiguration____value_domain[2] = {"option[_CreateBucketConfiguration]","option[_CreateBucketConfiguration].domain_t"};
    mk_decl("option[_CreateBucketConfiguration].value",2,option___CreateBucketConfiguration____value_domain,"_CreateBucketConfiguration");
    const char *vector___Tiering____end_domain[1] = {"vector[_Tiering]"};
    mk_decl("vector[_Tiering].end",1,vector___Tiering____end_domain,"vector[_Tiering].domain");
    const char *_NoncurrentVersionExpiration___NoncurrentDays__domain[1] = {"_NoncurrentVersionExpiration"};
    mk_decl("_NoncurrentVersionExpiration._NoncurrentDays_",1,_NoncurrentVersionExpiration___NoncurrentDays__domain,"integer");
    const char *_RequestProgress___Enabled__domain[1] = {"_RequestProgress"};
    mk_decl("_RequestProgress._Enabled_",1,_RequestProgress___Enabled__domain,"Bool");
    const char *_StorageClassAnalysis___DataExport__domain[1] = {"_StorageClassAnalysis"};
    mk_decl("_StorageClassAnalysis._DataExport_",1,_StorageClassAnalysis___DataExport__domain,"_StorageClassAnalysisDataExport");
    const char *option__string____end_domain[1] = {"option[string]"};
    mk_decl("option[string].end",1,option__string____end_domain,"option[string].domain_t");
    const char *_GetObjectRequest___SSECustomerKey__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKey_",1,_GetObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_SourceSelectionCriteria___SseKmsEncryptedObjects__domain[1] = {"_SourceSelectionCriteria"};
    mk_decl("_SourceSelectionCriteria._SseKmsEncryptedObjects_",1,_SourceSelectionCriteria___SseKmsEncryptedObjects__domain,"_SseKmsEncryptedObjects");
    const char *vector___Part____end_domain[1] = {"vector[_Part]"};
    mk_decl("vector[_Part].end",1,vector___Part____end_domain,"vector[_Part].domain");
    const char *option___LifecycleConfiguration____end_domain[1] = {"option[_LifecycleConfiguration]"};
    mk_decl("option[_LifecycleConfiguration].end",1,option___LifecycleConfiguration____end_domain,"option[_LifecycleConfiguration].domain_t");
    const char *option___LifecycleRuleFilter____value_domain[2] = {"option[_LifecycleRuleFilter]","option[_LifecycleRuleFilter].domain_t"};
    mk_decl("option[_LifecycleRuleFilter].value",2,option___LifecycleRuleFilter____value_domain,"_LifecycleRuleFilter");
    const char *option___CompletedMultipartUpload____value_domain[2] = {"option[_CompletedMultipartUpload]","option[_CompletedMultipartUpload].domain_t"};
    mk_decl("option[_CompletedMultipartUpload].value",2,option___CompletedMultipartUpload____value_domain,"_CompletedMultipartUpload");
    const char *_CompletedMultipartUpload___Parts__domain[1] = {"_CompletedMultipartUpload"};
    mk_decl("_CompletedMultipartUpload._Parts_",1,_CompletedMultipartUpload___Parts__domain,"vector[_CompletedPart]");
    const char *_ReplicationRuleFilter___And__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._And_",1,_ReplicationRuleFilter___And__domain,"_ReplicationRuleAndOperator");
    const char *_GetObjectOutput___ObjectLockLegalHoldStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockLegalHoldStatus_",1,_GetObjectOutput___ObjectLockLegalHoldStatus__domain,"string");
    const char *_Object___LastModified__domain[1] = {"_Object"};
    mk_decl("_Object._LastModified_",1,_Object___LastModified__domain,"timestamp");
    const char *_PutObjectRequest___ContentDisposition__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentDisposition_",1,_PutObjectRequest___ContentDisposition__domain,"option[string]");
    const char *_Grant___Permission__domain[1] = {"_Grant"};
    mk_decl("_Grant._Permission_",1,_Grant___Permission__domain,"string");
    const char *_QueueConfiguration___QueueArn__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._QueueArn_",1,_QueueConfiguration___QueueArn__domain,"string");
    const char *_GetObjectOutput___ObjectLockRetainUntilDate__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockRetainUntilDate_",1,_GetObjectOutput___ObjectLockRetainUntilDate__domain,"timestamp");
    const char *option___SourceSelectionCriteria____end_domain[1] = {"option[_SourceSelectionCriteria]"};
    mk_decl("option[_SourceSelectionCriteria].end",1,option___SourceSelectionCriteria____end_domain,"option[_SourceSelectionCriteria].domain_t");
    const char *_ObjectVersion___LastModified__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._LastModified_",1,_ObjectVersion___LastModified__domain,"timestamp");
    const char *_TopicConfiguration___TopicArn__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._TopicArn_",1,_TopicConfiguration___TopicArn__domain,"string");
    const char *option___ExistingObjectReplication____end_domain[1] = {"option[_ExistingObjectReplication]"};
    mk_decl("option[_ExistingObjectReplication].end",1,option___ExistingObjectReplication____end_domain,"option[_ExistingObjectReplication].domain_t");
    const char *_GetObjectRequest___ResponseContentType__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentType_",1,_GetObjectRequest___ResponseContentType__domain,"option[string]");
    const char *vector___Tiering____value_domain[2] = {"vector[_Tiering]","vector[_Tiering].domain"};
    mk_decl("vector[_Tiering].value",2,vector___Tiering____value_domain,"_Tiering");
    const char *_RestoreRequest___Description__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Description_",1,_RestoreRequest___Description__domain,"string");
    const char *_ScanRange___End__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._End_",1,_ScanRange___End__domain,"long");
    const char *_PutObjectRequest___Tagging__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Tagging_",1,_PutObjectRequest___Tagging__domain,"option[string]");
    const char *vector___ServerSideEncryptionRule____value_domain[2] = {"vector[_ServerSideEncryptionRule]","vector[_ServerSideEncryptionRule].domain"};
    mk_decl("vector[_ServerSideEncryptionRule].value",2,vector___ServerSideEncryptionRule____value_domain,"_ServerSideEncryptionRule");
    const char *_PutObjectRequest___WebsiteRedirectLocation__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._WebsiteRedirectLocation_",1,_PutObjectRequest___WebsiteRedirectLocation__domain,"option[string]");
    const char *vector___Transition____value_domain[2] = {"vector[_Transition]","vector[_Transition].domain"};
    mk_decl("vector[_Transition].value",2,vector___Transition____value_domain,"_Transition");
    const char *_Rule___Prefix__domain[1] = {"_Rule"};
    mk_decl("_Rule._Prefix_",1,_Rule___Prefix__domain,"string");
    const char *option___Tagging____value_domain[2] = {"option[_Tagging]","option[_Tagging].domain_t"};
    mk_decl("option[_Tagging].value",2,option___Tagging____value_domain,"_Tagging");
    const char *option___AccessControlPolicy____end_domain[1] = {"option[_AccessControlPolicy]"};
    mk_decl("option[_AccessControlPolicy].end",1,option___AccessControlPolicy____end_domain,"option[_AccessControlPolicy].domain_t");
    const char *_TargetGrant___Grantee__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Grantee_",1,_TargetGrant___Grantee__domain,"_Grantee");
    const char *_Rule___NoncurrentVersionExpiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionExpiration_",1,_Rule___NoncurrentVersionExpiration__domain,"option[_NoncurrentVersionExpiration]");
    const char *_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain[1] = {"_AbortIncompleteMultipartUpload"};
    mk_decl("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",1,_AbortIncompleteMultipartUpload___DaysAfterInitiation__domain,"integer");
    const char *option__unordered_map__string____string______end_domain[1] = {"option[unordered_map[string][string]]"};
    mk_decl("option[unordered_map[string][string]].end",1,option__unordered_map__string____string______end_domain,"option[unordered_map[string][string]].domain_t");
    const char *_PutObjectOutput___RequestCharged__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._RequestCharged_",1,_PutObjectOutput___RequestCharged__domain,"string");
    const char *_InventoryEncryption___SSES3__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSES3_",1,_InventoryEncryption___SSES3__domain,"_SSES3");
    const char *_Redirect___HostName__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HostName_",1,_Redirect___HostName__domain,"string");
    const char *option___AnalyticsFilter____value_domain[2] = {"option[_AnalyticsFilter]","option[_AnalyticsFilter].domain_t"};
    mk_decl("option[_AnalyticsFilter].value",2,option___AnalyticsFilter____value_domain,"_AnalyticsFilter");
    const char *option___EncryptionConfiguration____value_domain[2] = {"option[_EncryptionConfiguration]","option[_EncryptionConfiguration].domain_t"};
    mk_decl("option[_EncryptionConfiguration].value",2,option___EncryptionConfiguration____value_domain,"_EncryptionConfiguration");
    const char *_Condition___KeyPrefixEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._KeyPrefixEquals_",1,_Condition___KeyPrefixEquals__domain,"string");
    const char *_GetObjectRequest___ResponseContentEncoding__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentEncoding_",1,_GetObjectRequest___ResponseContentEncoding__domain,"option[string]");
    const char *_CSVInput___AllowQuotedRecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._AllowQuotedRecordDelimiter_",1,_CSVInput___AllowQuotedRecordDelimiter__domain,"Bool");
    const char *option___RestoreRequest____end_domain[1] = {"option[_RestoreRequest]"};
    mk_decl("option[_RestoreRequest].end",1,option___RestoreRequest____end_domain,"option[_RestoreRequest].domain_t");
    const char *_JSONInput___Type__domain[1] = {"_JSONInput"};
    mk_decl("_JSONInput._Type_",1,_JSONInput___Type__domain,"string");
    const char *_LifecycleExpiration___Days__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Days_",1,_LifecycleExpiration___Days__domain,"integer");
    const char *_GetObjectOutput___ReplicationStatus__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ReplicationStatus_",1,_GetObjectOutput___ReplicationStatus__domain,"string");
    const char *option__vector___NoncurrentVersionTransition______end_domain[1] = {"option[vector[_NoncurrentVersionTransition]]"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].end",1,option__vector___NoncurrentVersionTransition______end_domain,"option[vector[_NoncurrentVersionTransition]].domain_t");
    const char *_MultipartUpload___StorageClass__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._StorageClass_",1,_MultipartUpload___StorageClass__domain,"string");
    const char *_InventoryDestination___S3BucketDestination__domain[1] = {"_InventoryDestination"};
    mk_decl("_InventoryDestination._S3BucketDestination_",1,_InventoryDestination___S3BucketDestination__domain,"_InventoryS3BucketDestination");
    const char *option___NotificationConfigurationFilter____value_domain[2] = {"option[_NotificationConfigurationFilter]","option[_NotificationConfigurationFilter].domain_t"};
    mk_decl("option[_NotificationConfigurationFilter].value",2,option___NotificationConfigurationFilter____value_domain,"_NotificationConfigurationFilter");
    const char *option__blob____value_domain[2] = {"option[blob]","option[blob].domain_t"};
    mk_decl("option[blob].value",2,option__blob____value_domain,"blob");
    const char *_GetObjectOutput___ContentLanguage__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLanguage_",1,_GetObjectOutput___ContentLanguage__domain,"string");
    const char *_InventoryS3BucketDestination___AccountId__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._AccountId_",1,_InventoryS3BucketDestination___AccountId__domain,"option[string]");
    const char *_ReplicationRule___ExistingObjectReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._ExistingObjectReplication_",1,_ReplicationRule___ExistingObjectReplication__domain,"option[_ExistingObjectReplication]");
    const char *_StorageClassAnalysisDataExport___Destination__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._Destination_",1,_StorageClassAnalysisDataExport___Destination__domain,"_AnalyticsExportDestination");
    const char *_RestoreRequest___Days__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Days_",1,_RestoreRequest___Days__domain,"integer");
    const char *_ObjectVersion___StorageClass__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._StorageClass_",1,_ObjectVersion___StorageClass__domain,"string");
    const char *_CSVInput___FileHeaderInfo__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FileHeaderInfo_",1,_CSVInput___FileHeaderInfo__domain,"string");
    const char *option___AccessControlPolicy____value_domain[2] = {"option[_AccessControlPolicy]","option[_AccessControlPolicy].domain_t"};
    mk_decl("option[_AccessControlPolicy].value",2,option___AccessControlPolicy____value_domain,"_AccessControlPolicy");
    const char *_LifecycleRule___Prefix__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Prefix_",1,_LifecycleRule___Prefix__domain,"option[string]");
    const char *option___InventoryEncryption____end_domain[1] = {"option[_InventoryEncryption]"};
    mk_decl("option[_InventoryEncryption].end",1,option___InventoryEncryption____end_domain,"option[_InventoryEncryption].domain_t");
    const char *_AnalyticsS3BucketDestination___Bucket__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Bucket_",1,_AnalyticsS3BucketDestination___Bucket__domain,"string");
    const char *_CORSRule___AllowedMethods__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedMethods_",1,_CORSRule___AllowedMethods__domain,"vector[string]");
    const char *_OutputSerialization___CSV__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._CSV_",1,_OutputSerialization___CSV__domain,"_CSVOutput");
    const char *_GetObjectRequest___SSECustomerKeyMD5__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerKeyMD5_",1,_GetObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Destination___ReplicationTime__domain[1] = {"_Destination"};
    mk_decl("_Destination._ReplicationTime_",1,_Destination___ReplicationTime__domain,"option[_ReplicationTime]");
    const char *_Redirect___HttpRedirectCode__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._HttpRedirectCode_",1,_Redirect___HttpRedirectCode__domain,"string");
    const char *_Encryption___KMSKeyId__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSKeyId_",1,_Encryption___KMSKeyId__domain,"option[string]");
    const char *_RestoreRequest___GlacierJobParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._GlacierJobParameters_",1,_RestoreRequest___GlacierJobParameters__domain,"_GlacierJobParameters");
    const char *_PutObjectOutput___ServerSideEncryption__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ServerSideEncryption_",1,_PutObjectOutput___ServerSideEncryption__domain,"string");
    const char *_CommonPrefix___Prefix__domain[1] = {"_CommonPrefix"};
    mk_decl("_CommonPrefix._Prefix_",1,_CommonPrefix___Prefix__domain,"string");
    const char *_InventoryConfiguration___Destination__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Destination_",1,_InventoryConfiguration___Destination__domain,"_InventoryDestination");
    const char *_DeletedObject___VersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._VersionId_",1,_DeletedObject___VersionId__domain,"string");
    const char *_S3Location___BucketName__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._BucketName_",1,_S3Location___BucketName__domain,"string");
    const char *_ReplicationTime___Time__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Time_",1,_ReplicationTime___Time__domain,"_ReplicationTimeValue");
    const char *_GetObjectOutput___Body__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Body_",1,_GetObjectOutput___Body__domain,"blob");
    const char *_TargetGrant___Permission__domain[1] = {"_TargetGrant"};
    mk_decl("_TargetGrant._Permission_",1,_TargetGrant___Permission__domain,"string");
    const char *_Grant___Grantee__domain[1] = {"_Grant"};
    mk_decl("_Grant._Grantee_",1,_Grant___Grantee__domain,"_Grantee");
    const char *option___AbortIncompleteMultipartUpload____value_domain[2] = {"option[_AbortIncompleteMultipartUpload]","option[_AbortIncompleteMultipartUpload].domain_t"};
    mk_decl("option[_AbortIncompleteMultipartUpload].value",2,option___AbortIncompleteMultipartUpload____value_domain,"_AbortIncompleteMultipartUpload");
    const char *option___Transition____value_domain[2] = {"option[_Transition]","option[_Transition].domain_t"};
    mk_decl("option[_Transition].value",2,option___Transition____value_domain,"_Transition");
    const char *vector___Tag____value_domain[2] = {"vector[_Tag]","vector[_Tag].domain"};
    mk_decl("vector[_Tag].value",2,vector___Tag____value_domain,"_Tag");
    const char *_GetObjectOutput___StorageClass__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._StorageClass_",1,_GetObjectOutput___StorageClass__domain,"string");
    const char *option___IntelligentTieringFilter____end_domain[1] = {"option[_IntelligentTieringFilter]"};
    mk_decl("option[_IntelligentTieringFilter].end",1,option___IntelligentTieringFilter____end_domain,"option[_IntelligentTieringFilter].domain_t");
    const char *_DeleteMarkerEntry___IsLatest__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._IsLatest_",1,_DeleteMarkerEntry___IsLatest__domain,"Bool");
    const char *vector___ObjectVersion____value_domain[2] = {"vector[_ObjectVersion]","vector[_ObjectVersion].domain"};
    mk_decl("vector[_ObjectVersion].value",2,vector___ObjectVersion____value_domain,"_ObjectVersion");
    const char *_S3Location___UserMetadata__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._UserMetadata_",1,_S3Location___UserMetadata__domain,"option[vector[_MetadataEntry]]");
    const char *_InventoryConfiguration___Filter__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Filter_",1,_InventoryConfiguration___Filter__domain,"option[_InventoryFilter]");
    const char *_AnalyticsFilter___Tag__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Tag_",1,_AnalyticsFilter___Tag__domain,"_Tag");
    const char *_ServerSideEncryptionByDefault___SSEAlgorithm__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._SSEAlgorithm_",1,_ServerSideEncryptionByDefault___SSEAlgorithm__domain,"string");
    const char *_GetObjectOutput___PartsCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._PartsCount_",1,_GetObjectOutput___PartsCount__domain,"integer");
    const char *_IntelligentTieringAndOperator___Tags__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Tags_",1,_IntelligentTieringAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___Bucket____value_domain[2] = {"vector[_Bucket]","vector[_Bucket].domain"};
    mk_decl("vector[_Bucket].value",2,vector___Bucket____value_domain,"_Bucket");
    const char *option__vector___Grant______end_domain[1] = {"option[vector[_Grant]]"};
    mk_decl("option[vector[_Grant]].end",1,option__vector___Grant______end_domain,"option[vector[_Grant]].domain_t");
    const char *_ObjectVersion___Key__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Key_",1,_ObjectVersion___Key__domain,"string");
    const char *option___AccessControlTranslation____end_domain[1] = {"option[_AccessControlTranslation]"};
    mk_decl("option[_AccessControlTranslation].end",1,option___AccessControlTranslation____end_domain,"option[_AccessControlTranslation].domain_t");
    const char *_CORSRule___AllowedHeaders__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._AllowedHeaders_",1,_CORSRule___AllowedHeaders__domain,"option[vector[string]]");
    const char *_InventoryS3BucketDestination___Bucket__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Bucket_",1,_InventoryS3BucketDestination___Bucket__domain,"string");
    const char *_NoncurrentVersionTransition___NoncurrentDays__domain[1] = {"_NoncurrentVersionTransition"};
    mk_decl("_NoncurrentVersionTransition._NoncurrentDays_",1,_NoncurrentVersionTransition___NoncurrentDays__domain,"integer");
    const char *_PutObjectRequest___ACL__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ACL_",1,_PutObjectRequest___ACL__domain,"option[string]");
    const char *_CreateBucketConfiguration___LocationConstraint__domain[1] = {"_CreateBucketConfiguration"};
    mk_decl("_CreateBucketConfiguration._LocationConstraint_",1,_CreateBucketConfiguration___LocationConstraint__domain,"string");
    const char *_MetricsConfiguration___Id__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Id_",1,_MetricsConfiguration___Id__domain,"string");
    const char *_InventoryConfiguration___Schedule__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Schedule_",1,_InventoryConfiguration___Schedule__domain,"_InventorySchedule");
    const char *_InventoryConfiguration___IncludedObjectVersions__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._IncludedObjectVersions_",1,_InventoryConfiguration___IncludedObjectVersions__domain,"string");
    const char *_Part___PartNumber__domain[1] = {"_Part"};
    mk_decl("_Part._PartNumber_",1,_Part___PartNumber__domain,"integer");
    const char *_DefaultRetention___Years__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Years_",1,_DefaultRetention___Years__domain,"integer");
    const char *_Error___VersionId__domain[1] = {"_Error"};
    mk_decl("_Error._VersionId_",1,_Error___VersionId__domain,"string");
    const char *_ReplicationRule___Prefix__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Prefix_",1,_ReplicationRule___Prefix__domain,"option[string]");
    const char *_CORSRule___MaxAgeSeconds__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._MaxAgeSeconds_",1,_CORSRule___MaxAgeSeconds__domain,"option[integer]");
    const char *_MetricsAndOperator___Prefix__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Prefix_",1,_MetricsAndOperator___Prefix__domain,"string");
    const char *_CSVOutput___QuoteFields__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteFields_",1,_CSVOutput___QuoteFields__domain,"string");
    const char *vector___ReplicationRule____end_domain[1] = {"vector[_ReplicationRule]"};
    mk_decl("vector[_ReplicationRule].end",1,vector___ReplicationRule____end_domain,"vector[_ReplicationRule].domain");
    const char *vector___DeleteMarkerEntry____value_domain[2] = {"vector[_DeleteMarkerEntry]","vector[_DeleteMarkerEntry].domain"};
    mk_decl("vector[_DeleteMarkerEntry].value",2,vector___DeleteMarkerEntry____value_domain,"_DeleteMarkerEntry");
    const char *_RestoreRequest___OutputLocation__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._OutputLocation_",1,_RestoreRequest___OutputLocation__domain,"_OutputLocation");
    const char *_Condition___HttpErrorCodeReturnedEquals__domain[1] = {"_Condition"};
    mk_decl("_Condition._HttpErrorCodeReturnedEquals_",1,_Condition___HttpErrorCodeReturnedEquals__domain,"string");
    const char *vector___InventoryConfiguration____end_domain[1] = {"vector[_InventoryConfiguration]"};
    mk_decl("vector[_InventoryConfiguration].end",1,vector___InventoryConfiguration____end_domain,"vector[_InventoryConfiguration].domain");
    const char *vector___CommonPrefix____value_domain[2] = {"vector[_CommonPrefix]","vector[_CommonPrefix].domain"};
    mk_decl("vector[_CommonPrefix].value",2,vector___CommonPrefix____value_domain,"_CommonPrefix");
    const char *_GetObjectOutput___LastModified__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._LastModified_",1,_GetObjectOutput___LastModified__domain,"timestamp");
    const char *_InputSerialization___JSON__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._JSON_",1,_InputSerialization___JSON__domain,"_JSONInput");
    const char *option__vector___MetadataEntry______end_domain[1] = {"option[vector[_MetadataEntry]]"};
    mk_decl("option[vector[_MetadataEntry]].end",1,option__vector___MetadataEntry______end_domain,"option[vector[_MetadataEntry]].domain_t");
    const char *_PutObjectRequest___ContentMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentMD5_",1,_PutObjectRequest___ContentMD5__domain,"option[string]");
    const char *_ObjectLockLegalHold___Status__domain[1] = {"_ObjectLockLegalHold"};
    mk_decl("_ObjectLockLegalHold._Status_",1,_ObjectLockLegalHold___Status__domain,"string");
    const char *option___LifecycleRuleFilter____end_domain[1] = {"option[_LifecycleRuleFilter]"};
    mk_decl("option[_LifecycleRuleFilter].end",1,option___LifecycleRuleFilter____end_domain,"option[_LifecycleRuleFilter].domain_t");
    const char *_StorageClassAnalysisDataExport___OutputSchemaVersion__domain[1] = {"_StorageClassAnalysisDataExport"};
    mk_decl("_StorageClassAnalysisDataExport._OutputSchemaVersion_",1,_StorageClassAnalysisDataExport___OutputSchemaVersion__domain,"string");
    const char *option___Condition____value_domain[2] = {"option[_Condition]","option[_Condition].domain_t"};
    mk_decl("option[_Condition].value",2,option___Condition____value_domain,"_Condition");
    const char *option___DeleteMarkerReplication____value_domain[2] = {"option[_DeleteMarkerReplication]","option[_DeleteMarkerReplication].domain_t"};
    mk_decl("option[_DeleteMarkerReplication].value",2,option___DeleteMarkerReplication____value_domain,"_DeleteMarkerReplication");
    const char *vector___FilterRule____end_domain[1] = {"vector[_FilterRule]"};
    mk_decl("vector[_FilterRule].end",1,vector___FilterRule____end_domain,"vector[_FilterRule].domain");
    const char *_SelectParameters___OutputSerialization__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._OutputSerialization_",1,_SelectParameters___OutputSerialization__domain,"_OutputSerialization");
    const char *_Grantee___DisplayName__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._DisplayName_",1,_Grantee___DisplayName__domain,"option[string]");
    const char *_GetObjectOutput___CacheControl__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._CacheControl_",1,_GetObjectOutput___CacheControl__domain,"string");
    const char *_S3Location___Tagging__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Tagging_",1,_S3Location___Tagging__domain,"option[_Tagging]");
    const char *option___ScanRange____end_domain[1] = {"option[_ScanRange]"};
    mk_decl("option[_ScanRange].end",1,option___ScanRange____end_domain,"option[_ScanRange].domain_t");
    const char *_LambdaFunctionConfiguration___Events__domain[1] = {"_LambdaFunctionConfiguration"};
    mk_decl("_LambdaFunctionConfiguration._Events_",1,_LambdaFunctionConfiguration___Events__domain,"vector[string]");
    const char *vector___LifecycleRule____end_domain[1] = {"vector[_LifecycleRule]"};
    mk_decl("vector[_LifecycleRule].end",1,vector___LifecycleRule____end_domain,"vector[_LifecycleRule].domain");
    const char *_SseKmsEncryptedObjects___Status__domain[1] = {"_SseKmsEncryptedObjects"};
    mk_decl("_SseKmsEncryptedObjects._Status_",1,_SseKmsEncryptedObjects___Status__domain,"string");
    const char *_InventoryFilter___Prefix__domain[1] = {"_InventoryFilter"};
    mk_decl("_InventoryFilter._Prefix_",1,_InventoryFilter___Prefix__domain,"string");
    const char *_ScanRange___Start__domain[1] = {"_ScanRange"};
    mk_decl("_ScanRange._Start_",1,_ScanRange___Start__domain,"long");
    const char *_PutObjectRequest___BucketKeyEnabled__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._BucketKeyEnabled_",1,_PutObjectRequest___BucketKeyEnabled__domain,"option[bool]");
    const char *_MetadataEntry___Name__domain[1] = {"_MetadataEntry"};
    mk_decl("_MetadataEntry._Name_",1,_MetadataEntry___Name__domain,"string");
    const char *option___NotificationConfigurationFilter____end_domain[1] = {"option[_NotificationConfigurationFilter]"};
    mk_decl("option[_NotificationConfigurationFilter].end",1,option___NotificationConfigurationFilter____end_domain,"option[_NotificationConfigurationFilter].domain_t");
    const char *vector___FilterRule____value_domain[2] = {"vector[_FilterRule]","vector[_FilterRule].domain"};
    mk_decl("vector[_FilterRule].value",2,vector___FilterRule____value_domain,"_FilterRule");
    const char *_CSVInput___QuoteEscapeCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteEscapeCharacter_",1,_CSVInput___QuoteEscapeCharacter__domain,"string");
    const char *_CSVOutput___FieldDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._FieldDelimiter_",1,_CSVOutput___FieldDelimiter__domain,"string");
    const char *vector___NoncurrentVersionTransition____end_domain[1] = {"vector[_NoncurrentVersionTransition]"};
    mk_decl("vector[_NoncurrentVersionTransition].end",1,vector___NoncurrentVersionTransition____end_domain,"vector[_NoncurrentVersionTransition].domain");
    const char *option___IntelligentTieringFilter____value_domain[2] = {"option[_IntelligentTieringFilter]","option[_IntelligentTieringFilter].domain_t"};
    mk_decl("option[_IntelligentTieringFilter].value",2,option___IntelligentTieringFilter____value_domain,"_IntelligentTieringFilter");
    const char *_GetObjectRequest___RequestPayer__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._RequestPayer_",1,_GetObjectRequest___RequestPayer__domain,"option[string]");
    const char *_SelectParameters___Expression__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._Expression_",1,_SelectParameters___Expression__domain,"string");
    const char *_Error___Code__domain[1] = {"_Error"};
    mk_decl("_Error._Code_",1,_Error___Code__domain,"string");
    const char *_Grantee___Type__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._Type_",1,_Grantee___Type__domain,"string");
    const char *_LifecycleExpiration___ExpiredObjectDeleteMarker__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._ExpiredObjectDeleteMarker_",1,_LifecycleExpiration___ExpiredObjectDeleteMarker__domain,"Bool");
    const char *_InputSerialization___CSV__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CSV_",1,_InputSerialization___CSV__domain,"_CSVInput");
    const char *option___NoncurrentVersionExpiration____end_domain[1] = {"option[_NoncurrentVersionExpiration]"};
    mk_decl("option[_NoncurrentVersionExpiration].end",1,option___NoncurrentVersionExpiration____end_domain,"option[_NoncurrentVersionExpiration].domain_t");
    const char *_Rule___Transition__domain[1] = {"_Rule"};
    mk_decl("_Rule._Transition_",1,_Rule___Transition__domain,"option[_Transition]");
    const char *_AccessControlPolicy___Owner__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Owner_",1,_AccessControlPolicy___Owner__domain,"_Owner");
    const char *vector___OwnershipControlsRule____end_domain[1] = {"vector[_OwnershipControlsRule]"};
    mk_decl("vector[_OwnershipControlsRule].end",1,vector___OwnershipControlsRule____end_domain,"vector[_OwnershipControlsRule].domain");
    const char *_PutObjectRequest___SSECustomerAlgorithm__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerAlgorithm_",1,_PutObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_Transition___StorageClass__domain[1] = {"_Transition"};
    mk_decl("_Transition._StorageClass_",1,_Transition___StorageClass__domain,"string");
    const char *_Initiator___ID__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._ID_",1,_Initiator___ID__domain,"string");
    const char *_MetricsFilter___And__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._And_",1,_MetricsFilter___And__domain,"_MetricsAndOperator");
    const char *_PutObjectOutput___SSEKMSKeyId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSKeyId_",1,_PutObjectOutput___SSEKMSKeyId__domain,"string");
    const char *contents_domain[2] = {"string","string"};
    mk_decl("contents",2,contents_domain,"blob");
    const char *_AnalyticsFilter___Prefix__domain[1] = {"_AnalyticsFilter"};
    mk_decl("_AnalyticsFilter._Prefix_",1,_AnalyticsFilter___Prefix__domain,"string");
    const char *_AnalyticsS3BucketDestination___Prefix__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Prefix_",1,_AnalyticsS3BucketDestination___Prefix__domain,"option[string]");
    const char *_GetObjectOutput___Expiration__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expiration_",1,_GetObjectOutput___Expiration__domain,"string");
    const char *_PutObjectOutput___Expiration__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._Expiration_",1,_PutObjectOutput___Expiration__domain,"string");
    const char *_Transition___Days__domain[1] = {"_Transition"};
    mk_decl("_Transition._Days_",1,_Transition___Days__domain,"integer");
    const char *_LifecycleRuleFilter___Prefix__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Prefix_",1,_LifecycleRuleFilter___Prefix__domain,"string");
    const char *_BucketLifecycleConfiguration___Rules__domain[1] = {"_BucketLifecycleConfiguration"};
    mk_decl("_BucketLifecycleConfiguration._Rules_",1,_BucketLifecycleConfiguration___Rules__domain,"vector[_LifecycleRule]");
    const char *_MultipartUpload___Initiated__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiated_",1,_MultipartUpload___Initiated__domain,"timestamp");
    const char *_Metrics___EventThreshold__domain[1] = {"_Metrics"};
    mk_decl("_Metrics._EventThreshold_",1,_Metrics___EventThreshold__domain,"option[_ReplicationTimeValue]");
    const char *_ObjectVersion___Owner__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._Owner_",1,_ObjectVersion___Owner__domain,"_Owner");
    const char *_Rule___ID__domain[1] = {"_Rule"};
    mk_decl("_Rule._ID_",1,_Rule___ID__domain,"option[string]");
    const char *_PutObjectRequest___ServerSideEncryption__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ServerSideEncryption_",1,_PutObjectRequest___ServerSideEncryption__domain,"option[string]");
    const char *_PutObjectOutput___BucketKeyEnabled__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._BucketKeyEnabled_",1,_PutObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *_Object___Key__domain[1] = {"_Object"};
    mk_decl("_Object._Key_",1,_Object___Key__domain,"string");
    const char *option___ObjectLockRetention____end_domain[1] = {"option[_ObjectLockRetention]"};
    mk_decl("option[_ObjectLockRetention].end",1,option___ObjectLockRetention____end_domain,"option[_ObjectLockRetention].domain_t");
    const char *_CSVOutput___RecordDelimiter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._RecordDelimiter_",1,_CSVOutput___RecordDelimiter__domain,"string");
    const char *_Rule___AbortIncompleteMultipartUpload__domain[1] = {"_Rule"};
    mk_decl("_Rule._AbortIncompleteMultipartUpload_",1,_Rule___AbortIncompleteMultipartUpload__domain,"option[_AbortIncompleteMultipartUpload]");
    const char *vector___MultipartUpload____value_domain[2] = {"vector[_MultipartUpload]","vector[_MultipartUpload].domain"};
    mk_decl("vector[_MultipartUpload].value",2,vector___MultipartUpload____value_domain,"_MultipartUpload");
    const char *vector___CORSRule____value_domain[2] = {"vector[_CORSRule]","vector[_CORSRule].domain"};
    mk_decl("vector[_CORSRule].value",2,vector___CORSRule____value_domain,"_CORSRule");
    const char *option___AccessControlTranslation____value_domain[2] = {"option[_AccessControlTranslation]","option[_AccessControlTranslation].domain_t"};
    mk_decl("option[_AccessControlTranslation].value",2,option___AccessControlTranslation____value_domain,"_AccessControlTranslation");
    const char *_GetObjectRequest___SSECustomerAlgorithm__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._SSECustomerAlgorithm_",1,_GetObjectRequest___SSECustomerAlgorithm__domain,"option[string]");
    const char *_LifecycleRule___Filter__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Filter_",1,_LifecycleRule___Filter__domain,"option[_LifecycleRuleFilter]");
    const char *option__vector___MetadataEntry______value_domain[2] = {"option[vector[_MetadataEntry]]","option[vector[_MetadataEntry]].domain_t"};
    mk_decl("option[vector[_MetadataEntry]].value",2,option__vector___MetadataEntry______value_domain,"vector[_MetadataEntry]");
    const char *_GetObjectOutput___Metadata__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Metadata_",1,_GetObjectOutput___Metadata__domain,"unordered_map[string][string]");
    const char *_GetObjectRequest___ResponseContentDisposition__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentDisposition_",1,_GetObjectRequest___ResponseContentDisposition__domain,"option[string]");
    const char *_ReplicationRule___SourceSelectionCriteria__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._SourceSelectionCriteria_",1,_ReplicationRule___SourceSelectionCriteria__domain,"option[_SourceSelectionCriteria]");
    const char *_PutObjectOutput___SSEKMSEncryptionContext__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSEKMSEncryptionContext_",1,_PutObjectOutput___SSEKMSEncryptionContext__domain,"string");
    const char *_GetObjectRequest___ResponseCacheControl__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseCacheControl_",1,_GetObjectRequest___ResponseCacheControl__domain,"option[string]");
    const char *vector___CompletedPart____end_domain[1] = {"vector[_CompletedPart]"};
    mk_decl("vector[_CompletedPart].end",1,vector___CompletedPart____end_domain,"vector[_CompletedPart].domain");
    const char *option___ReplicationTime____end_domain[1] = {"option[_ReplicationTime]"};
    mk_decl("option[_ReplicationTime].end",1,option___ReplicationTime____end_domain,"option[_ReplicationTime].domain_t");
    const char *_DeletedObject___DeleteMarkerVersionId__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarkerVersionId_",1,_DeletedObject___DeleteMarkerVersionId__domain,"string");
    const char *_Grantee___ID__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._ID_",1,_Grantee___ID__domain,"option[string]");
    const char *option___Condition____end_domain[1] = {"option[_Condition]"};
    mk_decl("option[_Condition].end",1,option___Condition____end_domain,"option[_Condition].domain_t");
    const char *_ObjectLockConfiguration___Rule__domain[1] = {"_ObjectLockConfiguration"};
    mk_decl("_ObjectLockConfiguration._Rule_",1,_ObjectLockConfiguration___Rule__domain,"_ObjectLockRule");
    const char *vector___MetricsConfiguration____value_domain[2] = {"vector[_MetricsConfiguration]","vector[_MetricsConfiguration].domain"};
    mk_decl("vector[_MetricsConfiguration].value",2,vector___MetricsConfiguration____value_domain,"_MetricsConfiguration");
    const char *_AnalyticsS3BucketDestination___Format__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._Format_",1,_AnalyticsS3BucketDestination___Format__domain,"string");
    const char *_AnalyticsAndOperator___Tags__domain[1] = {"_AnalyticsAndOperator"};
    mk_decl("_AnalyticsAndOperator._Tags_",1,_AnalyticsAndOperator___Tags__domain,"vector[_Tag]");
    const char *vector___DeletedObject____end_domain[1] = {"vector[_DeletedObject]"};
    mk_decl("vector[_DeletedObject].end",1,vector___DeletedObject____end_domain,"vector[_DeletedObject].domain");
    const char *option___CreateBucketConfiguration____end_domain[1] = {"option[_CreateBucketConfiguration]"};
    mk_decl("option[_CreateBucketConfiguration].end",1,option___CreateBucketConfiguration____end_domain,"option[_CreateBucketConfiguration].domain_t");
    const char *_GetObjectRequest___ResponseContentLanguage__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseContentLanguage_",1,_GetObjectRequest___ResponseContentLanguage__domain,"option[string]");
    const char *_MultipartUpload___UploadId__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._UploadId_",1,_MultipartUpload___UploadId__domain,"string");
    const char *_ReplicationRule___Status__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Status_",1,_ReplicationRule___Status__domain,"string");
    const char *_MultipartUpload___Initiator__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Initiator_",1,_MultipartUpload___Initiator__domain,"_Initiator");
    const char *_PutObjectOutput___SSECustomerAlgorithm__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerAlgorithm_",1,_PutObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *option__long____end_domain[1] = {"option[long]"};
    mk_decl("option[long].end",1,option__long____end_domain,"option[long].domain_t");
    const char *option___BucketLifecycleConfiguration____value_domain[2] = {"option[_BucketLifecycleConfiguration]","option[_BucketLifecycleConfiguration].domain_t"};
    mk_decl("option[_BucketLifecycleConfiguration].value",2,option___BucketLifecycleConfiguration____value_domain,"_BucketLifecycleConfiguration");
    const char *_InventorySchedule___Frequency__domain[1] = {"_InventorySchedule"};
    mk_decl("_InventorySchedule._Frequency_",1,_InventorySchedule___Frequency__domain,"string");
    const char *_Owner___DisplayName__domain[1] = {"_Owner"};
    mk_decl("_Owner._DisplayName_",1,_Owner___DisplayName__domain,"string");
    const char *_DeleteMarkerEntry___Key__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Key_",1,_DeleteMarkerEntry___Key__domain,"string");
    const char *_Tiering___Days__domain[1] = {"_Tiering"};
    mk_decl("_Tiering._Days_",1,_Tiering___Days__domain,"integer");
    const char *option___NoncurrentVersionTransition____value_domain[2] = {"option[_NoncurrentVersionTransition]","option[_NoncurrentVersionTransition].domain_t"};
    mk_decl("option[_NoncurrentVersionTransition].value",2,option___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *_GetObjectOutput___ServerSideEncryption__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ServerSideEncryption_",1,_GetObjectOutput___ServerSideEncryption__domain,"string");
    const char *_PutObjectRequest___Expires__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Expires_",1,_PutObjectRequest___Expires__domain,"option[timestamp]");
    const char *option___BucketLifecycleConfiguration____end_domain[1] = {"option[_BucketLifecycleConfiguration]"};
    mk_decl("option[_BucketLifecycleConfiguration].end",1,option___BucketLifecycleConfiguration____end_domain,"option[_BucketLifecycleConfiguration].domain_t");
    const char *option___ReplicationTime____value_domain[2] = {"option[_ReplicationTime]","option[_ReplicationTime].domain_t"};
    mk_decl("option[_ReplicationTime].value",2,option___ReplicationTime____value_domain,"_ReplicationTime");
    const char *_InputSerialization___CompressionType__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._CompressionType_",1,_InputSerialization___CompressionType__domain,"string");
    const char *_DeleteMarkerEntry___LastModified__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._LastModified_",1,_DeleteMarkerEntry___LastModified__domain,"timestamp");
    const char *_GetObjectRequest___IfMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfMatch_",1,_GetObjectRequest___IfMatch__domain,"option[string]");
    const char *_LifecycleRule___Expiration__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Expiration_",1,_LifecycleRule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *_ReplicationRule___Destination__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Destination_",1,_ReplicationRule___Destination__domain,"_Destination");
    const char *vector___DeleteMarkerEntry____end_domain[1] = {"vector[_DeleteMarkerEntry]"};
    mk_decl("vector[_DeleteMarkerEntry].end",1,vector___DeleteMarkerEntry____end_domain,"vector[_DeleteMarkerEntry].domain");
    const char *_InputSerialization___Parquet__domain[1] = {"_InputSerialization"};
    mk_decl("_InputSerialization._Parquet_",1,_InputSerialization___Parquet__domain,"_ParquetInput");
    const char *_ObjectLockRule___DefaultRetention__domain[1] = {"_ObjectLockRule"};
    mk_decl("_ObjectLockRule._DefaultRetention_",1,_ObjectLockRule___DefaultRetention__domain,"_DefaultRetention");
    const char *option__timestamp____end_domain[1] = {"option[timestamp]"};
    mk_decl("option[timestamp].end",1,option__timestamp____end_domain,"option[timestamp].domain_t");
    const char *_GetObjectOutput___SSECustomerAlgorithm__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._SSECustomerAlgorithm_",1,_GetObjectOutput___SSECustomerAlgorithm__domain,"string");
    const char *_QueueConfiguration___Id__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Id_",1,_QueueConfiguration___Id__domain,"option[string]");
    const char *_Object___Size__domain[1] = {"_Object"};
    mk_decl("_Object._Size_",1,_Object___Size__domain,"integer");
    const char *option__integer____value_domain[2] = {"option[integer]","option[integer].domain_t"};
    mk_decl("option[integer].value",2,option__integer____value_domain,"integer");
    const char *blob__value_domain[2] = {"blob","blob.domain"};
    mk_decl("blob.value",2,blob__value_domain,"byte");
    const char *_DeleteMarkerEntry___VersionId__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._VersionId_",1,_DeleteMarkerEntry___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentLength__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentLength_",1,_GetObjectOutput___ContentLength__domain,"long");
    const char *option__integer____end_domain[1] = {"option[integer]"};
    mk_decl("option[integer].end",1,option__integer____end_domain,"option[integer].domain_t");
    const char *_LifecycleRuleAndOperator___Tags__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Tags_",1,_LifecycleRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_GetObjectRequest___IfNoneMatch__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfNoneMatch_",1,_GetObjectRequest___IfNoneMatch__domain,"option[string]");
    const char *_S3KeyFilter___FilterRules__domain[1] = {"_S3KeyFilter"};
    mk_decl("_S3KeyFilter._FilterRules_",1,_S3KeyFilter___FilterRules__domain,"vector[_FilterRule]");
    const char *option___ObjectLockLegalHold____value_domain[2] = {"option[_ObjectLockLegalHold]","option[_ObjectLockLegalHold].domain_t"};
    mk_decl("option[_ObjectLockLegalHold].value",2,option___ObjectLockLegalHold____value_domain,"_ObjectLockLegalHold");
    const char *option___EncryptionConfiguration____end_domain[1] = {"option[_EncryptionConfiguration]"};
    mk_decl("option[_EncryptionConfiguration].end",1,option___EncryptionConfiguration____end_domain,"option[_EncryptionConfiguration].domain_t");
    const char *_LifecycleExpiration___Date__domain[1] = {"_LifecycleExpiration"};
    mk_decl("_LifecycleExpiration._Date_",1,_LifecycleExpiration___Date__domain,"timestamp");
    const char *_PutObjectRequest___RequestPayer__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._RequestPayer_",1,_PutObjectRequest___RequestPayer__domain,"option[string]");
    const char *_PutObjectRequest___ContentLength__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLength_",1,_PutObjectRequest___ContentLength__domain,"option[long]");
    const char *_PutObjectRequest___ObjectLockLegalHoldStatus__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockLegalHoldStatus_",1,_PutObjectRequest___ObjectLockLegalHoldStatus__domain,"option[string]");
    const char *_CSVInput___RecordDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._RecordDelimiter_",1,_CSVInput___RecordDelimiter__domain,"string");
    const char *vector___Tag____end_domain[1] = {"vector[_Tag]"};
    mk_decl("vector[_Tag].end",1,vector___Tag____end_domain,"vector[_Tag].domain");
    const char *vector___Rule____value_domain[2] = {"vector[_Rule]","vector[_Rule].domain"};
    mk_decl("vector[_Rule].value",2,vector___Rule____value_domain,"_Rule");
    const char *_InventoryEncryption___SSEKMS__domain[1] = {"_InventoryEncryption"};
    mk_decl("_InventoryEncryption._SSEKMS_",1,_InventoryEncryption___SSEKMS__domain,"_SSEKMS");
    const char *_Destination___Metrics__domain[1] = {"_Destination"};
    mk_decl("_Destination._Metrics_",1,_Destination___Metrics__domain,"option[_Metrics]");
    const char *_GetObjectOutput___RequestCharged__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._RequestCharged_",1,_GetObjectOutput___RequestCharged__domain,"string");
    const char *vector___Error____value_domain[2] = {"vector[_Error]","vector[_Error].domain"};
    mk_decl("vector[_Error].value",2,vector___Error____value_domain,"_Error");
    const char *blob__end_domain[1] = {"blob"};
    mk_decl("blob.end",1,blob__end_domain,"blob.domain");
    const char *_NotificationConfigurationFilter___Key__domain[1] = {"_NotificationConfigurationFilter"};
    mk_decl("_NotificationConfigurationFilter._Key_",1,_NotificationConfigurationFilter___Key__domain,"_S3KeyFilter");
    const char *option__vector___NoncurrentVersionTransition______value_domain[2] = {"option[vector[_NoncurrentVersionTransition]]","option[vector[_NoncurrentVersionTransition]].domain_t"};
    mk_decl("option[vector[_NoncurrentVersionTransition]].value",2,option__vector___NoncurrentVersionTransition______value_domain,"vector[_NoncurrentVersionTransition]");
    const char *option___Metrics____end_domain[1] = {"option[_Metrics]"};
    mk_decl("option[_Metrics].end",1,option___Metrics____end_domain,"option[_Metrics].domain_t");
    const char *vector___LambdaFunctionConfiguration____value_domain[2] = {"vector[_LambdaFunctionConfiguration]","vector[_LambdaFunctionConfiguration].domain"};
    mk_decl("vector[_LambdaFunctionConfiguration].value",2,vector___LambdaFunctionConfiguration____value_domain,"_LambdaFunctionConfiguration");
    const char *_Error___Message__domain[1] = {"_Error"};
    mk_decl("_Error._Message_",1,_Error___Message__domain,"string");
    const char *option___Transition____end_domain[1] = {"option[_Transition]"};
    mk_decl("option[_Transition].end",1,option___Transition____end_domain,"option[_Transition].domain_t");
    const char *vector___RoutingRule____end_domain[1] = {"vector[_RoutingRule]"};
    mk_decl("vector[_RoutingRule].end",1,vector___RoutingRule____end_domain,"vector[_RoutingRule].domain");
    const char *_ReplicationRule___DeleteMarkerReplication__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._DeleteMarkerReplication_",1,_ReplicationRule___DeleteMarkerReplication__domain,"option[_DeleteMarkerReplication]");
    const char *_DeletedObject___DeleteMarker__domain[1] = {"_DeletedObject"};
    mk_decl("_DeletedObject._DeleteMarker_",1,_DeletedObject___DeleteMarker__domain,"Bool");
    const char *_PutObjectRequest___GrantRead__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantRead_",1,_PutObjectRequest___GrantRead__domain,"option[string]");
    const char *_AnalyticsConfiguration___Filter__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._Filter_",1,_AnalyticsConfiguration___Filter__domain,"option[_AnalyticsFilter]");
    const char *vector___MetricsConfiguration____end_domain[1] = {"vector[_MetricsConfiguration]"};
    mk_decl("vector[_MetricsConfiguration].end",1,vector___MetricsConfiguration____end_domain,"vector[_MetricsConfiguration].domain");
    const char *_GetObjectOutput___DeleteMarker__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._DeleteMarker_",1,_GetObjectOutput___DeleteMarker__domain,"Bool");
    const char *_S3Location___AccessControlList__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._AccessControlList_",1,_S3Location___AccessControlList__domain,"option[vector[_Grant]]");
    const char *option__timestamp____value_domain[2] = {"option[timestamp]","option[timestamp].domain_t"};
    mk_decl("option[timestamp].value",2,option__timestamp____value_domain,"timestamp");
    const char *present_domain[2] = {"string","string"};
    mk_decl("present",2,present_domain,"Bool");
    const char *_CompletedPart___ETag__domain[1] = {"_CompletedPart"};
    mk_decl("_CompletedPart._ETag_",1,_CompletedPart___ETag__domain,"string");
    const char *_InventoryConfiguration___Id__domain[1] = {"_InventoryConfiguration"};
    mk_decl("_InventoryConfiguration._Id_",1,_InventoryConfiguration___Id__domain,"string");
    const char *_Rule___Status__domain[1] = {"_Rule"};
    mk_decl("_Rule._Status_",1,_Rule___Status__domain,"string");
    const char *_PutObjectRequest___StorageClass__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._StorageClass_",1,_PutObjectRequest___StorageClass__domain,"option[string]");
    const char *unordered_map__string____string____maps_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].maps",2,unordered_map__string____string____maps_domain,"string");
    const char *_GetObjectOutput___TagCount__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._TagCount_",1,_GetObjectOutput___TagCount__domain,"integer");
    const char *vector___InventoryConfiguration____value_domain[2] = {"vector[_InventoryConfiguration]","vector[_InventoryConfiguration].domain"};
    mk_decl("vector[_InventoryConfiguration].value",2,vector___InventoryConfiguration____value_domain,"_InventoryConfiguration");
    const char *option___ObjectLockConfiguration____end_domain[1] = {"option[_ObjectLockConfiguration]"};
    mk_decl("option[_ObjectLockConfiguration].end",1,option___ObjectLockConfiguration____end_domain,"option[_ObjectLockConfiguration].domain_t");
    const char *_ExistingObjectReplication___Status__domain[1] = {"_ExistingObjectReplication"};
    mk_decl("_ExistingObjectReplication._Status_",1,_ExistingObjectReplication___Status__domain,"string");
    const char *_PutObjectRequest___SSEKMSEncryptionContext__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSEKMSEncryptionContext_",1,_PutObjectRequest___SSEKMSEncryptionContext__domain,"option[string]");
    const char *_SelectParameters___ExpressionType__domain[1] = {"_SelectParameters"};
    mk_decl("_SelectParameters._ExpressionType_",1,_SelectParameters___ExpressionType__domain,"string");
    const char *_LifecycleConfiguration___Rules__domain[1] = {"_LifecycleConfiguration"};
    mk_decl("_LifecycleConfiguration._Rules_",1,_LifecycleConfiguration___Rules__domain,"vector[_Rule]");
    const char *_GetObjectOutput___ContentDisposition__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentDisposition_",1,_GetObjectOutput___ContentDisposition__domain,"string");
    const char *_LifecycleRuleFilter___Tag__domain[1] = {"_LifecycleRuleFilter"};
    mk_decl("_LifecycleRuleFilter._Tag_",1,_LifecycleRuleFilter___Tag__domain,"_Tag");
    const char *_GetObjectOutput___BucketKeyEnabled__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._BucketKeyEnabled_",1,_GetObjectOutput___BucketKeyEnabled__domain,"Bool");
    const char *option___AbortIncompleteMultipartUpload____end_domain[1] = {"option[_AbortIncompleteMultipartUpload]"};
    mk_decl("option[_AbortIncompleteMultipartUpload].end",1,option___AbortIncompleteMultipartUpload____end_domain,"option[_AbortIncompleteMultipartUpload].domain_t");
    const char *_PutObjectRequest___GrantWriteACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantWriteACP_",1,_PutObjectRequest___GrantWriteACP__domain,"option[string]");
    const char *option___ReplicationTimeValue____end_domain[1] = {"option[_ReplicationTimeValue]"};
    mk_decl("option[_ReplicationTimeValue].end",1,option___ReplicationTimeValue____end_domain,"option[_ReplicationTimeValue].domain_t");
    const char *_RestoreRequest___SelectParameters__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._SelectParameters_",1,_RestoreRequest___SelectParameters__domain,"_SelectParameters");
    const char *option___LifecycleExpiration____end_domain[1] = {"option[_LifecycleExpiration]"};
    mk_decl("option[_LifecycleExpiration].end",1,option___LifecycleExpiration____end_domain,"option[_LifecycleExpiration].domain_t");
    const char *_Destination___Account__domain[1] = {"_Destination"};
    mk_decl("_Destination._Account_",1,_Destination___Account__domain,"option[string]");
    const char *vector___MultipartUpload____end_domain[1] = {"vector[_MultipartUpload]"};
    mk_decl("vector[_MultipartUpload].end",1,vector___MultipartUpload____end_domain,"vector[_MultipartUpload].domain");
    const char *_ObjectIdentifier___VersionId__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._VersionId_",1,_ObjectIdentifier___VersionId__domain,"option[string]");
    const char *_JSONOutput___RecordDelimiter__domain[1] = {"_JSONOutput"};
    mk_decl("_JSONOutput._RecordDelimiter_",1,_JSONOutput___RecordDelimiter__domain,"string");
    const char *_Destination___Bucket__domain[1] = {"_Destination"};
    mk_decl("_Destination._Bucket_",1,_Destination___Bucket__domain,"string");
    const char *option__vector___TargetGrant______end_domain[1] = {"option[vector[_TargetGrant]]"};
    mk_decl("option[vector[_TargetGrant]].end",1,option__vector___TargetGrant______end_domain,"option[vector[_TargetGrant]].domain_t");
    const char *_PutObjectRequest___Key__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Key_",1,_PutObjectRequest___Key__domain,"string");
    const char *_CORSRule___ID__domain[1] = {"_CORSRule"};
    mk_decl("_CORSRule._ID_",1,_CORSRule___ID__domain,"option[string]");
    const char *option___DeleteMarkerReplication____end_domain[1] = {"option[_DeleteMarkerReplication]"};
    mk_decl("option[_DeleteMarkerReplication].end",1,option___DeleteMarkerReplication____end_domain,"option[_DeleteMarkerReplication].domain_t");
    const char *_GetObjectOutput___ContentType__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentType_",1,_GetObjectOutput___ContentType__domain,"string");
    const char *_Rule___NoncurrentVersionTransition__domain[1] = {"_Rule"};
    mk_decl("_Rule._NoncurrentVersionTransition_",1,_Rule___NoncurrentVersionTransition__domain,"option[_NoncurrentVersionTransition]");
    const char *_ObjectLockRetention___Mode__domain[1] = {"_ObjectLockRetention"};
    mk_decl("_ObjectLockRetention._Mode_",1,_ObjectLockRetention___Mode__domain,"string");
    const char *_Destination___AccessControlTranslation__domain[1] = {"_Destination"};
    mk_decl("_Destination._AccessControlTranslation_",1,_Destination___AccessControlTranslation__domain,"option[_AccessControlTranslation]");
    const char *_CSVInput___QuoteCharacter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._QuoteCharacter_",1,_CSVInput___QuoteCharacter__domain,"string");
    const char *vector___Transition____end_domain[1] = {"vector[_Transition]"};
    mk_decl("vector[_Transition].end",1,vector___Transition____end_domain,"vector[_Transition].domain");
    const char *vector___CompletedPart____value_domain[2] = {"vector[_CompletedPart]","vector[_CompletedPart].domain"};
    mk_decl("vector[_CompletedPart].value",2,vector___CompletedPart____value_domain,"_CompletedPart");
    const char *_CSVInput___FieldDelimiter__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._FieldDelimiter_",1,_CSVInput___FieldDelimiter__domain,"string");
    const char *_GetObjectOutput___MissingMeta__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._MissingMeta_",1,_GetObjectOutput___MissingMeta__domain,"integer");
    const char *vector___Error____end_domain[1] = {"vector[_Error]"};
    mk_decl("vector[_Error].end",1,vector___Error____end_domain,"vector[_Error].domain");
    mk_const("_generating","Bool");
    const char *_Initiator___DisplayName__domain[1] = {"_Initiator"};
    mk_decl("_Initiator._DisplayName_",1,_Initiator___DisplayName__domain,"string");
    const char *_TopicConfiguration___Id__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Id_",1,_TopicConfiguration___Id__domain,"option[string]");
    const char *_PutObjectRequest___ContentLanguage__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ContentLanguage_",1,_PutObjectRequest___ContentLanguage__domain,"option[string]");
    const char *option__bool____end_domain[1] = {"option[bool]"};
    mk_decl("option[bool].end",1,option__bool____end_domain,"option[bool].domain_t");
    const char *_ServerSideEncryptionByDefault___KMSMasterKeyID__domain[1] = {"_ServerSideEncryptionByDefault"};
    mk_decl("_ServerSideEncryptionByDefault._KMSMasterKeyID_",1,_ServerSideEncryptionByDefault___KMSMasterKeyID__domain,"option[string]");
    const char *option___ScanRange____value_domain[2] = {"option[_ScanRange]","option[_ScanRange].domain_t"};
    mk_decl("option[_ScanRange].value",2,option___ScanRange____value_domain,"_ScanRange");
    const char *option___ExistingObjectReplication____value_domain[2] = {"option[_ExistingObjectReplication]","option[_ExistingObjectReplication].domain_t"};
    mk_decl("option[_ExistingObjectReplication].value",2,option___ExistingObjectReplication____value_domain,"_ExistingObjectReplication");
    const char *_GetObjectRequest___ResponseExpires__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._ResponseExpires_",1,_GetObjectRequest___ResponseExpires__domain,"option[timestamp]");
    const char *vector___ObjectIdentifier____end_domain[1] = {"vector[_ObjectIdentifier]"};
    mk_decl("vector[_ObjectIdentifier].end",1,vector___ObjectIdentifier____end_domain,"vector[_ObjectIdentifier].domain");
    const char *_RestoreRequest___Type__domain[1] = {"_RestoreRequest"};
    mk_decl("_RestoreRequest._Type_",1,_RestoreRequest___Type__domain,"string");
    const char *_DeleteMarkerReplication___Status__domain[1] = {"_DeleteMarkerReplication"};
    mk_decl("_DeleteMarkerReplication._Status_",1,_DeleteMarkerReplication___Status__domain,"string");
    const char *option___ReplicationRuleFilter____end_domain[1] = {"option[_ReplicationRuleFilter]"};
    mk_decl("option[_ReplicationRuleFilter].end",1,option___ReplicationRuleFilter____end_domain,"option[_ReplicationRuleFilter].domain_t");
    const char *_RoutingRule___Condition__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Condition_",1,_RoutingRule___Condition__domain,"option[_Condition]");
    const char *_MetricsAndOperator___Tags__domain[1] = {"_MetricsAndOperator"};
    mk_decl("_MetricsAndOperator._Tags_",1,_MetricsAndOperator___Tags__domain,"vector[_Tag]");
    const char *option___RequestProgress____end_domain[1] = {"option[_RequestProgress]"};
    mk_decl("option[_RequestProgress].end",1,option___RequestProgress____end_domain,"option[_RequestProgress].domain_t");
    const char *_CSVInput___Comments__domain[1] = {"_CSVInput"};
    mk_decl("_CSVInput._Comments_",1,_CSVInput___Comments__domain,"string");
    const char *_Part___Size__domain[1] = {"_Part"};
    mk_decl("_Part._Size_",1,_Part___Size__domain,"integer");
    const char *vector___ServerSideEncryptionRule____end_domain[1] = {"vector[_ServerSideEncryptionRule]"};
    mk_decl("vector[_ServerSideEncryptionRule].end",1,vector___ServerSideEncryptionRule____end_domain,"vector[_ServerSideEncryptionRule].domain");
    const char *vector___QueueConfiguration____end_domain[1] = {"vector[_QueueConfiguration]"};
    mk_decl("vector[_QueueConfiguration].end",1,vector___QueueConfiguration____end_domain,"vector[_QueueConfiguration].domain");
    const char *_PutObjectOutput___SSECustomerKeyMD5__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._SSECustomerKeyMD5_",1,_PutObjectOutput___SSECustomerKeyMD5__domain,"string");
    const char *_OwnershipControlsRule___ObjectOwnership__domain[1] = {"_OwnershipControlsRule"};
    mk_decl("_OwnershipControlsRule._ObjectOwnership_",1,_OwnershipControlsRule___ObjectOwnership__domain,"string");
    const char *option___MetricsFilter____end_domain[1] = {"option[_MetricsFilter]"};
    mk_decl("option[_MetricsFilter].end",1,option___MetricsFilter____end_domain,"option[_MetricsFilter].domain_t");
    const char *_QueueConfiguration___Events__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Events_",1,_QueueConfiguration___Events__domain,"vector[string]");
    const char *_IntelligentTieringConfiguration___Tierings__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Tierings_",1,_IntelligentTieringConfiguration___Tierings__domain,"vector[_Tiering]");
    const char *option__bool____value_domain[2] = {"option[bool]","option[bool].domain_t"};
    mk_decl("option[bool].value",2,option__bool____value_domain,"Bool");
    const char *option___InventoryFilter____end_domain[1] = {"option[_InventoryFilter]"};
    mk_decl("option[_InventoryFilter].end",1,option___InventoryFilter____end_domain,"option[_InventoryFilter].domain_t");
    const char *_Grantee___URI__domain[1] = {"_Grantee"};
    mk_decl("_Grantee._URI_",1,_Grantee___URI__domain,"option[string]");
    const char *_Encryption___KMSContext__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._KMSContext_",1,_Encryption___KMSContext__domain,"option[string]");
    const char *vector___LambdaFunctionConfiguration____end_domain[1] = {"vector[_LambdaFunctionConfiguration]"};
    mk_decl("vector[_LambdaFunctionConfiguration].end",1,vector___LambdaFunctionConfiguration____end_domain,"vector[_LambdaFunctionConfiguration].domain");
    const char *_ReplicationTimeValue___Minutes__domain[1] = {"_ReplicationTimeValue"};
    mk_decl("_ReplicationTimeValue._Minutes_",1,_ReplicationTimeValue___Minutes__domain,"integer");
    const char *vector___AnalyticsConfiguration____end_domain[1] = {"vector[_AnalyticsConfiguration]"};
    mk_decl("vector[_AnalyticsConfiguration].end",1,vector___AnalyticsConfiguration____end_domain,"vector[_AnalyticsConfiguration].domain");
    const char *option__vector___TargetGrant______value_domain[2] = {"option[vector[_TargetGrant]]","option[vector[_TargetGrant]].domain_t"};
    mk_decl("option[vector[_TargetGrant]].value",2,option__vector___TargetGrant______value_domain,"vector[_TargetGrant]");
    const char *_PutObjectRequest___SSECustomerKey__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKey_",1,_PutObjectRequest___SSECustomerKey__domain,"option[string]");
    const char *_GetObjectRequest___IfUnmodifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfUnmodifiedSince_",1,_GetObjectRequest___IfUnmodifiedSince__domain,"option[timestamp]");
    const char *_S3Location___Prefix__domain[1] = {"_S3Location"};
    mk_decl("_S3Location._Prefix_",1,_S3Location___Prefix__domain,"string");
    const char *option___RestoreRequest____value_domain[2] = {"option[_RestoreRequest]","option[_RestoreRequest].domain_t"};
    mk_decl("option[_RestoreRequest].value",2,option___RestoreRequest____value_domain,"_RestoreRequest");
    const char *_EncryptionConfiguration___ReplicaKmsKeyID__domain[1] = {"_EncryptionConfiguration"};
    mk_decl("_EncryptionConfiguration._ReplicaKmsKeyID_",1,_EncryptionConfiguration___ReplicaKmsKeyID__domain,"string");
    const char *_Tag___Value__domain[1] = {"_Tag"};
    mk_decl("_Tag._Value_",1,_Tag___Value__domain,"string");
    const char *vector___TopicConfiguration____value_domain[2] = {"vector[_TopicConfiguration]","vector[_TopicConfiguration].domain"};
    mk_decl("vector[_TopicConfiguration].value",2,vector___TopicConfiguration____value_domain,"_TopicConfiguration");
    const char *_PutObjectRequest___Metadata__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Metadata_",1,_PutObjectRequest___Metadata__domain,"option[unordered_map[string][string]]");
    const char *vector___NoncurrentVersionTransition____value_domain[2] = {"vector[_NoncurrentVersionTransition]","vector[_NoncurrentVersionTransition].domain"};
    mk_decl("vector[_NoncurrentVersionTransition].value",2,vector___NoncurrentVersionTransition____value_domain,"_NoncurrentVersionTransition");
    const char *vector___Part____value_domain[2] = {"vector[_Part]","vector[_Part].domain"};
    mk_decl("vector[_Part].value",2,vector___Part____value_domain,"_Part");
    const char *vector___IntelligentTieringConfiguration____value_domain[2] = {"vector[_IntelligentTieringConfiguration]","vector[_IntelligentTieringConfiguration].domain"};
    mk_decl("vector[_IntelligentTieringConfiguration].value",2,vector___IntelligentTieringConfiguration____value_domain,"_IntelligentTieringConfiguration");
    const char *_FilterRule___Value__domain[1] = {"_FilterRule"};
    mk_decl("_FilterRule._Value_",1,_FilterRule___Value__domain,"string");
    const char *_LifecycleRule___NoncurrentVersionTransitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._NoncurrentVersionTransitions_",1,_LifecycleRule___NoncurrentVersionTransitions__domain,"option[vector[_NoncurrentVersionTransition]]");
    const char *option__vector__string______value_domain[2] = {"option[vector[string]]","option[vector[string]].domain_t"};
    mk_decl("option[vector[string]].value",2,option__vector__string______value_domain,"vector[string]");
    const char *_ObjectIdentifier___Key__domain[1] = {"_ObjectIdentifier"};
    mk_decl("_ObjectIdentifier._Key_",1,_ObjectIdentifier___Key__domain,"string");
    const char *_InventoryS3BucketDestination___Format__domain[1] = {"_InventoryS3BucketDestination"};
    mk_decl("_InventoryS3BucketDestination._Format_",1,_InventoryS3BucketDestination___Format__domain,"string");
    const char *_OutputSerialization___JSON__domain[1] = {"_OutputSerialization"};
    mk_decl("_OutputSerialization._JSON_",1,_OutputSerialization___JSON__domain,"_JSONOutput");
    const char *vector___Object____end_domain[1] = {"vector[_Object]"};
    mk_decl("vector[_Object].end",1,vector___Object____end_domain,"vector[_Object].domain");
    const char *_MetricsFilter___Tag__domain[1] = {"_MetricsFilter"};
    mk_decl("_MetricsFilter._Tag_",1,_MetricsFilter___Tag__domain,"_Tag");
    const char *_ReplicaModifications___Status__domain[1] = {"_ReplicaModifications"};
    mk_decl("_ReplicaModifications._Status_",1,_ReplicaModifications___Status__domain,"string");
    const char *_AccessControlTranslation___Owner__domain[1] = {"_AccessControlTranslation"};
    mk_decl("_AccessControlTranslation._Owner_",1,_AccessControlTranslation___Owner__domain,"string");
    const char *_QueueConfiguration___Filter__domain[1] = {"_QueueConfiguration"};
    mk_decl("_QueueConfiguration._Filter_",1,_QueueConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_ObjectVersion___ETag__domain[1] = {"_ObjectVersion"};
    mk_decl("_ObjectVersion._ETag_",1,_ObjectVersion___ETag__domain,"string");
    const char *_Transition___Date__domain[1] = {"_Transition"};
    mk_decl("_Transition._Date_",1,_Transition___Date__domain,"timestamp");
    const char *vector___TargetGrant____end_domain[1] = {"vector[_TargetGrant]"};
    mk_decl("vector[_TargetGrant].end",1,vector___TargetGrant____end_domain,"vector[_TargetGrant].domain");
    const char *vector___Grant____end_domain[1] = {"vector[_Grant]"};
    mk_decl("vector[_Grant].end",1,vector___Grant____end_domain,"vector[_Grant].domain");
    const char *_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain[1] = {"_ServerSideEncryptionRule"};
    mk_decl("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",1,_ServerSideEncryptionRule___ApplyServerSideEncryptionByDefault__domain,"_ServerSideEncryptionByDefault");
    const char *_AnalyticsExportDestination___S3BucketDestination__domain[1] = {"_AnalyticsExportDestination"};
    mk_decl("_AnalyticsExportDestination._S3BucketDestination_",1,_AnalyticsExportDestination___S3BucketDestination__domain,"_AnalyticsS3BucketDestination");
    const char *vector___QueueConfiguration____value_domain[2] = {"vector[_QueueConfiguration]","vector[_QueueConfiguration].domain"};
    mk_decl("vector[_QueueConfiguration].value",2,vector___QueueConfiguration____value_domain,"_QueueConfiguration");
    const char *_IntelligentTieringAndOperator___Prefix__domain[1] = {"_IntelligentTieringAndOperator"};
    mk_decl("_IntelligentTieringAndOperator._Prefix_",1,_IntelligentTieringAndOperator___Prefix__domain,"string");
    const char *option___InventoryEncryption____value_domain[2] = {"option[_InventoryEncryption]","option[_InventoryEncryption].domain_t"};
    mk_decl("option[_InventoryEncryption].value",2,option___InventoryEncryption____value_domain,"_InventoryEncryption");
    const char *option___CompletedMultipartUpload____end_domain[1] = {"option[_CompletedMultipartUpload]"};
    mk_decl("option[_CompletedMultipartUpload].end",1,option___CompletedMultipartUpload____end_domain,"option[_CompletedMultipartUpload].domain_t");
    const char *_MultipartUpload___Owner__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Owner_",1,_MultipartUpload___Owner__domain,"_Owner");
    const char *_RoutingRule___Redirect__domain[1] = {"_RoutingRule"};
    mk_decl("_RoutingRule._Redirect_",1,_RoutingRule___Redirect__domain,"_Redirect");
    const char *_ReplicationRuleAndOperator___Tags__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Tags_",1,_ReplicationRuleAndOperator___Tags__domain,"vector[_Tag]");
    const char *_LifecycleRule___Transitions__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._Transitions_",1,_LifecycleRule___Transitions__domain,"option[vector[_Transition]]");
    const char *_Part___LastModified__domain[1] = {"_Part"};
    mk_decl("_Part._LastModified_",1,_Part___LastModified__domain,"timestamp");
    const char *_GetObjectOutput___ObjectLockMode__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ObjectLockMode_",1,_GetObjectOutput___ObjectLockMode__domain,"string");
    const char *vector___ObjectVersion____end_domain[1] = {"vector[_ObjectVersion]"};
    mk_decl("vector[_ObjectVersion].end",1,vector___ObjectVersion____end_domain,"vector[_ObjectVersion].domain");
    const char *_GetObjectOutput___WebsiteRedirectLocation__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._WebsiteRedirectLocation_",1,_GetObjectOutput___WebsiteRedirectLocation__domain,"string");
    const char *_AnalyticsS3BucketDestination___BucketAccountId__domain[1] = {"_AnalyticsS3BucketDestination"};
    mk_decl("_AnalyticsS3BucketDestination._BucketAccountId_",1,_AnalyticsS3BucketDestination___BucketAccountId__domain,"option[string]");
    const char *vector___CORSRule____end_domain[1] = {"vector[_CORSRule]"};
    mk_decl("vector[_CORSRule].end",1,vector___CORSRule____end_domain,"vector[_CORSRule].domain");
    const char *_GetObjectRequest___Bucket__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._Bucket_",1,_GetObjectRequest___Bucket__domain,"string");
    const char *_Object___ETag__domain[1] = {"_Object"};
    mk_decl("_Object._ETag_",1,_Object___ETag__domain,"string");
    const char *_Object___StorageClass__domain[1] = {"_Object"};
    mk_decl("_Object._StorageClass_",1,_Object___StorageClass__domain,"string");
    const char *_TopicConfiguration___Filter__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Filter_",1,_TopicConfiguration___Filter__domain,"option[_NotificationConfigurationFilter]");
    const char *_PutObjectRequest___ObjectLockRetainUntilDate__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ObjectLockRetainUntilDate_",1,_PutObjectRequest___ObjectLockRetainUntilDate__domain,"option[timestamp]");
    const char *_Tagging___TagSet__domain[1] = {"_Tagging"};
    mk_decl("_Tagging._TagSet_",1,_Tagging___TagSet__domain,"vector[_Tag]");
    const char *_ReplicationRuleFilter___Prefix__domain[1] = {"_ReplicationRuleFilter"};
    mk_decl("_ReplicationRuleFilter._Prefix_",1,_ReplicationRuleFilter___Prefix__domain,"string");
    mk_const("the_bucket","string");
    const char *_PutObjectOutput___ETag__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._ETag_",1,_PutObjectOutput___ETag__domain,"string");
    const char *_IntelligentTieringConfiguration___Status__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Status_",1,_IntelligentTieringConfiguration___Status__domain,"string");
    const char *_GetObjectOutput___VersionId__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._VersionId_",1,_GetObjectOutput___VersionId__domain,"string");
    const char *_GetObjectOutput___ContentEncoding__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._ContentEncoding_",1,_GetObjectOutput___ContentEncoding__domain,"string");
    const char *option___AnalyticsFilter____end_domain[1] = {"option[_AnalyticsFilter]"};
    mk_decl("option[_AnalyticsFilter].end",1,option___AnalyticsFilter____end_domain,"option[_AnalyticsFilter].domain_t");
    const char *_IntelligentTieringFilter___And__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._And_",1,_IntelligentTieringFilter___And__domain,"_IntelligentTieringAndOperator");
    const char *_PutObjectRequest___ExpectedBucketOwner__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._ExpectedBucketOwner_",1,_PutObjectRequest___ExpectedBucketOwner__domain,"option[string]");
    const char *_PutObjectRequest___CacheControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._CacheControl_",1,_PutObjectRequest___CacheControl__domain,"option[string]");
    const char *vector___TargetGrant____value_domain[2] = {"vector[_TargetGrant]","vector[_TargetGrant].domain"};
    mk_decl("vector[_TargetGrant].value",2,vector___TargetGrant____value_domain,"_TargetGrant");
    const char *_ReplicationRule___Priority__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Priority_",1,_ReplicationRule___Priority__domain,"option[integer]");
    const char *option___NoncurrentVersionTransition____end_domain[1] = {"option[_NoncurrentVersionTransition]"};
    mk_decl("option[_NoncurrentVersionTransition].end",1,option___NoncurrentVersionTransition____end_domain,"option[_NoncurrentVersionTransition].domain_t");
    const char *_IntelligentTieringFilter___Prefix__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Prefix_",1,_IntelligentTieringFilter___Prefix__domain,"string");
    const char *_MetricsConfiguration___Filter__domain[1] = {"_MetricsConfiguration"};
    mk_decl("_MetricsConfiguration._Filter_",1,_MetricsConfiguration___Filter__domain,"option[_MetricsFilter]");
    const char *_GetObjectRequest___IfModifiedSince__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._IfModifiedSince_",1,_GetObjectRequest___IfModifiedSince__domain,"option[timestamp]");
    const char *_PutObjectOutput___VersionId__domain[1] = {"_PutObjectOutput"};
    mk_decl("_PutObjectOutput._VersionId_",1,_PutObjectOutput___VersionId__domain,"string");
    const char *vector___OwnershipControlsRule____value_domain[2] = {"vector[_OwnershipControlsRule]","vector[_OwnershipControlsRule].domain"};
    mk_decl("vector[_OwnershipControlsRule].value",2,vector___OwnershipControlsRule____value_domain,"_OwnershipControlsRule");
    const char *_GlacierJobParameters___Tier__domain[1] = {"_GlacierJobParameters"};
    mk_decl("_GlacierJobParameters._Tier_",1,_GlacierJobParameters___Tier__domain,"string");
    const char *_PutObjectRequest___Body__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._Body_",1,_PutObjectRequest___Body__domain,"option[blob]");
    const char *_ReplicationTime___Status__domain[1] = {"_ReplicationTime"};
    mk_decl("_ReplicationTime._Status_",1,_ReplicationTime___Status__domain,"string");
    const char *_LifecycleRuleAndOperator___Prefix__domain[1] = {"_LifecycleRuleAndOperator"};
    mk_decl("_LifecycleRuleAndOperator._Prefix_",1,_LifecycleRuleAndOperator___Prefix__domain,"string");
    const char *_GetObjectRequest___VersionId__domain[1] = {"_GetObjectRequest"};
    mk_decl("_GetObjectRequest._VersionId_",1,_GetObjectRequest___VersionId__domain,"option[string]");
    const char *option___Tagging____end_domain[1] = {"option[_Tagging]"};
    mk_decl("option[_Tagging].end",1,option___Tagging____end_domain,"option[_Tagging].domain_t");
    const char *unordered_map__string____string____contains_domain[2] = {"unordered_map[string][string]","string"};
    mk_decl("unordered_map[string][string].contains",2,unordered_map__string____string____contains_domain,"Bool");
    const char *option__unordered_map__string____string______value_domain[2] = {"option[unordered_map[string][string]]","option[unordered_map[string][string]].domain_t"};
    mk_decl("option[unordered_map[string][string]].value",2,option__unordered_map__string____string______value_domain,"unordered_map[string][string]");
    const char *_DeleteMarkerEntry___Owner__domain[1] = {"_DeleteMarkerEntry"};
    mk_decl("_DeleteMarkerEntry._Owner_",1,_DeleteMarkerEntry___Owner__domain,"_Owner");
    const char *_AccessControlPolicy___Grants__domain[1] = {"_AccessControlPolicy"};
    mk_decl("_AccessControlPolicy._Grants_",1,_AccessControlPolicy___Grants__domain,"vector[_Grant]");
    const char *_GetObjectOutput___Restore__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Restore_",1,_GetObjectOutput___Restore__domain,"string");
    const char *option__vector___Transition______value_domain[2] = {"option[vector[_Transition]]","option[vector[_Transition]].domain_t"};
    mk_decl("option[vector[_Transition]].value",2,option__vector___Transition______value_domain,"vector[_Transition]");
    const char *vector__string____end_domain[1] = {"vector[string]"};
    mk_decl("vector[string].end",1,vector__string____end_domain,"vector[string].domain");
    const char *vector___MetadataEntry____value_domain[2] = {"vector[_MetadataEntry]","vector[_MetadataEntry].domain"};
    mk_decl("vector[_MetadataEntry].value",2,vector___MetadataEntry____value_domain,"_MetadataEntry");
    const char *_IntelligentTieringConfiguration___Filter__domain[1] = {"_IntelligentTieringConfiguration"};
    mk_decl("_IntelligentTieringConfiguration._Filter_",1,_IntelligentTieringConfiguration___Filter__domain,"option[_IntelligentTieringFilter]");
    const char *_IntelligentTieringFilter___Tag__domain[1] = {"_IntelligentTieringFilter"};
    mk_decl("_IntelligentTieringFilter._Tag_",1,_IntelligentTieringFilter___Tag__domain,"_Tag");
    const char *_PutObjectRequest___GrantFullControl__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantFullControl_",1,_PutObjectRequest___GrantFullControl__domain,"option[string]");
    const char *option___Encryption____end_domain[1] = {"option[_Encryption]"};
    mk_decl("option[_Encryption].end",1,option___Encryption____end_domain,"option[_Encryption].domain_t");
    const char *_CSVOutput___QuoteEscapeCharacter__domain[1] = {"_CSVOutput"};
    mk_decl("_CSVOutput._QuoteEscapeCharacter_",1,_CSVOutput___QuoteEscapeCharacter__domain,"string");
    const char *_AnalyticsConfiguration___StorageClassAnalysis__domain[1] = {"_AnalyticsConfiguration"};
    mk_decl("_AnalyticsConfiguration._StorageClassAnalysis_",1,_AnalyticsConfiguration___StorageClassAnalysis__domain,"_StorageClassAnalysis");
    const char *_Redirect___ReplaceKeyPrefixWith__domain[1] = {"_Redirect"};
    mk_decl("_Redirect._ReplaceKeyPrefixWith_",1,_Redirect___ReplaceKeyPrefixWith__domain,"string");
    const char *_ReplicationRuleAndOperator___Prefix__domain[1] = {"_ReplicationRuleAndOperator"};
    mk_decl("_ReplicationRuleAndOperator._Prefix_",1,_ReplicationRuleAndOperator___Prefix__domain,"string");
    const char *option__string____value_domain[2] = {"option[string]","option[string].domain_t"};
    mk_decl("option[string].value",2,option__string____value_domain,"string");
    const char *_PutObjectRequest___SSECustomerKeyMD5__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._SSECustomerKeyMD5_",1,_PutObjectRequest___SSECustomerKeyMD5__domain,"option[string]");
    const char *_Object___Owner__domain[1] = {"_Object"};
    mk_decl("_Object._Owner_",1,_Object___Owner__domain,"_Owner");
    const char *_MultipartUpload___Key__domain[1] = {"_MultipartUpload"};
    mk_decl("_MultipartUpload._Key_",1,_MultipartUpload___Key__domain,"string");
    const char *_Encryption___EncryptionType__domain[1] = {"_Encryption"};
    mk_decl("_Encryption._EncryptionType_",1,_Encryption___EncryptionType__domain,"string");
    const char *_Rule___Expiration__domain[1] = {"_Rule"};
    mk_decl("_Rule._Expiration_",1,_Rule___Expiration__domain,"option[_LifecycleExpiration]");
    const char *vector___Grant____value_domain[2] = {"vector[_Grant]","vector[_Grant].domain"};
    mk_decl("vector[_Grant].value",2,vector___Grant____value_domain,"_Grant");
    const char *_TopicConfiguration___Events__domain[1] = {"_TopicConfiguration"};
    mk_decl("_TopicConfiguration._Events_",1,_TopicConfiguration___Events__domain,"vector[string]");
    const char *option___ReplicationRuleFilter____value_domain[2] = {"option[_ReplicationRuleFilter]","option[_ReplicationRuleFilter].domain_t"};
    mk_decl("option[_ReplicationRuleFilter].value",2,option___ReplicationRuleFilter____value_domain,"_ReplicationRuleFilter");
    const char *_PutObjectRequest___GrantReadACP__domain[1] = {"_PutObjectRequest"};
    mk_decl("_PutObjectRequest._GrantReadACP_",1,_PutObjectRequest___GrantReadACP__domain,"option[string]");
    const char *_Bucket___Name__domain[1] = {"_Bucket"};
    mk_decl("_Bucket._Name_",1,_Bucket___Name__domain,"string");
    const char *_LifecycleRule___ID__domain[1] = {"_LifecycleRule"};
    mk_decl("_LifecycleRule._ID_",1,_LifecycleRule___ID__domain,"option[string]");
    const char *_DefaultRetention___Mode__domain[1] = {"_DefaultRetention"};
    mk_decl("_DefaultRetention._Mode_",1,_DefaultRetention___Mode__domain,"string");
    const char *vector___ObjectIdentifier____value_domain[2] = {"vector[_ObjectIdentifier]","vector[_ObjectIdentifier].domain"};
    mk_decl("vector[_ObjectIdentifier].value",2,vector___ObjectIdentifier____value_domain,"_ObjectIdentifier");
    const char *_GetObjectOutput___Expires__domain[1] = {"_GetObjectOutput"};
    mk_decl("_GetObjectOutput._Expires_",1,_GetObjectOutput___Expires__domain,"timestamp");
    const char *_ReplicationRule___Filter__domain[1] = {"_ReplicationRule"};
    mk_decl("_ReplicationRule._Filter_",1,_ReplicationRule___Filter__domain,"option[_ReplicationRuleFilter]");
    mk_const("__fml:key","string");
    mk_const("__fml:data","blob");
    mk_const("__fml:bucket","string");
    add("(assert and)");
}
bool ext__put_gen::generate(s3_test& obj) {
    push();
    s3_test::string::prepare();
    alits.clear();
    __randomize<s3_test::string>(*this,apply("__fml:key"));
    __randomize<s3_test::blob>(*this,apply("__fml:data"));
    __randomize<s3_test::string>(*this,apply("__fml:bucket"));

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
                __from_solver<s3_test::blob>(*this,apply("__fml:data"),data);
    s3_test::string (&the_bucket) = obj.the_bucket;
    s3_test::string (&the_key) = obj.the_key;
        bucket = the_bucket;
        key = the_key;

    }s3_test::string::cleanup();

    pop();
    obj.___ivy_gen = this;
    return __res;
}
void ext__put_gen::execute(s3_test& obj){
    __ivy_out << "> put(" << bucket << ","  << key << ","  << data << ")" << std::endl;
    obj.ext__put(bucket,key,data);
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AbortIncompleteMultipartUpload &t){
    s<<"{";
    s<< "_DaysAfterInitiation_:";
    s << t._DaysAfterInitiation_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AbortIncompleteMultipartUpload>(ivy_ser &res, const s3_test::_AbortIncompleteMultipartUpload&t){
    res.open_struct();
    res.open_field("_DaysAfterInitiation_");
    __ser<int>(res,t._DaysAfterInitiation_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Grantee &t){
    s<<"{";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<",";
    s<< "_EmailAddress_:";
    s << t._EmailAddress_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Type_:";
    s << t._Type_;
    s<<",";
    s<< "_URI_:";
    s << t._URI_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Grantee>(ivy_ser &res, const s3_test::_Grantee&t){
    res.open_struct();
    res.open_field("_DisplayName_");
    __ser<s3_test::option__string__>(res,t._DisplayName_);
    res.close_field();
    res.open_field("_EmailAddress_");
    __ser<s3_test::option__string__>(res,t._EmailAddress_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Type_");
    __ser<s3_test::string>(res,t._Type_);
    res.close_field();
    res.open_field("_URI_");
    __ser<s3_test::option__string__>(res,t._URI_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Grant &t){
    s<<"{";
    s<< "_Grantee_:";
    s << t._Grantee_;
    s<<",";
    s<< "_Permission_:";
    s << t._Permission_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Grant>(ivy_ser &res, const s3_test::_Grant&t){
    res.open_struct();
    res.open_field("_Grantee_");
    __ser<s3_test::_Grantee>(res,t._Grantee_);
    res.close_field();
    res.open_field("_Permission_");
    __ser<s3_test::string>(res,t._Permission_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Owner &t){
    s<<"{";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Owner>(ivy_ser &res, const s3_test::_Owner&t){
    res.open_struct();
    res.open_field("_DisplayName_");
    __ser<s3_test::string>(res,t._DisplayName_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::string>(res,t._ID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlPolicy &t){
    s<<"{";
    s<< "_Grants_:";
    s << t._Grants_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AccessControlPolicy>(ivy_ser &res, const s3_test::_AccessControlPolicy&t){
    res.open_struct();
    res.open_field("_Grants_");
    __ser<s3_test::vector___Grant__>(res,t._Grants_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AccessControlTranslation &t){
    s<<"{";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AccessControlTranslation>(ivy_ser &res, const s3_test::_AccessControlTranslation&t){
    res.open_struct();
    res.open_field("_Owner_");
    __ser<s3_test::string>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tag &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tag>(ivy_ser &res, const s3_test::_Tag&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_Value_");
    __ser<s3_test::string>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsAndOperator>(ivy_ser &res, const s3_test::_AnalyticsAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsFilter>(ivy_ser &res, const s3_test::_AnalyticsFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_AnalyticsAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsS3BucketDestination &t){
    s<<"{";
    s<< "_Format_:";
    s << t._Format_;
    s<<",";
    s<< "_BucketAccountId_:";
    s << t._BucketAccountId_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsS3BucketDestination>(ivy_ser &res, const s3_test::_AnalyticsS3BucketDestination&t){
    res.open_struct();
    res.open_field("_Format_");
    __ser<s3_test::string>(res,t._Format_);
    res.close_field();
    res.open_field("_BucketAccountId_");
    __ser<s3_test::option__string__>(res,t._BucketAccountId_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<s3_test::string>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsExportDestination &t){
    s<<"{";
    s<< "_S3BucketDestination_:";
    s << t._S3BucketDestination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsExportDestination>(ivy_ser &res, const s3_test::_AnalyticsExportDestination&t){
    res.open_struct();
    res.open_field("_S3BucketDestination_");
    __ser<s3_test::_AnalyticsS3BucketDestination>(res,t._S3BucketDestination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysisDataExport &t){
    s<<"{";
    s<< "_OutputSchemaVersion_:";
    s << t._OutputSchemaVersion_;
    s<<",";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_StorageClassAnalysisDataExport>(ivy_ser &res, const s3_test::_StorageClassAnalysisDataExport&t){
    res.open_struct();
    res.open_field("_OutputSchemaVersion_");
    __ser<s3_test::string>(res,t._OutputSchemaVersion_);
    res.close_field();
    res.open_field("_Destination_");
    __ser<s3_test::_AnalyticsExportDestination>(res,t._Destination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_StorageClassAnalysis &t){
    s<<"{";
    s<< "_DataExport_:";
    s << t._DataExport_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_StorageClassAnalysis>(ivy_ser &res, const s3_test::_StorageClassAnalysis&t){
    res.open_struct();
    res.open_field("_DataExport_");
    __ser<s3_test::_StorageClassAnalysisDataExport>(res,t._DataExport_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_AnalyticsConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_StorageClassAnalysis_:";
    s << t._StorageClassAnalysis_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_AnalyticsConfiguration>(ivy_ser &res, const s3_test::_AnalyticsConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::string>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___AnalyticsFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_StorageClassAnalysis_");
    __ser<s3_test::_StorageClassAnalysis>(res,t._StorageClassAnalysis_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Bucket &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_CreationDate_:";
    s << t._CreationDate_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Bucket>(ivy_ser &res, const s3_test::_Bucket&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<s3_test::string>(res,t._Name_);
    res.close_field();
    res.open_field("_CreationDate_");
    __ser<int>(res,t._CreationDate_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleExpiration &t){
    s<<"{";
    s<< "_Date_:";
    s << t._Date_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_ExpiredObjectDeleteMarker_:";
    s << t._ExpiredObjectDeleteMarker_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleExpiration>(ivy_ser &res, const s3_test::_LifecycleExpiration&t){
    res.open_struct();
    res.open_field("_Date_");
    __ser<int>(res,t._Date_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_ExpiredObjectDeleteMarker_");
    __ser<bool>(res,t._ExpiredObjectDeleteMarker_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRuleAndOperator>(ivy_ser &res, const s3_test::_LifecycleRuleAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRuleFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRuleFilter>(ivy_ser &res, const s3_test::_LifecycleRuleFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_LifecycleRuleAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Transition &t){
    s<<"{";
    s<< "_Date_:";
    s << t._Date_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Transition>(ivy_ser &res, const s3_test::_Transition&t){
    res.open_struct();
    res.open_field("_Date_");
    __ser<int>(res,t._Date_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionTransition &t){
    s<<"{";
    s<< "_NoncurrentDays_:";
    s << t._NoncurrentDays_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NoncurrentVersionTransition>(ivy_ser &res, const s3_test::_NoncurrentVersionTransition&t){
    res.open_struct();
    res.open_field("_NoncurrentDays_");
    __ser<int>(res,t._NoncurrentDays_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NoncurrentVersionExpiration &t){
    s<<"{";
    s<< "_NoncurrentDays_:";
    s << t._NoncurrentDays_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NoncurrentVersionExpiration>(ivy_ser &res, const s3_test::_NoncurrentVersionExpiration&t){
    res.open_struct();
    res.open_field("_NoncurrentDays_");
    __ser<int>(res,t._NoncurrentDays_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleRule &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Transitions_:";
    s << t._Transitions_;
    s<<",";
    s<< "_NoncurrentVersionTransitions_:";
    s << t._NoncurrentVersionTransitions_;
    s<<",";
    s<< "_NoncurrentVersionExpiration_:";
    s << t._NoncurrentVersionExpiration_;
    s<<",";
    s<< "_AbortIncompleteMultipartUpload_:";
    s << t._AbortIncompleteMultipartUpload_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleRule>(ivy_ser &res, const s3_test::_LifecycleRule&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<s3_test::option___LifecycleExpiration__>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___LifecycleRuleFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_Transitions_");
    __ser<s3_test::option__vector___Transition____>(res,t._Transitions_);
    res.close_field();
    res.open_field("_NoncurrentVersionTransitions_");
    __ser<s3_test::option__vector___NoncurrentVersionTransition____>(res,t._NoncurrentVersionTransitions_);
    res.close_field();
    res.open_field("_NoncurrentVersionExpiration_");
    __ser<s3_test::option___NoncurrentVersionExpiration__>(res,t._NoncurrentVersionExpiration_);
    res.close_field();
    res.open_field("_AbortIncompleteMultipartUpload_");
    __ser<s3_test::option___AbortIncompleteMultipartUpload__>(res,t._AbortIncompleteMultipartUpload_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_BucketLifecycleConfiguration &t){
    s<<"{";
    s<< "_Rules_:";
    s << t._Rules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_BucketLifecycleConfiguration>(ivy_ser &res, const s3_test::_BucketLifecycleConfiguration&t){
    res.open_struct();
    res.open_field("_Rules_");
    __ser<s3_test::vector___LifecycleRule__>(res,t._Rules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_TargetGrant &t){
    s<<"{";
    s<< "_Grantee_:";
    s << t._Grantee_;
    s<<",";
    s<< "_Permission_:";
    s << t._Permission_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_TargetGrant>(ivy_ser &res, const s3_test::_TargetGrant&t){
    res.open_struct();
    res.open_field("_Grantee_");
    __ser<s3_test::_Grantee>(res,t._Grantee_);
    res.close_field();
    res.open_field("_Permission_");
    __ser<s3_test::string>(res,t._Permission_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CORSRule &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_AllowedHeaders_:";
    s << t._AllowedHeaders_;
    s<<",";
    s<< "_AllowedMethods_:";
    s << t._AllowedMethods_;
    s<<",";
    s<< "_AllowedOrigins_:";
    s << t._AllowedOrigins_;
    s<<",";
    s<< "_ExposeHeaders_:";
    s << t._ExposeHeaders_;
    s<<",";
    s<< "_MaxAgeSeconds_:";
    s << t._MaxAgeSeconds_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CORSRule>(ivy_ser &res, const s3_test::_CORSRule&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_AllowedHeaders_");
    __ser<s3_test::option__vector__string____>(res,t._AllowedHeaders_);
    res.close_field();
    res.open_field("_AllowedMethods_");
    __ser<s3_test::vector__string__>(res,t._AllowedMethods_);
    res.close_field();
    res.open_field("_AllowedOrigins_");
    __ser<s3_test::vector__string__>(res,t._AllowedOrigins_);
    res.close_field();
    res.open_field("_ExposeHeaders_");
    __ser<s3_test::option__vector__string____>(res,t._ExposeHeaders_);
    res.close_field();
    res.open_field("_MaxAgeSeconds_");
    __ser<s3_test::option__integer__>(res,t._MaxAgeSeconds_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVInput &t){
    s<<"{";
    s<< "_FileHeaderInfo_:";
    s << t._FileHeaderInfo_;
    s<<",";
    s<< "_Comments_:";
    s << t._Comments_;
    s<<",";
    s<< "_QuoteEscapeCharacter_:";
    s << t._QuoteEscapeCharacter_;
    s<<",";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<",";
    s<< "_FieldDelimiter_:";
    s << t._FieldDelimiter_;
    s<<",";
    s<< "_QuoteCharacter_:";
    s << t._QuoteCharacter_;
    s<<",";
    s<< "_AllowQuotedRecordDelimiter_:";
    s << t._AllowQuotedRecordDelimiter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CSVInput>(ivy_ser &res, const s3_test::_CSVInput&t){
    res.open_struct();
    res.open_field("_FileHeaderInfo_");
    __ser<s3_test::string>(res,t._FileHeaderInfo_);
    res.close_field();
    res.open_field("_Comments_");
    __ser<s3_test::string>(res,t._Comments_);
    res.close_field();
    res.open_field("_QuoteEscapeCharacter_");
    __ser<s3_test::string>(res,t._QuoteEscapeCharacter_);
    res.close_field();
    res.open_field("_RecordDelimiter_");
    __ser<s3_test::string>(res,t._RecordDelimiter_);
    res.close_field();
    res.open_field("_FieldDelimiter_");
    __ser<s3_test::string>(res,t._FieldDelimiter_);
    res.close_field();
    res.open_field("_QuoteCharacter_");
    __ser<s3_test::string>(res,t._QuoteCharacter_);
    res.close_field();
    res.open_field("_AllowQuotedRecordDelimiter_");
    __ser<bool>(res,t._AllowQuotedRecordDelimiter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CSVOutput &t){
    s<<"{";
    s<< "_QuoteFields_:";
    s << t._QuoteFields_;
    s<<",";
    s<< "_QuoteEscapeCharacter_:";
    s << t._QuoteEscapeCharacter_;
    s<<",";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<",";
    s<< "_FieldDelimiter_:";
    s << t._FieldDelimiter_;
    s<<",";
    s<< "_QuoteCharacter_:";
    s << t._QuoteCharacter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CSVOutput>(ivy_ser &res, const s3_test::_CSVOutput&t){
    res.open_struct();
    res.open_field("_QuoteFields_");
    __ser<s3_test::string>(res,t._QuoteFields_);
    res.close_field();
    res.open_field("_QuoteEscapeCharacter_");
    __ser<s3_test::string>(res,t._QuoteEscapeCharacter_);
    res.close_field();
    res.open_field("_RecordDelimiter_");
    __ser<s3_test::string>(res,t._RecordDelimiter_);
    res.close_field();
    res.open_field("_FieldDelimiter_");
    __ser<s3_test::string>(res,t._FieldDelimiter_);
    res.close_field();
    res.open_field("_QuoteCharacter_");
    __ser<s3_test::string>(res,t._QuoteCharacter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CommonPrefix &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CommonPrefix>(ivy_ser &res, const s3_test::_CommonPrefix&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedPart &t){
    s<<"{";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CompletedPart>(ivy_ser &res, const s3_test::_CompletedPart&t){
    res.open_struct();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_PartNumber_");
    __ser<int>(res,t._PartNumber_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CompletedMultipartUpload &t){
    s<<"{";
    s<< "_Parts_:";
    s << t._Parts_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CompletedMultipartUpload>(ivy_ser &res, const s3_test::_CompletedMultipartUpload&t){
    res.open_struct();
    res.open_field("_Parts_");
    __ser<s3_test::vector___CompletedPart__>(res,t._Parts_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Condition &t){
    s<<"{";
    s<< "_HttpErrorCodeReturnedEquals_:";
    s << t._HttpErrorCodeReturnedEquals_;
    s<<",";
    s<< "_KeyPrefixEquals_:";
    s << t._KeyPrefixEquals_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Condition>(ivy_ser &res, const s3_test::_Condition&t){
    res.open_struct();
    res.open_field("_HttpErrorCodeReturnedEquals_");
    __ser<s3_test::string>(res,t._HttpErrorCodeReturnedEquals_);
    res.close_field();
    res.open_field("_KeyPrefixEquals_");
    __ser<s3_test::string>(res,t._KeyPrefixEquals_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_CreateBucketConfiguration &t){
    s<<"{";
    s<< "_LocationConstraint_:";
    s << t._LocationConstraint_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_CreateBucketConfiguration>(ivy_ser &res, const s3_test::_CreateBucketConfiguration&t){
    res.open_struct();
    res.open_field("_LocationConstraint_");
    __ser<s3_test::string>(res,t._LocationConstraint_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DefaultRetention &t){
    s<<"{";
    s<< "_Mode_:";
    s << t._Mode_;
    s<<",";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_Years_:";
    s << t._Years_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DefaultRetention>(ivy_ser &res, const s3_test::_DefaultRetention&t){
    res.open_struct();
    res.open_field("_Mode_");
    __ser<s3_test::string>(res,t._Mode_);
    res.close_field();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_Years_");
    __ser<int>(res,t._Years_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectIdentifier &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectIdentifier>(ivy_ser &res, const s3_test::_ObjectIdentifier&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::option__string__>(res,t._VersionId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerEntry &t){
    s<<"{";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_IsLatest_:";
    s << t._IsLatest_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeleteMarkerEntry>(ivy_ser &res, const s3_test::_DeleteMarkerEntry&t){
    res.open_struct();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_IsLatest_");
    __ser<bool>(res,t._IsLatest_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeleteMarkerReplication &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeleteMarkerReplication>(ivy_ser &res, const s3_test::_DeleteMarkerReplication&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_DeletedObject &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_DeleteMarker_:";
    s << t._DeleteMarker_;
    s<<",";
    s<< "_DeleteMarkerVersionId_:";
    s << t._DeleteMarkerVersionId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_DeletedObject>(ivy_ser &res, const s3_test::_DeletedObject&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_DeleteMarker_");
    __ser<bool>(res,t._DeleteMarker_);
    res.close_field();
    res.open_field("_DeleteMarkerVersionId_");
    __ser<s3_test::string>(res,t._DeleteMarkerVersionId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Error &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_Code_:";
    s << t._Code_;
    s<<",";
    s<< "_Message_:";
    s << t._Message_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Error>(ivy_ser &res, const s3_test::_Error&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_Code_");
    __ser<s3_test::string>(res,t._Code_);
    res.close_field();
    res.open_field("_Message_");
    __ser<s3_test::string>(res,t._Message_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_EncryptionConfiguration &t){
    s<<"{";
    s<< "_ReplicaKmsKeyID_:";
    s << t._ReplicaKmsKeyID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_EncryptionConfiguration>(ivy_ser &res, const s3_test::_EncryptionConfiguration&t){
    res.open_struct();
    res.open_field("_ReplicaKmsKeyID_");
    __ser<s3_test::string>(res,t._ReplicaKmsKeyID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTimeValue &t){
    s<<"{";
    s<< "_Minutes_:";
    s << t._Minutes_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationTimeValue>(ivy_ser &res, const s3_test::_ReplicationTimeValue&t){
    res.open_struct();
    res.open_field("_Minutes_");
    __ser<int>(res,t._Minutes_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationTime &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Time_:";
    s << t._Time_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationTime>(ivy_ser &res, const s3_test::_ReplicationTime&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_Time_");
    __ser<s3_test::_ReplicationTimeValue>(res,t._Time_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Metrics &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_EventThreshold_:";
    s << t._EventThreshold_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Metrics>(ivy_ser &res, const s3_test::_Metrics&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_EventThreshold_");
    __ser<s3_test::option___ReplicationTimeValue__>(res,t._EventThreshold_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Destination &t){
    s<<"{";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Account_:";
    s << t._Account_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_AccessControlTranslation_:";
    s << t._AccessControlTranslation_;
    s<<",";
    s<< "_EncryptionConfiguration_:";
    s << t._EncryptionConfiguration_;
    s<<",";
    s<< "_ReplicationTime_:";
    s << t._ReplicationTime_;
    s<<",";
    s<< "_Metrics_:";
    s << t._Metrics_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Destination>(ivy_ser &res, const s3_test::_Destination&t){
    res.open_struct();
    res.open_field("_Bucket_");
    __ser<s3_test::string>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Account_");
    __ser<s3_test::option__string__>(res,t._Account_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_AccessControlTranslation_");
    __ser<s3_test::option___AccessControlTranslation__>(res,t._AccessControlTranslation_);
    res.close_field();
    res.open_field("_EncryptionConfiguration_");
    __ser<s3_test::option___EncryptionConfiguration__>(res,t._EncryptionConfiguration_);
    res.close_field();
    res.open_field("_ReplicationTime_");
    __ser<s3_test::option___ReplicationTime__>(res,t._ReplicationTime_);
    res.close_field();
    res.open_field("_Metrics_");
    __ser<s3_test::option___Metrics__>(res,t._Metrics_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Encryption &t){
    s<<"{";
    s<< "_EncryptionType_:";
    s << t._EncryptionType_;
    s<<",";
    s<< "_KMSKeyId_:";
    s << t._KMSKeyId_;
    s<<",";
    s<< "_KMSContext_:";
    s << t._KMSContext_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Encryption>(ivy_ser &res, const s3_test::_Encryption&t){
    res.open_struct();
    res.open_field("_EncryptionType_");
    __ser<s3_test::string>(res,t._EncryptionType_);
    res.close_field();
    res.open_field("_KMSKeyId_");
    __ser<s3_test::option__string__>(res,t._KMSKeyId_);
    res.close_field();
    res.open_field("_KMSContext_");
    __ser<s3_test::option__string__>(res,t._KMSContext_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ExistingObjectReplication &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ExistingObjectReplication>(ivy_ser &res, const s3_test::_ExistingObjectReplication&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_FilterRule &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_FilterRule>(ivy_ser &res, const s3_test::_FilterRule&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<s3_test::string>(res,t._Name_);
    res.close_field();
    res.open_field("_Value_");
    __ser<s3_test::string>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionByDefault &t){
    s<<"{";
    s<< "_SSEAlgorithm_:";
    s << t._SSEAlgorithm_;
    s<<",";
    s<< "_KMSMasterKeyID_:";
    s << t._KMSMasterKeyID_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ServerSideEncryptionByDefault>(ivy_ser &res, const s3_test::_ServerSideEncryptionByDefault&t){
    res.open_struct();
    res.open_field("_SSEAlgorithm_");
    __ser<s3_test::string>(res,t._SSEAlgorithm_);
    res.close_field();
    res.open_field("_KMSMasterKeyID_");
    __ser<s3_test::option__string__>(res,t._KMSMasterKeyID_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ServerSideEncryptionRule &t){
    s<<"{";
    s<< "_ApplyServerSideEncryptionByDefault_:";
    s << t._ApplyServerSideEncryptionByDefault_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ServerSideEncryptionRule>(ivy_ser &res, const s3_test::_ServerSideEncryptionRule&t){
    res.open_struct();
    res.open_field("_ApplyServerSideEncryptionByDefault_");
    __ser<s3_test::_ServerSideEncryptionByDefault>(res,t._ApplyServerSideEncryptionByDefault_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringAndOperator>(ivy_ser &res, const s3_test::_IntelligentTieringAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringFilter>(ivy_ser &res, const s3_test::_IntelligentTieringFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_IntelligentTieringAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tiering &t){
    s<<"{";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_AccessTier_:";
    s << t._AccessTier_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tiering>(ivy_ser &res, const s3_test::_Tiering&t){
    res.open_struct();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_AccessTier_");
    __ser<s3_test::string>(res,t._AccessTier_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_IntelligentTieringConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Tierings_:";
    s << t._Tierings_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_IntelligentTieringConfiguration>(ivy_ser &res, const s3_test::_IntelligentTieringConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::string>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___IntelligentTieringFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_Tierings_");
    __ser<s3_test::vector___Tiering__>(res,t._Tierings_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SSES3 &t){
    s<<"{";
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SSES3>(ivy_ser &res, const s3_test::_SSES3&t){
    res.open_struct();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SSEKMS &t){
    s<<"{";
    s<< "_KeyId_:";
    s << t._KeyId_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SSEKMS>(ivy_ser &res, const s3_test::_SSEKMS&t){
    res.open_struct();
    res.open_field("_KeyId_");
    __ser<s3_test::string>(res,t._KeyId_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryEncryption &t){
    s<<"{";
    s<< "_SSES3_:";
    s << t._SSES3_;
    s<<",";
    s<< "_SSEKMS_:";
    s << t._SSEKMS_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryEncryption>(ivy_ser &res, const s3_test::_InventoryEncryption&t){
    res.open_struct();
    res.open_field("_SSES3_");
    __ser<s3_test::_SSES3>(res,t._SSES3_);
    res.close_field();
    res.open_field("_SSEKMS_");
    __ser<s3_test::_SSEKMS>(res,t._SSEKMS_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryS3BucketDestination &t){
    s<<"{";
    s<< "_AccountId_:";
    s << t._AccountId_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_Format_:";
    s << t._Format_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Encryption_:";
    s << t._Encryption_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryS3BucketDestination>(ivy_ser &res, const s3_test::_InventoryS3BucketDestination&t){
    res.open_struct();
    res.open_field("_AccountId_");
    __ser<s3_test::option__string__>(res,t._AccountId_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<s3_test::string>(res,t._Bucket_);
    res.close_field();
    res.open_field("_Format_");
    __ser<s3_test::string>(res,t._Format_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Encryption_");
    __ser<s3_test::option___InventoryEncryption__>(res,t._Encryption_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryDestination &t){
    s<<"{";
    s<< "_S3BucketDestination_:";
    s << t._S3BucketDestination_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryDestination>(ivy_ser &res, const s3_test::_InventoryDestination&t){
    res.open_struct();
    res.open_field("_S3BucketDestination_");
    __ser<s3_test::_InventoryS3BucketDestination>(res,t._S3BucketDestination_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryFilter>(ivy_ser &res, const s3_test::_InventoryFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventorySchedule &t){
    s<<"{";
    s<< "_Frequency_:";
    s << t._Frequency_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventorySchedule>(ivy_ser &res, const s3_test::_InventorySchedule&t){
    res.open_struct();
    res.open_field("_Frequency_");
    __ser<s3_test::string>(res,t._Frequency_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InventoryConfiguration &t){
    s<<"{";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<",";
    s<< "_IsEnabled_:";
    s << t._IsEnabled_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_IncludedObjectVersions_:";
    s << t._IncludedObjectVersions_;
    s<<",";
    s<< "_OptionalFields_:";
    s << t._OptionalFields_;
    s<<",";
    s<< "_Schedule_:";
    s << t._Schedule_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InventoryConfiguration>(ivy_ser &res, const s3_test::_InventoryConfiguration&t){
    res.open_struct();
    res.open_field("_Destination_");
    __ser<s3_test::_InventoryDestination>(res,t._Destination_);
    res.close_field();
    res.open_field("_IsEnabled_");
    __ser<bool>(res,t._IsEnabled_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___InventoryFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Id_");
    __ser<s3_test::string>(res,t._Id_);
    res.close_field();
    res.open_field("_IncludedObjectVersions_");
    __ser<s3_test::string>(res,t._IncludedObjectVersions_);
    res.close_field();
    res.open_field("_OptionalFields_");
    __ser<s3_test::option__vector__string____>(res,t._OptionalFields_);
    res.close_field();
    res.open_field("_Schedule_");
    __ser<s3_test::_InventorySchedule>(res,t._Schedule_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Rule &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_Transition_:";
    s << t._Transition_;
    s<<",";
    s<< "_NoncurrentVersionTransition_:";
    s << t._NoncurrentVersionTransition_;
    s<<",";
    s<< "_NoncurrentVersionExpiration_:";
    s << t._NoncurrentVersionExpiration_;
    s<<",";
    s<< "_AbortIncompleteMultipartUpload_:";
    s << t._AbortIncompleteMultipartUpload_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Rule>(ivy_ser &res, const s3_test::_Rule&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<s3_test::option___LifecycleExpiration__>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_Transition_");
    __ser<s3_test::option___Transition__>(res,t._Transition_);
    res.close_field();
    res.open_field("_NoncurrentVersionTransition_");
    __ser<s3_test::option___NoncurrentVersionTransition__>(res,t._NoncurrentVersionTransition_);
    res.close_field();
    res.open_field("_NoncurrentVersionExpiration_");
    __ser<s3_test::option___NoncurrentVersionExpiration__>(res,t._NoncurrentVersionExpiration_);
    res.close_field();
    res.open_field("_AbortIncompleteMultipartUpload_");
    __ser<s3_test::option___AbortIncompleteMultipartUpload__>(res,t._AbortIncompleteMultipartUpload_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsAndOperator>(ivy_ser &res, const s3_test::_MetricsAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsFilter>(ivy_ser &res, const s3_test::_MetricsFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_MetricsAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetricsConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetricsConfiguration>(ivy_ser &res, const s3_test::_MetricsConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::string>(res,t._Id_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___MetricsFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OwnershipControlsRule &t){
    s<<"{";
    s<< "_ObjectOwnership_:";
    s << t._ObjectOwnership_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OwnershipControlsRule>(ivy_ser &res, const s3_test::_OwnershipControlsRule&t){
    res.open_struct();
    res.open_field("_ObjectOwnership_");
    __ser<s3_test::string>(res,t._ObjectOwnership_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleAndOperator &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tags_:";
    s << t._Tags_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRuleAndOperator>(ivy_ser &res, const s3_test::_ReplicationRuleAndOperator&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tags_");
    __ser<s3_test::vector___Tag__>(res,t._Tags_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRuleFilter &t){
    s<<"{";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Tag_:";
    s << t._Tag_;
    s<<",";
    s<< "_And_:";
    s << t._And_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRuleFilter>(ivy_ser &res, const s3_test::_ReplicationRuleFilter&t){
    res.open_struct();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Tag_");
    __ser<s3_test::_Tag>(res,t._Tag_);
    res.close_field();
    res.open_field("_And_");
    __ser<s3_test::_ReplicationRuleAndOperator>(res,t._And_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SseKmsEncryptedObjects &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SseKmsEncryptedObjects>(ivy_ser &res, const s3_test::_SseKmsEncryptedObjects&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicaModifications &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicaModifications>(ivy_ser &res, const s3_test::_ReplicaModifications&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SourceSelectionCriteria &t){
    s<<"{";
    s<< "_SseKmsEncryptedObjects_:";
    s << t._SseKmsEncryptedObjects_;
    s<<",";
    s<< "_ReplicaModifications_:";
    s << t._ReplicaModifications_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SourceSelectionCriteria>(ivy_ser &res, const s3_test::_SourceSelectionCriteria&t){
    res.open_struct();
    res.open_field("_SseKmsEncryptedObjects_");
    __ser<s3_test::_SseKmsEncryptedObjects>(res,t._SseKmsEncryptedObjects_);
    res.close_field();
    res.open_field("_ReplicaModifications_");
    __ser<s3_test::_ReplicaModifications>(res,t._ReplicaModifications_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ReplicationRule &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_Priority_:";
    s << t._Priority_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<",";
    s<< "_Status_:";
    s << t._Status_;
    s<<",";
    s<< "_SourceSelectionCriteria_:";
    s << t._SourceSelectionCriteria_;
    s<<",";
    s<< "_ExistingObjectReplication_:";
    s << t._ExistingObjectReplication_;
    s<<",";
    s<< "_Destination_:";
    s << t._Destination_;
    s<<",";
    s<< "_DeleteMarkerReplication_:";
    s << t._DeleteMarkerReplication_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ReplicationRule>(ivy_ser &res, const s3_test::_ReplicationRule&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<s3_test::option__string__>(res,t._ID_);
    res.close_field();
    res.open_field("_Priority_");
    __ser<s3_test::option__integer__>(res,t._Priority_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::option__string__>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___ReplicationRuleFilter__>(res,t._Filter_);
    res.close_field();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.open_field("_SourceSelectionCriteria_");
    __ser<s3_test::option___SourceSelectionCriteria__>(res,t._SourceSelectionCriteria_);
    res.close_field();
    res.open_field("_ExistingObjectReplication_");
    __ser<s3_test::option___ExistingObjectReplication__>(res,t._ExistingObjectReplication_);
    res.close_field();
    res.open_field("_Destination_");
    __ser<s3_test::_Destination>(res,t._Destination_);
    res.close_field();
    res.open_field("_DeleteMarkerReplication_");
    __ser<s3_test::option___DeleteMarkerReplication__>(res,t._DeleteMarkerReplication_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Redirect &t){
    s<<"{";
    s<< "_HostName_:";
    s << t._HostName_;
    s<<",";
    s<< "_HttpRedirectCode_:";
    s << t._HttpRedirectCode_;
    s<<",";
    s<< "_Protocol_:";
    s << t._Protocol_;
    s<<",";
    s<< "_ReplaceKeyPrefixWith_:";
    s << t._ReplaceKeyPrefixWith_;
    s<<",";
    s<< "_ReplaceKeyWith_:";
    s << t._ReplaceKeyWith_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Redirect>(ivy_ser &res, const s3_test::_Redirect&t){
    res.open_struct();
    res.open_field("_HostName_");
    __ser<s3_test::string>(res,t._HostName_);
    res.close_field();
    res.open_field("_HttpRedirectCode_");
    __ser<s3_test::string>(res,t._HttpRedirectCode_);
    res.close_field();
    res.open_field("_Protocol_");
    __ser<s3_test::string>(res,t._Protocol_);
    res.close_field();
    res.open_field("_ReplaceKeyPrefixWith_");
    __ser<s3_test::string>(res,t._ReplaceKeyPrefixWith_);
    res.close_field();
    res.open_field("_ReplaceKeyWith_");
    __ser<s3_test::string>(res,t._ReplaceKeyWith_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RoutingRule &t){
    s<<"{";
    s<< "_Condition_:";
    s << t._Condition_;
    s<<",";
    s<< "_Redirect_:";
    s << t._Redirect_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RoutingRule>(ivy_ser &res, const s3_test::_RoutingRule&t){
    res.open_struct();
    res.open_field("_Condition_");
    __ser<s3_test::option___Condition__>(res,t._Condition_);
    res.close_field();
    res.open_field("_Redirect_");
    __ser<s3_test::_Redirect>(res,t._Redirect_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockLegalHold &t){
    s<<"{";
    s<< "_Status_:";
    s << t._Status_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockLegalHold>(ivy_ser &res, const s3_test::_ObjectLockLegalHold&t){
    res.open_struct();
    res.open_field("_Status_");
    __ser<s3_test::string>(res,t._Status_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRule &t){
    s<<"{";
    s<< "_DefaultRetention_:";
    s << t._DefaultRetention_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockRule>(ivy_ser &res, const s3_test::_ObjectLockRule&t){
    res.open_struct();
    res.open_field("_DefaultRetention_");
    __ser<s3_test::_DefaultRetention>(res,t._DefaultRetention_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockConfiguration &t){
    s<<"{";
    s<< "_ObjectLockEnabled_:";
    s << t._ObjectLockEnabled_;
    s<<",";
    s<< "_Rule_:";
    s << t._Rule_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockConfiguration>(ivy_ser &res, const s3_test::_ObjectLockConfiguration&t){
    res.open_struct();
    res.open_field("_ObjectLockEnabled_");
    __ser<s3_test::string>(res,t._ObjectLockEnabled_);
    res.close_field();
    res.open_field("_Rule_");
    __ser<s3_test::_ObjectLockRule>(res,t._Rule_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectOutput &t){
    s<<"{";
    s<< "_Body_:";
    s << t._Body_;
    s<<",";
    s<< "_DeleteMarker_:";
    s << t._DeleteMarker_;
    s<<",";
    s<< "_AcceptRanges_:";
    s << t._AcceptRanges_;
    s<<",";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_Restore_:";
    s << t._Restore_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ContentLength_:";
    s << t._ContentLength_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_MissingMeta_:";
    s << t._MissingMeta_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_CacheControl_:";
    s << t._CacheControl_;
    s<<",";
    s<< "_ContentDisposition_:";
    s << t._ContentDisposition_;
    s<<",";
    s<< "_ContentEncoding_:";
    s << t._ContentEncoding_;
    s<<",";
    s<< "_ContentLanguage_:";
    s << t._ContentLanguage_;
    s<<",";
    s<< "_ContentRange_:";
    s << t._ContentRange_;
    s<<",";
    s<< "_ContentType_:";
    s << t._ContentType_;
    s<<",";
    s<< "_Expires_:";
    s << t._Expires_;
    s<<",";
    s<< "_WebsiteRedirectLocation_:";
    s << t._WebsiteRedirectLocation_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_Metadata_:";
    s << t._Metadata_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_RequestCharged_:";
    s << t._RequestCharged_;
    s<<",";
    s<< "_ReplicationStatus_:";
    s << t._ReplicationStatus_;
    s<<",";
    s<< "_PartsCount_:";
    s << t._PartsCount_;
    s<<",";
    s<< "_TagCount_:";
    s << t._TagCount_;
    s<<",";
    s<< "_ObjectLockMode_:";
    s << t._ObjectLockMode_;
    s<<",";
    s<< "_ObjectLockRetainUntilDate_:";
    s << t._ObjectLockRetainUntilDate_;
    s<<",";
    s<< "_ObjectLockLegalHoldStatus_:";
    s << t._ObjectLockLegalHoldStatus_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GetObjectOutput>(ivy_ser &res, const s3_test::_GetObjectOutput&t){
    res.open_struct();
    res.open_field("_Body_");
    __ser<s3_test::blob>(res,t._Body_);
    res.close_field();
    res.open_field("_DeleteMarker_");
    __ser<bool>(res,t._DeleteMarker_);
    res.close_field();
    res.open_field("_AcceptRanges_");
    __ser<s3_test::string>(res,t._AcceptRanges_);
    res.close_field();
    res.open_field("_Expiration_");
    __ser<s3_test::string>(res,t._Expiration_);
    res.close_field();
    res.open_field("_Restore_");
    __ser<s3_test::string>(res,t._Restore_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ContentLength_");
    __ser<int>(res,t._ContentLength_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_MissingMeta_");
    __ser<int>(res,t._MissingMeta_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_CacheControl_");
    __ser<s3_test::string>(res,t._CacheControl_);
    res.close_field();
    res.open_field("_ContentDisposition_");
    __ser<s3_test::string>(res,t._ContentDisposition_);
    res.close_field();
    res.open_field("_ContentEncoding_");
    __ser<s3_test::string>(res,t._ContentEncoding_);
    res.close_field();
    res.open_field("_ContentLanguage_");
    __ser<s3_test::string>(res,t._ContentLanguage_);
    res.close_field();
    res.open_field("_ContentRange_");
    __ser<s3_test::string>(res,t._ContentRange_);
    res.close_field();
    res.open_field("_ContentType_");
    __ser<s3_test::string>(res,t._ContentType_);
    res.close_field();
    res.open_field("_Expires_");
    __ser<int>(res,t._Expires_);
    res.close_field();
    res.open_field("_WebsiteRedirectLocation_");
    __ser<s3_test::string>(res,t._WebsiteRedirectLocation_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<s3_test::string>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_Metadata_");
    __ser<s3_test::unordered_map__string____string__>(res,t._Metadata_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::string>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::string>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<s3_test::string>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_RequestCharged_");
    __ser<s3_test::string>(res,t._RequestCharged_);
    res.close_field();
    res.open_field("_ReplicationStatus_");
    __ser<s3_test::string>(res,t._ReplicationStatus_);
    res.close_field();
    res.open_field("_PartsCount_");
    __ser<int>(res,t._PartsCount_);
    res.close_field();
    res.open_field("_TagCount_");
    __ser<int>(res,t._TagCount_);
    res.close_field();
    res.open_field("_ObjectLockMode_");
    __ser<s3_test::string>(res,t._ObjectLockMode_);
    res.close_field();
    res.open_field("_ObjectLockRetainUntilDate_");
    __ser<int>(res,t._ObjectLockRetainUntilDate_);
    res.close_field();
    res.open_field("_ObjectLockLegalHoldStatus_");
    __ser<s3_test::string>(res,t._ObjectLockLegalHoldStatus_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GetObjectRequest &t){
    s<<"{";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_IfMatch_:";
    s << t._IfMatch_;
    s<<",";
    s<< "_IfModifiedSince_:";
    s << t._IfModifiedSince_;
    s<<",";
    s<< "_IfNoneMatch_:";
    s << t._IfNoneMatch_;
    s<<",";
    s<< "_IfUnmodifiedSince_:";
    s << t._IfUnmodifiedSince_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Range_:";
    s << t._Range_;
    s<<",";
    s<< "_ResponseCacheControl_:";
    s << t._ResponseCacheControl_;
    s<<",";
    s<< "_ResponseContentDisposition_:";
    s << t._ResponseContentDisposition_;
    s<<",";
    s<< "_ResponseContentEncoding_:";
    s << t._ResponseContentEncoding_;
    s<<",";
    s<< "_ResponseContentLanguage_:";
    s << t._ResponseContentLanguage_;
    s<<",";
    s<< "_ResponseContentType_:";
    s << t._ResponseContentType_;
    s<<",";
    s<< "_ResponseExpires_:";
    s << t._ResponseExpires_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKey_:";
    s << t._SSECustomerKey_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_RequestPayer_:";
    s << t._RequestPayer_;
    s<<",";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<",";
    s<< "_ExpectedBucketOwner_:";
    s << t._ExpectedBucketOwner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GetObjectRequest>(ivy_ser &res, const s3_test::_GetObjectRequest&t){
    res.open_struct();
    res.open_field("_Bucket_");
    __ser<s3_test::string>(res,t._Bucket_);
    res.close_field();
    res.open_field("_IfMatch_");
    __ser<s3_test::option__string__>(res,t._IfMatch_);
    res.close_field();
    res.open_field("_IfModifiedSince_");
    __ser<s3_test::option__timestamp__>(res,t._IfModifiedSince_);
    res.close_field();
    res.open_field("_IfNoneMatch_");
    __ser<s3_test::option__string__>(res,t._IfNoneMatch_);
    res.close_field();
    res.open_field("_IfUnmodifiedSince_");
    __ser<s3_test::option__timestamp__>(res,t._IfUnmodifiedSince_);
    res.close_field();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_Range_");
    __ser<s3_test::option__string__>(res,t._Range_);
    res.close_field();
    res.open_field("_ResponseCacheControl_");
    __ser<s3_test::option__string__>(res,t._ResponseCacheControl_);
    res.close_field();
    res.open_field("_ResponseContentDisposition_");
    __ser<s3_test::option__string__>(res,t._ResponseContentDisposition_);
    res.close_field();
    res.open_field("_ResponseContentEncoding_");
    __ser<s3_test::option__string__>(res,t._ResponseContentEncoding_);
    res.close_field();
    res.open_field("_ResponseContentLanguage_");
    __ser<s3_test::option__string__>(res,t._ResponseContentLanguage_);
    res.close_field();
    res.open_field("_ResponseContentType_");
    __ser<s3_test::option__string__>(res,t._ResponseContentType_);
    res.close_field();
    res.open_field("_ResponseExpires_");
    __ser<s3_test::option__timestamp__>(res,t._ResponseExpires_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::option__string__>(res,t._VersionId_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::option__string__>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKey_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKey_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_RequestPayer_");
    __ser<s3_test::option__string__>(res,t._RequestPayer_);
    res.close_field();
    res.open_field("_PartNumber_");
    __ser<s3_test::option__integer__>(res,t._PartNumber_);
    res.close_field();
    res.open_field("_ExpectedBucketOwner_");
    __ser<s3_test::option__string__>(res,t._ExpectedBucketOwner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectLockRetention &t){
    s<<"{";
    s<< "_Mode_:";
    s << t._Mode_;
    s<<",";
    s<< "_RetainUntilDate_:";
    s << t._RetainUntilDate_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectLockRetention>(ivy_ser &res, const s3_test::_ObjectLockRetention&t){
    res.open_struct();
    res.open_field("_Mode_");
    __ser<s3_test::string>(res,t._Mode_);
    res.close_field();
    res.open_field("_RetainUntilDate_");
    __ser<int>(res,t._RetainUntilDate_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_GlacierJobParameters &t){
    s<<"{";
    s<< "_Tier_:";
    s << t._Tier_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_GlacierJobParameters>(ivy_ser &res, const s3_test::_GlacierJobParameters&t){
    res.open_struct();
    res.open_field("_Tier_");
    __ser<s3_test::string>(res,t._Tier_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Initiator &t){
    s<<"{";
    s<< "_ID_:";
    s << t._ID_;
    s<<",";
    s<< "_DisplayName_:";
    s << t._DisplayName_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Initiator>(ivy_ser &res, const s3_test::_Initiator&t){
    res.open_struct();
    res.open_field("_ID_");
    __ser<s3_test::string>(res,t._ID_);
    res.close_field();
    res.open_field("_DisplayName_");
    __ser<s3_test::string>(res,t._DisplayName_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONInput &t){
    s<<"{";
    s<< "_Type_:";
    s << t._Type_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_JSONInput>(ivy_ser &res, const s3_test::_JSONInput&t){
    res.open_struct();
    res.open_field("_Type_");
    __ser<s3_test::string>(res,t._Type_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ParquetInput &t){
    s<<"{";
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ParquetInput>(ivy_ser &res, const s3_test::_ParquetInput&t){
    res.open_struct();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_InputSerialization &t){
    s<<"{";
    s<< "_CSV_:";
    s << t._CSV_;
    s<<",";
    s<< "_CompressionType_:";
    s << t._CompressionType_;
    s<<",";
    s<< "_JSON_:";
    s << t._JSON_;
    s<<",";
    s<< "_Parquet_:";
    s << t._Parquet_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_InputSerialization>(ivy_ser &res, const s3_test::_InputSerialization&t){
    res.open_struct();
    res.open_field("_CSV_");
    __ser<s3_test::_CSVInput>(res,t._CSV_);
    res.close_field();
    res.open_field("_CompressionType_");
    __ser<s3_test::string>(res,t._CompressionType_);
    res.close_field();
    res.open_field("_JSON_");
    __ser<s3_test::_JSONInput>(res,t._JSON_);
    res.close_field();
    res.open_field("_Parquet_");
    __ser<s3_test::_ParquetInput>(res,t._Parquet_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_JSONOutput &t){
    s<<"{";
    s<< "_RecordDelimiter_:";
    s << t._RecordDelimiter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_JSONOutput>(ivy_ser &res, const s3_test::_JSONOutput&t){
    res.open_struct();
    res.open_field("_RecordDelimiter_");
    __ser<s3_test::string>(res,t._RecordDelimiter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_S3KeyFilter &t){
    s<<"{";
    s<< "_FilterRules_:";
    s << t._FilterRules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_S3KeyFilter>(ivy_ser &res, const s3_test::_S3KeyFilter&t){
    res.open_struct();
    res.open_field("_FilterRules_");
    __ser<s3_test::vector___FilterRule__>(res,t._FilterRules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_NotificationConfigurationFilter &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_NotificationConfigurationFilter>(ivy_ser &res, const s3_test::_NotificationConfigurationFilter&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::_S3KeyFilter>(res,t._Key_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LambdaFunctionConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_LambdaFunctionArn_:";
    s << t._LambdaFunctionArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LambdaFunctionConfiguration>(ivy_ser &res, const s3_test::_LambdaFunctionConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_LambdaFunctionArn_");
    __ser<s3_test::string>(res,t._LambdaFunctionArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_LifecycleConfiguration &t){
    s<<"{";
    s<< "_Rules_:";
    s << t._Rules_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_LifecycleConfiguration>(ivy_ser &res, const s3_test::_LifecycleConfiguration&t){
    res.open_struct();
    res.open_field("_Rules_");
    __ser<s3_test::vector___Rule__>(res,t._Rules_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MultipartUpload &t){
    s<<"{";
    s<< "_UploadId_:";
    s << t._UploadId_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Initiated_:";
    s << t._Initiated_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<",";
    s<< "_Initiator_:";
    s << t._Initiator_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MultipartUpload>(ivy_ser &res, const s3_test::_MultipartUpload&t){
    res.open_struct();
    res.open_field("_UploadId_");
    __ser<s3_test::string>(res,t._UploadId_);
    res.close_field();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_Initiated_");
    __ser<int>(res,t._Initiated_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.open_field("_Initiator_");
    __ser<s3_test::_Initiator>(res,t._Initiator_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ObjectVersion &t){
    s<<"{";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_IsLatest_:";
    s << t._IsLatest_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ObjectVersion>(ivy_ser &res, const s3_test::_ObjectVersion&t){
    res.open_struct();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_IsLatest_");
    __ser<bool>(res,t._IsLatest_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Object &t){
    s<<"{";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_Owner_:";
    s << t._Owner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Object>(ivy_ser &res, const s3_test::_Object&t){
    res.open_struct();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::string>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_Owner_");
    __ser<s3_test::_Owner>(res,t._Owner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Part &t){
    s<<"{";
    s<< "_PartNumber_:";
    s << t._PartNumber_;
    s<<",";
    s<< "_LastModified_:";
    s << t._LastModified_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_Size_:";
    s << t._Size_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Part>(ivy_ser &res, const s3_test::_Part&t){
    res.open_struct();
    res.open_field("_PartNumber_");
    __ser<int>(res,t._PartNumber_);
    res.close_field();
    res.open_field("_LastModified_");
    __ser<int>(res,t._LastModified_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_Size_");
    __ser<int>(res,t._Size_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_MetadataEntry &t){
    s<<"{";
    s<< "_Name_:";
    s << t._Name_;
    s<<",";
    s<< "_Value_:";
    s << t._Value_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_MetadataEntry>(ivy_ser &res, const s3_test::_MetadataEntry&t){
    res.open_struct();
    res.open_field("_Name_");
    __ser<s3_test::string>(res,t._Name_);
    res.close_field();
    res.open_field("_Value_");
    __ser<s3_test::string>(res,t._Value_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_TopicConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_TopicArn_:";
    s << t._TopicArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_TopicConfiguration>(ivy_ser &res, const s3_test::_TopicConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_TopicArn_");
    __ser<s3_test::string>(res,t._TopicArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_QueueConfiguration &t){
    s<<"{";
    s<< "_Id_:";
    s << t._Id_;
    s<<",";
    s<< "_QueueArn_:";
    s << t._QueueArn_;
    s<<",";
    s<< "_Events_:";
    s << t._Events_;
    s<<",";
    s<< "_Filter_:";
    s << t._Filter_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_QueueConfiguration>(ivy_ser &res, const s3_test::_QueueConfiguration&t){
    res.open_struct();
    res.open_field("_Id_");
    __ser<s3_test::option__string__>(res,t._Id_);
    res.close_field();
    res.open_field("_QueueArn_");
    __ser<s3_test::string>(res,t._QueueArn_);
    res.close_field();
    res.open_field("_Events_");
    __ser<s3_test::vector__string__>(res,t._Events_);
    res.close_field();
    res.open_field("_Filter_");
    __ser<s3_test::option___NotificationConfigurationFilter__>(res,t._Filter_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_Tagging &t){
    s<<"{";
    s<< "_TagSet_:";
    s << t._TagSet_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_Tagging>(ivy_ser &res, const s3_test::_Tagging&t){
    res.open_struct();
    res.open_field("_TagSet_");
    __ser<s3_test::vector___Tag__>(res,t._TagSet_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_S3Location &t){
    s<<"{";
    s<< "_BucketName_:";
    s << t._BucketName_;
    s<<",";
    s<< "_Prefix_:";
    s << t._Prefix_;
    s<<",";
    s<< "_Encryption_:";
    s << t._Encryption_;
    s<<",";
    s<< "_CannedACL_:";
    s << t._CannedACL_;
    s<<",";
    s<< "_AccessControlList_:";
    s << t._AccessControlList_;
    s<<",";
    s<< "_Tagging_:";
    s << t._Tagging_;
    s<<",";
    s<< "_UserMetadata_:";
    s << t._UserMetadata_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_S3Location>(ivy_ser &res, const s3_test::_S3Location&t){
    res.open_struct();
    res.open_field("_BucketName_");
    __ser<s3_test::string>(res,t._BucketName_);
    res.close_field();
    res.open_field("_Prefix_");
    __ser<s3_test::string>(res,t._Prefix_);
    res.close_field();
    res.open_field("_Encryption_");
    __ser<s3_test::option___Encryption__>(res,t._Encryption_);
    res.close_field();
    res.open_field("_CannedACL_");
    __ser<s3_test::option__string__>(res,t._CannedACL_);
    res.close_field();
    res.open_field("_AccessControlList_");
    __ser<s3_test::option__vector___Grant____>(res,t._AccessControlList_);
    res.close_field();
    res.open_field("_Tagging_");
    __ser<s3_test::option___Tagging__>(res,t._Tagging_);
    res.close_field();
    res.open_field("_UserMetadata_");
    __ser<s3_test::option__vector___MetadataEntry____>(res,t._UserMetadata_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputLocation &t){
    s<<"{";
    s<< "_S3_:";
    s << t._S3_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OutputLocation>(ivy_ser &res, const s3_test::_OutputLocation&t){
    res.open_struct();
    res.open_field("_S3_");
    __ser<s3_test::_S3Location>(res,t._S3_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_OutputSerialization &t){
    s<<"{";
    s<< "_CSV_:";
    s << t._CSV_;
    s<<",";
    s<< "_JSON_:";
    s << t._JSON_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_OutputSerialization>(ivy_ser &res, const s3_test::_OutputSerialization&t){
    res.open_struct();
    res.open_field("_CSV_");
    __ser<s3_test::_CSVOutput>(res,t._CSV_);
    res.close_field();
    res.open_field("_JSON_");
    __ser<s3_test::_JSONOutput>(res,t._JSON_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectOutput &t){
    s<<"{";
    s<< "_Expiration_:";
    s << t._Expiration_;
    s<<",";
    s<< "_ETag_:";
    s << t._ETag_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_VersionId_:";
    s << t._VersionId_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_SSEKMSEncryptionContext_:";
    s << t._SSEKMSEncryptionContext_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_RequestCharged_:";
    s << t._RequestCharged_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_PutObjectOutput>(ivy_ser &res, const s3_test::_PutObjectOutput&t){
    res.open_struct();
    res.open_field("_Expiration_");
    __ser<s3_test::string>(res,t._Expiration_);
    res.close_field();
    res.open_field("_ETag_");
    __ser<s3_test::string>(res,t._ETag_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<s3_test::string>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_VersionId_");
    __ser<s3_test::string>(res,t._VersionId_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::string>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::string>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<s3_test::string>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_SSEKMSEncryptionContext_");
    __ser<s3_test::string>(res,t._SSEKMSEncryptionContext_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<bool>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_RequestCharged_");
    __ser<s3_test::string>(res,t._RequestCharged_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_PutObjectRequest &t){
    s<<"{";
    s<< "_ACL_:";
    s << t._ACL_;
    s<<",";
    s<< "_Body_:";
    s << t._Body_;
    s<<",";
    s<< "_Bucket_:";
    s << t._Bucket_;
    s<<",";
    s<< "_CacheControl_:";
    s << t._CacheControl_;
    s<<",";
    s<< "_ContentDisposition_:";
    s << t._ContentDisposition_;
    s<<",";
    s<< "_ContentEncoding_:";
    s << t._ContentEncoding_;
    s<<",";
    s<< "_ContentLanguage_:";
    s << t._ContentLanguage_;
    s<<",";
    s<< "_ContentLength_:";
    s << t._ContentLength_;
    s<<",";
    s<< "_ContentMD5_:";
    s << t._ContentMD5_;
    s<<",";
    s<< "_ContentType_:";
    s << t._ContentType_;
    s<<",";
    s<< "_Expires_:";
    s << t._Expires_;
    s<<",";
    s<< "_GrantFullControl_:";
    s << t._GrantFullControl_;
    s<<",";
    s<< "_GrantRead_:";
    s << t._GrantRead_;
    s<<",";
    s<< "_GrantReadACP_:";
    s << t._GrantReadACP_;
    s<<",";
    s<< "_GrantWriteACP_:";
    s << t._GrantWriteACP_;
    s<<",";
    s<< "_Key_:";
    s << t._Key_;
    s<<",";
    s<< "_Metadata_:";
    s << t._Metadata_;
    s<<",";
    s<< "_ServerSideEncryption_:";
    s << t._ServerSideEncryption_;
    s<<",";
    s<< "_StorageClass_:";
    s << t._StorageClass_;
    s<<",";
    s<< "_WebsiteRedirectLocation_:";
    s << t._WebsiteRedirectLocation_;
    s<<",";
    s<< "_SSECustomerAlgorithm_:";
    s << t._SSECustomerAlgorithm_;
    s<<",";
    s<< "_SSECustomerKey_:";
    s << t._SSECustomerKey_;
    s<<",";
    s<< "_SSECustomerKeyMD5_:";
    s << t._SSECustomerKeyMD5_;
    s<<",";
    s<< "_SSEKMSKeyId_:";
    s << t._SSEKMSKeyId_;
    s<<",";
    s<< "_SSEKMSEncryptionContext_:";
    s << t._SSEKMSEncryptionContext_;
    s<<",";
    s<< "_BucketKeyEnabled_:";
    s << t._BucketKeyEnabled_;
    s<<",";
    s<< "_RequestPayer_:";
    s << t._RequestPayer_;
    s<<",";
    s<< "_Tagging_:";
    s << t._Tagging_;
    s<<",";
    s<< "_ObjectLockMode_:";
    s << t._ObjectLockMode_;
    s<<",";
    s<< "_ObjectLockRetainUntilDate_:";
    s << t._ObjectLockRetainUntilDate_;
    s<<",";
    s<< "_ObjectLockLegalHoldStatus_:";
    s << t._ObjectLockLegalHoldStatus_;
    s<<",";
    s<< "_ExpectedBucketOwner_:";
    s << t._ExpectedBucketOwner_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_PutObjectRequest>(ivy_ser &res, const s3_test::_PutObjectRequest&t){
    res.open_struct();
    res.open_field("_ACL_");
    __ser<s3_test::option__string__>(res,t._ACL_);
    res.close_field();
    res.open_field("_Body_");
    __ser<s3_test::option__blob__>(res,t._Body_);
    res.close_field();
    res.open_field("_Bucket_");
    __ser<s3_test::string>(res,t._Bucket_);
    res.close_field();
    res.open_field("_CacheControl_");
    __ser<s3_test::option__string__>(res,t._CacheControl_);
    res.close_field();
    res.open_field("_ContentDisposition_");
    __ser<s3_test::option__string__>(res,t._ContentDisposition_);
    res.close_field();
    res.open_field("_ContentEncoding_");
    __ser<s3_test::option__string__>(res,t._ContentEncoding_);
    res.close_field();
    res.open_field("_ContentLanguage_");
    __ser<s3_test::option__string__>(res,t._ContentLanguage_);
    res.close_field();
    res.open_field("_ContentLength_");
    __ser<s3_test::option__long__>(res,t._ContentLength_);
    res.close_field();
    res.open_field("_ContentMD5_");
    __ser<s3_test::option__string__>(res,t._ContentMD5_);
    res.close_field();
    res.open_field("_ContentType_");
    __ser<s3_test::option__string__>(res,t._ContentType_);
    res.close_field();
    res.open_field("_Expires_");
    __ser<s3_test::option__timestamp__>(res,t._Expires_);
    res.close_field();
    res.open_field("_GrantFullControl_");
    __ser<s3_test::option__string__>(res,t._GrantFullControl_);
    res.close_field();
    res.open_field("_GrantRead_");
    __ser<s3_test::option__string__>(res,t._GrantRead_);
    res.close_field();
    res.open_field("_GrantReadACP_");
    __ser<s3_test::option__string__>(res,t._GrantReadACP_);
    res.close_field();
    res.open_field("_GrantWriteACP_");
    __ser<s3_test::option__string__>(res,t._GrantWriteACP_);
    res.close_field();
    res.open_field("_Key_");
    __ser<s3_test::string>(res,t._Key_);
    res.close_field();
    res.open_field("_Metadata_");
    __ser<s3_test::option__unordered_map__string____string____>(res,t._Metadata_);
    res.close_field();
    res.open_field("_ServerSideEncryption_");
    __ser<s3_test::option__string__>(res,t._ServerSideEncryption_);
    res.close_field();
    res.open_field("_StorageClass_");
    __ser<s3_test::option__string__>(res,t._StorageClass_);
    res.close_field();
    res.open_field("_WebsiteRedirectLocation_");
    __ser<s3_test::option__string__>(res,t._WebsiteRedirectLocation_);
    res.close_field();
    res.open_field("_SSECustomerAlgorithm_");
    __ser<s3_test::option__string__>(res,t._SSECustomerAlgorithm_);
    res.close_field();
    res.open_field("_SSECustomerKey_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKey_);
    res.close_field();
    res.open_field("_SSECustomerKeyMD5_");
    __ser<s3_test::option__string__>(res,t._SSECustomerKeyMD5_);
    res.close_field();
    res.open_field("_SSEKMSKeyId_");
    __ser<s3_test::option__string__>(res,t._SSEKMSKeyId_);
    res.close_field();
    res.open_field("_SSEKMSEncryptionContext_");
    __ser<s3_test::option__string__>(res,t._SSEKMSEncryptionContext_);
    res.close_field();
    res.open_field("_BucketKeyEnabled_");
    __ser<s3_test::option__bool__>(res,t._BucketKeyEnabled_);
    res.close_field();
    res.open_field("_RequestPayer_");
    __ser<s3_test::option__string__>(res,t._RequestPayer_);
    res.close_field();
    res.open_field("_Tagging_");
    __ser<s3_test::option__string__>(res,t._Tagging_);
    res.close_field();
    res.open_field("_ObjectLockMode_");
    __ser<s3_test::option__string__>(res,t._ObjectLockMode_);
    res.close_field();
    res.open_field("_ObjectLockRetainUntilDate_");
    __ser<s3_test::option__timestamp__>(res,t._ObjectLockRetainUntilDate_);
    res.close_field();
    res.open_field("_ObjectLockLegalHoldStatus_");
    __ser<s3_test::option__string__>(res,t._ObjectLockLegalHoldStatus_);
    res.close_field();
    res.open_field("_ExpectedBucketOwner_");
    __ser<s3_test::option__string__>(res,t._ExpectedBucketOwner_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RequestProgress &t){
    s<<"{";
    s<< "_Enabled_:";
    s << t._Enabled_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RequestProgress>(ivy_ser &res, const s3_test::_RequestProgress&t){
    res.open_struct();
    res.open_field("_Enabled_");
    __ser<bool>(res,t._Enabled_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_SelectParameters &t){
    s<<"{";
    s<< "_InputSerialization_:";
    s << t._InputSerialization_;
    s<<",";
    s<< "_ExpressionType_:";
    s << t._ExpressionType_;
    s<<",";
    s<< "_Expression_:";
    s << t._Expression_;
    s<<",";
    s<< "_OutputSerialization_:";
    s << t._OutputSerialization_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_SelectParameters>(ivy_ser &res, const s3_test::_SelectParameters&t){
    res.open_struct();
    res.open_field("_InputSerialization_");
    __ser<s3_test::_InputSerialization>(res,t._InputSerialization_);
    res.close_field();
    res.open_field("_ExpressionType_");
    __ser<s3_test::string>(res,t._ExpressionType_);
    res.close_field();
    res.open_field("_Expression_");
    __ser<s3_test::string>(res,t._Expression_);
    res.close_field();
    res.open_field("_OutputSerialization_");
    __ser<s3_test::_OutputSerialization>(res,t._OutputSerialization_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_RestoreRequest &t){
    s<<"{";
    s<< "_Days_:";
    s << t._Days_;
    s<<",";
    s<< "_GlacierJobParameters_:";
    s << t._GlacierJobParameters_;
    s<<",";
    s<< "_Type_:";
    s << t._Type_;
    s<<",";
    s<< "_Tier_:";
    s << t._Tier_;
    s<<",";
    s<< "_Description_:";
    s << t._Description_;
    s<<",";
    s<< "_SelectParameters_:";
    s << t._SelectParameters_;
    s<<",";
    s<< "_OutputLocation_:";
    s << t._OutputLocation_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_RestoreRequest>(ivy_ser &res, const s3_test::_RestoreRequest&t){
    res.open_struct();
    res.open_field("_Days_");
    __ser<int>(res,t._Days_);
    res.close_field();
    res.open_field("_GlacierJobParameters_");
    __ser<s3_test::_GlacierJobParameters>(res,t._GlacierJobParameters_);
    res.close_field();
    res.open_field("_Type_");
    __ser<s3_test::string>(res,t._Type_);
    res.close_field();
    res.open_field("_Tier_");
    __ser<s3_test::string>(res,t._Tier_);
    res.close_field();
    res.open_field("_Description_");
    __ser<s3_test::string>(res,t._Description_);
    res.close_field();
    res.open_field("_SelectParameters_");
    __ser<s3_test::_SelectParameters>(res,t._SelectParameters_);
    res.close_field();
    res.open_field("_OutputLocation_");
    __ser<s3_test::_OutputLocation>(res,t._OutputLocation_);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const s3_test::_ScanRange &t){
    s<<"{";
    s<< "_Start_:";
    s << t._Start_;
    s<<",";
    s<< "_End_:";
    s << t._End_;
    s<<"}";
    return s;
}
template <>
void  __ser<s3_test::_ScanRange>(ivy_ser &res, const s3_test::_ScanRange&t){
    res.open_struct();
    res.open_field("_Start_");
    __ser<int>(res,t._Start_);
    res.close_field();
    res.open_field("_End_");
    __ser<int>(res,t._End_);
    res.close_field();
    res.close_struct();
}


int ask_ret(long long bound) {
    int res;
    while(true) {
        __ivy_out << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cerr << "value out of range" << std::endl;
    }
}



    class s3_test_repl : public s3_test {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assertion_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assertion failed\n";
            
            __ivy_exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assumption_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assumption failed\n";
            
            __ivy_exit(1);
        }
    }
    s3_test_repl() : s3_test(){}
    virtual void imp___PutObject__response_PutObjectOutput(const _PutObjectOutput& val){}
    virtual void imp___GetObject__response_GetObjectOutput(const _GetObjectOutput& val){}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
    int pos;
    syntax_error(int pos) : pos(pos) {}
};

void throw_syntax(int pos){
    throw syntax_error(pos);
}

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw_syntax(pos);
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    res.pos = pos;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw_syntax(pos);
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"') {
            char c = cmd[pos++];
            if (c == '\\') {
                if (pos == cmd.size())
                    throw_syntax(pos);
                c = cmd[pos++];
                c = (c == 'n') ? 10 : (c == 'r') ? 13 : (c == 't') ? 9 : c;
            }
            res.atom.push_back(c);
        }
        if(pos == cmd.size())
            throw_syntax(pos);
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw_syntax(pos);
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw_syntax(pos);
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
s3_test::_AbortIncompleteMultipartUpload _arg<s3_test::_AbortIncompleteMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AbortIncompleteMultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DaysAfterInitiation_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DaysAfterInitiation_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DaysAfterInitiation_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AbortIncompleteMultipartUpload>(ivy_deser &inp, s3_test::_AbortIncompleteMultipartUpload &res){
    inp.open_struct();
    inp.open_field("_DaysAfterInitiation_");
    __deser(inp,res._DaysAfterInitiation_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v,s3_test::_AbortIncompleteMultipartUpload &res){
    __from_solver(g,g.apply("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",v),res._DaysAfterInitiation_);
}
template <>
z3::expr  __to_solver<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v,s3_test::_AbortIncompleteMultipartUpload &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",v),val._DaysAfterInitiation_);
    return res;
}
template <>
void  __randomize<s3_test::_AbortIncompleteMultipartUpload>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_AbortIncompleteMultipartUpload._DaysAfterInitiation_",v));
}
template <>
s3_test::_AccessControlPolicy _arg<s3_test::_AccessControlPolicy>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AccessControlPolicy res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grants_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grants_ = _arg<s3_test::vector___Grant__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grants_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AccessControlPolicy>(ivy_deser &inp, s3_test::_AccessControlPolicy &res){
    inp.open_struct();
    inp.open_field("_Grants_");
    __deser(inp,res._Grants_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v,s3_test::_AccessControlPolicy &res){
    __from_solver(g,g.apply("_AccessControlPolicy._Grants_",v),res._Grants_);
    __from_solver(g,g.apply("_AccessControlPolicy._Owner_",v),res._Owner_);
}
template <>
z3::expr  __to_solver<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v,s3_test::_AccessControlPolicy &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AccessControlPolicy._Grants_",v),val._Grants_);
    res = res && __to_solver(g,g.apply("_AccessControlPolicy._Owner_",v),val._Owner_);
    return res;
}
template <>
void  __randomize<s3_test::_AccessControlPolicy>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___Grant__>(g,g.apply("_AccessControlPolicy._Grants_",v));
    __randomize<s3_test::_Owner>(g,g.apply("_AccessControlPolicy._Owner_",v));
}
template <>
s3_test::_AccessControlTranslation _arg<s3_test::_AccessControlTranslation>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AccessControlTranslation res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Owner_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AccessControlTranslation>(ivy_deser &inp, s3_test::_AccessControlTranslation &res){
    inp.open_struct();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v,s3_test::_AccessControlTranslation &res){
    __from_solver(g,g.apply("_AccessControlTranslation._Owner_",v),res._Owner_);
}
template <>
z3::expr  __to_solver<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v,s3_test::_AccessControlTranslation &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AccessControlTranslation._Owner_",v),val._Owner_);
    return res;
}
template <>
void  __randomize<s3_test::_AccessControlTranslation>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_AccessControlTranslation._Owner_",v));
}
template <>
s3_test::_AnalyticsAndOperator _arg<s3_test::_AnalyticsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsAndOperator>(ivy_deser &inp, s3_test::_AnalyticsAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v,s3_test::_AnalyticsAndOperator &res){
    __from_solver(g,g.apply("_AnalyticsAndOperator._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_AnalyticsAndOperator._Tags_",v),res._Tags_);
}
template <>
z3::expr  __to_solver<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v,s3_test::_AnalyticsAndOperator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AnalyticsAndOperator._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_AnalyticsAndOperator._Tags_",v),val._Tags_);
    return res;
}
template <>
void  __randomize<s3_test::_AnalyticsAndOperator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_AnalyticsAndOperator._Prefix_",v));
    __randomize<s3_test::vector___Tag__>(g,g.apply("_AnalyticsAndOperator._Tags_",v));
}
template <>
s3_test::_AnalyticsConfiguration _arg<s3_test::_AnalyticsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___AnalyticsFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClassAnalysis_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClassAnalysis_ = _arg<s3_test::_StorageClassAnalysis>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClassAnalysis_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsConfiguration>(ivy_deser &inp, s3_test::_AnalyticsConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_StorageClassAnalysis_");
    __deser(inp,res._StorageClassAnalysis_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v,s3_test::_AnalyticsConfiguration &res){
    __from_solver(g,g.apply("_AnalyticsConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_AnalyticsConfiguration._Filter_",v),res._Filter_);
    __from_solver(g,g.apply("_AnalyticsConfiguration._StorageClassAnalysis_",v),res._StorageClassAnalysis_);
}
template <>
z3::expr  __to_solver<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v,s3_test::_AnalyticsConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AnalyticsConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_AnalyticsConfiguration._Filter_",v),val._Filter_);
    res = res && __to_solver(g,g.apply("_AnalyticsConfiguration._StorageClassAnalysis_",v),val._StorageClassAnalysis_);
    return res;
}
template <>
void  __randomize<s3_test::_AnalyticsConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_AnalyticsConfiguration._Id_",v));
    __randomize<s3_test::option___AnalyticsFilter__>(g,g.apply("_AnalyticsConfiguration._Filter_",v));
    __randomize<s3_test::_StorageClassAnalysis>(g,g.apply("_AnalyticsConfiguration._StorageClassAnalysis_",v));
}
template <>
s3_test::_AnalyticsExportDestination _arg<s3_test::_AnalyticsExportDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsExportDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3BucketDestination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3BucketDestination_ = _arg<s3_test::_AnalyticsS3BucketDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3BucketDestination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsExportDestination>(ivy_deser &inp, s3_test::_AnalyticsExportDestination &res){
    inp.open_struct();
    inp.open_field("_S3BucketDestination_");
    __deser(inp,res._S3BucketDestination_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v,s3_test::_AnalyticsExportDestination &res){
    __from_solver(g,g.apply("_AnalyticsExportDestination._S3BucketDestination_",v),res._S3BucketDestination_);
}
template <>
z3::expr  __to_solver<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v,s3_test::_AnalyticsExportDestination &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AnalyticsExportDestination._S3BucketDestination_",v),val._S3BucketDestination_);
    return res;
}
template <>
void  __randomize<s3_test::_AnalyticsExportDestination>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_AnalyticsS3BucketDestination>(g,g.apply("_AnalyticsExportDestination._S3BucketDestination_",v));
}
template <>
s3_test::_AnalyticsFilter _arg<s3_test::_AnalyticsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_AnalyticsAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsFilter>(ivy_deser &inp, s3_test::_AnalyticsFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v,s3_test::_AnalyticsFilter &res){
    __from_solver(g,g.apply("_AnalyticsFilter._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_AnalyticsFilter._Tag_",v),res._Tag_);
    __from_solver(g,g.apply("_AnalyticsFilter._And_",v),res._And_);
}
template <>
z3::expr  __to_solver<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v,s3_test::_AnalyticsFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AnalyticsFilter._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_AnalyticsFilter._Tag_",v),val._Tag_);
    res = res && __to_solver(g,g.apply("_AnalyticsFilter._And_",v),val._And_);
    return res;
}
template <>
void  __randomize<s3_test::_AnalyticsFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_AnalyticsFilter._Prefix_",v));
    __randomize<s3_test::_Tag>(g,g.apply("_AnalyticsFilter._Tag_",v));
    __randomize<s3_test::_AnalyticsAndOperator>(g,g.apply("_AnalyticsFilter._And_",v));
}
template <>
s3_test::_AnalyticsS3BucketDestination _arg<s3_test::_AnalyticsS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_AnalyticsS3BucketDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Format_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Format_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Format_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_BucketAccountId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._BucketAccountId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketAccountId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Bucket_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_AnalyticsS3BucketDestination>(ivy_deser &inp, s3_test::_AnalyticsS3BucketDestination &res){
    inp.open_struct();
    inp.open_field("_Format_");
    __deser(inp,res._Format_);
    inp.close_field();
    inp.open_field("_BucketAccountId_");
    __deser(inp,res._BucketAccountId_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v,s3_test::_AnalyticsS3BucketDestination &res){
    __from_solver(g,g.apply("_AnalyticsS3BucketDestination._Format_",v),res._Format_);
    __from_solver(g,g.apply("_AnalyticsS3BucketDestination._BucketAccountId_",v),res._BucketAccountId_);
    __from_solver(g,g.apply("_AnalyticsS3BucketDestination._Bucket_",v),res._Bucket_);
    __from_solver(g,g.apply("_AnalyticsS3BucketDestination._Prefix_",v),res._Prefix_);
}
template <>
z3::expr  __to_solver<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v,s3_test::_AnalyticsS3BucketDestination &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_AnalyticsS3BucketDestination._Format_",v),val._Format_);
    res = res && __to_solver(g,g.apply("_AnalyticsS3BucketDestination._BucketAccountId_",v),val._BucketAccountId_);
    res = res && __to_solver(g,g.apply("_AnalyticsS3BucketDestination._Bucket_",v),val._Bucket_);
    res = res && __to_solver(g,g.apply("_AnalyticsS3BucketDestination._Prefix_",v),val._Prefix_);
    return res;
}
template <>
void  __randomize<s3_test::_AnalyticsS3BucketDestination>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_AnalyticsS3BucketDestination._Format_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_AnalyticsS3BucketDestination._BucketAccountId_",v));
    __randomize<s3_test::string>(g,g.apply("_AnalyticsS3BucketDestination._Bucket_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_AnalyticsS3BucketDestination._Prefix_",v));
}
template <>
s3_test::_Bucket _arg<s3_test::_Bucket>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Bucket res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_CreationDate_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._CreationDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CreationDate_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Bucket>(ivy_deser &inp, s3_test::_Bucket &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_CreationDate_");
    __deser(inp,res._CreationDate_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Bucket>( gen &g, const  z3::expr &v,s3_test::_Bucket &res){
    __from_solver(g,g.apply("_Bucket._Name_",v),res._Name_);
    __from_solver(g,g.apply("_Bucket._CreationDate_",v),res._CreationDate_);
}
template <>
z3::expr  __to_solver<s3_test::_Bucket>( gen &g, const  z3::expr &v,s3_test::_Bucket &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Bucket._Name_",v),val._Name_);
    res = res && __to_solver(g,g.apply("_Bucket._CreationDate_",v),val._CreationDate_);
    return res;
}
template <>
void  __randomize<s3_test::_Bucket>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Bucket._Name_",v));
    __randomize<int>(g,g.apply("_Bucket._CreationDate_",v));
}
template <>
s3_test::_BucketLifecycleConfiguration _arg<s3_test::_BucketLifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_BucketLifecycleConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Rules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Rules_ = _arg<s3_test::vector___LifecycleRule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_BucketLifecycleConfiguration>(ivy_deser &inp, s3_test::_BucketLifecycleConfiguration &res){
    inp.open_struct();
    inp.open_field("_Rules_");
    __deser(inp,res._Rules_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v,s3_test::_BucketLifecycleConfiguration &res){
    __from_solver(g,g.apply("_BucketLifecycleConfiguration._Rules_",v),res._Rules_);
}
template <>
z3::expr  __to_solver<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v,s3_test::_BucketLifecycleConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_BucketLifecycleConfiguration._Rules_",v),val._Rules_);
    return res;
}
template <>
void  __randomize<s3_test::_BucketLifecycleConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___LifecycleRule__>(g,g.apply("_BucketLifecycleConfiguration._Rules_",v));
}
template <>
s3_test::_CORSRule _arg<s3_test::_CORSRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CORSRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_AllowedHeaders_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._AllowedHeaders_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedHeaders_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_AllowedMethods_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._AllowedMethods_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedMethods_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_AllowedOrigins_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._AllowedOrigins_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowedOrigins_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ExposeHeaders_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ExposeHeaders_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExposeHeaders_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_MaxAgeSeconds_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._MaxAgeSeconds_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _MaxAgeSeconds_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CORSRule>(ivy_deser &inp, s3_test::_CORSRule &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_AllowedHeaders_");
    __deser(inp,res._AllowedHeaders_);
    inp.close_field();
    inp.open_field("_AllowedMethods_");
    __deser(inp,res._AllowedMethods_);
    inp.close_field();
    inp.open_field("_AllowedOrigins_");
    __deser(inp,res._AllowedOrigins_);
    inp.close_field();
    inp.open_field("_ExposeHeaders_");
    __deser(inp,res._ExposeHeaders_);
    inp.close_field();
    inp.open_field("_MaxAgeSeconds_");
    __deser(inp,res._MaxAgeSeconds_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CORSRule>( gen &g, const  z3::expr &v,s3_test::_CORSRule &res){
    __from_solver(g,g.apply("_CORSRule._ID_",v),res._ID_);
    __from_solver(g,g.apply("_CORSRule._AllowedHeaders_",v),res._AllowedHeaders_);
    __from_solver(g,g.apply("_CORSRule._AllowedMethods_",v),res._AllowedMethods_);
    __from_solver(g,g.apply("_CORSRule._AllowedOrigins_",v),res._AllowedOrigins_);
    __from_solver(g,g.apply("_CORSRule._ExposeHeaders_",v),res._ExposeHeaders_);
    __from_solver(g,g.apply("_CORSRule._MaxAgeSeconds_",v),res._MaxAgeSeconds_);
}
template <>
z3::expr  __to_solver<s3_test::_CORSRule>( gen &g, const  z3::expr &v,s3_test::_CORSRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CORSRule._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_CORSRule._AllowedHeaders_",v),val._AllowedHeaders_);
    res = res && __to_solver(g,g.apply("_CORSRule._AllowedMethods_",v),val._AllowedMethods_);
    res = res && __to_solver(g,g.apply("_CORSRule._AllowedOrigins_",v),val._AllowedOrigins_);
    res = res && __to_solver(g,g.apply("_CORSRule._ExposeHeaders_",v),val._ExposeHeaders_);
    res = res && __to_solver(g,g.apply("_CORSRule._MaxAgeSeconds_",v),val._MaxAgeSeconds_);
    return res;
}
template <>
void  __randomize<s3_test::_CORSRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_CORSRule._ID_",v));
    __randomize<s3_test::option__vector__string____>(g,g.apply("_CORSRule._AllowedHeaders_",v));
    __randomize<s3_test::vector__string__>(g,g.apply("_CORSRule._AllowedMethods_",v));
    __randomize<s3_test::vector__string__>(g,g.apply("_CORSRule._AllowedOrigins_",v));
    __randomize<s3_test::option__vector__string____>(g,g.apply("_CORSRule._ExposeHeaders_",v));
    __randomize<s3_test::option__integer__>(g,g.apply("_CORSRule._MaxAgeSeconds_",v));
}
template <>
s3_test::_CSVInput _arg<s3_test::_CSVInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CSVInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_FileHeaderInfo_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._FileHeaderInfo_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FileHeaderInfo_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Comments_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Comments_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Comments_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_QuoteEscapeCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._QuoteEscapeCharacter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteEscapeCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._RecordDelimiter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_FieldDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._FieldDelimiter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FieldDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_QuoteCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._QuoteCharacter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_AllowQuotedRecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._AllowQuotedRecordDelimiter_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AllowQuotedRecordDelimiter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CSVInput>(ivy_deser &inp, s3_test::_CSVInput &res){
    inp.open_struct();
    inp.open_field("_FileHeaderInfo_");
    __deser(inp,res._FileHeaderInfo_);
    inp.close_field();
    inp.open_field("_Comments_");
    __deser(inp,res._Comments_);
    inp.close_field();
    inp.open_field("_QuoteEscapeCharacter_");
    __deser(inp,res._QuoteEscapeCharacter_);
    inp.close_field();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.open_field("_FieldDelimiter_");
    __deser(inp,res._FieldDelimiter_);
    inp.close_field();
    inp.open_field("_QuoteCharacter_");
    __deser(inp,res._QuoteCharacter_);
    inp.close_field();
    inp.open_field("_AllowQuotedRecordDelimiter_");
    __deser(inp,res._AllowQuotedRecordDelimiter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CSVInput>( gen &g, const  z3::expr &v,s3_test::_CSVInput &res){
    __from_solver(g,g.apply("_CSVInput._FileHeaderInfo_",v),res._FileHeaderInfo_);
    __from_solver(g,g.apply("_CSVInput._Comments_",v),res._Comments_);
    __from_solver(g,g.apply("_CSVInput._QuoteEscapeCharacter_",v),res._QuoteEscapeCharacter_);
    __from_solver(g,g.apply("_CSVInput._RecordDelimiter_",v),res._RecordDelimiter_);
    __from_solver(g,g.apply("_CSVInput._FieldDelimiter_",v),res._FieldDelimiter_);
    __from_solver(g,g.apply("_CSVInput._QuoteCharacter_",v),res._QuoteCharacter_);
    __from_solver(g,g.apply("_CSVInput._AllowQuotedRecordDelimiter_",v),res._AllowQuotedRecordDelimiter_);
}
template <>
z3::expr  __to_solver<s3_test::_CSVInput>( gen &g, const  z3::expr &v,s3_test::_CSVInput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CSVInput._FileHeaderInfo_",v),val._FileHeaderInfo_);
    res = res && __to_solver(g,g.apply("_CSVInput._Comments_",v),val._Comments_);
    res = res && __to_solver(g,g.apply("_CSVInput._QuoteEscapeCharacter_",v),val._QuoteEscapeCharacter_);
    res = res && __to_solver(g,g.apply("_CSVInput._RecordDelimiter_",v),val._RecordDelimiter_);
    res = res && __to_solver(g,g.apply("_CSVInput._FieldDelimiter_",v),val._FieldDelimiter_);
    res = res && __to_solver(g,g.apply("_CSVInput._QuoteCharacter_",v),val._QuoteCharacter_);
    res = res && __to_solver(g,g.apply("_CSVInput._AllowQuotedRecordDelimiter_",v),val._AllowQuotedRecordDelimiter_);
    return res;
}
template <>
void  __randomize<s3_test::_CSVInput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_CSVInput._FileHeaderInfo_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVInput._Comments_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVInput._QuoteEscapeCharacter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVInput._RecordDelimiter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVInput._FieldDelimiter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVInput._QuoteCharacter_",v));
    __randomize<bool>(g,g.apply("_CSVInput._AllowQuotedRecordDelimiter_",v));
}
template <>
s3_test::_CSVOutput _arg<s3_test::_CSVOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CSVOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_QuoteFields_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._QuoteFields_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteFields_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_QuoteEscapeCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._QuoteEscapeCharacter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteEscapeCharacter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._RecordDelimiter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_FieldDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._FieldDelimiter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FieldDelimiter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_QuoteCharacter_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._QuoteCharacter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QuoteCharacter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CSVOutput>(ivy_deser &inp, s3_test::_CSVOutput &res){
    inp.open_struct();
    inp.open_field("_QuoteFields_");
    __deser(inp,res._QuoteFields_);
    inp.close_field();
    inp.open_field("_QuoteEscapeCharacter_");
    __deser(inp,res._QuoteEscapeCharacter_);
    inp.close_field();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.open_field("_FieldDelimiter_");
    __deser(inp,res._FieldDelimiter_);
    inp.close_field();
    inp.open_field("_QuoteCharacter_");
    __deser(inp,res._QuoteCharacter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CSVOutput>( gen &g, const  z3::expr &v,s3_test::_CSVOutput &res){
    __from_solver(g,g.apply("_CSVOutput._QuoteFields_",v),res._QuoteFields_);
    __from_solver(g,g.apply("_CSVOutput._QuoteEscapeCharacter_",v),res._QuoteEscapeCharacter_);
    __from_solver(g,g.apply("_CSVOutput._RecordDelimiter_",v),res._RecordDelimiter_);
    __from_solver(g,g.apply("_CSVOutput._FieldDelimiter_",v),res._FieldDelimiter_);
    __from_solver(g,g.apply("_CSVOutput._QuoteCharacter_",v),res._QuoteCharacter_);
}
template <>
z3::expr  __to_solver<s3_test::_CSVOutput>( gen &g, const  z3::expr &v,s3_test::_CSVOutput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CSVOutput._QuoteFields_",v),val._QuoteFields_);
    res = res && __to_solver(g,g.apply("_CSVOutput._QuoteEscapeCharacter_",v),val._QuoteEscapeCharacter_);
    res = res && __to_solver(g,g.apply("_CSVOutput._RecordDelimiter_",v),val._RecordDelimiter_);
    res = res && __to_solver(g,g.apply("_CSVOutput._FieldDelimiter_",v),val._FieldDelimiter_);
    res = res && __to_solver(g,g.apply("_CSVOutput._QuoteCharacter_",v),val._QuoteCharacter_);
    return res;
}
template <>
void  __randomize<s3_test::_CSVOutput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_CSVOutput._QuoteFields_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVOutput._QuoteEscapeCharacter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVOutput._RecordDelimiter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVOutput._FieldDelimiter_",v));
    __randomize<s3_test::string>(g,g.apply("_CSVOutput._QuoteCharacter_",v));
}
template <>
s3_test::_CommonPrefix _arg<s3_test::_CommonPrefix>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CommonPrefix res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CommonPrefix>(ivy_deser &inp, s3_test::_CommonPrefix &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v,s3_test::_CommonPrefix &res){
    __from_solver(g,g.apply("_CommonPrefix._Prefix_",v),res._Prefix_);
}
template <>
z3::expr  __to_solver<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v,s3_test::_CommonPrefix &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CommonPrefix._Prefix_",v),val._Prefix_);
    return res;
}
template <>
void  __randomize<s3_test::_CommonPrefix>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_CommonPrefix._Prefix_",v));
}
template <>
s3_test::_CompletedMultipartUpload _arg<s3_test::_CompletedMultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CompletedMultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Parts_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Parts_ = _arg<s3_test::vector___CompletedPart__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Parts_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CompletedMultipartUpload>(ivy_deser &inp, s3_test::_CompletedMultipartUpload &res){
    inp.open_struct();
    inp.open_field("_Parts_");
    __deser(inp,res._Parts_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v,s3_test::_CompletedMultipartUpload &res){
    __from_solver(g,g.apply("_CompletedMultipartUpload._Parts_",v),res._Parts_);
}
template <>
z3::expr  __to_solver<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v,s3_test::_CompletedMultipartUpload &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CompletedMultipartUpload._Parts_",v),val._Parts_);
    return res;
}
template <>
void  __randomize<s3_test::_CompletedMultipartUpload>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___CompletedPart__>(g,g.apply("_CompletedMultipartUpload._Parts_",v));
}
template <>
s3_test::_CompletedPart _arg<s3_test::_CompletedPart>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CompletedPart res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._PartNumber_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CompletedPart>(ivy_deser &inp, s3_test::_CompletedPart &res){
    inp.open_struct();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CompletedPart>( gen &g, const  z3::expr &v,s3_test::_CompletedPart &res){
    __from_solver(g,g.apply("_CompletedPart._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_CompletedPart._PartNumber_",v),res._PartNumber_);
}
template <>
z3::expr  __to_solver<s3_test::_CompletedPart>( gen &g, const  z3::expr &v,s3_test::_CompletedPart &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CompletedPart._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_CompletedPart._PartNumber_",v),val._PartNumber_);
    return res;
}
template <>
void  __randomize<s3_test::_CompletedPart>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_CompletedPart._ETag_",v));
    __randomize<int>(g,g.apply("_CompletedPart._PartNumber_",v));
}
template <>
s3_test::_Condition _arg<s3_test::_Condition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Condition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_HttpErrorCodeReturnedEquals_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._HttpErrorCodeReturnedEquals_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HttpErrorCodeReturnedEquals_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KeyPrefixEquals_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KeyPrefixEquals_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KeyPrefixEquals_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Condition>(ivy_deser &inp, s3_test::_Condition &res){
    inp.open_struct();
    inp.open_field("_HttpErrorCodeReturnedEquals_");
    __deser(inp,res._HttpErrorCodeReturnedEquals_);
    inp.close_field();
    inp.open_field("_KeyPrefixEquals_");
    __deser(inp,res._KeyPrefixEquals_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Condition>( gen &g, const  z3::expr &v,s3_test::_Condition &res){
    __from_solver(g,g.apply("_Condition._HttpErrorCodeReturnedEquals_",v),res._HttpErrorCodeReturnedEquals_);
    __from_solver(g,g.apply("_Condition._KeyPrefixEquals_",v),res._KeyPrefixEquals_);
}
template <>
z3::expr  __to_solver<s3_test::_Condition>( gen &g, const  z3::expr &v,s3_test::_Condition &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Condition._HttpErrorCodeReturnedEquals_",v),val._HttpErrorCodeReturnedEquals_);
    res = res && __to_solver(g,g.apply("_Condition._KeyPrefixEquals_",v),val._KeyPrefixEquals_);
    return res;
}
template <>
void  __randomize<s3_test::_Condition>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Condition._HttpErrorCodeReturnedEquals_",v));
    __randomize<s3_test::string>(g,g.apply("_Condition._KeyPrefixEquals_",v));
}
template <>
s3_test::_CreateBucketConfiguration _arg<s3_test::_CreateBucketConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_CreateBucketConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_LocationConstraint_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._LocationConstraint_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LocationConstraint_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_CreateBucketConfiguration>(ivy_deser &inp, s3_test::_CreateBucketConfiguration &res){
    inp.open_struct();
    inp.open_field("_LocationConstraint_");
    __deser(inp,res._LocationConstraint_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v,s3_test::_CreateBucketConfiguration &res){
    __from_solver(g,g.apply("_CreateBucketConfiguration._LocationConstraint_",v),res._LocationConstraint_);
}
template <>
z3::expr  __to_solver<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v,s3_test::_CreateBucketConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_CreateBucketConfiguration._LocationConstraint_",v),val._LocationConstraint_);
    return res;
}
template <>
void  __randomize<s3_test::_CreateBucketConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_CreateBucketConfiguration._LocationConstraint_",v));
}
template <>
s3_test::_DefaultRetention _arg<s3_test::_DefaultRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DefaultRetention res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Mode_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Mode_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Mode_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Years_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Years_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Years_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DefaultRetention>(ivy_deser &inp, s3_test::_DefaultRetention &res){
    inp.open_struct();
    inp.open_field("_Mode_");
    __deser(inp,res._Mode_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_Years_");
    __deser(inp,res._Years_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v,s3_test::_DefaultRetention &res){
    __from_solver(g,g.apply("_DefaultRetention._Mode_",v),res._Mode_);
    __from_solver(g,g.apply("_DefaultRetention._Days_",v),res._Days_);
    __from_solver(g,g.apply("_DefaultRetention._Years_",v),res._Years_);
}
template <>
z3::expr  __to_solver<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v,s3_test::_DefaultRetention &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_DefaultRetention._Mode_",v),val._Mode_);
    res = res && __to_solver(g,g.apply("_DefaultRetention._Days_",v),val._Days_);
    res = res && __to_solver(g,g.apply("_DefaultRetention._Years_",v),val._Years_);
    return res;
}
template <>
void  __randomize<s3_test::_DefaultRetention>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_DefaultRetention._Mode_",v));
    __randomize<int>(g,g.apply("_DefaultRetention._Days_",v));
    __randomize<int>(g,g.apply("_DefaultRetention._Years_",v));
}
template <>
s3_test::_DeleteMarkerEntry _arg<s3_test::_DeleteMarkerEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeleteMarkerEntry res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_IsLatest_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._IsLatest_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsLatest_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeleteMarkerEntry>(ivy_deser &inp, s3_test::_DeleteMarkerEntry &res){
    inp.open_struct();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_IsLatest_");
    __deser(inp,res._IsLatest_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v,s3_test::_DeleteMarkerEntry &res){
    __from_solver(g,g.apply("_DeleteMarkerEntry._Owner_",v),res._Owner_);
    __from_solver(g,g.apply("_DeleteMarkerEntry._Key_",v),res._Key_);
    __from_solver(g,g.apply("_DeleteMarkerEntry._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_DeleteMarkerEntry._IsLatest_",v),res._IsLatest_);
    __from_solver(g,g.apply("_DeleteMarkerEntry._LastModified_",v),res._LastModified_);
}
template <>
z3::expr  __to_solver<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v,s3_test::_DeleteMarkerEntry &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_DeleteMarkerEntry._Owner_",v),val._Owner_);
    res = res && __to_solver(g,g.apply("_DeleteMarkerEntry._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_DeleteMarkerEntry._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_DeleteMarkerEntry._IsLatest_",v),val._IsLatest_);
    res = res && __to_solver(g,g.apply("_DeleteMarkerEntry._LastModified_",v),val._LastModified_);
    return res;
}
template <>
void  __randomize<s3_test::_DeleteMarkerEntry>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_Owner>(g,g.apply("_DeleteMarkerEntry._Owner_",v));
    __randomize<s3_test::string>(g,g.apply("_DeleteMarkerEntry._Key_",v));
    __randomize<s3_test::string>(g,g.apply("_DeleteMarkerEntry._VersionId_",v));
    __randomize<bool>(g,g.apply("_DeleteMarkerEntry._IsLatest_",v));
    __randomize<int>(g,g.apply("_DeleteMarkerEntry._LastModified_",v));
}
template <>
s3_test::_DeleteMarkerReplication _arg<s3_test::_DeleteMarkerReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeleteMarkerReplication res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeleteMarkerReplication>(ivy_deser &inp, s3_test::_DeleteMarkerReplication &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v,s3_test::_DeleteMarkerReplication &res){
    __from_solver(g,g.apply("_DeleteMarkerReplication._Status_",v),res._Status_);
}
template <>
z3::expr  __to_solver<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v,s3_test::_DeleteMarkerReplication &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_DeleteMarkerReplication._Status_",v),val._Status_);
    return res;
}
template <>
void  __randomize<s3_test::_DeleteMarkerReplication>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_DeleteMarkerReplication._Status_",v));
}
template <>
s3_test::_DeletedObject _arg<s3_test::_DeletedObject>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_DeletedObject res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_DeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._DeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarker_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_DeleteMarkerVersionId_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._DeleteMarkerVersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarkerVersionId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_DeletedObject>(ivy_deser &inp, s3_test::_DeletedObject &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_DeleteMarker_");
    __deser(inp,res._DeleteMarker_);
    inp.close_field();
    inp.open_field("_DeleteMarkerVersionId_");
    __deser(inp,res._DeleteMarkerVersionId_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_DeletedObject>( gen &g, const  z3::expr &v,s3_test::_DeletedObject &res){
    __from_solver(g,g.apply("_DeletedObject._Key_",v),res._Key_);
    __from_solver(g,g.apply("_DeletedObject._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_DeletedObject._DeleteMarker_",v),res._DeleteMarker_);
    __from_solver(g,g.apply("_DeletedObject._DeleteMarkerVersionId_",v),res._DeleteMarkerVersionId_);
}
template <>
z3::expr  __to_solver<s3_test::_DeletedObject>( gen &g, const  z3::expr &v,s3_test::_DeletedObject &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_DeletedObject._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_DeletedObject._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_DeletedObject._DeleteMarker_",v),val._DeleteMarker_);
    res = res && __to_solver(g,g.apply("_DeletedObject._DeleteMarkerVersionId_",v),val._DeleteMarkerVersionId_);
    return res;
}
template <>
void  __randomize<s3_test::_DeletedObject>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_DeletedObject._Key_",v));
    __randomize<s3_test::string>(g,g.apply("_DeletedObject._VersionId_",v));
    __randomize<bool>(g,g.apply("_DeletedObject._DeleteMarker_",v));
    __randomize<s3_test::string>(g,g.apply("_DeletedObject._DeleteMarkerVersionId_",v));
}
template <>
s3_test::_Destination _arg<s3_test::_Destination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Destination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Bucket_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Account_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Account_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Account_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_AccessControlTranslation_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._AccessControlTranslation_ = _arg<s3_test::option___AccessControlTranslation__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessControlTranslation_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_EncryptionConfiguration_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._EncryptionConfiguration_ = _arg<s3_test::option___EncryptionConfiguration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EncryptionConfiguration_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_ReplicationTime_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._ReplicationTime_ = _arg<s3_test::option___ReplicationTime__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicationTime_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Metrics_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Metrics_ = _arg<s3_test::option___Metrics__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metrics_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Destination>(ivy_deser &inp, s3_test::_Destination &res){
    inp.open_struct();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Account_");
    __deser(inp,res._Account_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_AccessControlTranslation_");
    __deser(inp,res._AccessControlTranslation_);
    inp.close_field();
    inp.open_field("_EncryptionConfiguration_");
    __deser(inp,res._EncryptionConfiguration_);
    inp.close_field();
    inp.open_field("_ReplicationTime_");
    __deser(inp,res._ReplicationTime_);
    inp.close_field();
    inp.open_field("_Metrics_");
    __deser(inp,res._Metrics_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Destination>( gen &g, const  z3::expr &v,s3_test::_Destination &res){
    __from_solver(g,g.apply("_Destination._Bucket_",v),res._Bucket_);
    __from_solver(g,g.apply("_Destination._Account_",v),res._Account_);
    __from_solver(g,g.apply("_Destination._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_Destination._AccessControlTranslation_",v),res._AccessControlTranslation_);
    __from_solver(g,g.apply("_Destination._EncryptionConfiguration_",v),res._EncryptionConfiguration_);
    __from_solver(g,g.apply("_Destination._ReplicationTime_",v),res._ReplicationTime_);
    __from_solver(g,g.apply("_Destination._Metrics_",v),res._Metrics_);
}
template <>
z3::expr  __to_solver<s3_test::_Destination>( gen &g, const  z3::expr &v,s3_test::_Destination &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Destination._Bucket_",v),val._Bucket_);
    res = res && __to_solver(g,g.apply("_Destination._Account_",v),val._Account_);
    res = res && __to_solver(g,g.apply("_Destination._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_Destination._AccessControlTranslation_",v),val._AccessControlTranslation_);
    res = res && __to_solver(g,g.apply("_Destination._EncryptionConfiguration_",v),val._EncryptionConfiguration_);
    res = res && __to_solver(g,g.apply("_Destination._ReplicationTime_",v),val._ReplicationTime_);
    res = res && __to_solver(g,g.apply("_Destination._Metrics_",v),val._Metrics_);
    return res;
}
template <>
void  __randomize<s3_test::_Destination>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Destination._Bucket_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Destination._Account_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Destination._StorageClass_",v));
    __randomize<s3_test::option___AccessControlTranslation__>(g,g.apply("_Destination._AccessControlTranslation_",v));
    __randomize<s3_test::option___EncryptionConfiguration__>(g,g.apply("_Destination._EncryptionConfiguration_",v));
    __randomize<s3_test::option___ReplicationTime__>(g,g.apply("_Destination._ReplicationTime_",v));
    __randomize<s3_test::option___Metrics__>(g,g.apply("_Destination._Metrics_",v));
}
template <>
s3_test::_Encryption _arg<s3_test::_Encryption>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Encryption res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_EncryptionType_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._EncryptionType_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EncryptionType_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KMSKeyId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_KMSContext_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._KMSContext_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSContext_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Encryption>(ivy_deser &inp, s3_test::_Encryption &res){
    inp.open_struct();
    inp.open_field("_EncryptionType_");
    __deser(inp,res._EncryptionType_);
    inp.close_field();
    inp.open_field("_KMSKeyId_");
    __deser(inp,res._KMSKeyId_);
    inp.close_field();
    inp.open_field("_KMSContext_");
    __deser(inp,res._KMSContext_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Encryption>( gen &g, const  z3::expr &v,s3_test::_Encryption &res){
    __from_solver(g,g.apply("_Encryption._EncryptionType_",v),res._EncryptionType_);
    __from_solver(g,g.apply("_Encryption._KMSKeyId_",v),res._KMSKeyId_);
    __from_solver(g,g.apply("_Encryption._KMSContext_",v),res._KMSContext_);
}
template <>
z3::expr  __to_solver<s3_test::_Encryption>( gen &g, const  z3::expr &v,s3_test::_Encryption &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Encryption._EncryptionType_",v),val._EncryptionType_);
    res = res && __to_solver(g,g.apply("_Encryption._KMSKeyId_",v),val._KMSKeyId_);
    res = res && __to_solver(g,g.apply("_Encryption._KMSContext_",v),val._KMSContext_);
    return res;
}
template <>
void  __randomize<s3_test::_Encryption>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Encryption._EncryptionType_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Encryption._KMSKeyId_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Encryption._KMSContext_",v));
}
template <>
s3_test::_EncryptionConfiguration _arg<s3_test::_EncryptionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_EncryptionConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ReplicaKmsKeyID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ReplicaKmsKeyID_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicaKmsKeyID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_EncryptionConfiguration>(ivy_deser &inp, s3_test::_EncryptionConfiguration &res){
    inp.open_struct();
    inp.open_field("_ReplicaKmsKeyID_");
    __deser(inp,res._ReplicaKmsKeyID_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v,s3_test::_EncryptionConfiguration &res){
    __from_solver(g,g.apply("_EncryptionConfiguration._ReplicaKmsKeyID_",v),res._ReplicaKmsKeyID_);
}
template <>
z3::expr  __to_solver<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v,s3_test::_EncryptionConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_EncryptionConfiguration._ReplicaKmsKeyID_",v),val._ReplicaKmsKeyID_);
    return res;
}
template <>
void  __randomize<s3_test::_EncryptionConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_EncryptionConfiguration._ReplicaKmsKeyID_",v));
}
template <>
s3_test::_Error _arg<s3_test::_Error>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Error res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Code_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Code_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Code_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Message_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Message_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Message_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Error>(ivy_deser &inp, s3_test::_Error &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_Code_");
    __deser(inp,res._Code_);
    inp.close_field();
    inp.open_field("_Message_");
    __deser(inp,res._Message_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Error>( gen &g, const  z3::expr &v,s3_test::_Error &res){
    __from_solver(g,g.apply("_Error._Key_",v),res._Key_);
    __from_solver(g,g.apply("_Error._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_Error._Code_",v),res._Code_);
    __from_solver(g,g.apply("_Error._Message_",v),res._Message_);
}
template <>
z3::expr  __to_solver<s3_test::_Error>( gen &g, const  z3::expr &v,s3_test::_Error &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Error._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_Error._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_Error._Code_",v),val._Code_);
    res = res && __to_solver(g,g.apply("_Error._Message_",v),val._Message_);
    return res;
}
template <>
void  __randomize<s3_test::_Error>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Error._Key_",v));
    __randomize<s3_test::string>(g,g.apply("_Error._VersionId_",v));
    __randomize<s3_test::string>(g,g.apply("_Error._Code_",v));
    __randomize<s3_test::string>(g,g.apply("_Error._Message_",v));
}
template <>
s3_test::_ExistingObjectReplication _arg<s3_test::_ExistingObjectReplication>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ExistingObjectReplication res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ExistingObjectReplication>(ivy_deser &inp, s3_test::_ExistingObjectReplication &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v,s3_test::_ExistingObjectReplication &res){
    __from_solver(g,g.apply("_ExistingObjectReplication._Status_",v),res._Status_);
}
template <>
z3::expr  __to_solver<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v,s3_test::_ExistingObjectReplication &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ExistingObjectReplication._Status_",v),val._Status_);
    return res;
}
template <>
void  __randomize<s3_test::_ExistingObjectReplication>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ExistingObjectReplication._Status_",v));
}
template <>
s3_test::_FilterRule _arg<s3_test::_FilterRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_FilterRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_FilterRule>(ivy_deser &inp, s3_test::_FilterRule &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_FilterRule>( gen &g, const  z3::expr &v,s3_test::_FilterRule &res){
    __from_solver(g,g.apply("_FilterRule._Name_",v),res._Name_);
    __from_solver(g,g.apply("_FilterRule._Value_",v),res._Value_);
}
template <>
z3::expr  __to_solver<s3_test::_FilterRule>( gen &g, const  z3::expr &v,s3_test::_FilterRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_FilterRule._Name_",v),val._Name_);
    res = res && __to_solver(g,g.apply("_FilterRule._Value_",v),val._Value_);
    return res;
}
template <>
void  __randomize<s3_test::_FilterRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_FilterRule._Name_",v));
    __randomize<s3_test::string>(g,g.apply("_FilterRule._Value_",v));
}
template <>
s3_test::_GetObjectOutput _arg<s3_test::_GetObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GetObjectOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 32) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Body_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Body_ = _arg<s3_test::blob>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Body_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_DeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._DeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarker_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_AcceptRanges_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._AcceptRanges_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AcceptRanges_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Expiration_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Restore_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Restore_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Restore_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ContentLength_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ContentLength_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLength_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_MissingMeta_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._MissingMeta_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _MissingMeta_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_CacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._CacheControl_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_ContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._ContentDisposition_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_ContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._ContentEncoding_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_ContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._ContentLanguage_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_ContentRange_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._ContentRange_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentRange_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_ContentType_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._ContentType_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_Expires_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._Expires_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expires_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_WebsiteRedirectLocation_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._WebsiteRedirectLocation_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _WebsiteRedirectLocation_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._ServerSideEncryption_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_Metadata_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._Metadata_ = _arg<s3_test::unordered_map__string____string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metadata_: " + err.txt,err.pos);
    }
    if (arg.fields[20].is_member()){
        tmp_args[0] = arg.fields[20].fields[0];
        if (arg.fields[20].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[20].atom,arg.fields[20].pos);
    }
    else{
        tmp_args[0] = arg.fields[20];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[21].is_member()){
        tmp_args[0] = arg.fields[21].fields[0];
        if (arg.fields[21].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[21].atom,arg.fields[21].pos);
    }
    else{
        tmp_args[0] = arg.fields[21];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[22].is_member()){
        tmp_args[0] = arg.fields[22].fields[0];
        if (arg.fields[22].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[22].atom,arg.fields[22].pos);
    }
    else{
        tmp_args[0] = arg.fields[22];
    }
    try{
        res._SSEKMSKeyId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[23].is_member()){
        tmp_args[0] = arg.fields[23].fields[0];
        if (arg.fields[23].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[23].atom,arg.fields[23].pos);
    }
    else{
        tmp_args[0] = arg.fields[23];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[24].is_member()){
        tmp_args[0] = arg.fields[24].fields[0];
        if (arg.fields[24].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[24].atom,arg.fields[24].pos);
    }
    else{
        tmp_args[0] = arg.fields[24];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[25].is_member()){
        tmp_args[0] = arg.fields[25].fields[0];
        if (arg.fields[25].atom != "_RequestCharged_") throw out_of_bounds("unexpected field: " + arg.fields[25].atom,arg.fields[25].pos);
    }
    else{
        tmp_args[0] = arg.fields[25];
    }
    try{
        res._RequestCharged_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestCharged_: " + err.txt,err.pos);
    }
    if (arg.fields[26].is_member()){
        tmp_args[0] = arg.fields[26].fields[0];
        if (arg.fields[26].atom != "_ReplicationStatus_") throw out_of_bounds("unexpected field: " + arg.fields[26].atom,arg.fields[26].pos);
    }
    else{
        tmp_args[0] = arg.fields[26];
    }
    try{
        res._ReplicationStatus_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicationStatus_: " + err.txt,err.pos);
    }
    if (arg.fields[27].is_member()){
        tmp_args[0] = arg.fields[27].fields[0];
        if (arg.fields[27].atom != "_PartsCount_") throw out_of_bounds("unexpected field: " + arg.fields[27].atom,arg.fields[27].pos);
    }
    else{
        tmp_args[0] = arg.fields[27];
    }
    try{
        res._PartsCount_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartsCount_: " + err.txt,err.pos);
    }
    if (arg.fields[28].is_member()){
        tmp_args[0] = arg.fields[28].fields[0];
        if (arg.fields[28].atom != "_TagCount_") throw out_of_bounds("unexpected field: " + arg.fields[28].atom,arg.fields[28].pos);
    }
    else{
        tmp_args[0] = arg.fields[28];
    }
    try{
        res._TagCount_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TagCount_: " + err.txt,err.pos);
    }
    if (arg.fields[29].is_member()){
        tmp_args[0] = arg.fields[29].fields[0];
        if (arg.fields[29].atom != "_ObjectLockMode_") throw out_of_bounds("unexpected field: " + arg.fields[29].atom,arg.fields[29].pos);
    }
    else{
        tmp_args[0] = arg.fields[29];
    }
    try{
        res._ObjectLockMode_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockMode_: " + err.txt,err.pos);
    }
    if (arg.fields[30].is_member()){
        tmp_args[0] = arg.fields[30].fields[0];
        if (arg.fields[30].atom != "_ObjectLockRetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[30].atom,arg.fields[30].pos);
    }
    else{
        tmp_args[0] = arg.fields[30];
    }
    try{
        res._ObjectLockRetainUntilDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockRetainUntilDate_: " + err.txt,err.pos);
    }
    if (arg.fields[31].is_member()){
        tmp_args[0] = arg.fields[31].fields[0];
        if (arg.fields[31].atom != "_ObjectLockLegalHoldStatus_") throw out_of_bounds("unexpected field: " + arg.fields[31].atom,arg.fields[31].pos);
    }
    else{
        tmp_args[0] = arg.fields[31];
    }
    try{
        res._ObjectLockLegalHoldStatus_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockLegalHoldStatus_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GetObjectOutput>(ivy_deser &inp, s3_test::_GetObjectOutput &res){
    inp.open_struct();
    inp.open_field("_Body_");
    __deser(inp,res._Body_);
    inp.close_field();
    inp.open_field("_DeleteMarker_");
    __deser(inp,res._DeleteMarker_);
    inp.close_field();
    inp.open_field("_AcceptRanges_");
    __deser(inp,res._AcceptRanges_);
    inp.close_field();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_Restore_");
    __deser(inp,res._Restore_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ContentLength_");
    __deser(inp,res._ContentLength_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_MissingMeta_");
    __deser(inp,res._MissingMeta_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_CacheControl_");
    __deser(inp,res._CacheControl_);
    inp.close_field();
    inp.open_field("_ContentDisposition_");
    __deser(inp,res._ContentDisposition_);
    inp.close_field();
    inp.open_field("_ContentEncoding_");
    __deser(inp,res._ContentEncoding_);
    inp.close_field();
    inp.open_field("_ContentLanguage_");
    __deser(inp,res._ContentLanguage_);
    inp.close_field();
    inp.open_field("_ContentRange_");
    __deser(inp,res._ContentRange_);
    inp.close_field();
    inp.open_field("_ContentType_");
    __deser(inp,res._ContentType_);
    inp.close_field();
    inp.open_field("_Expires_");
    __deser(inp,res._Expires_);
    inp.close_field();
    inp.open_field("_WebsiteRedirectLocation_");
    __deser(inp,res._WebsiteRedirectLocation_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_Metadata_");
    __deser(inp,res._Metadata_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_RequestCharged_");
    __deser(inp,res._RequestCharged_);
    inp.close_field();
    inp.open_field("_ReplicationStatus_");
    __deser(inp,res._ReplicationStatus_);
    inp.close_field();
    inp.open_field("_PartsCount_");
    __deser(inp,res._PartsCount_);
    inp.close_field();
    inp.open_field("_TagCount_");
    __deser(inp,res._TagCount_);
    inp.close_field();
    inp.open_field("_ObjectLockMode_");
    __deser(inp,res._ObjectLockMode_);
    inp.close_field();
    inp.open_field("_ObjectLockRetainUntilDate_");
    __deser(inp,res._ObjectLockRetainUntilDate_);
    inp.close_field();
    inp.open_field("_ObjectLockLegalHoldStatus_");
    __deser(inp,res._ObjectLockLegalHoldStatus_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v,s3_test::_GetObjectOutput &res){
    __from_solver(g,g.apply("_GetObjectOutput._Body_",v),res._Body_);
    __from_solver(g,g.apply("_GetObjectOutput._DeleteMarker_",v),res._DeleteMarker_);
    __from_solver(g,g.apply("_GetObjectOutput._AcceptRanges_",v),res._AcceptRanges_);
    __from_solver(g,g.apply("_GetObjectOutput._Expiration_",v),res._Expiration_);
    __from_solver(g,g.apply("_GetObjectOutput._Restore_",v),res._Restore_);
    __from_solver(g,g.apply("_GetObjectOutput._LastModified_",v),res._LastModified_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentLength_",v),res._ContentLength_);
    __from_solver(g,g.apply("_GetObjectOutput._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_GetObjectOutput._MissingMeta_",v),res._MissingMeta_);
    __from_solver(g,g.apply("_GetObjectOutput._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_GetObjectOutput._CacheControl_",v),res._CacheControl_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentDisposition_",v),res._ContentDisposition_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentEncoding_",v),res._ContentEncoding_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentLanguage_",v),res._ContentLanguage_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentRange_",v),res._ContentRange_);
    __from_solver(g,g.apply("_GetObjectOutput._ContentType_",v),res._ContentType_);
    __from_solver(g,g.apply("_GetObjectOutput._Expires_",v),res._Expires_);
    __from_solver(g,g.apply("_GetObjectOutput._WebsiteRedirectLocation_",v),res._WebsiteRedirectLocation_);
    __from_solver(g,g.apply("_GetObjectOutput._ServerSideEncryption_",v),res._ServerSideEncryption_);
    __from_solver(g,g.apply("_GetObjectOutput._Metadata_",v),res._Metadata_);
    __from_solver(g,g.apply("_GetObjectOutput._SSECustomerAlgorithm_",v),res._SSECustomerAlgorithm_);
    __from_solver(g,g.apply("_GetObjectOutput._SSECustomerKeyMD5_",v),res._SSECustomerKeyMD5_);
    __from_solver(g,g.apply("_GetObjectOutput._SSEKMSKeyId_",v),res._SSEKMSKeyId_);
    __from_solver(g,g.apply("_GetObjectOutput._BucketKeyEnabled_",v),res._BucketKeyEnabled_);
    __from_solver(g,g.apply("_GetObjectOutput._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_GetObjectOutput._RequestCharged_",v),res._RequestCharged_);
    __from_solver(g,g.apply("_GetObjectOutput._ReplicationStatus_",v),res._ReplicationStatus_);
    __from_solver(g,g.apply("_GetObjectOutput._PartsCount_",v),res._PartsCount_);
    __from_solver(g,g.apply("_GetObjectOutput._TagCount_",v),res._TagCount_);
    __from_solver(g,g.apply("_GetObjectOutput._ObjectLockMode_",v),res._ObjectLockMode_);
    __from_solver(g,g.apply("_GetObjectOutput._ObjectLockRetainUntilDate_",v),res._ObjectLockRetainUntilDate_);
    __from_solver(g,g.apply("_GetObjectOutput._ObjectLockLegalHoldStatus_",v),res._ObjectLockLegalHoldStatus_);
}
template <>
z3::expr  __to_solver<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v,s3_test::_GetObjectOutput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._Body_",v),val._Body_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._DeleteMarker_",v),val._DeleteMarker_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._AcceptRanges_",v),val._AcceptRanges_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._Expiration_",v),val._Expiration_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._Restore_",v),val._Restore_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._LastModified_",v),val._LastModified_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentLength_",v),val._ContentLength_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._MissingMeta_",v),val._MissingMeta_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._CacheControl_",v),val._CacheControl_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentDisposition_",v),val._ContentDisposition_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentEncoding_",v),val._ContentEncoding_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentLanguage_",v),val._ContentLanguage_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentRange_",v),val._ContentRange_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ContentType_",v),val._ContentType_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._Expires_",v),val._Expires_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._WebsiteRedirectLocation_",v),val._WebsiteRedirectLocation_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ServerSideEncryption_",v),val._ServerSideEncryption_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._Metadata_",v),val._Metadata_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._SSECustomerAlgorithm_",v),val._SSECustomerAlgorithm_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._SSECustomerKeyMD5_",v),val._SSECustomerKeyMD5_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._SSEKMSKeyId_",v),val._SSEKMSKeyId_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._BucketKeyEnabled_",v),val._BucketKeyEnabled_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._RequestCharged_",v),val._RequestCharged_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ReplicationStatus_",v),val._ReplicationStatus_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._PartsCount_",v),val._PartsCount_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._TagCount_",v),val._TagCount_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ObjectLockMode_",v),val._ObjectLockMode_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ObjectLockRetainUntilDate_",v),val._ObjectLockRetainUntilDate_);
    res = res && __to_solver(g,g.apply("_GetObjectOutput._ObjectLockLegalHoldStatus_",v),val._ObjectLockLegalHoldStatus_);
    return res;
}
template <>
void  __randomize<s3_test::_GetObjectOutput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::blob>(g,g.apply("_GetObjectOutput._Body_",v));
    __randomize<bool>(g,g.apply("_GetObjectOutput._DeleteMarker_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._AcceptRanges_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._Expiration_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._Restore_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._LastModified_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._ContentLength_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ETag_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._MissingMeta_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._VersionId_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._CacheControl_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ContentDisposition_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ContentEncoding_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ContentLanguage_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ContentRange_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ContentType_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._Expires_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._WebsiteRedirectLocation_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ServerSideEncryption_",v));
    __randomize<s3_test::unordered_map__string____string__>(g,g.apply("_GetObjectOutput._Metadata_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._SSECustomerAlgorithm_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._SSECustomerKeyMD5_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._SSEKMSKeyId_",v));
    __randomize<bool>(g,g.apply("_GetObjectOutput._BucketKeyEnabled_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._StorageClass_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._RequestCharged_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ReplicationStatus_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._PartsCount_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._TagCount_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ObjectLockMode_",v));
    __randomize<int>(g,g.apply("_GetObjectOutput._ObjectLockRetainUntilDate_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectOutput._ObjectLockLegalHoldStatus_",v));
}
template <>
s3_test::_GetObjectRequest _arg<s3_test::_GetObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GetObjectRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 20) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Bucket_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_IfMatch_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._IfMatch_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfMatch_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_IfModifiedSince_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._IfModifiedSince_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfModifiedSince_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_IfNoneMatch_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._IfNoneMatch_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfNoneMatch_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_IfUnmodifiedSince_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._IfUnmodifiedSince_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IfUnmodifiedSince_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Range_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Range_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Range_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ResponseCacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ResponseCacheControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseCacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_ResponseContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._ResponseContentDisposition_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_ResponseContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._ResponseContentEncoding_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_ResponseContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._ResponseContentLanguage_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_ResponseContentType_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._ResponseContentType_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_ResponseExpires_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._ResponseExpires_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ResponseExpires_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._VersionId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_SSECustomerKey_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._SSECustomerKey_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKey_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_RequestPayer_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._RequestPayer_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestPayer_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._PartNumber_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_ExpectedBucketOwner_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._ExpectedBucketOwner_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpectedBucketOwner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GetObjectRequest>(ivy_deser &inp, s3_test::_GetObjectRequest &res){
    inp.open_struct();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_IfMatch_");
    __deser(inp,res._IfMatch_);
    inp.close_field();
    inp.open_field("_IfModifiedSince_");
    __deser(inp,res._IfModifiedSince_);
    inp.close_field();
    inp.open_field("_IfNoneMatch_");
    __deser(inp,res._IfNoneMatch_);
    inp.close_field();
    inp.open_field("_IfUnmodifiedSince_");
    __deser(inp,res._IfUnmodifiedSince_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Range_");
    __deser(inp,res._Range_);
    inp.close_field();
    inp.open_field("_ResponseCacheControl_");
    __deser(inp,res._ResponseCacheControl_);
    inp.close_field();
    inp.open_field("_ResponseContentDisposition_");
    __deser(inp,res._ResponseContentDisposition_);
    inp.close_field();
    inp.open_field("_ResponseContentEncoding_");
    __deser(inp,res._ResponseContentEncoding_);
    inp.close_field();
    inp.open_field("_ResponseContentLanguage_");
    __deser(inp,res._ResponseContentLanguage_);
    inp.close_field();
    inp.open_field("_ResponseContentType_");
    __deser(inp,res._ResponseContentType_);
    inp.close_field();
    inp.open_field("_ResponseExpires_");
    __deser(inp,res._ResponseExpires_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKey_");
    __deser(inp,res._SSECustomerKey_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_RequestPayer_");
    __deser(inp,res._RequestPayer_);
    inp.close_field();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.open_field("_ExpectedBucketOwner_");
    __deser(inp,res._ExpectedBucketOwner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v,s3_test::_GetObjectRequest &res){
    __from_solver(g,g.apply("_GetObjectRequest._Bucket_",v),res._Bucket_);
    __from_solver(g,g.apply("_GetObjectRequest._IfMatch_",v),res._IfMatch_);
    __from_solver(g,g.apply("_GetObjectRequest._IfModifiedSince_",v),res._IfModifiedSince_);
    __from_solver(g,g.apply("_GetObjectRequest._IfNoneMatch_",v),res._IfNoneMatch_);
    __from_solver(g,g.apply("_GetObjectRequest._IfUnmodifiedSince_",v),res._IfUnmodifiedSince_);
    __from_solver(g,g.apply("_GetObjectRequest._Key_",v),res._Key_);
    __from_solver(g,g.apply("_GetObjectRequest._Range_",v),res._Range_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseCacheControl_",v),res._ResponseCacheControl_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseContentDisposition_",v),res._ResponseContentDisposition_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseContentEncoding_",v),res._ResponseContentEncoding_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseContentLanguage_",v),res._ResponseContentLanguage_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseContentType_",v),res._ResponseContentType_);
    __from_solver(g,g.apply("_GetObjectRequest._ResponseExpires_",v),res._ResponseExpires_);
    __from_solver(g,g.apply("_GetObjectRequest._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_GetObjectRequest._SSECustomerAlgorithm_",v),res._SSECustomerAlgorithm_);
    __from_solver(g,g.apply("_GetObjectRequest._SSECustomerKey_",v),res._SSECustomerKey_);
    __from_solver(g,g.apply("_GetObjectRequest._SSECustomerKeyMD5_",v),res._SSECustomerKeyMD5_);
    __from_solver(g,g.apply("_GetObjectRequest._RequestPayer_",v),res._RequestPayer_);
    __from_solver(g,g.apply("_GetObjectRequest._PartNumber_",v),res._PartNumber_);
    __from_solver(g,g.apply("_GetObjectRequest._ExpectedBucketOwner_",v),res._ExpectedBucketOwner_);
}
template <>
z3::expr  __to_solver<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v,s3_test::_GetObjectRequest &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._Bucket_",v),val._Bucket_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._IfMatch_",v),val._IfMatch_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._IfModifiedSince_",v),val._IfModifiedSince_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._IfNoneMatch_",v),val._IfNoneMatch_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._IfUnmodifiedSince_",v),val._IfUnmodifiedSince_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._Range_",v),val._Range_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseCacheControl_",v),val._ResponseCacheControl_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseContentDisposition_",v),val._ResponseContentDisposition_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseContentEncoding_",v),val._ResponseContentEncoding_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseContentLanguage_",v),val._ResponseContentLanguage_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseContentType_",v),val._ResponseContentType_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ResponseExpires_",v),val._ResponseExpires_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._SSECustomerAlgorithm_",v),val._SSECustomerAlgorithm_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._SSECustomerKey_",v),val._SSECustomerKey_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._SSECustomerKeyMD5_",v),val._SSECustomerKeyMD5_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._RequestPayer_",v),val._RequestPayer_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._PartNumber_",v),val._PartNumber_);
    res = res && __to_solver(g,g.apply("_GetObjectRequest._ExpectedBucketOwner_",v),val._ExpectedBucketOwner_);
    return res;
}
template <>
void  __randomize<s3_test::_GetObjectRequest>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_GetObjectRequest._Bucket_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._IfMatch_",v));
    __randomize<s3_test::option__timestamp__>(g,g.apply("_GetObjectRequest._IfModifiedSince_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._IfNoneMatch_",v));
    __randomize<s3_test::option__timestamp__>(g,g.apply("_GetObjectRequest._IfUnmodifiedSince_",v));
    __randomize<s3_test::string>(g,g.apply("_GetObjectRequest._Key_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._Range_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ResponseCacheControl_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ResponseContentDisposition_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ResponseContentEncoding_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ResponseContentLanguage_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ResponseContentType_",v));
    __randomize<s3_test::option__timestamp__>(g,g.apply("_GetObjectRequest._ResponseExpires_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._VersionId_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._SSECustomerAlgorithm_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._SSECustomerKey_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._SSECustomerKeyMD5_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._RequestPayer_",v));
    __randomize<s3_test::option__integer__>(g,g.apply("_GetObjectRequest._PartNumber_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_GetObjectRequest._ExpectedBucketOwner_",v));
}
template <>
s3_test::_GlacierJobParameters _arg<s3_test::_GlacierJobParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_GlacierJobParameters res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Tier_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Tier_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tier_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_GlacierJobParameters>(ivy_deser &inp, s3_test::_GlacierJobParameters &res){
    inp.open_struct();
    inp.open_field("_Tier_");
    __deser(inp,res._Tier_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v,s3_test::_GlacierJobParameters &res){
    __from_solver(g,g.apply("_GlacierJobParameters._Tier_",v),res._Tier_);
}
template <>
z3::expr  __to_solver<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v,s3_test::_GlacierJobParameters &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_GlacierJobParameters._Tier_",v),val._Tier_);
    return res;
}
template <>
void  __randomize<s3_test::_GlacierJobParameters>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_GlacierJobParameters._Tier_",v));
}
template <>
s3_test::_Grant _arg<s3_test::_Grant>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Grant res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grantee_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grantee_ = _arg<s3_test::_Grantee>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grantee_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Permission_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Permission_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Permission_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Grant>(ivy_deser &inp, s3_test::_Grant &res){
    inp.open_struct();
    inp.open_field("_Grantee_");
    __deser(inp,res._Grantee_);
    inp.close_field();
    inp.open_field("_Permission_");
    __deser(inp,res._Permission_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Grant>( gen &g, const  z3::expr &v,s3_test::_Grant &res){
    __from_solver(g,g.apply("_Grant._Grantee_",v),res._Grantee_);
    __from_solver(g,g.apply("_Grant._Permission_",v),res._Permission_);
}
template <>
z3::expr  __to_solver<s3_test::_Grant>( gen &g, const  z3::expr &v,s3_test::_Grant &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Grant._Grantee_",v),val._Grantee_);
    res = res && __to_solver(g,g.apply("_Grant._Permission_",v),val._Permission_);
    return res;
}
template <>
void  __randomize<s3_test::_Grant>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_Grantee>(g,g.apply("_Grant._Grantee_",v));
    __randomize<s3_test::string>(g,g.apply("_Grant._Permission_",v));
}
template <>
s3_test::_Grantee _arg<s3_test::_Grantee>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Grantee res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DisplayName_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_EmailAddress_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._EmailAddress_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EmailAddress_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Type_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_URI_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._URI_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _URI_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Grantee>(ivy_deser &inp, s3_test::_Grantee &res){
    inp.open_struct();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.open_field("_EmailAddress_");
    __deser(inp,res._EmailAddress_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.open_field("_URI_");
    __deser(inp,res._URI_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Grantee>( gen &g, const  z3::expr &v,s3_test::_Grantee &res){
    __from_solver(g,g.apply("_Grantee._DisplayName_",v),res._DisplayName_);
    __from_solver(g,g.apply("_Grantee._EmailAddress_",v),res._EmailAddress_);
    __from_solver(g,g.apply("_Grantee._ID_",v),res._ID_);
    __from_solver(g,g.apply("_Grantee._Type_",v),res._Type_);
    __from_solver(g,g.apply("_Grantee._URI_",v),res._URI_);
}
template <>
z3::expr  __to_solver<s3_test::_Grantee>( gen &g, const  z3::expr &v,s3_test::_Grantee &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Grantee._DisplayName_",v),val._DisplayName_);
    res = res && __to_solver(g,g.apply("_Grantee._EmailAddress_",v),val._EmailAddress_);
    res = res && __to_solver(g,g.apply("_Grantee._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_Grantee._Type_",v),val._Type_);
    res = res && __to_solver(g,g.apply("_Grantee._URI_",v),val._URI_);
    return res;
}
template <>
void  __randomize<s3_test::_Grantee>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_Grantee._DisplayName_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Grantee._EmailAddress_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Grantee._ID_",v));
    __randomize<s3_test::string>(g,g.apply("_Grantee._Type_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Grantee._URI_",v));
}
template <>
s3_test::_Initiator _arg<s3_test::_Initiator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Initiator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._DisplayName_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Initiator>(ivy_deser &inp, s3_test::_Initiator &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Initiator>( gen &g, const  z3::expr &v,s3_test::_Initiator &res){
    __from_solver(g,g.apply("_Initiator._ID_",v),res._ID_);
    __from_solver(g,g.apply("_Initiator._DisplayName_",v),res._DisplayName_);
}
template <>
z3::expr  __to_solver<s3_test::_Initiator>( gen &g, const  z3::expr &v,s3_test::_Initiator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Initiator._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_Initiator._DisplayName_",v),val._DisplayName_);
    return res;
}
template <>
void  __randomize<s3_test::_Initiator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Initiator._ID_",v));
    __randomize<s3_test::string>(g,g.apply("_Initiator._DisplayName_",v));
}
template <>
s3_test::_InputSerialization _arg<s3_test::_InputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InputSerialization res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_CSV_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._CSV_ = _arg<s3_test::_CSVInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CSV_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_CompressionType_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._CompressionType_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CompressionType_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_JSON_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._JSON_ = _arg<s3_test::_JSONInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _JSON_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Parquet_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Parquet_ = _arg<s3_test::_ParquetInput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Parquet_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InputSerialization>(ivy_deser &inp, s3_test::_InputSerialization &res){
    inp.open_struct();
    inp.open_field("_CSV_");
    __deser(inp,res._CSV_);
    inp.close_field();
    inp.open_field("_CompressionType_");
    __deser(inp,res._CompressionType_);
    inp.close_field();
    inp.open_field("_JSON_");
    __deser(inp,res._JSON_);
    inp.close_field();
    inp.open_field("_Parquet_");
    __deser(inp,res._Parquet_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InputSerialization>( gen &g, const  z3::expr &v,s3_test::_InputSerialization &res){
    __from_solver(g,g.apply("_InputSerialization._CSV_",v),res._CSV_);
    __from_solver(g,g.apply("_InputSerialization._CompressionType_",v),res._CompressionType_);
    __from_solver(g,g.apply("_InputSerialization._JSON_",v),res._JSON_);
    __from_solver(g,g.apply("_InputSerialization._Parquet_",v),res._Parquet_);
}
template <>
z3::expr  __to_solver<s3_test::_InputSerialization>( gen &g, const  z3::expr &v,s3_test::_InputSerialization &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InputSerialization._CSV_",v),val._CSV_);
    res = res && __to_solver(g,g.apply("_InputSerialization._CompressionType_",v),val._CompressionType_);
    res = res && __to_solver(g,g.apply("_InputSerialization._JSON_",v),val._JSON_);
    res = res && __to_solver(g,g.apply("_InputSerialization._Parquet_",v),val._Parquet_);
    return res;
}
template <>
void  __randomize<s3_test::_InputSerialization>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_CSVInput>(g,g.apply("_InputSerialization._CSV_",v));
    __randomize<s3_test::string>(g,g.apply("_InputSerialization._CompressionType_",v));
    __randomize<s3_test::_JSONInput>(g,g.apply("_InputSerialization._JSON_",v));
    __randomize<s3_test::_ParquetInput>(g,g.apply("_InputSerialization._Parquet_",v));
}
template <>
s3_test::_IntelligentTieringAndOperator _arg<s3_test::_IntelligentTieringAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringAndOperator>(ivy_deser &inp, s3_test::_IntelligentTieringAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringAndOperator &res){
    __from_solver(g,g.apply("_IntelligentTieringAndOperator._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_IntelligentTieringAndOperator._Tags_",v),res._Tags_);
}
template <>
z3::expr  __to_solver<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringAndOperator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_IntelligentTieringAndOperator._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringAndOperator._Tags_",v),val._Tags_);
    return res;
}
template <>
void  __randomize<s3_test::_IntelligentTieringAndOperator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_IntelligentTieringAndOperator._Prefix_",v));
    __randomize<s3_test::vector___Tag__>(g,g.apply("_IntelligentTieringAndOperator._Tags_",v));
}
template <>
s3_test::_IntelligentTieringConfiguration _arg<s3_test::_IntelligentTieringConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___IntelligentTieringFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Tierings_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Tierings_ = _arg<s3_test::vector___Tiering__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tierings_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringConfiguration>(ivy_deser &inp, s3_test::_IntelligentTieringConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Tierings_");
    __deser(inp,res._Tierings_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringConfiguration &res){
    __from_solver(g,g.apply("_IntelligentTieringConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_IntelligentTieringConfiguration._Filter_",v),res._Filter_);
    __from_solver(g,g.apply("_IntelligentTieringConfiguration._Status_",v),res._Status_);
    __from_solver(g,g.apply("_IntelligentTieringConfiguration._Tierings_",v),res._Tierings_);
}
template <>
z3::expr  __to_solver<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_IntelligentTieringConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringConfiguration._Filter_",v),val._Filter_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringConfiguration._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringConfiguration._Tierings_",v),val._Tierings_);
    return res;
}
template <>
void  __randomize<s3_test::_IntelligentTieringConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_IntelligentTieringConfiguration._Id_",v));
    __randomize<s3_test::option___IntelligentTieringFilter__>(g,g.apply("_IntelligentTieringConfiguration._Filter_",v));
    __randomize<s3_test::string>(g,g.apply("_IntelligentTieringConfiguration._Status_",v));
    __randomize<s3_test::vector___Tiering__>(g,g.apply("_IntelligentTieringConfiguration._Tierings_",v));
}
template <>
s3_test::_IntelligentTieringFilter _arg<s3_test::_IntelligentTieringFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_IntelligentTieringFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_IntelligentTieringAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_IntelligentTieringFilter>(ivy_deser &inp, s3_test::_IntelligentTieringFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringFilter &res){
    __from_solver(g,g.apply("_IntelligentTieringFilter._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_IntelligentTieringFilter._Tag_",v),res._Tag_);
    __from_solver(g,g.apply("_IntelligentTieringFilter._And_",v),res._And_);
}
template <>
z3::expr  __to_solver<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v,s3_test::_IntelligentTieringFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_IntelligentTieringFilter._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringFilter._Tag_",v),val._Tag_);
    res = res && __to_solver(g,g.apply("_IntelligentTieringFilter._And_",v),val._And_);
    return res;
}
template <>
void  __randomize<s3_test::_IntelligentTieringFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_IntelligentTieringFilter._Prefix_",v));
    __randomize<s3_test::_Tag>(g,g.apply("_IntelligentTieringFilter._Tag_",v));
    __randomize<s3_test::_IntelligentTieringAndOperator>(g,g.apply("_IntelligentTieringFilter._And_",v));
}
template <>
s3_test::_InventoryConfiguration _arg<s3_test::_InventoryConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Destination_ = _arg<s3_test::_InventoryDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_IsEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._IsEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Filter_ = _arg<s3_test::option___InventoryFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Id_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_IncludedObjectVersions_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._IncludedObjectVersions_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IncludedObjectVersions_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_OptionalFields_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._OptionalFields_ = _arg<s3_test::option__vector__string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OptionalFields_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_Schedule_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._Schedule_ = _arg<s3_test::_InventorySchedule>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Schedule_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryConfiguration>(ivy_deser &inp, s3_test::_InventoryConfiguration &res){
    inp.open_struct();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.open_field("_IsEnabled_");
    __deser(inp,res._IsEnabled_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_IncludedObjectVersions_");
    __deser(inp,res._IncludedObjectVersions_);
    inp.close_field();
    inp.open_field("_OptionalFields_");
    __deser(inp,res._OptionalFields_);
    inp.close_field();
    inp.open_field("_Schedule_");
    __deser(inp,res._Schedule_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v,s3_test::_InventoryConfiguration &res){
    __from_solver(g,g.apply("_InventoryConfiguration._Destination_",v),res._Destination_);
    __from_solver(g,g.apply("_InventoryConfiguration._IsEnabled_",v),res._IsEnabled_);
    __from_solver(g,g.apply("_InventoryConfiguration._Filter_",v),res._Filter_);
    __from_solver(g,g.apply("_InventoryConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_InventoryConfiguration._IncludedObjectVersions_",v),res._IncludedObjectVersions_);
    __from_solver(g,g.apply("_InventoryConfiguration._OptionalFields_",v),res._OptionalFields_);
    __from_solver(g,g.apply("_InventoryConfiguration._Schedule_",v),res._Schedule_);
}
template <>
z3::expr  __to_solver<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v,s3_test::_InventoryConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._Destination_",v),val._Destination_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._IsEnabled_",v),val._IsEnabled_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._Filter_",v),val._Filter_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._IncludedObjectVersions_",v),val._IncludedObjectVersions_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._OptionalFields_",v),val._OptionalFields_);
    res = res && __to_solver(g,g.apply("_InventoryConfiguration._Schedule_",v),val._Schedule_);
    return res;
}
template <>
void  __randomize<s3_test::_InventoryConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_InventoryDestination>(g,g.apply("_InventoryConfiguration._Destination_",v));
    __randomize<bool>(g,g.apply("_InventoryConfiguration._IsEnabled_",v));
    __randomize<s3_test::option___InventoryFilter__>(g,g.apply("_InventoryConfiguration._Filter_",v));
    __randomize<s3_test::string>(g,g.apply("_InventoryConfiguration._Id_",v));
    __randomize<s3_test::string>(g,g.apply("_InventoryConfiguration._IncludedObjectVersions_",v));
    __randomize<s3_test::option__vector__string____>(g,g.apply("_InventoryConfiguration._OptionalFields_",v));
    __randomize<s3_test::_InventorySchedule>(g,g.apply("_InventoryConfiguration._Schedule_",v));
}
template <>
s3_test::_InventoryDestination _arg<s3_test::_InventoryDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3BucketDestination_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3BucketDestination_ = _arg<s3_test::_InventoryS3BucketDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3BucketDestination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryDestination>(ivy_deser &inp, s3_test::_InventoryDestination &res){
    inp.open_struct();
    inp.open_field("_S3BucketDestination_");
    __deser(inp,res._S3BucketDestination_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v,s3_test::_InventoryDestination &res){
    __from_solver(g,g.apply("_InventoryDestination._S3BucketDestination_",v),res._S3BucketDestination_);
}
template <>
z3::expr  __to_solver<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v,s3_test::_InventoryDestination &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventoryDestination._S3BucketDestination_",v),val._S3BucketDestination_);
    return res;
}
template <>
void  __randomize<s3_test::_InventoryDestination>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_InventoryS3BucketDestination>(g,g.apply("_InventoryDestination._S3BucketDestination_",v));
}
template <>
s3_test::_InventoryEncryption _arg<s3_test::_InventoryEncryption>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryEncryption res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SSES3_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SSES3_ = _arg<s3_test::_SSES3>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSES3_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_SSEKMS_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._SSEKMS_ = _arg<s3_test::_SSEKMS>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMS_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryEncryption>(ivy_deser &inp, s3_test::_InventoryEncryption &res){
    inp.open_struct();
    inp.open_field("_SSES3_");
    __deser(inp,res._SSES3_);
    inp.close_field();
    inp.open_field("_SSEKMS_");
    __deser(inp,res._SSEKMS_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v,s3_test::_InventoryEncryption &res){
    __from_solver(g,g.apply("_InventoryEncryption._SSES3_",v),res._SSES3_);
    __from_solver(g,g.apply("_InventoryEncryption._SSEKMS_",v),res._SSEKMS_);
}
template <>
z3::expr  __to_solver<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v,s3_test::_InventoryEncryption &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventoryEncryption._SSES3_",v),val._SSES3_);
    res = res && __to_solver(g,g.apply("_InventoryEncryption._SSEKMS_",v),val._SSEKMS_);
    return res;
}
template <>
void  __randomize<s3_test::_InventoryEncryption>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_SSES3>(g,g.apply("_InventoryEncryption._SSES3_",v));
    __randomize<s3_test::_SSEKMS>(g,g.apply("_InventoryEncryption._SSEKMS_",v));
}
template <>
s3_test::_InventoryFilter _arg<s3_test::_InventoryFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryFilter>(ivy_deser &inp, s3_test::_InventoryFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v,s3_test::_InventoryFilter &res){
    __from_solver(g,g.apply("_InventoryFilter._Prefix_",v),res._Prefix_);
}
template <>
z3::expr  __to_solver<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v,s3_test::_InventoryFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventoryFilter._Prefix_",v),val._Prefix_);
    return res;
}
template <>
void  __randomize<s3_test::_InventoryFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_InventoryFilter._Prefix_",v));
}
template <>
s3_test::_InventoryS3BucketDestination _arg<s3_test::_InventoryS3BucketDestination>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventoryS3BucketDestination res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_AccountId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._AccountId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccountId_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Bucket_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Format_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Format_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Format_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Encryption_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Encryption_ = _arg<s3_test::option___InventoryEncryption__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Encryption_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventoryS3BucketDestination>(ivy_deser &inp, s3_test::_InventoryS3BucketDestination &res){
    inp.open_struct();
    inp.open_field("_AccountId_");
    __deser(inp,res._AccountId_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_Format_");
    __deser(inp,res._Format_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Encryption_");
    __deser(inp,res._Encryption_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v,s3_test::_InventoryS3BucketDestination &res){
    __from_solver(g,g.apply("_InventoryS3BucketDestination._AccountId_",v),res._AccountId_);
    __from_solver(g,g.apply("_InventoryS3BucketDestination._Bucket_",v),res._Bucket_);
    __from_solver(g,g.apply("_InventoryS3BucketDestination._Format_",v),res._Format_);
    __from_solver(g,g.apply("_InventoryS3BucketDestination._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_InventoryS3BucketDestination._Encryption_",v),res._Encryption_);
}
template <>
z3::expr  __to_solver<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v,s3_test::_InventoryS3BucketDestination &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventoryS3BucketDestination._AccountId_",v),val._AccountId_);
    res = res && __to_solver(g,g.apply("_InventoryS3BucketDestination._Bucket_",v),val._Bucket_);
    res = res && __to_solver(g,g.apply("_InventoryS3BucketDestination._Format_",v),val._Format_);
    res = res && __to_solver(g,g.apply("_InventoryS3BucketDestination._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_InventoryS3BucketDestination._Encryption_",v),val._Encryption_);
    return res;
}
template <>
void  __randomize<s3_test::_InventoryS3BucketDestination>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_InventoryS3BucketDestination._AccountId_",v));
    __randomize<s3_test::string>(g,g.apply("_InventoryS3BucketDestination._Bucket_",v));
    __randomize<s3_test::string>(g,g.apply("_InventoryS3BucketDestination._Format_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_InventoryS3BucketDestination._Prefix_",v));
    __randomize<s3_test::option___InventoryEncryption__>(g,g.apply("_InventoryS3BucketDestination._Encryption_",v));
}
template <>
s3_test::_InventorySchedule _arg<s3_test::_InventorySchedule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_InventorySchedule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Frequency_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Frequency_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Frequency_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_InventorySchedule>(ivy_deser &inp, s3_test::_InventorySchedule &res){
    inp.open_struct();
    inp.open_field("_Frequency_");
    __deser(inp,res._Frequency_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v,s3_test::_InventorySchedule &res){
    __from_solver(g,g.apply("_InventorySchedule._Frequency_",v),res._Frequency_);
}
template <>
z3::expr  __to_solver<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v,s3_test::_InventorySchedule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_InventorySchedule._Frequency_",v),val._Frequency_);
    return res;
}
template <>
void  __randomize<s3_test::_InventorySchedule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_InventorySchedule._Frequency_",v));
}
template <>
s3_test::_JSONInput _arg<s3_test::_JSONInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_JSONInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Type_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_JSONInput>(ivy_deser &inp, s3_test::_JSONInput &res){
    inp.open_struct();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_JSONInput>( gen &g, const  z3::expr &v,s3_test::_JSONInput &res){
    __from_solver(g,g.apply("_JSONInput._Type_",v),res._Type_);
}
template <>
z3::expr  __to_solver<s3_test::_JSONInput>( gen &g, const  z3::expr &v,s3_test::_JSONInput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_JSONInput._Type_",v),val._Type_);
    return res;
}
template <>
void  __randomize<s3_test::_JSONInput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_JSONInput._Type_",v));
}
template <>
s3_test::_JSONOutput _arg<s3_test::_JSONOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_JSONOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_RecordDelimiter_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._RecordDelimiter_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RecordDelimiter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_JSONOutput>(ivy_deser &inp, s3_test::_JSONOutput &res){
    inp.open_struct();
    inp.open_field("_RecordDelimiter_");
    __deser(inp,res._RecordDelimiter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_JSONOutput>( gen &g, const  z3::expr &v,s3_test::_JSONOutput &res){
    __from_solver(g,g.apply("_JSONOutput._RecordDelimiter_",v),res._RecordDelimiter_);
}
template <>
z3::expr  __to_solver<s3_test::_JSONOutput>( gen &g, const  z3::expr &v,s3_test::_JSONOutput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_JSONOutput._RecordDelimiter_",v),val._RecordDelimiter_);
    return res;
}
template <>
void  __randomize<s3_test::_JSONOutput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_JSONOutput._RecordDelimiter_",v));
}
template <>
s3_test::_LambdaFunctionConfiguration _arg<s3_test::_LambdaFunctionConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LambdaFunctionConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LambdaFunctionArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LambdaFunctionArn_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LambdaFunctionArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LambdaFunctionConfiguration>(ivy_deser &inp, s3_test::_LambdaFunctionConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_LambdaFunctionArn_");
    __deser(inp,res._LambdaFunctionArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v,s3_test::_LambdaFunctionConfiguration &res){
    __from_solver(g,g.apply("_LambdaFunctionConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_LambdaFunctionConfiguration._LambdaFunctionArn_",v),res._LambdaFunctionArn_);
    __from_solver(g,g.apply("_LambdaFunctionConfiguration._Events_",v),res._Events_);
    __from_solver(g,g.apply("_LambdaFunctionConfiguration._Filter_",v),res._Filter_);
}
template <>
z3::expr  __to_solver<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v,s3_test::_LambdaFunctionConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LambdaFunctionConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_LambdaFunctionConfiguration._LambdaFunctionArn_",v),val._LambdaFunctionArn_);
    res = res && __to_solver(g,g.apply("_LambdaFunctionConfiguration._Events_",v),val._Events_);
    res = res && __to_solver(g,g.apply("_LambdaFunctionConfiguration._Filter_",v),val._Filter_);
    return res;
}
template <>
void  __randomize<s3_test::_LambdaFunctionConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_LambdaFunctionConfiguration._Id_",v));
    __randomize<s3_test::string>(g,g.apply("_LambdaFunctionConfiguration._LambdaFunctionArn_",v));
    __randomize<s3_test::vector__string__>(g,g.apply("_LambdaFunctionConfiguration._Events_",v));
    __randomize<s3_test::option___NotificationConfigurationFilter__>(g,g.apply("_LambdaFunctionConfiguration._Filter_",v));
}
template <>
s3_test::_LifecycleConfiguration _arg<s3_test::_LifecycleConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Rules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Rules_ = _arg<s3_test::vector___Rule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleConfiguration>(ivy_deser &inp, s3_test::_LifecycleConfiguration &res){
    inp.open_struct();
    inp.open_field("_Rules_");
    __deser(inp,res._Rules_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v,s3_test::_LifecycleConfiguration &res){
    __from_solver(g,g.apply("_LifecycleConfiguration._Rules_",v),res._Rules_);
}
template <>
z3::expr  __to_solver<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v,s3_test::_LifecycleConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LifecycleConfiguration._Rules_",v),val._Rules_);
    return res;
}
template <>
void  __randomize<s3_test::_LifecycleConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___Rule__>(g,g.apply("_LifecycleConfiguration._Rules_",v));
}
template <>
s3_test::_LifecycleExpiration _arg<s3_test::_LifecycleExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleExpiration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Date_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Date_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Date_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ExpiredObjectDeleteMarker_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ExpiredObjectDeleteMarker_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpiredObjectDeleteMarker_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleExpiration>(ivy_deser &inp, s3_test::_LifecycleExpiration &res){
    inp.open_struct();
    inp.open_field("_Date_");
    __deser(inp,res._Date_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_ExpiredObjectDeleteMarker_");
    __deser(inp,res._ExpiredObjectDeleteMarker_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v,s3_test::_LifecycleExpiration &res){
    __from_solver(g,g.apply("_LifecycleExpiration._Date_",v),res._Date_);
    __from_solver(g,g.apply("_LifecycleExpiration._Days_",v),res._Days_);
    __from_solver(g,g.apply("_LifecycleExpiration._ExpiredObjectDeleteMarker_",v),res._ExpiredObjectDeleteMarker_);
}
template <>
z3::expr  __to_solver<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v,s3_test::_LifecycleExpiration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LifecycleExpiration._Date_",v),val._Date_);
    res = res && __to_solver(g,g.apply("_LifecycleExpiration._Days_",v),val._Days_);
    res = res && __to_solver(g,g.apply("_LifecycleExpiration._ExpiredObjectDeleteMarker_",v),val._ExpiredObjectDeleteMarker_);
    return res;
}
template <>
void  __randomize<s3_test::_LifecycleExpiration>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_LifecycleExpiration._Date_",v));
    __randomize<int>(g,g.apply("_LifecycleExpiration._Days_",v));
    __randomize<bool>(g,g.apply("_LifecycleExpiration._ExpiredObjectDeleteMarker_",v));
}
template <>
s3_test::_LifecycleRule _arg<s3_test::_LifecycleRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 9) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<s3_test::option___LifecycleExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___LifecycleRuleFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Transitions_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Transitions_ = _arg<s3_test::option__vector___Transition____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Transitions_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_NoncurrentVersionTransitions_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._NoncurrentVersionTransitions_ = _arg<s3_test::option__vector___NoncurrentVersionTransition____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionTransitions_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_NoncurrentVersionExpiration_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._NoncurrentVersionExpiration_ = _arg<s3_test::option___NoncurrentVersionExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionExpiration_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_AbortIncompleteMultipartUpload_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._AbortIncompleteMultipartUpload_ = _arg<s3_test::option___AbortIncompleteMultipartUpload__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AbortIncompleteMultipartUpload_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRule>(ivy_deser &inp, s3_test::_LifecycleRule &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Transitions_");
    __deser(inp,res._Transitions_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionTransitions_");
    __deser(inp,res._NoncurrentVersionTransitions_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionExpiration_");
    __deser(inp,res._NoncurrentVersionExpiration_);
    inp.close_field();
    inp.open_field("_AbortIncompleteMultipartUpload_");
    __deser(inp,res._AbortIncompleteMultipartUpload_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v,s3_test::_LifecycleRule &res){
    __from_solver(g,g.apply("_LifecycleRule._Expiration_",v),res._Expiration_);
    __from_solver(g,g.apply("_LifecycleRule._ID_",v),res._ID_);
    __from_solver(g,g.apply("_LifecycleRule._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_LifecycleRule._Filter_",v),res._Filter_);
    __from_solver(g,g.apply("_LifecycleRule._Status_",v),res._Status_);
    __from_solver(g,g.apply("_LifecycleRule._Transitions_",v),res._Transitions_);
    __from_solver(g,g.apply("_LifecycleRule._NoncurrentVersionTransitions_",v),res._NoncurrentVersionTransitions_);
    __from_solver(g,g.apply("_LifecycleRule._NoncurrentVersionExpiration_",v),res._NoncurrentVersionExpiration_);
    __from_solver(g,g.apply("_LifecycleRule._AbortIncompleteMultipartUpload_",v),res._AbortIncompleteMultipartUpload_);
}
template <>
z3::expr  __to_solver<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v,s3_test::_LifecycleRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LifecycleRule._Expiration_",v),val._Expiration_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._Filter_",v),val._Filter_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._Transitions_",v),val._Transitions_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._NoncurrentVersionTransitions_",v),val._NoncurrentVersionTransitions_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._NoncurrentVersionExpiration_",v),val._NoncurrentVersionExpiration_);
    res = res && __to_solver(g,g.apply("_LifecycleRule._AbortIncompleteMultipartUpload_",v),val._AbortIncompleteMultipartUpload_);
    return res;
}
template <>
void  __randomize<s3_test::_LifecycleRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option___LifecycleExpiration__>(g,g.apply("_LifecycleRule._Expiration_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_LifecycleRule._ID_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_LifecycleRule._Prefix_",v));
    __randomize<s3_test::option___LifecycleRuleFilter__>(g,g.apply("_LifecycleRule._Filter_",v));
    __randomize<s3_test::string>(g,g.apply("_LifecycleRule._Status_",v));
    __randomize<s3_test::option__vector___Transition____>(g,g.apply("_LifecycleRule._Transitions_",v));
    __randomize<s3_test::option__vector___NoncurrentVersionTransition____>(g,g.apply("_LifecycleRule._NoncurrentVersionTransitions_",v));
    __randomize<s3_test::option___NoncurrentVersionExpiration__>(g,g.apply("_LifecycleRule._NoncurrentVersionExpiration_",v));
    __randomize<s3_test::option___AbortIncompleteMultipartUpload__>(g,g.apply("_LifecycleRule._AbortIncompleteMultipartUpload_",v));
}
template <>
s3_test::_LifecycleRuleAndOperator _arg<s3_test::_LifecycleRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRuleAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRuleAndOperator>(ivy_deser &inp, s3_test::_LifecycleRuleAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v,s3_test::_LifecycleRuleAndOperator &res){
    __from_solver(g,g.apply("_LifecycleRuleAndOperator._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_LifecycleRuleAndOperator._Tags_",v),res._Tags_);
}
template <>
z3::expr  __to_solver<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v,s3_test::_LifecycleRuleAndOperator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LifecycleRuleAndOperator._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_LifecycleRuleAndOperator._Tags_",v),val._Tags_);
    return res;
}
template <>
void  __randomize<s3_test::_LifecycleRuleAndOperator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_LifecycleRuleAndOperator._Prefix_",v));
    __randomize<s3_test::vector___Tag__>(g,g.apply("_LifecycleRuleAndOperator._Tags_",v));
}
template <>
s3_test::_LifecycleRuleFilter _arg<s3_test::_LifecycleRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_LifecycleRuleFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_LifecycleRuleAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_LifecycleRuleFilter>(ivy_deser &inp, s3_test::_LifecycleRuleFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v,s3_test::_LifecycleRuleFilter &res){
    __from_solver(g,g.apply("_LifecycleRuleFilter._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_LifecycleRuleFilter._Tag_",v),res._Tag_);
    __from_solver(g,g.apply("_LifecycleRuleFilter._And_",v),res._And_);
}
template <>
z3::expr  __to_solver<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v,s3_test::_LifecycleRuleFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_LifecycleRuleFilter._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_LifecycleRuleFilter._Tag_",v),val._Tag_);
    res = res && __to_solver(g,g.apply("_LifecycleRuleFilter._And_",v),val._And_);
    return res;
}
template <>
void  __randomize<s3_test::_LifecycleRuleFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_LifecycleRuleFilter._Prefix_",v));
    __randomize<s3_test::_Tag>(g,g.apply("_LifecycleRuleFilter._Tag_",v));
    __randomize<s3_test::_LifecycleRuleAndOperator>(g,g.apply("_LifecycleRuleFilter._And_",v));
}
template <>
s3_test::_MetadataEntry _arg<s3_test::_MetadataEntry>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetadataEntry res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Name_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Name_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Name_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetadataEntry>(ivy_deser &inp, s3_test::_MetadataEntry &res){
    inp.open_struct();
    inp.open_field("_Name_");
    __deser(inp,res._Name_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v,s3_test::_MetadataEntry &res){
    __from_solver(g,g.apply("_MetadataEntry._Name_",v),res._Name_);
    __from_solver(g,g.apply("_MetadataEntry._Value_",v),res._Value_);
}
template <>
z3::expr  __to_solver<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v,s3_test::_MetadataEntry &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_MetadataEntry._Name_",v),val._Name_);
    res = res && __to_solver(g,g.apply("_MetadataEntry._Value_",v),val._Value_);
    return res;
}
template <>
void  __randomize<s3_test::_MetadataEntry>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_MetadataEntry._Name_",v));
    __randomize<s3_test::string>(g,g.apply("_MetadataEntry._Value_",v));
}
template <>
s3_test::_Metrics _arg<s3_test::_Metrics>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Metrics res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_EventThreshold_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._EventThreshold_ = _arg<s3_test::option___ReplicationTimeValue__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _EventThreshold_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Metrics>(ivy_deser &inp, s3_test::_Metrics &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_EventThreshold_");
    __deser(inp,res._EventThreshold_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Metrics>( gen &g, const  z3::expr &v,s3_test::_Metrics &res){
    __from_solver(g,g.apply("_Metrics._Status_",v),res._Status_);
    __from_solver(g,g.apply("_Metrics._EventThreshold_",v),res._EventThreshold_);
}
template <>
z3::expr  __to_solver<s3_test::_Metrics>( gen &g, const  z3::expr &v,s3_test::_Metrics &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Metrics._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_Metrics._EventThreshold_",v),val._EventThreshold_);
    return res;
}
template <>
void  __randomize<s3_test::_Metrics>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Metrics._Status_",v));
    __randomize<s3_test::option___ReplicationTimeValue__>(g,g.apply("_Metrics._EventThreshold_",v));
}
template <>
s3_test::_MetricsAndOperator _arg<s3_test::_MetricsAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsAndOperator>(ivy_deser &inp, s3_test::_MetricsAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v,s3_test::_MetricsAndOperator &res){
    __from_solver(g,g.apply("_MetricsAndOperator._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_MetricsAndOperator._Tags_",v),res._Tags_);
}
template <>
z3::expr  __to_solver<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v,s3_test::_MetricsAndOperator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_MetricsAndOperator._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_MetricsAndOperator._Tags_",v),val._Tags_);
    return res;
}
template <>
void  __randomize<s3_test::_MetricsAndOperator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_MetricsAndOperator._Prefix_",v));
    __randomize<s3_test::vector___Tag__>(g,g.apply("_MetricsAndOperator._Tags_",v));
}
template <>
s3_test::_MetricsConfiguration _arg<s3_test::_MetricsConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Filter_ = _arg<s3_test::option___MetricsFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsConfiguration>(ivy_deser &inp, s3_test::_MetricsConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v,s3_test::_MetricsConfiguration &res){
    __from_solver(g,g.apply("_MetricsConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_MetricsConfiguration._Filter_",v),res._Filter_);
}
template <>
z3::expr  __to_solver<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v,s3_test::_MetricsConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_MetricsConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_MetricsConfiguration._Filter_",v),val._Filter_);
    return res;
}
template <>
void  __randomize<s3_test::_MetricsConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_MetricsConfiguration._Id_",v));
    __randomize<s3_test::option___MetricsFilter__>(g,g.apply("_MetricsConfiguration._Filter_",v));
}
template <>
s3_test::_MetricsFilter _arg<s3_test::_MetricsFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MetricsFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_MetricsAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MetricsFilter>(ivy_deser &inp, s3_test::_MetricsFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v,s3_test::_MetricsFilter &res){
    __from_solver(g,g.apply("_MetricsFilter._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_MetricsFilter._Tag_",v),res._Tag_);
    __from_solver(g,g.apply("_MetricsFilter._And_",v),res._And_);
}
template <>
z3::expr  __to_solver<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v,s3_test::_MetricsFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_MetricsFilter._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_MetricsFilter._Tag_",v),val._Tag_);
    res = res && __to_solver(g,g.apply("_MetricsFilter._And_",v),val._And_);
    return res;
}
template <>
void  __randomize<s3_test::_MetricsFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_MetricsFilter._Prefix_",v));
    __randomize<s3_test::_Tag>(g,g.apply("_MetricsFilter._Tag_",v));
    __randomize<s3_test::_MetricsAndOperator>(g,g.apply("_MetricsFilter._And_",v));
}
template <>
s3_test::_MultipartUpload _arg<s3_test::_MultipartUpload>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_MultipartUpload res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_UploadId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._UploadId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _UploadId_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Initiated_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Initiated_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Initiated_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Initiator_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Initiator_ = _arg<s3_test::_Initiator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Initiator_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_MultipartUpload>(ivy_deser &inp, s3_test::_MultipartUpload &res){
    inp.open_struct();
    inp.open_field("_UploadId_");
    __deser(inp,res._UploadId_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Initiated_");
    __deser(inp,res._Initiated_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.open_field("_Initiator_");
    __deser(inp,res._Initiator_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v,s3_test::_MultipartUpload &res){
    __from_solver(g,g.apply("_MultipartUpload._UploadId_",v),res._UploadId_);
    __from_solver(g,g.apply("_MultipartUpload._Key_",v),res._Key_);
    __from_solver(g,g.apply("_MultipartUpload._Initiated_",v),res._Initiated_);
    __from_solver(g,g.apply("_MultipartUpload._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_MultipartUpload._Owner_",v),res._Owner_);
    __from_solver(g,g.apply("_MultipartUpload._Initiator_",v),res._Initiator_);
}
template <>
z3::expr  __to_solver<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v,s3_test::_MultipartUpload &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_MultipartUpload._UploadId_",v),val._UploadId_);
    res = res && __to_solver(g,g.apply("_MultipartUpload._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_MultipartUpload._Initiated_",v),val._Initiated_);
    res = res && __to_solver(g,g.apply("_MultipartUpload._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_MultipartUpload._Owner_",v),val._Owner_);
    res = res && __to_solver(g,g.apply("_MultipartUpload._Initiator_",v),val._Initiator_);
    return res;
}
template <>
void  __randomize<s3_test::_MultipartUpload>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_MultipartUpload._UploadId_",v));
    __randomize<s3_test::string>(g,g.apply("_MultipartUpload._Key_",v));
    __randomize<int>(g,g.apply("_MultipartUpload._Initiated_",v));
    __randomize<s3_test::string>(g,g.apply("_MultipartUpload._StorageClass_",v));
    __randomize<s3_test::_Owner>(g,g.apply("_MultipartUpload._Owner_",v));
    __randomize<s3_test::_Initiator>(g,g.apply("_MultipartUpload._Initiator_",v));
}
template <>
s3_test::_NoncurrentVersionExpiration _arg<s3_test::_NoncurrentVersionExpiration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NoncurrentVersionExpiration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_NoncurrentDays_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._NoncurrentDays_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentDays_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NoncurrentVersionExpiration>(ivy_deser &inp, s3_test::_NoncurrentVersionExpiration &res){
    inp.open_struct();
    inp.open_field("_NoncurrentDays_");
    __deser(inp,res._NoncurrentDays_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v,s3_test::_NoncurrentVersionExpiration &res){
    __from_solver(g,g.apply("_NoncurrentVersionExpiration._NoncurrentDays_",v),res._NoncurrentDays_);
}
template <>
z3::expr  __to_solver<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v,s3_test::_NoncurrentVersionExpiration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_NoncurrentVersionExpiration._NoncurrentDays_",v),val._NoncurrentDays_);
    return res;
}
template <>
void  __randomize<s3_test::_NoncurrentVersionExpiration>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_NoncurrentVersionExpiration._NoncurrentDays_",v));
}
template <>
s3_test::_NoncurrentVersionTransition _arg<s3_test::_NoncurrentVersionTransition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NoncurrentVersionTransition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_NoncurrentDays_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._NoncurrentDays_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentDays_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NoncurrentVersionTransition>(ivy_deser &inp, s3_test::_NoncurrentVersionTransition &res){
    inp.open_struct();
    inp.open_field("_NoncurrentDays_");
    __deser(inp,res._NoncurrentDays_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v,s3_test::_NoncurrentVersionTransition &res){
    __from_solver(g,g.apply("_NoncurrentVersionTransition._NoncurrentDays_",v),res._NoncurrentDays_);
    __from_solver(g,g.apply("_NoncurrentVersionTransition._StorageClass_",v),res._StorageClass_);
}
template <>
z3::expr  __to_solver<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v,s3_test::_NoncurrentVersionTransition &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_NoncurrentVersionTransition._NoncurrentDays_",v),val._NoncurrentDays_);
    res = res && __to_solver(g,g.apply("_NoncurrentVersionTransition._StorageClass_",v),val._StorageClass_);
    return res;
}
template <>
void  __randomize<s3_test::_NoncurrentVersionTransition>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_NoncurrentVersionTransition._NoncurrentDays_",v));
    __randomize<s3_test::string>(g,g.apply("_NoncurrentVersionTransition._StorageClass_",v));
}
template <>
s3_test::_NotificationConfigurationFilter _arg<s3_test::_NotificationConfigurationFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_NotificationConfigurationFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::_S3KeyFilter>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_NotificationConfigurationFilter>(ivy_deser &inp, s3_test::_NotificationConfigurationFilter &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v,s3_test::_NotificationConfigurationFilter &res){
    __from_solver(g,g.apply("_NotificationConfigurationFilter._Key_",v),res._Key_);
}
template <>
z3::expr  __to_solver<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v,s3_test::_NotificationConfigurationFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_NotificationConfigurationFilter._Key_",v),val._Key_);
    return res;
}
template <>
void  __randomize<s3_test::_NotificationConfigurationFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_S3KeyFilter>(g,g.apply("_NotificationConfigurationFilter._Key_",v));
}
template <>
s3_test::_Object _arg<s3_test::_Object>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Object res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Object>(ivy_deser &inp, s3_test::_Object &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Object>( gen &g, const  z3::expr &v,s3_test::_Object &res){
    __from_solver(g,g.apply("_Object._Key_",v),res._Key_);
    __from_solver(g,g.apply("_Object._LastModified_",v),res._LastModified_);
    __from_solver(g,g.apply("_Object._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_Object._Size_",v),res._Size_);
    __from_solver(g,g.apply("_Object._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_Object._Owner_",v),res._Owner_);
}
template <>
z3::expr  __to_solver<s3_test::_Object>( gen &g, const  z3::expr &v,s3_test::_Object &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Object._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_Object._LastModified_",v),val._LastModified_);
    res = res && __to_solver(g,g.apply("_Object._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_Object._Size_",v),val._Size_);
    res = res && __to_solver(g,g.apply("_Object._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_Object._Owner_",v),val._Owner_);
    return res;
}
template <>
void  __randomize<s3_test::_Object>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Object._Key_",v));
    __randomize<int>(g,g.apply("_Object._LastModified_",v));
    __randomize<s3_test::string>(g,g.apply("_Object._ETag_",v));
    __randomize<int>(g,g.apply("_Object._Size_",v));
    __randomize<s3_test::string>(g,g.apply("_Object._StorageClass_",v));
    __randomize<s3_test::_Owner>(g,g.apply("_Object._Owner_",v));
}
template <>
s3_test::_ObjectIdentifier _arg<s3_test::_ObjectIdentifier>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectIdentifier res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._VersionId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectIdentifier>(ivy_deser &inp, s3_test::_ObjectIdentifier &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v,s3_test::_ObjectIdentifier &res){
    __from_solver(g,g.apply("_ObjectIdentifier._Key_",v),res._Key_);
    __from_solver(g,g.apply("_ObjectIdentifier._VersionId_",v),res._VersionId_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v,s3_test::_ObjectIdentifier &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectIdentifier._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_ObjectIdentifier._VersionId_",v),val._VersionId_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectIdentifier>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ObjectIdentifier._Key_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_ObjectIdentifier._VersionId_",v));
}
template <>
s3_test::_ObjectLockConfiguration _arg<s3_test::_ObjectLockConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ObjectLockEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ObjectLockEnabled_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Rule_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Rule_ = _arg<s3_test::_ObjectLockRule>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Rule_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockConfiguration>(ivy_deser &inp, s3_test::_ObjectLockConfiguration &res){
    inp.open_struct();
    inp.open_field("_ObjectLockEnabled_");
    __deser(inp,res._ObjectLockEnabled_);
    inp.close_field();
    inp.open_field("_Rule_");
    __deser(inp,res._Rule_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v,s3_test::_ObjectLockConfiguration &res){
    __from_solver(g,g.apply("_ObjectLockConfiguration._ObjectLockEnabled_",v),res._ObjectLockEnabled_);
    __from_solver(g,g.apply("_ObjectLockConfiguration._Rule_",v),res._Rule_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v,s3_test::_ObjectLockConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectLockConfiguration._ObjectLockEnabled_",v),val._ObjectLockEnabled_);
    res = res && __to_solver(g,g.apply("_ObjectLockConfiguration._Rule_",v),val._Rule_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectLockConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ObjectLockConfiguration._ObjectLockEnabled_",v));
    __randomize<s3_test::_ObjectLockRule>(g,g.apply("_ObjectLockConfiguration._Rule_",v));
}
template <>
s3_test::_ObjectLockLegalHold _arg<s3_test::_ObjectLockLegalHold>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockLegalHold res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockLegalHold>(ivy_deser &inp, s3_test::_ObjectLockLegalHold &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v,s3_test::_ObjectLockLegalHold &res){
    __from_solver(g,g.apply("_ObjectLockLegalHold._Status_",v),res._Status_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v,s3_test::_ObjectLockLegalHold &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectLockLegalHold._Status_",v),val._Status_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectLockLegalHold>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ObjectLockLegalHold._Status_",v));
}
template <>
s3_test::_ObjectLockRetention _arg<s3_test::_ObjectLockRetention>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockRetention res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Mode_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Mode_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Mode_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_RetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._RetainUntilDate_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RetainUntilDate_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockRetention>(ivy_deser &inp, s3_test::_ObjectLockRetention &res){
    inp.open_struct();
    inp.open_field("_Mode_");
    __deser(inp,res._Mode_);
    inp.close_field();
    inp.open_field("_RetainUntilDate_");
    __deser(inp,res._RetainUntilDate_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v,s3_test::_ObjectLockRetention &res){
    __from_solver(g,g.apply("_ObjectLockRetention._Mode_",v),res._Mode_);
    __from_solver(g,g.apply("_ObjectLockRetention._RetainUntilDate_",v),res._RetainUntilDate_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v,s3_test::_ObjectLockRetention &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectLockRetention._Mode_",v),val._Mode_);
    res = res && __to_solver(g,g.apply("_ObjectLockRetention._RetainUntilDate_",v),val._RetainUntilDate_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectLockRetention>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ObjectLockRetention._Mode_",v));
    __randomize<int>(g,g.apply("_ObjectLockRetention._RetainUntilDate_",v));
}
template <>
s3_test::_ObjectLockRule _arg<s3_test::_ObjectLockRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectLockRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DefaultRetention_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DefaultRetention_ = _arg<s3_test::_DefaultRetention>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DefaultRetention_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectLockRule>(ivy_deser &inp, s3_test::_ObjectLockRule &res){
    inp.open_struct();
    inp.open_field("_DefaultRetention_");
    __deser(inp,res._DefaultRetention_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v,s3_test::_ObjectLockRule &res){
    __from_solver(g,g.apply("_ObjectLockRule._DefaultRetention_",v),res._DefaultRetention_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v,s3_test::_ObjectLockRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectLockRule._DefaultRetention_",v),val._DefaultRetention_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectLockRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_DefaultRetention>(g,g.apply("_ObjectLockRule._DefaultRetention_",v));
}
template <>
s3_test::_ObjectVersion _arg<s3_test::_ObjectVersion>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ObjectVersion res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_IsLatest_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._IsLatest_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _IsLatest_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_Owner_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._Owner_ = _arg<s3_test::_Owner>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Owner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ObjectVersion>(ivy_deser &inp, s3_test::_ObjectVersion &res){
    inp.open_struct();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_IsLatest_");
    __deser(inp,res._IsLatest_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_Owner_");
    __deser(inp,res._Owner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v,s3_test::_ObjectVersion &res){
    __from_solver(g,g.apply("_ObjectVersion._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_ObjectVersion._Size_",v),res._Size_);
    __from_solver(g,g.apply("_ObjectVersion._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_ObjectVersion._Key_",v),res._Key_);
    __from_solver(g,g.apply("_ObjectVersion._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_ObjectVersion._IsLatest_",v),res._IsLatest_);
    __from_solver(g,g.apply("_ObjectVersion._LastModified_",v),res._LastModified_);
    __from_solver(g,g.apply("_ObjectVersion._Owner_",v),res._Owner_);
}
template <>
z3::expr  __to_solver<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v,s3_test::_ObjectVersion &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ObjectVersion._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._Size_",v),val._Size_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._IsLatest_",v),val._IsLatest_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._LastModified_",v),val._LastModified_);
    res = res && __to_solver(g,g.apply("_ObjectVersion._Owner_",v),val._Owner_);
    return res;
}
template <>
void  __randomize<s3_test::_ObjectVersion>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ObjectVersion._ETag_",v));
    __randomize<int>(g,g.apply("_ObjectVersion._Size_",v));
    __randomize<s3_test::string>(g,g.apply("_ObjectVersion._StorageClass_",v));
    __randomize<s3_test::string>(g,g.apply("_ObjectVersion._Key_",v));
    __randomize<s3_test::string>(g,g.apply("_ObjectVersion._VersionId_",v));
    __randomize<bool>(g,g.apply("_ObjectVersion._IsLatest_",v));
    __randomize<int>(g,g.apply("_ObjectVersion._LastModified_",v));
    __randomize<s3_test::_Owner>(g,g.apply("_ObjectVersion._Owner_",v));
}
template <>
s3_test::_OutputLocation _arg<s3_test::_OutputLocation>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OutputLocation res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_S3_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._S3_ = _arg<s3_test::_S3Location>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _S3_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OutputLocation>(ivy_deser &inp, s3_test::_OutputLocation &res){
    inp.open_struct();
    inp.open_field("_S3_");
    __deser(inp,res._S3_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_OutputLocation>( gen &g, const  z3::expr &v,s3_test::_OutputLocation &res){
    __from_solver(g,g.apply("_OutputLocation._S3_",v),res._S3_);
}
template <>
z3::expr  __to_solver<s3_test::_OutputLocation>( gen &g, const  z3::expr &v,s3_test::_OutputLocation &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_OutputLocation._S3_",v),val._S3_);
    return res;
}
template <>
void  __randomize<s3_test::_OutputLocation>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_S3Location>(g,g.apply("_OutputLocation._S3_",v));
}
template <>
s3_test::_OutputSerialization _arg<s3_test::_OutputSerialization>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OutputSerialization res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_CSV_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._CSV_ = _arg<s3_test::_CSVOutput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CSV_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_JSON_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._JSON_ = _arg<s3_test::_JSONOutput>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _JSON_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OutputSerialization>(ivy_deser &inp, s3_test::_OutputSerialization &res){
    inp.open_struct();
    inp.open_field("_CSV_");
    __deser(inp,res._CSV_);
    inp.close_field();
    inp.open_field("_JSON_");
    __deser(inp,res._JSON_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v,s3_test::_OutputSerialization &res){
    __from_solver(g,g.apply("_OutputSerialization._CSV_",v),res._CSV_);
    __from_solver(g,g.apply("_OutputSerialization._JSON_",v),res._JSON_);
}
template <>
z3::expr  __to_solver<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v,s3_test::_OutputSerialization &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_OutputSerialization._CSV_",v),val._CSV_);
    res = res && __to_solver(g,g.apply("_OutputSerialization._JSON_",v),val._JSON_);
    return res;
}
template <>
void  __randomize<s3_test::_OutputSerialization>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_CSVOutput>(g,g.apply("_OutputSerialization._CSV_",v));
    __randomize<s3_test::_JSONOutput>(g,g.apply("_OutputSerialization._JSON_",v));
}
template <>
s3_test::_Owner _arg<s3_test::_Owner>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Owner res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DisplayName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DisplayName_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DisplayName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Owner>(ivy_deser &inp, s3_test::_Owner &res){
    inp.open_struct();
    inp.open_field("_DisplayName_");
    __deser(inp,res._DisplayName_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Owner>( gen &g, const  z3::expr &v,s3_test::_Owner &res){
    __from_solver(g,g.apply("_Owner._DisplayName_",v),res._DisplayName_);
    __from_solver(g,g.apply("_Owner._ID_",v),res._ID_);
}
template <>
z3::expr  __to_solver<s3_test::_Owner>( gen &g, const  z3::expr &v,s3_test::_Owner &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Owner._DisplayName_",v),val._DisplayName_);
    res = res && __to_solver(g,g.apply("_Owner._ID_",v),val._ID_);
    return res;
}
template <>
void  __randomize<s3_test::_Owner>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Owner._DisplayName_",v));
    __randomize<s3_test::string>(g,g.apply("_Owner._ID_",v));
}
template <>
s3_test::_OwnershipControlsRule _arg<s3_test::_OwnershipControlsRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_OwnershipControlsRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ObjectOwnership_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ObjectOwnership_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectOwnership_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_OwnershipControlsRule>(ivy_deser &inp, s3_test::_OwnershipControlsRule &res){
    inp.open_struct();
    inp.open_field("_ObjectOwnership_");
    __deser(inp,res._ObjectOwnership_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v,s3_test::_OwnershipControlsRule &res){
    __from_solver(g,g.apply("_OwnershipControlsRule._ObjectOwnership_",v),res._ObjectOwnership_);
}
template <>
z3::expr  __to_solver<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v,s3_test::_OwnershipControlsRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_OwnershipControlsRule._ObjectOwnership_",v),val._ObjectOwnership_);
    return res;
}
template <>
void  __randomize<s3_test::_OwnershipControlsRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_OwnershipControlsRule._ObjectOwnership_",v));
}
template <>
s3_test::_ParquetInput _arg<s3_test::_ParquetInput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ParquetInput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 0) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    return res;
}
template <>
void __deser<s3_test::_ParquetInput>(ivy_deser &inp, s3_test::_ParquetInput &res){
    inp.open_struct();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ParquetInput>( gen &g, const  z3::expr &v,s3_test::_ParquetInput &res){
}
template <>
z3::expr  __to_solver<s3_test::_ParquetInput>( gen &g, const  z3::expr &v,s3_test::_ParquetInput &val){
    z3::expr res = g.ctx.bool_val(1);
    return res;
}
template <>
void  __randomize<s3_test::_ParquetInput>( gen &g, const  z3::expr &v){
}
template <>
s3_test::_Part _arg<s3_test::_Part>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Part res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_PartNumber_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._PartNumber_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _PartNumber_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_LastModified_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._LastModified_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _LastModified_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Size_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Size_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Size_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Part>(ivy_deser &inp, s3_test::_Part &res){
    inp.open_struct();
    inp.open_field("_PartNumber_");
    __deser(inp,res._PartNumber_);
    inp.close_field();
    inp.open_field("_LastModified_");
    __deser(inp,res._LastModified_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_Size_");
    __deser(inp,res._Size_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Part>( gen &g, const  z3::expr &v,s3_test::_Part &res){
    __from_solver(g,g.apply("_Part._PartNumber_",v),res._PartNumber_);
    __from_solver(g,g.apply("_Part._LastModified_",v),res._LastModified_);
    __from_solver(g,g.apply("_Part._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_Part._Size_",v),res._Size_);
}
template <>
z3::expr  __to_solver<s3_test::_Part>( gen &g, const  z3::expr &v,s3_test::_Part &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Part._PartNumber_",v),val._PartNumber_);
    res = res && __to_solver(g,g.apply("_Part._LastModified_",v),val._LastModified_);
    res = res && __to_solver(g,g.apply("_Part._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_Part._Size_",v),val._Size_);
    return res;
}
template <>
void  __randomize<s3_test::_Part>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_Part._PartNumber_",v));
    __randomize<int>(g,g.apply("_Part._LastModified_",v));
    __randomize<s3_test::string>(g,g.apply("_Part._ETag_",v));
    __randomize<int>(g,g.apply("_Part._Size_",v));
}
template <>
s3_test::_PutObjectOutput _arg<s3_test::_PutObjectOutput>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_PutObjectOutput res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 10) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ETag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ETag_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ETag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._ServerSideEncryption_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_VersionId_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._VersionId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _VersionId_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._SSEKMSKeyId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_SSEKMSEncryptionContext_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._SSEKMSEncryptionContext_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSEncryptionContext_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_RequestCharged_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._RequestCharged_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestCharged_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_PutObjectOutput>(ivy_deser &inp, s3_test::_PutObjectOutput &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ETag_");
    __deser(inp,res._ETag_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_VersionId_");
    __deser(inp,res._VersionId_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_SSEKMSEncryptionContext_");
    __deser(inp,res._SSEKMSEncryptionContext_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_RequestCharged_");
    __deser(inp,res._RequestCharged_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v,s3_test::_PutObjectOutput &res){
    __from_solver(g,g.apply("_PutObjectOutput._Expiration_",v),res._Expiration_);
    __from_solver(g,g.apply("_PutObjectOutput._ETag_",v),res._ETag_);
    __from_solver(g,g.apply("_PutObjectOutput._ServerSideEncryption_",v),res._ServerSideEncryption_);
    __from_solver(g,g.apply("_PutObjectOutput._VersionId_",v),res._VersionId_);
    __from_solver(g,g.apply("_PutObjectOutput._SSECustomerAlgorithm_",v),res._SSECustomerAlgorithm_);
    __from_solver(g,g.apply("_PutObjectOutput._SSECustomerKeyMD5_",v),res._SSECustomerKeyMD5_);
    __from_solver(g,g.apply("_PutObjectOutput._SSEKMSKeyId_",v),res._SSEKMSKeyId_);
    __from_solver(g,g.apply("_PutObjectOutput._SSEKMSEncryptionContext_",v),res._SSEKMSEncryptionContext_);
    __from_solver(g,g.apply("_PutObjectOutput._BucketKeyEnabled_",v),res._BucketKeyEnabled_);
    __from_solver(g,g.apply("_PutObjectOutput._RequestCharged_",v),res._RequestCharged_);
}
template <>
z3::expr  __to_solver<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v,s3_test::_PutObjectOutput &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._Expiration_",v),val._Expiration_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._ETag_",v),val._ETag_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._ServerSideEncryption_",v),val._ServerSideEncryption_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._VersionId_",v),val._VersionId_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._SSECustomerAlgorithm_",v),val._SSECustomerAlgorithm_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._SSECustomerKeyMD5_",v),val._SSECustomerKeyMD5_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._SSEKMSKeyId_",v),val._SSEKMSKeyId_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._SSEKMSEncryptionContext_",v),val._SSEKMSEncryptionContext_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._BucketKeyEnabled_",v),val._BucketKeyEnabled_);
    res = res && __to_solver(g,g.apply("_PutObjectOutput._RequestCharged_",v),val._RequestCharged_);
    return res;
}
template <>
void  __randomize<s3_test::_PutObjectOutput>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._Expiration_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._ETag_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._ServerSideEncryption_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._VersionId_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._SSECustomerAlgorithm_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._SSECustomerKeyMD5_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._SSEKMSKeyId_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._SSEKMSEncryptionContext_",v));
    __randomize<bool>(g,g.apply("_PutObjectOutput._BucketKeyEnabled_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectOutput._RequestCharged_",v));
}
template <>
s3_test::_PutObjectRequest _arg<s3_test::_PutObjectRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_PutObjectRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 32) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ACL_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ACL_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ACL_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Body_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Body_ = _arg<s3_test::option__blob__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Body_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Bucket_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Bucket_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Bucket_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_CacheControl_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._CacheControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CacheControl_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ContentDisposition_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ContentDisposition_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentDisposition_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_ContentEncoding_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._ContentEncoding_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentEncoding_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ContentLanguage_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ContentLanguage_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLanguage_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_ContentLength_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._ContentLength_ = _arg<s3_test::option__long__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentLength_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_ContentMD5_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._ContentMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[9].is_member()){
        tmp_args[0] = arg.fields[9].fields[0];
        if (arg.fields[9].atom != "_ContentType_") throw out_of_bounds("unexpected field: " + arg.fields[9].atom,arg.fields[9].pos);
    }
    else{
        tmp_args[0] = arg.fields[9];
    }
    try{
        res._ContentType_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ContentType_: " + err.txt,err.pos);
    }
    if (arg.fields[10].is_member()){
        tmp_args[0] = arg.fields[10].fields[0];
        if (arg.fields[10].atom != "_Expires_") throw out_of_bounds("unexpected field: " + arg.fields[10].atom,arg.fields[10].pos);
    }
    else{
        tmp_args[0] = arg.fields[10];
    }
    try{
        res._Expires_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expires_: " + err.txt,err.pos);
    }
    if (arg.fields[11].is_member()){
        tmp_args[0] = arg.fields[11].fields[0];
        if (arg.fields[11].atom != "_GrantFullControl_") throw out_of_bounds("unexpected field: " + arg.fields[11].atom,arg.fields[11].pos);
    }
    else{
        tmp_args[0] = arg.fields[11];
    }
    try{
        res._GrantFullControl_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantFullControl_: " + err.txt,err.pos);
    }
    if (arg.fields[12].is_member()){
        tmp_args[0] = arg.fields[12].fields[0];
        if (arg.fields[12].atom != "_GrantRead_") throw out_of_bounds("unexpected field: " + arg.fields[12].atom,arg.fields[12].pos);
    }
    else{
        tmp_args[0] = arg.fields[12];
    }
    try{
        res._GrantRead_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantRead_: " + err.txt,err.pos);
    }
    if (arg.fields[13].is_member()){
        tmp_args[0] = arg.fields[13].fields[0];
        if (arg.fields[13].atom != "_GrantReadACP_") throw out_of_bounds("unexpected field: " + arg.fields[13].atom,arg.fields[13].pos);
    }
    else{
        tmp_args[0] = arg.fields[13];
    }
    try{
        res._GrantReadACP_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantReadACP_: " + err.txt,err.pos);
    }
    if (arg.fields[14].is_member()){
        tmp_args[0] = arg.fields[14].fields[0];
        if (arg.fields[14].atom != "_GrantWriteACP_") throw out_of_bounds("unexpected field: " + arg.fields[14].atom,arg.fields[14].pos);
    }
    else{
        tmp_args[0] = arg.fields[14];
    }
    try{
        res._GrantWriteACP_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GrantWriteACP_: " + err.txt,err.pos);
    }
    if (arg.fields[15].is_member()){
        tmp_args[0] = arg.fields[15].fields[0];
        if (arg.fields[15].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[15].atom,arg.fields[15].pos);
    }
    else{
        tmp_args[0] = arg.fields[15];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[16].is_member()){
        tmp_args[0] = arg.fields[16].fields[0];
        if (arg.fields[16].atom != "_Metadata_") throw out_of_bounds("unexpected field: " + arg.fields[16].atom,arg.fields[16].pos);
    }
    else{
        tmp_args[0] = arg.fields[16];
    }
    try{
        res._Metadata_ = _arg<s3_test::option__unordered_map__string____string____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Metadata_: " + err.txt,err.pos);
    }
    if (arg.fields[17].is_member()){
        tmp_args[0] = arg.fields[17].fields[0];
        if (arg.fields[17].atom != "_ServerSideEncryption_") throw out_of_bounds("unexpected field: " + arg.fields[17].atom,arg.fields[17].pos);
    }
    else{
        tmp_args[0] = arg.fields[17];
    }
    try{
        res._ServerSideEncryption_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ServerSideEncryption_: " + err.txt,err.pos);
    }
    if (arg.fields[18].is_member()){
        tmp_args[0] = arg.fields[18].fields[0];
        if (arg.fields[18].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[18].atom,arg.fields[18].pos);
    }
    else{
        tmp_args[0] = arg.fields[18];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    if (arg.fields[19].is_member()){
        tmp_args[0] = arg.fields[19].fields[0];
        if (arg.fields[19].atom != "_WebsiteRedirectLocation_") throw out_of_bounds("unexpected field: " + arg.fields[19].atom,arg.fields[19].pos);
    }
    else{
        tmp_args[0] = arg.fields[19];
    }
    try{
        res._WebsiteRedirectLocation_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _WebsiteRedirectLocation_: " + err.txt,err.pos);
    }
    if (arg.fields[20].is_member()){
        tmp_args[0] = arg.fields[20].fields[0];
        if (arg.fields[20].atom != "_SSECustomerAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[20].atom,arg.fields[20].pos);
    }
    else{
        tmp_args[0] = arg.fields[20];
    }
    try{
        res._SSECustomerAlgorithm_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[21].is_member()){
        tmp_args[0] = arg.fields[21].fields[0];
        if (arg.fields[21].atom != "_SSECustomerKey_") throw out_of_bounds("unexpected field: " + arg.fields[21].atom,arg.fields[21].pos);
    }
    else{
        tmp_args[0] = arg.fields[21];
    }
    try{
        res._SSECustomerKey_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKey_: " + err.txt,err.pos);
    }
    if (arg.fields[22].is_member()){
        tmp_args[0] = arg.fields[22].fields[0];
        if (arg.fields[22].atom != "_SSECustomerKeyMD5_") throw out_of_bounds("unexpected field: " + arg.fields[22].atom,arg.fields[22].pos);
    }
    else{
        tmp_args[0] = arg.fields[22];
    }
    try{
        res._SSECustomerKeyMD5_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSECustomerKeyMD5_: " + err.txt,err.pos);
    }
    if (arg.fields[23].is_member()){
        tmp_args[0] = arg.fields[23].fields[0];
        if (arg.fields[23].atom != "_SSEKMSKeyId_") throw out_of_bounds("unexpected field: " + arg.fields[23].atom,arg.fields[23].pos);
    }
    else{
        tmp_args[0] = arg.fields[23];
    }
    try{
        res._SSEKMSKeyId_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSKeyId_: " + err.txt,err.pos);
    }
    if (arg.fields[24].is_member()){
        tmp_args[0] = arg.fields[24].fields[0];
        if (arg.fields[24].atom != "_SSEKMSEncryptionContext_") throw out_of_bounds("unexpected field: " + arg.fields[24].atom,arg.fields[24].pos);
    }
    else{
        tmp_args[0] = arg.fields[24];
    }
    try{
        res._SSEKMSEncryptionContext_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEKMSEncryptionContext_: " + err.txt,err.pos);
    }
    if (arg.fields[25].is_member()){
        tmp_args[0] = arg.fields[25].fields[0];
        if (arg.fields[25].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[25].atom,arg.fields[25].pos);
    }
    else{
        tmp_args[0] = arg.fields[25];
    }
    try{
        res._BucketKeyEnabled_ = _arg<s3_test::option__bool__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    if (arg.fields[26].is_member()){
        tmp_args[0] = arg.fields[26].fields[0];
        if (arg.fields[26].atom != "_RequestPayer_") throw out_of_bounds("unexpected field: " + arg.fields[26].atom,arg.fields[26].pos);
    }
    else{
        tmp_args[0] = arg.fields[26];
    }
    try{
        res._RequestPayer_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _RequestPayer_: " + err.txt,err.pos);
    }
    if (arg.fields[27].is_member()){
        tmp_args[0] = arg.fields[27].fields[0];
        if (arg.fields[27].atom != "_Tagging_") throw out_of_bounds("unexpected field: " + arg.fields[27].atom,arg.fields[27].pos);
    }
    else{
        tmp_args[0] = arg.fields[27];
    }
    try{
        res._Tagging_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tagging_: " + err.txt,err.pos);
    }
    if (arg.fields[28].is_member()){
        tmp_args[0] = arg.fields[28].fields[0];
        if (arg.fields[28].atom != "_ObjectLockMode_") throw out_of_bounds("unexpected field: " + arg.fields[28].atom,arg.fields[28].pos);
    }
    else{
        tmp_args[0] = arg.fields[28];
    }
    try{
        res._ObjectLockMode_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockMode_: " + err.txt,err.pos);
    }
    if (arg.fields[29].is_member()){
        tmp_args[0] = arg.fields[29].fields[0];
        if (arg.fields[29].atom != "_ObjectLockRetainUntilDate_") throw out_of_bounds("unexpected field: " + arg.fields[29].atom,arg.fields[29].pos);
    }
    else{
        tmp_args[0] = arg.fields[29];
    }
    try{
        res._ObjectLockRetainUntilDate_ = _arg<s3_test::option__timestamp__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockRetainUntilDate_: " + err.txt,err.pos);
    }
    if (arg.fields[30].is_member()){
        tmp_args[0] = arg.fields[30].fields[0];
        if (arg.fields[30].atom != "_ObjectLockLegalHoldStatus_") throw out_of_bounds("unexpected field: " + arg.fields[30].atom,arg.fields[30].pos);
    }
    else{
        tmp_args[0] = arg.fields[30];
    }
    try{
        res._ObjectLockLegalHoldStatus_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ObjectLockLegalHoldStatus_: " + err.txt,err.pos);
    }
    if (arg.fields[31].is_member()){
        tmp_args[0] = arg.fields[31].fields[0];
        if (arg.fields[31].atom != "_ExpectedBucketOwner_") throw out_of_bounds("unexpected field: " + arg.fields[31].atom,arg.fields[31].pos);
    }
    else{
        tmp_args[0] = arg.fields[31];
    }
    try{
        res._ExpectedBucketOwner_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpectedBucketOwner_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_PutObjectRequest>(ivy_deser &inp, s3_test::_PutObjectRequest &res){
    inp.open_struct();
    inp.open_field("_ACL_");
    __deser(inp,res._ACL_);
    inp.close_field();
    inp.open_field("_Body_");
    __deser(inp,res._Body_);
    inp.close_field();
    inp.open_field("_Bucket_");
    __deser(inp,res._Bucket_);
    inp.close_field();
    inp.open_field("_CacheControl_");
    __deser(inp,res._CacheControl_);
    inp.close_field();
    inp.open_field("_ContentDisposition_");
    __deser(inp,res._ContentDisposition_);
    inp.close_field();
    inp.open_field("_ContentEncoding_");
    __deser(inp,res._ContentEncoding_);
    inp.close_field();
    inp.open_field("_ContentLanguage_");
    __deser(inp,res._ContentLanguage_);
    inp.close_field();
    inp.open_field("_ContentLength_");
    __deser(inp,res._ContentLength_);
    inp.close_field();
    inp.open_field("_ContentMD5_");
    __deser(inp,res._ContentMD5_);
    inp.close_field();
    inp.open_field("_ContentType_");
    __deser(inp,res._ContentType_);
    inp.close_field();
    inp.open_field("_Expires_");
    __deser(inp,res._Expires_);
    inp.close_field();
    inp.open_field("_GrantFullControl_");
    __deser(inp,res._GrantFullControl_);
    inp.close_field();
    inp.open_field("_GrantRead_");
    __deser(inp,res._GrantRead_);
    inp.close_field();
    inp.open_field("_GrantReadACP_");
    __deser(inp,res._GrantReadACP_);
    inp.close_field();
    inp.open_field("_GrantWriteACP_");
    __deser(inp,res._GrantWriteACP_);
    inp.close_field();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Metadata_");
    __deser(inp,res._Metadata_);
    inp.close_field();
    inp.open_field("_ServerSideEncryption_");
    __deser(inp,res._ServerSideEncryption_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.open_field("_WebsiteRedirectLocation_");
    __deser(inp,res._WebsiteRedirectLocation_);
    inp.close_field();
    inp.open_field("_SSECustomerAlgorithm_");
    __deser(inp,res._SSECustomerAlgorithm_);
    inp.close_field();
    inp.open_field("_SSECustomerKey_");
    __deser(inp,res._SSECustomerKey_);
    inp.close_field();
    inp.open_field("_SSECustomerKeyMD5_");
    __deser(inp,res._SSECustomerKeyMD5_);
    inp.close_field();
    inp.open_field("_SSEKMSKeyId_");
    __deser(inp,res._SSEKMSKeyId_);
    inp.close_field();
    inp.open_field("_SSEKMSEncryptionContext_");
    __deser(inp,res._SSEKMSEncryptionContext_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.open_field("_RequestPayer_");
    __deser(inp,res._RequestPayer_);
    inp.close_field();
    inp.open_field("_Tagging_");
    __deser(inp,res._Tagging_);
    inp.close_field();
    inp.open_field("_ObjectLockMode_");
    __deser(inp,res._ObjectLockMode_);
    inp.close_field();
    inp.open_field("_ObjectLockRetainUntilDate_");
    __deser(inp,res._ObjectLockRetainUntilDate_);
    inp.close_field();
    inp.open_field("_ObjectLockLegalHoldStatus_");
    __deser(inp,res._ObjectLockLegalHoldStatus_);
    inp.close_field();
    inp.open_field("_ExpectedBucketOwner_");
    __deser(inp,res._ExpectedBucketOwner_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v,s3_test::_PutObjectRequest &res){
    __from_solver(g,g.apply("_PutObjectRequest._ACL_",v),res._ACL_);
    __from_solver(g,g.apply("_PutObjectRequest._Body_",v),res._Body_);
    __from_solver(g,g.apply("_PutObjectRequest._Bucket_",v),res._Bucket_);
    __from_solver(g,g.apply("_PutObjectRequest._CacheControl_",v),res._CacheControl_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentDisposition_",v),res._ContentDisposition_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentEncoding_",v),res._ContentEncoding_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentLanguage_",v),res._ContentLanguage_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentLength_",v),res._ContentLength_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentMD5_",v),res._ContentMD5_);
    __from_solver(g,g.apply("_PutObjectRequest._ContentType_",v),res._ContentType_);
    __from_solver(g,g.apply("_PutObjectRequest._Expires_",v),res._Expires_);
    __from_solver(g,g.apply("_PutObjectRequest._GrantFullControl_",v),res._GrantFullControl_);
    __from_solver(g,g.apply("_PutObjectRequest._GrantRead_",v),res._GrantRead_);
    __from_solver(g,g.apply("_PutObjectRequest._GrantReadACP_",v),res._GrantReadACP_);
    __from_solver(g,g.apply("_PutObjectRequest._GrantWriteACP_",v),res._GrantWriteACP_);
    __from_solver(g,g.apply("_PutObjectRequest._Key_",v),res._Key_);
    __from_solver(g,g.apply("_PutObjectRequest._Metadata_",v),res._Metadata_);
    __from_solver(g,g.apply("_PutObjectRequest._ServerSideEncryption_",v),res._ServerSideEncryption_);
    __from_solver(g,g.apply("_PutObjectRequest._StorageClass_",v),res._StorageClass_);
    __from_solver(g,g.apply("_PutObjectRequest._WebsiteRedirectLocation_",v),res._WebsiteRedirectLocation_);
    __from_solver(g,g.apply("_PutObjectRequest._SSECustomerAlgorithm_",v),res._SSECustomerAlgorithm_);
    __from_solver(g,g.apply("_PutObjectRequest._SSECustomerKey_",v),res._SSECustomerKey_);
    __from_solver(g,g.apply("_PutObjectRequest._SSECustomerKeyMD5_",v),res._SSECustomerKeyMD5_);
    __from_solver(g,g.apply("_PutObjectRequest._SSEKMSKeyId_",v),res._SSEKMSKeyId_);
    __from_solver(g,g.apply("_PutObjectRequest._SSEKMSEncryptionContext_",v),res._SSEKMSEncryptionContext_);
    __from_solver(g,g.apply("_PutObjectRequest._BucketKeyEnabled_",v),res._BucketKeyEnabled_);
    __from_solver(g,g.apply("_PutObjectRequest._RequestPayer_",v),res._RequestPayer_);
    __from_solver(g,g.apply("_PutObjectRequest._Tagging_",v),res._Tagging_);
    __from_solver(g,g.apply("_PutObjectRequest._ObjectLockMode_",v),res._ObjectLockMode_);
    __from_solver(g,g.apply("_PutObjectRequest._ObjectLockRetainUntilDate_",v),res._ObjectLockRetainUntilDate_);
    __from_solver(g,g.apply("_PutObjectRequest._ObjectLockLegalHoldStatus_",v),res._ObjectLockLegalHoldStatus_);
    __from_solver(g,g.apply("_PutObjectRequest._ExpectedBucketOwner_",v),res._ExpectedBucketOwner_);
}
template <>
z3::expr  __to_solver<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v,s3_test::_PutObjectRequest &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ACL_",v),val._ACL_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Body_",v),val._Body_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Bucket_",v),val._Bucket_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._CacheControl_",v),val._CacheControl_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentDisposition_",v),val._ContentDisposition_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentEncoding_",v),val._ContentEncoding_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentLanguage_",v),val._ContentLanguage_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentLength_",v),val._ContentLength_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentMD5_",v),val._ContentMD5_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ContentType_",v),val._ContentType_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Expires_",v),val._Expires_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._GrantFullControl_",v),val._GrantFullControl_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._GrantRead_",v),val._GrantRead_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._GrantReadACP_",v),val._GrantReadACP_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._GrantWriteACP_",v),val._GrantWriteACP_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Metadata_",v),val._Metadata_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ServerSideEncryption_",v),val._ServerSideEncryption_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._StorageClass_",v),val._StorageClass_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._WebsiteRedirectLocation_",v),val._WebsiteRedirectLocation_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._SSECustomerAlgorithm_",v),val._SSECustomerAlgorithm_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._SSECustomerKey_",v),val._SSECustomerKey_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._SSECustomerKeyMD5_",v),val._SSECustomerKeyMD5_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._SSEKMSKeyId_",v),val._SSEKMSKeyId_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._SSEKMSEncryptionContext_",v),val._SSEKMSEncryptionContext_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._BucketKeyEnabled_",v),val._BucketKeyEnabled_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._RequestPayer_",v),val._RequestPayer_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._Tagging_",v),val._Tagging_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ObjectLockMode_",v),val._ObjectLockMode_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ObjectLockRetainUntilDate_",v),val._ObjectLockRetainUntilDate_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ObjectLockLegalHoldStatus_",v),val._ObjectLockLegalHoldStatus_);
    res = res && __to_solver(g,g.apply("_PutObjectRequest._ExpectedBucketOwner_",v),val._ExpectedBucketOwner_);
    return res;
}
template <>
void  __randomize<s3_test::_PutObjectRequest>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ACL_",v));
    __randomize<s3_test::option__blob__>(g,g.apply("_PutObjectRequest._Body_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectRequest._Bucket_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._CacheControl_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ContentDisposition_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ContentEncoding_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ContentLanguage_",v));
    __randomize<s3_test::option__long__>(g,g.apply("_PutObjectRequest._ContentLength_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ContentMD5_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ContentType_",v));
    __randomize<s3_test::option__timestamp__>(g,g.apply("_PutObjectRequest._Expires_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._GrantFullControl_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._GrantRead_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._GrantReadACP_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._GrantWriteACP_",v));
    __randomize<s3_test::string>(g,g.apply("_PutObjectRequest._Key_",v));
    __randomize<s3_test::option__unordered_map__string____string____>(g,g.apply("_PutObjectRequest._Metadata_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ServerSideEncryption_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._StorageClass_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._WebsiteRedirectLocation_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._SSECustomerAlgorithm_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._SSECustomerKey_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._SSECustomerKeyMD5_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._SSEKMSKeyId_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._SSEKMSEncryptionContext_",v));
    __randomize<s3_test::option__bool__>(g,g.apply("_PutObjectRequest._BucketKeyEnabled_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._RequestPayer_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._Tagging_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ObjectLockMode_",v));
    __randomize<s3_test::option__timestamp__>(g,g.apply("_PutObjectRequest._ObjectLockRetainUntilDate_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ObjectLockLegalHoldStatus_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_PutObjectRequest._ExpectedBucketOwner_",v));
}
template <>
s3_test::_QueueConfiguration _arg<s3_test::_QueueConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_QueueConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_QueueArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._QueueArn_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _QueueArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_QueueConfiguration>(ivy_deser &inp, s3_test::_QueueConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_QueueArn_");
    __deser(inp,res._QueueArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v,s3_test::_QueueConfiguration &res){
    __from_solver(g,g.apply("_QueueConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_QueueConfiguration._QueueArn_",v),res._QueueArn_);
    __from_solver(g,g.apply("_QueueConfiguration._Events_",v),res._Events_);
    __from_solver(g,g.apply("_QueueConfiguration._Filter_",v),res._Filter_);
}
template <>
z3::expr  __to_solver<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v,s3_test::_QueueConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_QueueConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_QueueConfiguration._QueueArn_",v),val._QueueArn_);
    res = res && __to_solver(g,g.apply("_QueueConfiguration._Events_",v),val._Events_);
    res = res && __to_solver(g,g.apply("_QueueConfiguration._Filter_",v),val._Filter_);
    return res;
}
template <>
void  __randomize<s3_test::_QueueConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_QueueConfiguration._Id_",v));
    __randomize<s3_test::string>(g,g.apply("_QueueConfiguration._QueueArn_",v));
    __randomize<s3_test::vector__string__>(g,g.apply("_QueueConfiguration._Events_",v));
    __randomize<s3_test::option___NotificationConfigurationFilter__>(g,g.apply("_QueueConfiguration._Filter_",v));
}
template <>
s3_test::_Redirect _arg<s3_test::_Redirect>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Redirect res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_HostName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._HostName_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HostName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_HttpRedirectCode_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._HttpRedirectCode_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _HttpRedirectCode_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Protocol_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Protocol_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Protocol_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_ReplaceKeyPrefixWith_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._ReplaceKeyPrefixWith_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplaceKeyPrefixWith_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_ReplaceKeyWith_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._ReplaceKeyWith_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplaceKeyWith_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Redirect>(ivy_deser &inp, s3_test::_Redirect &res){
    inp.open_struct();
    inp.open_field("_HostName_");
    __deser(inp,res._HostName_);
    inp.close_field();
    inp.open_field("_HttpRedirectCode_");
    __deser(inp,res._HttpRedirectCode_);
    inp.close_field();
    inp.open_field("_Protocol_");
    __deser(inp,res._Protocol_);
    inp.close_field();
    inp.open_field("_ReplaceKeyPrefixWith_");
    __deser(inp,res._ReplaceKeyPrefixWith_);
    inp.close_field();
    inp.open_field("_ReplaceKeyWith_");
    __deser(inp,res._ReplaceKeyWith_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Redirect>( gen &g, const  z3::expr &v,s3_test::_Redirect &res){
    __from_solver(g,g.apply("_Redirect._HostName_",v),res._HostName_);
    __from_solver(g,g.apply("_Redirect._HttpRedirectCode_",v),res._HttpRedirectCode_);
    __from_solver(g,g.apply("_Redirect._Protocol_",v),res._Protocol_);
    __from_solver(g,g.apply("_Redirect._ReplaceKeyPrefixWith_",v),res._ReplaceKeyPrefixWith_);
    __from_solver(g,g.apply("_Redirect._ReplaceKeyWith_",v),res._ReplaceKeyWith_);
}
template <>
z3::expr  __to_solver<s3_test::_Redirect>( gen &g, const  z3::expr &v,s3_test::_Redirect &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Redirect._HostName_",v),val._HostName_);
    res = res && __to_solver(g,g.apply("_Redirect._HttpRedirectCode_",v),val._HttpRedirectCode_);
    res = res && __to_solver(g,g.apply("_Redirect._Protocol_",v),val._Protocol_);
    res = res && __to_solver(g,g.apply("_Redirect._ReplaceKeyPrefixWith_",v),val._ReplaceKeyPrefixWith_);
    res = res && __to_solver(g,g.apply("_Redirect._ReplaceKeyWith_",v),val._ReplaceKeyWith_);
    return res;
}
template <>
void  __randomize<s3_test::_Redirect>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Redirect._HostName_",v));
    __randomize<s3_test::string>(g,g.apply("_Redirect._HttpRedirectCode_",v));
    __randomize<s3_test::string>(g,g.apply("_Redirect._Protocol_",v));
    __randomize<s3_test::string>(g,g.apply("_Redirect._ReplaceKeyPrefixWith_",v));
    __randomize<s3_test::string>(g,g.apply("_Redirect._ReplaceKeyWith_",v));
}
template <>
s3_test::_ReplicaModifications _arg<s3_test::_ReplicaModifications>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicaModifications res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicaModifications>(ivy_deser &inp, s3_test::_ReplicaModifications &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v,s3_test::_ReplicaModifications &res){
    __from_solver(g,g.apply("_ReplicaModifications._Status_",v),res._Status_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v,s3_test::_ReplicaModifications &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicaModifications._Status_",v),val._Status_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicaModifications>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ReplicaModifications._Status_",v));
}
template <>
s3_test::_ReplicationRule _arg<s3_test::_ReplicationRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 9) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Priority_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Priority_ = _arg<s3_test::option__integer__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Priority_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___ReplicationRuleFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SourceSelectionCriteria_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SourceSelectionCriteria_ = _arg<s3_test::option___SourceSelectionCriteria__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SourceSelectionCriteria_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_ExistingObjectReplication_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._ExistingObjectReplication_ = _arg<s3_test::option___ExistingObjectReplication__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExistingObjectReplication_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._Destination_ = _arg<s3_test::_Destination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    if (arg.fields[8].is_member()){
        tmp_args[0] = arg.fields[8].fields[0];
        if (arg.fields[8].atom != "_DeleteMarkerReplication_") throw out_of_bounds("unexpected field: " + arg.fields[8].atom,arg.fields[8].pos);
    }
    else{
        tmp_args[0] = arg.fields[8];
    }
    try{
        res._DeleteMarkerReplication_ = _arg<s3_test::option___DeleteMarkerReplication__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DeleteMarkerReplication_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRule>(ivy_deser &inp, s3_test::_ReplicationRule &res){
    inp.open_struct();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Priority_");
    __deser(inp,res._Priority_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_SourceSelectionCriteria_");
    __deser(inp,res._SourceSelectionCriteria_);
    inp.close_field();
    inp.open_field("_ExistingObjectReplication_");
    __deser(inp,res._ExistingObjectReplication_);
    inp.close_field();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.open_field("_DeleteMarkerReplication_");
    __deser(inp,res._DeleteMarkerReplication_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v,s3_test::_ReplicationRule &res){
    __from_solver(g,g.apply("_ReplicationRule._ID_",v),res._ID_);
    __from_solver(g,g.apply("_ReplicationRule._Priority_",v),res._Priority_);
    __from_solver(g,g.apply("_ReplicationRule._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_ReplicationRule._Filter_",v),res._Filter_);
    __from_solver(g,g.apply("_ReplicationRule._Status_",v),res._Status_);
    __from_solver(g,g.apply("_ReplicationRule._SourceSelectionCriteria_",v),res._SourceSelectionCriteria_);
    __from_solver(g,g.apply("_ReplicationRule._ExistingObjectReplication_",v),res._ExistingObjectReplication_);
    __from_solver(g,g.apply("_ReplicationRule._Destination_",v),res._Destination_);
    __from_solver(g,g.apply("_ReplicationRule._DeleteMarkerReplication_",v),res._DeleteMarkerReplication_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v,s3_test::_ReplicationRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicationRule._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._Priority_",v),val._Priority_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._Filter_",v),val._Filter_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._SourceSelectionCriteria_",v),val._SourceSelectionCriteria_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._ExistingObjectReplication_",v),val._ExistingObjectReplication_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._Destination_",v),val._Destination_);
    res = res && __to_solver(g,g.apply("_ReplicationRule._DeleteMarkerReplication_",v),val._DeleteMarkerReplication_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicationRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_ReplicationRule._ID_",v));
    __randomize<s3_test::option__integer__>(g,g.apply("_ReplicationRule._Priority_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_ReplicationRule._Prefix_",v));
    __randomize<s3_test::option___ReplicationRuleFilter__>(g,g.apply("_ReplicationRule._Filter_",v));
    __randomize<s3_test::string>(g,g.apply("_ReplicationRule._Status_",v));
    __randomize<s3_test::option___SourceSelectionCriteria__>(g,g.apply("_ReplicationRule._SourceSelectionCriteria_",v));
    __randomize<s3_test::option___ExistingObjectReplication__>(g,g.apply("_ReplicationRule._ExistingObjectReplication_",v));
    __randomize<s3_test::_Destination>(g,g.apply("_ReplicationRule._Destination_",v));
    __randomize<s3_test::option___DeleteMarkerReplication__>(g,g.apply("_ReplicationRule._DeleteMarkerReplication_",v));
}
template <>
s3_test::_ReplicationRuleAndOperator _arg<s3_test::_ReplicationRuleAndOperator>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRuleAndOperator res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tags_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tags_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tags_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRuleAndOperator>(ivy_deser &inp, s3_test::_ReplicationRuleAndOperator &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tags_");
    __deser(inp,res._Tags_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v,s3_test::_ReplicationRuleAndOperator &res){
    __from_solver(g,g.apply("_ReplicationRuleAndOperator._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_ReplicationRuleAndOperator._Tags_",v),res._Tags_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v,s3_test::_ReplicationRuleAndOperator &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicationRuleAndOperator._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_ReplicationRuleAndOperator._Tags_",v),val._Tags_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicationRuleAndOperator>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ReplicationRuleAndOperator._Prefix_",v));
    __randomize<s3_test::vector___Tag__>(g,g.apply("_ReplicationRuleAndOperator._Tags_",v));
}
template <>
s3_test::_ReplicationRuleFilter _arg<s3_test::_ReplicationRuleFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationRuleFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Tag_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Tag_ = _arg<s3_test::_Tag>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tag_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_And_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._And_ = _arg<s3_test::_ReplicationRuleAndOperator>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _And_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationRuleFilter>(ivy_deser &inp, s3_test::_ReplicationRuleFilter &res){
    inp.open_struct();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Tag_");
    __deser(inp,res._Tag_);
    inp.close_field();
    inp.open_field("_And_");
    __deser(inp,res._And_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v,s3_test::_ReplicationRuleFilter &res){
    __from_solver(g,g.apply("_ReplicationRuleFilter._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_ReplicationRuleFilter._Tag_",v),res._Tag_);
    __from_solver(g,g.apply("_ReplicationRuleFilter._And_",v),res._And_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v,s3_test::_ReplicationRuleFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicationRuleFilter._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_ReplicationRuleFilter._Tag_",v),val._Tag_);
    res = res && __to_solver(g,g.apply("_ReplicationRuleFilter._And_",v),val._And_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicationRuleFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ReplicationRuleFilter._Prefix_",v));
    __randomize<s3_test::_Tag>(g,g.apply("_ReplicationRuleFilter._Tag_",v));
    __randomize<s3_test::_ReplicationRuleAndOperator>(g,g.apply("_ReplicationRuleFilter._And_",v));
}
template <>
s3_test::_ReplicationTime _arg<s3_test::_ReplicationTime>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationTime res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Time_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Time_ = _arg<s3_test::_ReplicationTimeValue>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Time_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationTime>(ivy_deser &inp, s3_test::_ReplicationTime &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Time_");
    __deser(inp,res._Time_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v,s3_test::_ReplicationTime &res){
    __from_solver(g,g.apply("_ReplicationTime._Status_",v),res._Status_);
    __from_solver(g,g.apply("_ReplicationTime._Time_",v),res._Time_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v,s3_test::_ReplicationTime &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicationTime._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_ReplicationTime._Time_",v),val._Time_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicationTime>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ReplicationTime._Status_",v));
    __randomize<s3_test::_ReplicationTimeValue>(g,g.apply("_ReplicationTime._Time_",v));
}
template <>
s3_test::_ReplicationTimeValue _arg<s3_test::_ReplicationTimeValue>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ReplicationTimeValue res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Minutes_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Minutes_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Minutes_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ReplicationTimeValue>(ivy_deser &inp, s3_test::_ReplicationTimeValue &res){
    inp.open_struct();
    inp.open_field("_Minutes_");
    __deser(inp,res._Minutes_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v,s3_test::_ReplicationTimeValue &res){
    __from_solver(g,g.apply("_ReplicationTimeValue._Minutes_",v),res._Minutes_);
}
template <>
z3::expr  __to_solver<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v,s3_test::_ReplicationTimeValue &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ReplicationTimeValue._Minutes_",v),val._Minutes_);
    return res;
}
template <>
void  __randomize<s3_test::_ReplicationTimeValue>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_ReplicationTimeValue._Minutes_",v));
}
template <>
s3_test::_RequestProgress _arg<s3_test::_RequestProgress>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RequestProgress res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Enabled_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Enabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Enabled_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RequestProgress>(ivy_deser &inp, s3_test::_RequestProgress &res){
    inp.open_struct();
    inp.open_field("_Enabled_");
    __deser(inp,res._Enabled_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_RequestProgress>( gen &g, const  z3::expr &v,s3_test::_RequestProgress &res){
    __from_solver(g,g.apply("_RequestProgress._Enabled_",v),res._Enabled_);
}
template <>
z3::expr  __to_solver<s3_test::_RequestProgress>( gen &g, const  z3::expr &v,s3_test::_RequestProgress &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_RequestProgress._Enabled_",v),val._Enabled_);
    return res;
}
template <>
void  __randomize<s3_test::_RequestProgress>( gen &g, const  z3::expr &v){
    __randomize<bool>(g,g.apply("_RequestProgress._Enabled_",v));
}
template <>
s3_test::_RestoreRequest _arg<s3_test::_RestoreRequest>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RestoreRequest res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_GlacierJobParameters_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._GlacierJobParameters_ = _arg<s3_test::_GlacierJobParameters>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _GlacierJobParameters_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Type_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Type_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Type_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Tier_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Tier_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tier_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Description_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Description_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Description_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_SelectParameters_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._SelectParameters_ = _arg<s3_test::_SelectParameters>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SelectParameters_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_OutputLocation_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._OutputLocation_ = _arg<s3_test::_OutputLocation>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputLocation_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RestoreRequest>(ivy_deser &inp, s3_test::_RestoreRequest &res){
    inp.open_struct();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_GlacierJobParameters_");
    __deser(inp,res._GlacierJobParameters_);
    inp.close_field();
    inp.open_field("_Type_");
    __deser(inp,res._Type_);
    inp.close_field();
    inp.open_field("_Tier_");
    __deser(inp,res._Tier_);
    inp.close_field();
    inp.open_field("_Description_");
    __deser(inp,res._Description_);
    inp.close_field();
    inp.open_field("_SelectParameters_");
    __deser(inp,res._SelectParameters_);
    inp.close_field();
    inp.open_field("_OutputLocation_");
    __deser(inp,res._OutputLocation_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v,s3_test::_RestoreRequest &res){
    __from_solver(g,g.apply("_RestoreRequest._Days_",v),res._Days_);
    __from_solver(g,g.apply("_RestoreRequest._GlacierJobParameters_",v),res._GlacierJobParameters_);
    __from_solver(g,g.apply("_RestoreRequest._Type_",v),res._Type_);
    __from_solver(g,g.apply("_RestoreRequest._Tier_",v),res._Tier_);
    __from_solver(g,g.apply("_RestoreRequest._Description_",v),res._Description_);
    __from_solver(g,g.apply("_RestoreRequest._SelectParameters_",v),res._SelectParameters_);
    __from_solver(g,g.apply("_RestoreRequest._OutputLocation_",v),res._OutputLocation_);
}
template <>
z3::expr  __to_solver<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v,s3_test::_RestoreRequest &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_RestoreRequest._Days_",v),val._Days_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._GlacierJobParameters_",v),val._GlacierJobParameters_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._Type_",v),val._Type_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._Tier_",v),val._Tier_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._Description_",v),val._Description_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._SelectParameters_",v),val._SelectParameters_);
    res = res && __to_solver(g,g.apply("_RestoreRequest._OutputLocation_",v),val._OutputLocation_);
    return res;
}
template <>
void  __randomize<s3_test::_RestoreRequest>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_RestoreRequest._Days_",v));
    __randomize<s3_test::_GlacierJobParameters>(g,g.apply("_RestoreRequest._GlacierJobParameters_",v));
    __randomize<s3_test::string>(g,g.apply("_RestoreRequest._Type_",v));
    __randomize<s3_test::string>(g,g.apply("_RestoreRequest._Tier_",v));
    __randomize<s3_test::string>(g,g.apply("_RestoreRequest._Description_",v));
    __randomize<s3_test::_SelectParameters>(g,g.apply("_RestoreRequest._SelectParameters_",v));
    __randomize<s3_test::_OutputLocation>(g,g.apply("_RestoreRequest._OutputLocation_",v));
}
template <>
s3_test::_RoutingRule _arg<s3_test::_RoutingRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_RoutingRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Condition_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Condition_ = _arg<s3_test::option___Condition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Condition_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Redirect_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Redirect_ = _arg<s3_test::_Redirect>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Redirect_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_RoutingRule>(ivy_deser &inp, s3_test::_RoutingRule &res){
    inp.open_struct();
    inp.open_field("_Condition_");
    __deser(inp,res._Condition_);
    inp.close_field();
    inp.open_field("_Redirect_");
    __deser(inp,res._Redirect_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_RoutingRule>( gen &g, const  z3::expr &v,s3_test::_RoutingRule &res){
    __from_solver(g,g.apply("_RoutingRule._Condition_",v),res._Condition_);
    __from_solver(g,g.apply("_RoutingRule._Redirect_",v),res._Redirect_);
}
template <>
z3::expr  __to_solver<s3_test::_RoutingRule>( gen &g, const  z3::expr &v,s3_test::_RoutingRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_RoutingRule._Condition_",v),val._Condition_);
    res = res && __to_solver(g,g.apply("_RoutingRule._Redirect_",v),val._Redirect_);
    return res;
}
template <>
void  __randomize<s3_test::_RoutingRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option___Condition__>(g,g.apply("_RoutingRule._Condition_",v));
    __randomize<s3_test::_Redirect>(g,g.apply("_RoutingRule._Redirect_",v));
}
template <>
s3_test::_Rule _arg<s3_test::_Rule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Rule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Expiration_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Expiration_ = _arg<s3_test::option___LifecycleExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expiration_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ID_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_Transition_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._Transition_ = _arg<s3_test::option___Transition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Transition_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_NoncurrentVersionTransition_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._NoncurrentVersionTransition_ = _arg<s3_test::option___NoncurrentVersionTransition__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionTransition_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_NoncurrentVersionExpiration_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._NoncurrentVersionExpiration_ = _arg<s3_test::option___NoncurrentVersionExpiration__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _NoncurrentVersionExpiration_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_AbortIncompleteMultipartUpload_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._AbortIncompleteMultipartUpload_ = _arg<s3_test::option___AbortIncompleteMultipartUpload__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AbortIncompleteMultipartUpload_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Rule>(ivy_deser &inp, s3_test::_Rule &res){
    inp.open_struct();
    inp.open_field("_Expiration_");
    __deser(inp,res._Expiration_);
    inp.close_field();
    inp.open_field("_ID_");
    __deser(inp,res._ID_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.open_field("_Transition_");
    __deser(inp,res._Transition_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionTransition_");
    __deser(inp,res._NoncurrentVersionTransition_);
    inp.close_field();
    inp.open_field("_NoncurrentVersionExpiration_");
    __deser(inp,res._NoncurrentVersionExpiration_);
    inp.close_field();
    inp.open_field("_AbortIncompleteMultipartUpload_");
    __deser(inp,res._AbortIncompleteMultipartUpload_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Rule>( gen &g, const  z3::expr &v,s3_test::_Rule &res){
    __from_solver(g,g.apply("_Rule._Expiration_",v),res._Expiration_);
    __from_solver(g,g.apply("_Rule._ID_",v),res._ID_);
    __from_solver(g,g.apply("_Rule._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_Rule._Status_",v),res._Status_);
    __from_solver(g,g.apply("_Rule._Transition_",v),res._Transition_);
    __from_solver(g,g.apply("_Rule._NoncurrentVersionTransition_",v),res._NoncurrentVersionTransition_);
    __from_solver(g,g.apply("_Rule._NoncurrentVersionExpiration_",v),res._NoncurrentVersionExpiration_);
    __from_solver(g,g.apply("_Rule._AbortIncompleteMultipartUpload_",v),res._AbortIncompleteMultipartUpload_);
}
template <>
z3::expr  __to_solver<s3_test::_Rule>( gen &g, const  z3::expr &v,s3_test::_Rule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Rule._Expiration_",v),val._Expiration_);
    res = res && __to_solver(g,g.apply("_Rule._ID_",v),val._ID_);
    res = res && __to_solver(g,g.apply("_Rule._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_Rule._Status_",v),val._Status_);
    res = res && __to_solver(g,g.apply("_Rule._Transition_",v),val._Transition_);
    res = res && __to_solver(g,g.apply("_Rule._NoncurrentVersionTransition_",v),val._NoncurrentVersionTransition_);
    res = res && __to_solver(g,g.apply("_Rule._NoncurrentVersionExpiration_",v),val._NoncurrentVersionExpiration_);
    res = res && __to_solver(g,g.apply("_Rule._AbortIncompleteMultipartUpload_",v),val._AbortIncompleteMultipartUpload_);
    return res;
}
template <>
void  __randomize<s3_test::_Rule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option___LifecycleExpiration__>(g,g.apply("_Rule._Expiration_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_Rule._ID_",v));
    __randomize<s3_test::string>(g,g.apply("_Rule._Prefix_",v));
    __randomize<s3_test::string>(g,g.apply("_Rule._Status_",v));
    __randomize<s3_test::option___Transition__>(g,g.apply("_Rule._Transition_",v));
    __randomize<s3_test::option___NoncurrentVersionTransition__>(g,g.apply("_Rule._NoncurrentVersionTransition_",v));
    __randomize<s3_test::option___NoncurrentVersionExpiration__>(g,g.apply("_Rule._NoncurrentVersionExpiration_",v));
    __randomize<s3_test::option___AbortIncompleteMultipartUpload__>(g,g.apply("_Rule._AbortIncompleteMultipartUpload_",v));
}
template <>
s3_test::_S3KeyFilter _arg<s3_test::_S3KeyFilter>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_S3KeyFilter res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_FilterRules_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._FilterRules_ = _arg<s3_test::vector___FilterRule__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _FilterRules_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_S3KeyFilter>(ivy_deser &inp, s3_test::_S3KeyFilter &res){
    inp.open_struct();
    inp.open_field("_FilterRules_");
    __deser(inp,res._FilterRules_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v,s3_test::_S3KeyFilter &res){
    __from_solver(g,g.apply("_S3KeyFilter._FilterRules_",v),res._FilterRules_);
}
template <>
z3::expr  __to_solver<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v,s3_test::_S3KeyFilter &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_S3KeyFilter._FilterRules_",v),val._FilterRules_);
    return res;
}
template <>
void  __randomize<s3_test::_S3KeyFilter>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___FilterRule__>(g,g.apply("_S3KeyFilter._FilterRules_",v));
}
template <>
s3_test::_S3Location _arg<s3_test::_S3Location>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_S3Location res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 8) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_BucketName_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._BucketName_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketName_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Prefix_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Prefix_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Prefix_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Encryption_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Encryption_ = _arg<s3_test::option___Encryption__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Encryption_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_CannedACL_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._CannedACL_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _CannedACL_: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "_AccessControlList_") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res._AccessControlList_ = _arg<s3_test::option__vector___Grant____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessControlList_: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "_Tagging_") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res._Tagging_ = _arg<s3_test::option___Tagging__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Tagging_: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "_UserMetadata_") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res._UserMetadata_ = _arg<s3_test::option__vector___MetadataEntry____>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _UserMetadata_: " + err.txt,err.pos);
    }
    if (arg.fields[7].is_member()){
        tmp_args[0] = arg.fields[7].fields[0];
        if (arg.fields[7].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[7].atom,arg.fields[7].pos);
    }
    else{
        tmp_args[0] = arg.fields[7];
    }
    try{
        res._StorageClass_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_S3Location>(ivy_deser &inp, s3_test::_S3Location &res){
    inp.open_struct();
    inp.open_field("_BucketName_");
    __deser(inp,res._BucketName_);
    inp.close_field();
    inp.open_field("_Prefix_");
    __deser(inp,res._Prefix_);
    inp.close_field();
    inp.open_field("_Encryption_");
    __deser(inp,res._Encryption_);
    inp.close_field();
    inp.open_field("_CannedACL_");
    __deser(inp,res._CannedACL_);
    inp.close_field();
    inp.open_field("_AccessControlList_");
    __deser(inp,res._AccessControlList_);
    inp.close_field();
    inp.open_field("_Tagging_");
    __deser(inp,res._Tagging_);
    inp.close_field();
    inp.open_field("_UserMetadata_");
    __deser(inp,res._UserMetadata_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_S3Location>( gen &g, const  z3::expr &v,s3_test::_S3Location &res){
    __from_solver(g,g.apply("_S3Location._BucketName_",v),res._BucketName_);
    __from_solver(g,g.apply("_S3Location._Prefix_",v),res._Prefix_);
    __from_solver(g,g.apply("_S3Location._Encryption_",v),res._Encryption_);
    __from_solver(g,g.apply("_S3Location._CannedACL_",v),res._CannedACL_);
    __from_solver(g,g.apply("_S3Location._AccessControlList_",v),res._AccessControlList_);
    __from_solver(g,g.apply("_S3Location._Tagging_",v),res._Tagging_);
    __from_solver(g,g.apply("_S3Location._UserMetadata_",v),res._UserMetadata_);
    __from_solver(g,g.apply("_S3Location._StorageClass_",v),res._StorageClass_);
}
template <>
z3::expr  __to_solver<s3_test::_S3Location>( gen &g, const  z3::expr &v,s3_test::_S3Location &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_S3Location._BucketName_",v),val._BucketName_);
    res = res && __to_solver(g,g.apply("_S3Location._Prefix_",v),val._Prefix_);
    res = res && __to_solver(g,g.apply("_S3Location._Encryption_",v),val._Encryption_);
    res = res && __to_solver(g,g.apply("_S3Location._CannedACL_",v),val._CannedACL_);
    res = res && __to_solver(g,g.apply("_S3Location._AccessControlList_",v),val._AccessControlList_);
    res = res && __to_solver(g,g.apply("_S3Location._Tagging_",v),val._Tagging_);
    res = res && __to_solver(g,g.apply("_S3Location._UserMetadata_",v),val._UserMetadata_);
    res = res && __to_solver(g,g.apply("_S3Location._StorageClass_",v),val._StorageClass_);
    return res;
}
template <>
void  __randomize<s3_test::_S3Location>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_S3Location._BucketName_",v));
    __randomize<s3_test::string>(g,g.apply("_S3Location._Prefix_",v));
    __randomize<s3_test::option___Encryption__>(g,g.apply("_S3Location._Encryption_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_S3Location._CannedACL_",v));
    __randomize<s3_test::option__vector___Grant____>(g,g.apply("_S3Location._AccessControlList_",v));
    __randomize<s3_test::option___Tagging__>(g,g.apply("_S3Location._Tagging_",v));
    __randomize<s3_test::option__vector___MetadataEntry____>(g,g.apply("_S3Location._UserMetadata_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_S3Location._StorageClass_",v));
}
template <>
s3_test::_SSEKMS _arg<s3_test::_SSEKMS>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SSEKMS res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_KeyId_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._KeyId_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KeyId_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SSEKMS>(ivy_deser &inp, s3_test::_SSEKMS &res){
    inp.open_struct();
    inp.open_field("_KeyId_");
    __deser(inp,res._KeyId_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_SSEKMS>( gen &g, const  z3::expr &v,s3_test::_SSEKMS &res){
    __from_solver(g,g.apply("_SSEKMS._KeyId_",v),res._KeyId_);
}
template <>
z3::expr  __to_solver<s3_test::_SSEKMS>( gen &g, const  z3::expr &v,s3_test::_SSEKMS &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_SSEKMS._KeyId_",v),val._KeyId_);
    return res;
}
template <>
void  __randomize<s3_test::_SSEKMS>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_SSEKMS._KeyId_",v));
}
template <>
s3_test::_SSES3 _arg<s3_test::_SSES3>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SSES3 res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 0) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    return res;
}
template <>
void __deser<s3_test::_SSES3>(ivy_deser &inp, s3_test::_SSES3 &res){
    inp.open_struct();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_SSES3>( gen &g, const  z3::expr &v,s3_test::_SSES3 &res){
}
template <>
z3::expr  __to_solver<s3_test::_SSES3>( gen &g, const  z3::expr &v,s3_test::_SSES3 &val){
    z3::expr res = g.ctx.bool_val(1);
    return res;
}
template <>
void  __randomize<s3_test::_SSES3>( gen &g, const  z3::expr &v){
}
template <>
s3_test::_ScanRange _arg<s3_test::_ScanRange>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ScanRange res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Start_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Start_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Start_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_End_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._End_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _End_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ScanRange>(ivy_deser &inp, s3_test::_ScanRange &res){
    inp.open_struct();
    inp.open_field("_Start_");
    __deser(inp,res._Start_);
    inp.close_field();
    inp.open_field("_End_");
    __deser(inp,res._End_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ScanRange>( gen &g, const  z3::expr &v,s3_test::_ScanRange &res){
    __from_solver(g,g.apply("_ScanRange._Start_",v),res._Start_);
    __from_solver(g,g.apply("_ScanRange._End_",v),res._End_);
}
template <>
z3::expr  __to_solver<s3_test::_ScanRange>( gen &g, const  z3::expr &v,s3_test::_ScanRange &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ScanRange._Start_",v),val._Start_);
    res = res && __to_solver(g,g.apply("_ScanRange._End_",v),val._End_);
    return res;
}
template <>
void  __randomize<s3_test::_ScanRange>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_ScanRange._Start_",v));
    __randomize<int>(g,g.apply("_ScanRange._End_",v));
}
template <>
s3_test::_SelectParameters _arg<s3_test::_SelectParameters>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SelectParameters res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_InputSerialization_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._InputSerialization_ = _arg<s3_test::_InputSerialization>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _InputSerialization_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ExpressionType_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ExpressionType_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ExpressionType_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Expression_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Expression_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Expression_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_OutputSerialization_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._OutputSerialization_ = _arg<s3_test::_OutputSerialization>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputSerialization_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SelectParameters>(ivy_deser &inp, s3_test::_SelectParameters &res){
    inp.open_struct();
    inp.open_field("_InputSerialization_");
    __deser(inp,res._InputSerialization_);
    inp.close_field();
    inp.open_field("_ExpressionType_");
    __deser(inp,res._ExpressionType_);
    inp.close_field();
    inp.open_field("_Expression_");
    __deser(inp,res._Expression_);
    inp.close_field();
    inp.open_field("_OutputSerialization_");
    __deser(inp,res._OutputSerialization_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_SelectParameters>( gen &g, const  z3::expr &v,s3_test::_SelectParameters &res){
    __from_solver(g,g.apply("_SelectParameters._InputSerialization_",v),res._InputSerialization_);
    __from_solver(g,g.apply("_SelectParameters._ExpressionType_",v),res._ExpressionType_);
    __from_solver(g,g.apply("_SelectParameters._Expression_",v),res._Expression_);
    __from_solver(g,g.apply("_SelectParameters._OutputSerialization_",v),res._OutputSerialization_);
}
template <>
z3::expr  __to_solver<s3_test::_SelectParameters>( gen &g, const  z3::expr &v,s3_test::_SelectParameters &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_SelectParameters._InputSerialization_",v),val._InputSerialization_);
    res = res && __to_solver(g,g.apply("_SelectParameters._ExpressionType_",v),val._ExpressionType_);
    res = res && __to_solver(g,g.apply("_SelectParameters._Expression_",v),val._Expression_);
    res = res && __to_solver(g,g.apply("_SelectParameters._OutputSerialization_",v),val._OutputSerialization_);
    return res;
}
template <>
void  __randomize<s3_test::_SelectParameters>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_InputSerialization>(g,g.apply("_SelectParameters._InputSerialization_",v));
    __randomize<s3_test::string>(g,g.apply("_SelectParameters._ExpressionType_",v));
    __randomize<s3_test::string>(g,g.apply("_SelectParameters._Expression_",v));
    __randomize<s3_test::_OutputSerialization>(g,g.apply("_SelectParameters._OutputSerialization_",v));
}
template <>
s3_test::_ServerSideEncryptionByDefault _arg<s3_test::_ServerSideEncryptionByDefault>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ServerSideEncryptionByDefault res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SSEAlgorithm_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SSEAlgorithm_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SSEAlgorithm_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_KMSMasterKeyID_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._KMSMasterKeyID_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _KMSMasterKeyID_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ServerSideEncryptionByDefault>(ivy_deser &inp, s3_test::_ServerSideEncryptionByDefault &res){
    inp.open_struct();
    inp.open_field("_SSEAlgorithm_");
    __deser(inp,res._SSEAlgorithm_);
    inp.close_field();
    inp.open_field("_KMSMasterKeyID_");
    __deser(inp,res._KMSMasterKeyID_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v,s3_test::_ServerSideEncryptionByDefault &res){
    __from_solver(g,g.apply("_ServerSideEncryptionByDefault._SSEAlgorithm_",v),res._SSEAlgorithm_);
    __from_solver(g,g.apply("_ServerSideEncryptionByDefault._KMSMasterKeyID_",v),res._KMSMasterKeyID_);
}
template <>
z3::expr  __to_solver<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v,s3_test::_ServerSideEncryptionByDefault &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ServerSideEncryptionByDefault._SSEAlgorithm_",v),val._SSEAlgorithm_);
    res = res && __to_solver(g,g.apply("_ServerSideEncryptionByDefault._KMSMasterKeyID_",v),val._KMSMasterKeyID_);
    return res;
}
template <>
void  __randomize<s3_test::_ServerSideEncryptionByDefault>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_ServerSideEncryptionByDefault._SSEAlgorithm_",v));
    __randomize<s3_test::option__string__>(g,g.apply("_ServerSideEncryptionByDefault._KMSMasterKeyID_",v));
}
template <>
s3_test::_ServerSideEncryptionRule _arg<s3_test::_ServerSideEncryptionRule>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_ServerSideEncryptionRule res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_ApplyServerSideEncryptionByDefault_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._ApplyServerSideEncryptionByDefault_ = _arg<s3_test::_ServerSideEncryptionByDefault>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ApplyServerSideEncryptionByDefault_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_BucketKeyEnabled_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._BucketKeyEnabled_ = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _BucketKeyEnabled_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_ServerSideEncryptionRule>(ivy_deser &inp, s3_test::_ServerSideEncryptionRule &res){
    inp.open_struct();
    inp.open_field("_ApplyServerSideEncryptionByDefault_");
    __deser(inp,res._ApplyServerSideEncryptionByDefault_);
    inp.close_field();
    inp.open_field("_BucketKeyEnabled_");
    __deser(inp,res._BucketKeyEnabled_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v,s3_test::_ServerSideEncryptionRule &res){
    __from_solver(g,g.apply("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",v),res._ApplyServerSideEncryptionByDefault_);
    __from_solver(g,g.apply("_ServerSideEncryptionRule._BucketKeyEnabled_",v),res._BucketKeyEnabled_);
}
template <>
z3::expr  __to_solver<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v,s3_test::_ServerSideEncryptionRule &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",v),val._ApplyServerSideEncryptionByDefault_);
    res = res && __to_solver(g,g.apply("_ServerSideEncryptionRule._BucketKeyEnabled_",v),val._BucketKeyEnabled_);
    return res;
}
template <>
void  __randomize<s3_test::_ServerSideEncryptionRule>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_ServerSideEncryptionByDefault>(g,g.apply("_ServerSideEncryptionRule._ApplyServerSideEncryptionByDefault_",v));
    __randomize<bool>(g,g.apply("_ServerSideEncryptionRule._BucketKeyEnabled_",v));
}
template <>
s3_test::_SourceSelectionCriteria _arg<s3_test::_SourceSelectionCriteria>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SourceSelectionCriteria res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_SseKmsEncryptedObjects_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._SseKmsEncryptedObjects_ = _arg<s3_test::_SseKmsEncryptedObjects>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _SseKmsEncryptedObjects_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_ReplicaModifications_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._ReplicaModifications_ = _arg<s3_test::_ReplicaModifications>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _ReplicaModifications_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SourceSelectionCriteria>(ivy_deser &inp, s3_test::_SourceSelectionCriteria &res){
    inp.open_struct();
    inp.open_field("_SseKmsEncryptedObjects_");
    __deser(inp,res._SseKmsEncryptedObjects_);
    inp.close_field();
    inp.open_field("_ReplicaModifications_");
    __deser(inp,res._ReplicaModifications_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v,s3_test::_SourceSelectionCriteria &res){
    __from_solver(g,g.apply("_SourceSelectionCriteria._SseKmsEncryptedObjects_",v),res._SseKmsEncryptedObjects_);
    __from_solver(g,g.apply("_SourceSelectionCriteria._ReplicaModifications_",v),res._ReplicaModifications_);
}
template <>
z3::expr  __to_solver<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v,s3_test::_SourceSelectionCriteria &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_SourceSelectionCriteria._SseKmsEncryptedObjects_",v),val._SseKmsEncryptedObjects_);
    res = res && __to_solver(g,g.apply("_SourceSelectionCriteria._ReplicaModifications_",v),val._ReplicaModifications_);
    return res;
}
template <>
void  __randomize<s3_test::_SourceSelectionCriteria>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_SseKmsEncryptedObjects>(g,g.apply("_SourceSelectionCriteria._SseKmsEncryptedObjects_",v));
    __randomize<s3_test::_ReplicaModifications>(g,g.apply("_SourceSelectionCriteria._ReplicaModifications_",v));
}
template <>
s3_test::_SseKmsEncryptedObjects _arg<s3_test::_SseKmsEncryptedObjects>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_SseKmsEncryptedObjects res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Status_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Status_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Status_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_SseKmsEncryptedObjects>(ivy_deser &inp, s3_test::_SseKmsEncryptedObjects &res){
    inp.open_struct();
    inp.open_field("_Status_");
    __deser(inp,res._Status_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v,s3_test::_SseKmsEncryptedObjects &res){
    __from_solver(g,g.apply("_SseKmsEncryptedObjects._Status_",v),res._Status_);
}
template <>
z3::expr  __to_solver<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v,s3_test::_SseKmsEncryptedObjects &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_SseKmsEncryptedObjects._Status_",v),val._Status_);
    return res;
}
template <>
void  __randomize<s3_test::_SseKmsEncryptedObjects>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_SseKmsEncryptedObjects._Status_",v));
}
template <>
s3_test::_StorageClassAnalysis _arg<s3_test::_StorageClassAnalysis>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_StorageClassAnalysis res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_DataExport_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._DataExport_ = _arg<s3_test::_StorageClassAnalysisDataExport>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _DataExport_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_StorageClassAnalysis>(ivy_deser &inp, s3_test::_StorageClassAnalysis &res){
    inp.open_struct();
    inp.open_field("_DataExport_");
    __deser(inp,res._DataExport_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v,s3_test::_StorageClassAnalysis &res){
    __from_solver(g,g.apply("_StorageClassAnalysis._DataExport_",v),res._DataExport_);
}
template <>
z3::expr  __to_solver<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v,s3_test::_StorageClassAnalysis &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_StorageClassAnalysis._DataExport_",v),val._DataExport_);
    return res;
}
template <>
void  __randomize<s3_test::_StorageClassAnalysis>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_StorageClassAnalysisDataExport>(g,g.apply("_StorageClassAnalysis._DataExport_",v));
}
template <>
s3_test::_StorageClassAnalysisDataExport _arg<s3_test::_StorageClassAnalysisDataExport>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_StorageClassAnalysisDataExport res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_OutputSchemaVersion_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._OutputSchemaVersion_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _OutputSchemaVersion_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Destination_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Destination_ = _arg<s3_test::_AnalyticsExportDestination>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Destination_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_StorageClassAnalysisDataExport>(ivy_deser &inp, s3_test::_StorageClassAnalysisDataExport &res){
    inp.open_struct();
    inp.open_field("_OutputSchemaVersion_");
    __deser(inp,res._OutputSchemaVersion_);
    inp.close_field();
    inp.open_field("_Destination_");
    __deser(inp,res._Destination_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v,s3_test::_StorageClassAnalysisDataExport &res){
    __from_solver(g,g.apply("_StorageClassAnalysisDataExport._OutputSchemaVersion_",v),res._OutputSchemaVersion_);
    __from_solver(g,g.apply("_StorageClassAnalysisDataExport._Destination_",v),res._Destination_);
}
template <>
z3::expr  __to_solver<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v,s3_test::_StorageClassAnalysisDataExport &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_StorageClassAnalysisDataExport._OutputSchemaVersion_",v),val._OutputSchemaVersion_);
    res = res && __to_solver(g,g.apply("_StorageClassAnalysisDataExport._Destination_",v),val._Destination_);
    return res;
}
template <>
void  __randomize<s3_test::_StorageClassAnalysisDataExport>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_StorageClassAnalysisDataExport._OutputSchemaVersion_",v));
    __randomize<s3_test::_AnalyticsExportDestination>(g,g.apply("_StorageClassAnalysisDataExport._Destination_",v));
}
template <>
s3_test::_Tag _arg<s3_test::_Tag>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tag res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Key_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Key_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Key_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Value_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Value_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Value_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tag>(ivy_deser &inp, s3_test::_Tag &res){
    inp.open_struct();
    inp.open_field("_Key_");
    __deser(inp,res._Key_);
    inp.close_field();
    inp.open_field("_Value_");
    __deser(inp,res._Value_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Tag>( gen &g, const  z3::expr &v,s3_test::_Tag &res){
    __from_solver(g,g.apply("_Tag._Key_",v),res._Key_);
    __from_solver(g,g.apply("_Tag._Value_",v),res._Value_);
}
template <>
z3::expr  __to_solver<s3_test::_Tag>( gen &g, const  z3::expr &v,s3_test::_Tag &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Tag._Key_",v),val._Key_);
    res = res && __to_solver(g,g.apply("_Tag._Value_",v),val._Value_);
    return res;
}
template <>
void  __randomize<s3_test::_Tag>( gen &g, const  z3::expr &v){
    __randomize<s3_test::string>(g,g.apply("_Tag._Key_",v));
    __randomize<s3_test::string>(g,g.apply("_Tag._Value_",v));
}
template <>
s3_test::_Tagging _arg<s3_test::_Tagging>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tagging res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 1) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_TagSet_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._TagSet_ = _arg<s3_test::vector___Tag__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TagSet_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tagging>(ivy_deser &inp, s3_test::_Tagging &res){
    inp.open_struct();
    inp.open_field("_TagSet_");
    __deser(inp,res._TagSet_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Tagging>( gen &g, const  z3::expr &v,s3_test::_Tagging &res){
    __from_solver(g,g.apply("_Tagging._TagSet_",v),res._TagSet_);
}
template <>
z3::expr  __to_solver<s3_test::_Tagging>( gen &g, const  z3::expr &v,s3_test::_Tagging &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Tagging._TagSet_",v),val._TagSet_);
    return res;
}
template <>
void  __randomize<s3_test::_Tagging>( gen &g, const  z3::expr &v){
    __randomize<s3_test::vector___Tag__>(g,g.apply("_Tagging._TagSet_",v));
}
template <>
s3_test::_TargetGrant _arg<s3_test::_TargetGrant>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_TargetGrant res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Grantee_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Grantee_ = _arg<s3_test::_Grantee>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Grantee_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Permission_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Permission_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Permission_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_TargetGrant>(ivy_deser &inp, s3_test::_TargetGrant &res){
    inp.open_struct();
    inp.open_field("_Grantee_");
    __deser(inp,res._Grantee_);
    inp.close_field();
    inp.open_field("_Permission_");
    __deser(inp,res._Permission_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_TargetGrant>( gen &g, const  z3::expr &v,s3_test::_TargetGrant &res){
    __from_solver(g,g.apply("_TargetGrant._Grantee_",v),res._Grantee_);
    __from_solver(g,g.apply("_TargetGrant._Permission_",v),res._Permission_);
}
template <>
z3::expr  __to_solver<s3_test::_TargetGrant>( gen &g, const  z3::expr &v,s3_test::_TargetGrant &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_TargetGrant._Grantee_",v),val._Grantee_);
    res = res && __to_solver(g,g.apply("_TargetGrant._Permission_",v),val._Permission_);
    return res;
}
template <>
void  __randomize<s3_test::_TargetGrant>( gen &g, const  z3::expr &v){
    __randomize<s3_test::_Grantee>(g,g.apply("_TargetGrant._Grantee_",v));
    __randomize<s3_test::string>(g,g.apply("_TargetGrant._Permission_",v));
}
template <>
s3_test::_Tiering _arg<s3_test::_Tiering>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Tiering res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_AccessTier_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._AccessTier_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _AccessTier_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Tiering>(ivy_deser &inp, s3_test::_Tiering &res){
    inp.open_struct();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_AccessTier_");
    __deser(inp,res._AccessTier_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Tiering>( gen &g, const  z3::expr &v,s3_test::_Tiering &res){
    __from_solver(g,g.apply("_Tiering._Days_",v),res._Days_);
    __from_solver(g,g.apply("_Tiering._AccessTier_",v),res._AccessTier_);
}
template <>
z3::expr  __to_solver<s3_test::_Tiering>( gen &g, const  z3::expr &v,s3_test::_Tiering &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Tiering._Days_",v),val._Days_);
    res = res && __to_solver(g,g.apply("_Tiering._AccessTier_",v),val._AccessTier_);
    return res;
}
template <>
void  __randomize<s3_test::_Tiering>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_Tiering._Days_",v));
    __randomize<s3_test::string>(g,g.apply("_Tiering._AccessTier_",v));
}
template <>
s3_test::_TopicConfiguration _arg<s3_test::_TopicConfiguration>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_TopicConfiguration res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 4) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Id_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Id_ = _arg<s3_test::option__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Id_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_TopicArn_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._TopicArn_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _TopicArn_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_Events_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._Events_ = _arg<s3_test::vector__string__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Events_: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "_Filter_") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res._Filter_ = _arg<s3_test::option___NotificationConfigurationFilter__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Filter_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_TopicConfiguration>(ivy_deser &inp, s3_test::_TopicConfiguration &res){
    inp.open_struct();
    inp.open_field("_Id_");
    __deser(inp,res._Id_);
    inp.close_field();
    inp.open_field("_TopicArn_");
    __deser(inp,res._TopicArn_);
    inp.close_field();
    inp.open_field("_Events_");
    __deser(inp,res._Events_);
    inp.close_field();
    inp.open_field("_Filter_");
    __deser(inp,res._Filter_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v,s3_test::_TopicConfiguration &res){
    __from_solver(g,g.apply("_TopicConfiguration._Id_",v),res._Id_);
    __from_solver(g,g.apply("_TopicConfiguration._TopicArn_",v),res._TopicArn_);
    __from_solver(g,g.apply("_TopicConfiguration._Events_",v),res._Events_);
    __from_solver(g,g.apply("_TopicConfiguration._Filter_",v),res._Filter_);
}
template <>
z3::expr  __to_solver<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v,s3_test::_TopicConfiguration &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_TopicConfiguration._Id_",v),val._Id_);
    res = res && __to_solver(g,g.apply("_TopicConfiguration._TopicArn_",v),val._TopicArn_);
    res = res && __to_solver(g,g.apply("_TopicConfiguration._Events_",v),val._Events_);
    res = res && __to_solver(g,g.apply("_TopicConfiguration._Filter_",v),val._Filter_);
    return res;
}
template <>
void  __randomize<s3_test::_TopicConfiguration>( gen &g, const  z3::expr &v){
    __randomize<s3_test::option__string__>(g,g.apply("_TopicConfiguration._Id_",v));
    __randomize<s3_test::string>(g,g.apply("_TopicConfiguration._TopicArn_",v));
    __randomize<s3_test::vector__string__>(g,g.apply("_TopicConfiguration._Events_",v));
    __randomize<s3_test::option___NotificationConfigurationFilter__>(g,g.apply("_TopicConfiguration._Filter_",v));
}
template <>
s3_test::_Transition _arg<s3_test::_Transition>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    s3_test::_Transition res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "_Date_") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res._Date_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Date_: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "_Days_") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res._Days_ = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _Days_: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "_StorageClass_") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res._StorageClass_ = _arg<s3_test::string>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field _StorageClass_: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<s3_test::_Transition>(ivy_deser &inp, s3_test::_Transition &res){
    inp.open_struct();
    inp.open_field("_Date_");
    __deser(inp,res._Date_);
    inp.close_field();
    inp.open_field("_Days_");
    __deser(inp,res._Days_);
    inp.close_field();
    inp.open_field("_StorageClass_");
    __deser(inp,res._StorageClass_);
    inp.close_field();
    inp.close_struct();
}
template <>
void  __from_solver<s3_test::_Transition>( gen &g, const  z3::expr &v,s3_test::_Transition &res){
    __from_solver(g,g.apply("_Transition._Date_",v),res._Date_);
    __from_solver(g,g.apply("_Transition._Days_",v),res._Days_);
    __from_solver(g,g.apply("_Transition._StorageClass_",v),res._StorageClass_);
}
template <>
z3::expr  __to_solver<s3_test::_Transition>( gen &g, const  z3::expr &v,s3_test::_Transition &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("_Transition._Date_",v),val._Date_);
    res = res && __to_solver(g,g.apply("_Transition._Days_",v),val._Days_);
    res = res && __to_solver(g,g.apply("_Transition._StorageClass_",v),val._StorageClass_);
    return res;
}
template <>
void  __randomize<s3_test::_Transition>( gen &g, const  z3::expr &v){
    __randomize<int>(g,g.apply("_Transition._Date_",v));
    __randomize<int>(g,g.apply("_Transition._Days_",v));
    __randomize<s3_test::string>(g,g.apply("_Transition._StorageClass_",v));
}
template<typename R> class to_solver_class<hash_thunk<s3_test::__tup__string__string,R> >{
    public:;
    z3::expr operator()( gen &g, const  z3::expr &v, hash_thunk<s3_test::__tup__string__string,R> &val){
        z3::expr res = g.ctx.bool_val(true);
        z3::expr disj = g.ctx.bool_val(false);
        z3::expr bg = dynamic_cast<z3_thunk<s3_test::__tup__string__string,R> *>(val.fun)->to_z3(g,v);
        for(typename hash_map<s3_test::__tup__string__string,R>::iterator it=val.memo.begin(), en = val.memo.end(); it != en; it++){
            z3::expr asgn = __to_solver(g,v,it->second);
            z3::expr cond = __to_solver(g,v.arg(0),it->first.arg0) && __to_solver(g,v.arg(1),it->first.arg1);
            res = res && implies(cond,asgn);
            disj = disj || cond;
        }
        res = res && (disj || bg);
        return res;
    }
};
template<typename R> class to_solver_class<hash_thunk<s3_test::__tup__unordered_map__string____string____string,R> >{
    public:;
    z3::expr operator()( gen &g, const  z3::expr &v, hash_thunk<s3_test::__tup__unordered_map__string____string____string,R> &val){
        z3::expr res = g.ctx.bool_val(true);
        z3::expr disj = g.ctx.bool_val(false);
        z3::expr bg = dynamic_cast<z3_thunk<s3_test::__tup__unordered_map__string____string____string,R> *>(val.fun)->to_z3(g,v);
        for(typename hash_map<s3_test::__tup__unordered_map__string____string____string,R>::iterator it=val.memo.begin(), en = val.memo.end(); it != en; it++){
            z3::expr asgn = __to_solver(g,v,it->second);
            z3::expr cond = __to_solver(g,v.arg(0),it->first.arg0) && __to_solver(g,v.arg(1),it->first.arg1);
            res = res && implies(cond,asgn);
            disj = disj || cond;
        }
        res = res && (disj || bg);
        return res;
    }
};


class stdin_reader: public reader {
    std::string buf;
    std::string eof_flag;

public:
    bool eof(){
      return eof_flag.size();
    }
    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        if (chars == 0) {  // EOF
            if (buf.size())
                process(buf);
            eof_flag = "eof";
        }
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        __ivy_out << line;
    }
};

class cmd_reader: public stdin_reader {
    int lineno;
public:
    s3_test_repl &ivy;    

    cmd_reader(s3_test_repl &_ivy) : ivy(_ivy) {
        lineno = 1;
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);
            ivy.__lock();

                if (action == "get") {
                    check_arity(args,2,action);
                    ivy.ext__get(_arg<s3_test::string>(args,0,0),_arg<s3_test::string>(args,1,0));
                }
                else
    
                if (action == "put") {
                    check_arity(args,3,action);
                    ivy.ext__put(_arg<s3_test::string>(args,0,0),_arg<s3_test::string>(args,1,0),_arg<s3_test::blob>(args,2,0));
                }
                else
    
            {
                std::cerr << "undefined action: " << action << std::endl;
            }
            ivy.__unlock();
        }
        catch (syntax_error& err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            ivy.__unlock();
            std::cerr << "line " << lineno << ":" << err.pos << ": " << err.txt << " bad value" << std::endl;
        }
        catch (bad_arity &err) {
            ivy.__unlock();
            std::cerr << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
        lineno++;
    }
};



int main(int argc, char **argv){
        int test_iters = 100;
        int runs = 1;

    int seed = 1;
    int sleep_ms = 10;
    int final_ms = 0; 
    
    std::vector<char *> pargs; // positional args
    pargs.push_back(argv[0]);
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        size_t p = arg.find('=');
        if (p == std::string::npos)
            pargs.push_back(argv[i]);
        else {
            std::string param = arg.substr(0,p);
            std::string value = arg.substr(p+1);

            if (param == "out") {
                __ivy_out.open(value.c_str());
                if (!__ivy_out) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else if (param == "iters") {
                test_iters = atoi(value.c_str());
            }
            else if (param == "runs") {
                runs = atoi(value.c_str());
            }
            else if (param == "seed") {
                seed = atoi(value.c_str());
            }
            else if (param == "delay") {
                sleep_ms = atoi(value.c_str());
            }
            else if (param == "wait") {
                final_ms = atoi(value.c_str());
            }
            else if (param == "modelfile") {
                __ivy_modelfile.open(value.c_str());
                if (!__ivy_modelfile) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else {
                std::cerr << "unknown option: " << param << std::endl;
                return 1;
            }
        }
    }
    srand(seed);
    if (!__ivy_out.is_open())
        __ivy_out.basic_ios<char>::rdbuf(std::cout.rdbuf());
    argc = pargs.size();
    argv = &pargs[0];
    if (argc == 2){
        argc--;
        int fd = _open(argv[argc],0);
        if (fd < 0){
            std::cerr << "cannot open to read: " << argv[argc] << "\n";
            __ivy_exit(1);
        }
        _dup2(fd, 0);
    }
    if (argc != 1){
        std::cerr << "usage: s3_test \n";
        __ivy_exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(0);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}

#ifdef _WIN32
    // Boilerplate from windows docs

    {
        WORD wVersionRequested;
        WSADATA wsaData;
        int err;

    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
        wVersionRequested = MAKEWORD(2, 2);

        err = WSAStartup(wVersionRequested, &wsaData);
        if (err != 0) {
            /* Tell the user that we could not find a usable */
            /* Winsock DLL.                                  */
            printf("WSAStartup failed with error: %d\n", err);
            return 1;
        }

    /* Confirm that the WinSock DLL supports 2.2.*/
    /* Note that if the DLL supports versions greater    */
    /* than 2.2 in addition to 2.2, it will still return */
    /* 2.2 in wVersion since that is the version we      */
    /* requested.                                        */

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            /* Tell the user that we could not find a usable */
            /* WinSock DLL.                                  */
            printf("Could not find a usable version of Winsock.dll\n");
            WSACleanup();
            return 1;
        }
    }
#endif
    for(int runidx = 0; runidx < runs; runidx++) {
    initializing = true;
    s3_test_repl ivy;
    for(unsigned i = 0; i < argc; i++) {ivy.__argv.push_back(argv[i]);}
    ivy._generating = false;

        ivy.__unlock();
        initializing = false;
        for(int rdridx = 0; rdridx < readers.size(); rdridx++) {
            readers[rdridx]->bind();
        }
                    
        init_gen my_init_gen;
        my_init_gen.generate(ivy);
        std::vector<gen *> generators;
        std::vector<double> weights;

        generators.push_back(new ext__get_gen);
        weights.push_back(1.0);
        generators.push_back(new ext__put_gen);
        weights.push_back(1.0);
        double totalweight = 2.0;
        int num_gens = 2;


#ifdef _WIN32
    LARGE_INTEGER freq;
    QueryPerformanceFrequency(&freq);
#endif
    for(int cycle = 0; cycle < test_iters; cycle++) {

        double choices = totalweight + readers.size() + timers.size();
        double frnd = choices * (((double)rand())/(((double)RAND_MAX)+1.0));
        if (frnd < totalweight) {
            int idx = 0;
            double sum = 0.0;
            while (idx < num_gens-1) {
                sum += weights[idx];
                if (frnd < sum)
                    break;
                idx++;
            }
            gen &g = *generators[idx];
            ivy.__lock();
#ifdef _WIN32
            LARGE_INTEGER before;
            QueryPerformanceCounter(&before);
#endif
            ivy._generating = true;
            bool sat = g.generate(ivy);
#ifdef _WIN32
            LARGE_INTEGER after;
            QueryPerformanceCounter(&after);
//            __ivy_out << "idx: " << idx << " sat: " << sat << " time: " << (((double)(after.QuadPart-before.QuadPart))/freq.QuadPart) << std::endl;
#endif
            if (sat){
                g.execute(ivy);
                ivy._generating = false;
                ivy.__unlock();
#ifdef _WIN32
                Sleep(sleep_ms);
#endif
            }
            else {
                ivy._generating = false;
                ivy.__unlock();
                cycle--;
            }
            continue;
        }


        fd_set rdfds;
        FD_ZERO(&rdfds);
        int maxfds = 0;

        for (unsigned i = 0; i < readers.size(); i++) {
            reader *r = readers[i];
            int fds = r->fdes();
            if (fds >= 0) {
                FD_SET(fds,&rdfds);
            }
            if (fds > maxfds)
                maxfds = fds;
        }

#ifdef _WIN32
        int timer_min = 15;
#else
        int timer_min = 1;
#endif

        struct timeval timeout;
        timeout.tv_sec = timer_min/1000;
        timeout.tv_usec = 1000 * (timer_min % 1000);

#ifdef _WIN32
        int foo;
        if (readers.size() == 0){  // winsock can't handle empty fdset!
            Sleep(timer_min);
            foo = 0;
        }
        else
            foo = select(maxfds+1,&rdfds,0,0,&timeout);
#else
        int foo = select(maxfds+1,&rdfds,0,0,&timeout);
#endif

        if (foo < 0)
#ifdef _WIN32
            {std::cerr << "select failed: " << WSAGetLastError() << std::endl; __ivy_exit(1);}
#else
            {perror("select failed"); __ivy_exit(1);}
#endif
        
        if (foo == 0){
            // std::cout << "TIMEOUT\n";            
           cycle--;
           for (unsigned i = 0; i < timers.size(); i++){
               if (timer_min >= timers[i]->ms_delay()) {
                   cycle++;
                   break;
               }
           }
           for (unsigned i = 0; i < timers.size(); i++)
               timers[i]->timeout(timer_min);
        }
        else {
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds))
                    r->read();
            }
        }            
    }
    
#ifdef _WIN32
                Sleep(final_ms);  // HACK: wait for late responses
#endif
    __ivy_out << "test_completed" << std::endl;
    for (unsigned i = 0; i < readers.size(); i++)
        delete readers[i];
    readers.clear();
    for (unsigned i = 0; i < timers.size(); i++)
        delete timers[i];
    timers.clear();


    }
    return 0;
}
