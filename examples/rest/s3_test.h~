#define _HAS_ITERATOR_DEBUGGING 0

/*++
  Copyright (c) Microsoft Corporation

  This hash template is borrowed from Microsoft Z3
  (https://github.com/Z3Prover/z3).

  Simple implementation of bucket-list hash tables conforming roughly
  to SGI hash_map and hash_set interfaces, though not all members are
  implemented.

  These hash tables have the property that insert preserves iterators
  and references to elements.

  This package lives in namespace hash_space. Specializations of
  class "hash" should be made in this namespace.

  --*/

#pragma once

#ifndef HASH_H
#define HASH_H

#ifdef _WINDOWS
#pragma warning(disable:4267)
#endif

#include <string>
#include <vector>
#include <map>
#include <iterator>
#include <fstream>

namespace hash_space {

    unsigned string_hash(const char * str, unsigned length, unsigned init_value);

    template <typename T> class hash {
    public:
        size_t operator()(const T &s) const {
            return s.__hash();
        }
    };

    template <>
        class hash<int> {
    public:
        size_t operator()(const int &s) const {
            return s;
        }
    };

    template <>
        class hash<long long> {
    public:
        size_t operator()(const long long &s) const {
            return s;
        }
    };

    template <>
        class hash<unsigned> {
    public:
        size_t operator()(const unsigned &s) const {
            return s;
        }
    };

    template <>
        class hash<unsigned long long> {
    public:
        size_t operator()(const unsigned long long &s) const {
            return s;
        }
    };

    template <>
        class hash<bool> {
    public:
        size_t operator()(const bool &s) const {
            return s;
        }
    };

    template <>
        class hash<std::string> {
    public:
        size_t operator()(const std::string &s) const {
            return string_hash(s.c_str(), (unsigned)s.size(), 0);
        }
    };

    template <>
        class hash<std::pair<int,int> > {
    public:
        size_t operator()(const std::pair<int,int> &p) const {
            return p.first + p.second;
        }
    };

    template <typename T>
        class hash<std::vector<T> > {
    public:
        size_t operator()(const std::vector<T> &p) const {
            hash<T> h;
            size_t res = 0;
            for (unsigned i = 0; i < p.size(); i++)
                res += h(p[i]);
            return res;
        }
    };

    template <typename K, typename V>
        class hash<std::map<K,V> > {
    public:
        size_t operator()(const std::map<K,V> &p) const {
            hash<std::pair<K,V> > h;
            size_t res = 0;
            for (std::map::const_iterator it = p.begin(), en = p.end(); it != en; ++it)
                res += h(*it);
            return res;
        }
    };

    template <class T>
        class hash<std::pair<T *, T *> > {
    public:
        size_t operator()(const std::pair<T *,T *> &p) const {
            return (size_t)p.first + (size_t)p.second;
        }
    };

    template <class T>
        class hash<T *> {
    public:
        size_t operator()(T * const &p) const {
            return (size_t)p;
        }
    };

    enum { num_primes = 29 };

    static const unsigned long primes[num_primes] =
        {
            7ul,
            53ul,
            97ul,
            193ul,
            389ul,
            769ul,
            1543ul,
            3079ul,
            6151ul,
            12289ul,
            24593ul,
            49157ul,
            98317ul,
            196613ul,
            393241ul,
            786433ul,
            1572869ul,
            3145739ul,
            6291469ul,
            12582917ul,
            25165843ul,
            50331653ul,
            100663319ul,
            201326611ul,
            402653189ul,
            805306457ul,
            1610612741ul,
            3221225473ul,
            4294967291ul
        };

    inline unsigned long next_prime(unsigned long n) {
        const unsigned long* to = primes + (int)num_primes;
        for(const unsigned long* p = primes; p < to; p++)
            if(*p >= n) return *p;
        return primes[num_primes-1];
    }

    template<class Value, class Key, class HashFun, class GetKey, class KeyEqFun>
        class hashtable
    {
    public:

        typedef Value &reference;
        typedef const Value &const_reference;
    
        struct Entry
        {
            Entry* next;
            Value val;
      
        Entry(const Value &_val) : val(_val) {next = 0;}
        };
    

        struct iterator
        {      
            Entry* ent;
            hashtable* tab;

            typedef std::forward_iterator_tag iterator_category;
            typedef Value value_type;
            typedef std::ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef Value& reference;
            typedef Value* pointer;

        iterator(Entry* _ent, hashtable* _tab) : ent(_ent), tab(_tab) { }

            iterator() { }

            Value &operator*() const { return ent->val; }

            Value *operator->() const { return &(operator*()); }

            iterator &operator++() {
                Entry *old = ent;
                ent = ent->next;
                if (!ent) {
                    size_t bucket = tab->get_bucket(old->val);
                    while (!ent && ++bucket < tab->buckets.size())
                        ent = tab->buckets[bucket];
                }
                return *this;
            }

            iterator operator++(int) {
                iterator tmp = *this;
                operator++();
                return tmp;
            }


            bool operator==(const iterator& it) const { 
                return ent == it.ent;
            }

            bool operator!=(const iterator& it) const {
                return ent != it.ent;
            }
        };

        struct const_iterator
        {      
            const Entry* ent;
            const hashtable* tab;

            typedef std::forward_iterator_tag iterator_category;
            typedef Value value_type;
            typedef std::ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef const Value& reference;
            typedef const Value* pointer;

        const_iterator(const Entry* _ent, const hashtable* _tab) : ent(_ent), tab(_tab) { }

            const_iterator() { }

            const Value &operator*() const { return ent->val; }

            const Value *operator->() const { return &(operator*()); }

            const_iterator &operator++() {
                const Entry *old = ent;
                ent = ent->next;
                if (!ent) {
                    size_t bucket = tab->get_bucket(old->val);
                    while (!ent && ++bucket < tab->buckets.size())
                        ent = tab->buckets[bucket];
                }
                return *this;
            }

            const_iterator operator++(int) {
                const_iterator tmp = *this;
                operator++();
                return tmp;
            }


            bool operator==(const const_iterator& it) const { 
                return ent == it.ent;
            }

            bool operator!=(const const_iterator& it) const {
                return ent != it.ent;
            }
        };

    private:

        typedef std::vector<Entry*> Table;

        Table buckets;
        size_t entries;
        HashFun hash_fun ;
        GetKey get_key;
        KeyEqFun key_eq_fun;
    
    public:

    hashtable(size_t init_size) : buckets(init_size,(Entry *)0) {
            entries = 0;
        }
    
        hashtable(const hashtable& other) {
            dup(other);
        }

        hashtable& operator= (const hashtable& other) {
            if (&other != this)
                dup(other);
            return *this;
        }

        ~hashtable() {
            clear();
        }

        size_t size() const { 
            return entries;
        }

        bool empty() const { 
            return size() == 0;
        }

        void swap(hashtable& other) {
            buckets.swap(other.buckets);
            std::swap(entries, other.entries);
        }
    
        iterator begin() {
            for (size_t i = 0; i < buckets.size(); ++i)
                if (buckets[i])
                    return iterator(buckets[i], this);
            return end();
        }
    
        iterator end() { 
            return iterator(0, this);
        }

        const_iterator begin() const {
            for (size_t i = 0; i < buckets.size(); ++i)
                if (buckets[i])
                    return const_iterator(buckets[i], this);
            return end();
        }
    
        const_iterator end() const { 
            return const_iterator(0, this);
        }
    
        size_t get_bucket(const Value& val, size_t n) const {
            return hash_fun(get_key(val)) % n;
        }
    
        size_t get_key_bucket(const Key& key) const {
            return hash_fun(key) % buckets.size();
        }

        size_t get_bucket(const Value& val) const {
            return get_bucket(val,buckets.size());
        }

        Entry *lookup(const Value& val, bool ins = false)
        {
            resize(entries + 1);

            size_t n = get_bucket(val);
            Entry* from = buckets[n];
      
            for (Entry* ent = from; ent; ent = ent->next)
                if (key_eq_fun(get_key(ent->val), get_key(val)))
                    return ent;
      
            if(!ins) return 0;

            Entry* tmp = new Entry(val);
            tmp->next = from;
            buckets[n] = tmp;
            ++entries;
            return tmp;
        }

        Entry *lookup_key(const Key& key) const
        {
            size_t n = get_key_bucket(key);
            Entry* from = buckets[n];
      
            for (Entry* ent = from; ent; ent = ent->next)
                if (key_eq_fun(get_key(ent->val), key))
                    return ent;
      
            return 0;
        }

        const_iterator find(const Key& key) const {
            return const_iterator(lookup_key(key),this);
        }

        iterator find(const Key& key) {
            return iterator(lookup_key(key),this);
        }

        std::pair<iterator,bool> insert(const Value& val){
            size_t old_entries = entries;
            Entry *ent = lookup(val,true);
            return std::pair<iterator,bool>(iterator(ent,this),entries > old_entries);
        }
    
        iterator insert(const iterator &it, const Value& val){
            Entry *ent = lookup(val,true);
            return iterator(ent,this);
        }

        size_t erase(const Key& key)
        {
            Entry** p = &(buckets[get_key_bucket(key)]);
            size_t count = 0;
            while(*p){
                Entry *q = *p;
                if (key_eq_fun(get_key(q->val), key)) {
                    ++count;
                    *p = q->next;
                    delete q;
                }
                else
                    p = &(q->next);
            }
            entries -= count;
            return count;
        }

        void resize(size_t new_size) {
            const size_t old_n = buckets.size();
            if (new_size <= old_n) return;
            const size_t n = next_prime(new_size);
            if (n <= old_n) return;
            Table tmp(n, (Entry*)(0));
            for (size_t i = 0; i < old_n; ++i) {
                Entry* ent = buckets[i];
                while (ent) {
                    size_t new_bucket = get_bucket(ent->val, n);
                    buckets[i] = ent->next;
                    ent->next = tmp[new_bucket];
                    tmp[new_bucket] = ent;
                    ent = buckets[i];
                }
            }
            buckets.swap(tmp);
        }
    
        void clear()
        {
            for (size_t i = 0; i < buckets.size(); ++i) {
                for (Entry* ent = buckets[i]; ent != 0;) {
                    Entry* next = ent->next;
                    delete ent;
                    ent = next;
                }
                buckets[i] = 0;
            }
            entries = 0;
        }

        void dup(const hashtable& other)
        {
            clear();
            buckets.resize(other.buckets.size());
            for (size_t i = 0; i < other.buckets.size(); ++i) {
                Entry** to = &buckets[i];
                for (Entry* from = other.buckets[i]; from; from = from->next)
                    to = &((*to = new Entry(from->val))->next);
            }
            entries = other.entries;
        }
    };

    template <typename T> 
        class equal {
    public:
        bool operator()(const T& x, const T &y) const {
            return x == y;
        }
    };

    template <typename T>
        class identity {
    public:
        const T &operator()(const T &x) const {
            return x;
        }
    };

    template <typename T, typename U>
        class proj1 {
    public:
        const T &operator()(const std::pair<T,U> &x) const {
            return x.first;
        }
    };

    template <typename Element, class HashFun = hash<Element>, 
        class EqFun = equal<Element> >
        class hash_set
        : public hashtable<Element,Element,HashFun,identity<Element>,EqFun> {

    public:

    typedef Element value_type;

    hash_set()
    : hashtable<Element,Element,HashFun,identity<Element>,EqFun>(7) {}
    };

    template <typename Key, typename Value, class HashFun = hash<Key>, 
        class EqFun = equal<Key> >
        class hash_map
        : public hashtable<std::pair<Key,Value>,Key,HashFun,proj1<Key,Value>,EqFun> {

    public:

    hash_map()
    : hashtable<std::pair<Key,Value>,Key,HashFun,proj1<Key,Value>,EqFun>(7) {}

    Value &operator[](const Key& key) {
	std::pair<Key,Value> kvp(key,Value());
	return 
	hashtable<std::pair<Key,Value>,Key,HashFun,proj1<Key,Value>,EqFun>::
        lookup(kvp,true)->val.second;
    }
    };

    template <typename D,typename R>
        class hash<hash_map<D,R> > {
    public:
        size_t operator()(const hash_map<D,R> &p) const {
            hash<D > h1;
            hash<R > h2;
            size_t res = 0;
            
            for (typename hash_map<D,R>::const_iterator it=p.begin(), en=p.end(); it!=en; ++it)
                res += (h1(it->first)+h2(it->second));
            return res;
        }
    };

    template <typename D,typename R>
    inline bool operator ==(const hash_map<D,R> &s, const hash_map<D,R> &t){
        for (typename hash_map<D,R>::const_iterator it=s.begin(), en=s.end(); it!=en; ++it) {
            typename hash_map<D,R>::const_iterator it2 = t.find(it->first);
            if (it2 == t.end() || !(it->second == it2->second)) return false;
        }
        for (typename hash_map<D,R>::const_iterator it=t.begin(), en=t.end(); it!=en; ++it) {
            typename hash_map<D,R>::const_iterator it2 = s.find(it->first);
            if (it2 == t.end() || !(it->second == it2->second)) return false;
        }
        return true;
    }
}
#endif
typedef std::string __strlit;
extern std::ofstream __ivy_out;
void __ivy_exit(int);

template <typename D, typename R>
struct thunk {
    virtual R operator()(const D &) = 0;
    int ___ivy_choose(int rng,const char *name,int id) {
        return 0;
    }
};
template <typename D, typename R, class HashFun = hash_space::hash<D> >
struct hash_thunk {
    thunk<D,R> *fun;
    hash_space::hash_map<D,R,HashFun> memo;
    hash_thunk() : fun(0) {}
    hash_thunk(thunk<D,R> *fun) : fun(fun) {}
    ~hash_thunk() {
//        if (fun)
//            delete fun;
    }
    R &operator[](const D& arg){
        std::pair<typename hash_space::hash_map<D,R>::iterator,bool> foo = memo.insert(std::pair<D,R>(arg,R()));
        R &res = foo.first->second;
        if (foo.second && fun)
            res = (*fun)(arg);
        return res;
    }
};
	#include <map>
    

    class reader;
    class timer;

class s3_test {
  public:
    typedef s3_test ivy_class;

    std::vector<std::string> __argv;
#ifdef _WIN32
    void *mutex;  // forward reference to HANDLE
#else
    pthread_mutex_t mutex;
#endif
    void __lock();
    void __unlock();

#ifdef _WIN32
    std::vector<HANDLE> thread_ids;

#else
    std::vector<pthread_t> thread_ids;

#endif
    void install_reader(reader *);
    void install_thread(reader *);
    void install_timer(timer *);
    virtual ~s3_test();
    std::vector<int> ___ivy_stack;
    int ___ivy_choose(int rng,const char *name,int id);
    virtual void ivy_assert(bool,const char *){}
    virtual void ivy_assume(bool,const char *){}
    virtual void ivy_check_progress(int,int){}
    class blob : public std::vector<unsigned>{
        public: size_t __hash() const { return hash_space::hash<std::vector<unsigned> >()(*this);};
    };
    struct _AbortIncompleteMultipartUpload {
    int _DaysAfterInitiation_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_DaysAfterInitiation_);
return hv;
}
    };
    struct _Grantee {
    __strlit _DisplayName_;
    __strlit _EmailAddress_;
    __strlit _ID_;
    __strlit _Type_;
    __strlit _URI_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_DisplayName_);
hv += hash_space::hash<__strlit>()(_EmailAddress_);
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<__strlit>()(_Type_);
hv += hash_space::hash<__strlit>()(_URI_);
return hv;
}
    };
    struct _Grant {
    _Grantee _Grantee_;
    __strlit _Permission_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_Grantee>()(_Grantee_);
hv += hash_space::hash<__strlit>()(_Permission_);
return hv;
}
    };
    struct _Owner {
    __strlit _DisplayName_;
    __strlit _ID_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_DisplayName_);
hv += hash_space::hash<__strlit>()(_ID_);
return hv;
}
    };
    class vector___Grant__ : public std::vector<_Grant>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Grant> >()(*this);};
    };
    struct _AccessControlTranslation {
    __strlit _Owner_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Owner_);
return hv;
}
    };
    struct _Tag {
    __strlit _Key_;
    __strlit _Value_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_Value_);
return hv;
}
    };
    class vector___Tag__ : public std::vector<_Tag>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Tag> >()(*this);};
    };
    struct _AnalyticsAndOperator {
    __strlit _Prefix_;
    vector___Tag__ _Tags_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<vector___Tag__>()(_Tags_);
return hv;
}
    };
    struct _AnalyticsFilter {
    __strlit _Prefix_;
    _Tag _Tag_;
    _AnalyticsAndOperator _And_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_Tag>()(_Tag_);
hv += hash_space::hash<_AnalyticsAndOperator>()(_And_);
return hv;
}
    };
    struct _AnalyticsS3BucketDestination {
    __strlit _Format_;
    __strlit _BucketAccountId_;
    __strlit _Bucket_;
    __strlit _Prefix_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Format_);
hv += hash_space::hash<__strlit>()(_BucketAccountId_);
hv += hash_space::hash<__strlit>()(_Bucket_);
hv += hash_space::hash<__strlit>()(_Prefix_);
return hv;
}
    };
    struct _AnalyticsExportDestination {
    _AnalyticsS3BucketDestination _S3BucketDestination_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_AnalyticsS3BucketDestination>()(_S3BucketDestination_);
return hv;
}
    };
    struct _StorageClassAnalysisDataExport {
    __strlit _OutputSchemaVersion_;
    _AnalyticsExportDestination _Destination_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_OutputSchemaVersion_);
hv += hash_space::hash<_AnalyticsExportDestination>()(_Destination_);
return hv;
}
    };
    struct _StorageClassAnalysis {
    _StorageClassAnalysisDataExport _DataExport_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_StorageClassAnalysisDataExport>()(_DataExport_);
return hv;
}
    };
    struct _AnalyticsConfiguration {
    __strlit _Id_;
    _AnalyticsFilter _Filter_;
    _StorageClassAnalysis _StorageClassAnalysis_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<_AnalyticsFilter>()(_Filter_);
hv += hash_space::hash<_StorageClassAnalysis>()(_StorageClassAnalysis_);
return hv;
}
    };
    struct _Bucket {
    __strlit _Name_;
    int _CreationDate_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Name_);
hv += hash_space::hash<int>()(_CreationDate_);
return hv;
}
    };
    struct _LifecycleExpiration {
    int _Date_;
    int _Days_;
    bool _ExpiredObjectDeleteMarker_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_Date_);
hv += hash_space::hash<int>()(_Days_);
hv += hash_space::hash<bool>()(_ExpiredObjectDeleteMarker_);
return hv;
}
    };
    struct _LifecycleRuleAndOperator {
    __strlit _Prefix_;
    vector___Tag__ _Tags_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<vector___Tag__>()(_Tags_);
return hv;
}
    };
    struct _LifecycleRuleFilter {
    __strlit _Prefix_;
    _Tag _Tag_;
    _LifecycleRuleAndOperator _And_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_Tag>()(_Tag_);
hv += hash_space::hash<_LifecycleRuleAndOperator>()(_And_);
return hv;
}
    };
    struct _Transition {
    int _Date_;
    int _Days_;
    __strlit _StorageClass_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_Date_);
hv += hash_space::hash<int>()(_Days_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
return hv;
}
    };
    struct _NoncurrentVersionTransition {
    int _NoncurrentDays_;
    __strlit _StorageClass_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_NoncurrentDays_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
return hv;
}
    };
    struct _NoncurrentVersionExpiration {
    int _NoncurrentDays_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_NoncurrentDays_);
return hv;
}
    };
    class vector___Transition__ : public std::vector<_Transition>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Transition> >()(*this);};
    };
    class vector___NoncurrentVersionTransition__ : public std::vector<_NoncurrentVersionTransition>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_NoncurrentVersionTransition> >()(*this);};
    };
    struct _LifecycleRule {
    _LifecycleExpiration _Expiration_;
    __strlit _ID_;
    __strlit _Prefix_;
    _LifecycleRuleFilter _Filter_;
    __strlit _Status_;
    vector___Transition__ _Transitions_;
    vector___NoncurrentVersionTransition__ _NoncurrentVersionTransitions_;
    _NoncurrentVersionExpiration _NoncurrentVersionExpiration_;
    _AbortIncompleteMultipartUpload _AbortIncompleteMultipartUpload_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_LifecycleExpiration>()(_Expiration_);
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_LifecycleRuleFilter>()(_Filter_);
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<vector___Transition__>()(_Transitions_);
hv += hash_space::hash<vector___NoncurrentVersionTransition__>()(_NoncurrentVersionTransitions_);
hv += hash_space::hash<_NoncurrentVersionExpiration>()(_NoncurrentVersionExpiration_);
hv += hash_space::hash<_AbortIncompleteMultipartUpload>()(_AbortIncompleteMultipartUpload_);
return hv;
}
    };
    class vector___LifecycleRule__ : public std::vector<_LifecycleRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_LifecycleRule> >()(*this);};
    };
    struct _TargetGrant {
    _Grantee _Grantee_;
    __strlit _Permission_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_Grantee>()(_Grantee_);
hv += hash_space::hash<__strlit>()(_Permission_);
return hv;
}
    };
    class vector___TargetGrant__ : public std::vector<_TargetGrant>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_TargetGrant> >()(*this);};
    };
    class vector__string__ : public std::vector<__strlit>{
        public: size_t __hash() const { return hash_space::hash<std::vector<__strlit> >()(*this);};
    };
    struct _CORSRule {
    __strlit _ID_;
    vector__string__ _AllowedHeaders_;
    vector__string__ _AllowedMethods_;
    vector__string__ _AllowedOrigins_;
    vector__string__ _ExposeHeaders_;
    int _MaxAgeSeconds_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<vector__string__>()(_AllowedHeaders_);
hv += hash_space::hash<vector__string__>()(_AllowedMethods_);
hv += hash_space::hash<vector__string__>()(_AllowedOrigins_);
hv += hash_space::hash<vector__string__>()(_ExposeHeaders_);
hv += hash_space::hash<int>()(_MaxAgeSeconds_);
return hv;
}
    };
    class vector___CORSRule__ : public std::vector<_CORSRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_CORSRule> >()(*this);};
    };
    struct _CommonPrefix {
    __strlit _Prefix_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
return hv;
}
    };
    struct _CompletedPart {
    __strlit _ETag_;
    int _PartNumber_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ETag_);
hv += hash_space::hash<int>()(_PartNumber_);
return hv;
}
    };
    class vector___CompletedPart__ : public std::vector<_CompletedPart>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_CompletedPart> >()(*this);};
    };
    struct _Condition {
    __strlit _HttpErrorCodeReturnedEquals_;
    __strlit _KeyPrefixEquals_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_HttpErrorCodeReturnedEquals_);
hv += hash_space::hash<__strlit>()(_KeyPrefixEquals_);
return hv;
}
    };
    class unordered_map__string____string__ : public std::map<__strlit,__strlit>{
        public: size_t __hash() const { return hash_space::hash<std::map<__strlit,__strlit> >()(*this);};
    };
    struct _ObjectIdentifier {
    __strlit _Key_;
    __strlit _VersionId_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_VersionId_);
return hv;
}
    };
    class vector___ObjectIdentifier__ : public std::vector<_ObjectIdentifier>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_ObjectIdentifier> >()(*this);};
    };
    struct _DeleteMarkerEntry {
    _Owner _Owner_;
    __strlit _Key_;
    __strlit _VersionId_;
    bool _IsLatest_;
    int _LastModified_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_Owner>()(_Owner_);
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<bool>()(_IsLatest_);
hv += hash_space::hash<int>()(_LastModified_);
return hv;
}
    };
    struct _DeleteMarkerReplication {
    __strlit _Status_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
return hv;
}
    };
    struct _DeletedObject {
    __strlit _Key_;
    __strlit _VersionId_;
    bool _DeleteMarker_;
    __strlit _DeleteMarkerVersionId_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<bool>()(_DeleteMarker_);
hv += hash_space::hash<__strlit>()(_DeleteMarkerVersionId_);
return hv;
}
    };
    struct _Error {
    __strlit _Key_;
    __strlit _VersionId_;
    __strlit _Code_;
    __strlit _Message_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<__strlit>()(_Code_);
hv += hash_space::hash<__strlit>()(_Message_);
return hv;
}
    };
    class vector___Error__ : public std::vector<_Error>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Error> >()(*this);};
    };
    class vector___DeletedObject__ : public std::vector<_DeletedObject>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_DeletedObject> >()(*this);};
    };
    struct _EncryptionConfiguration {
    __strlit _ReplicaKmsKeyID_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ReplicaKmsKeyID_);
return hv;
}
    };
    struct _ReplicationTimeValue {
    int _Minutes_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_Minutes_);
return hv;
}
    };
    struct _ReplicationTime {
    __strlit _Status_;
    _ReplicationTimeValue _Time_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<_ReplicationTimeValue>()(_Time_);
return hv;
}
    };
    struct _Metrics {
    __strlit _Status_;
    _ReplicationTimeValue _EventThreshold_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<_ReplicationTimeValue>()(_EventThreshold_);
return hv;
}
    };
    struct _Destination {
    __strlit _Bucket_;
    __strlit _Account_;
    __strlit _StorageClass_;
    _AccessControlTranslation _AccessControlTranslation_;
    _EncryptionConfiguration _EncryptionConfiguration_;
    _ReplicationTime _ReplicationTime_;
    _Metrics _Metrics_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Bucket_);
hv += hash_space::hash<__strlit>()(_Account_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
hv += hash_space::hash<_AccessControlTranslation>()(_AccessControlTranslation_);
hv += hash_space::hash<_EncryptionConfiguration>()(_EncryptionConfiguration_);
hv += hash_space::hash<_ReplicationTime>()(_ReplicationTime_);
hv += hash_space::hash<_Metrics>()(_Metrics_);
return hv;
}
    };
    struct _ExistingObjectReplication {
    __strlit _Status_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
return hv;
}
    };
    struct _FilterRule {
    __strlit _Name_;
    __strlit _Value_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Name_);
hv += hash_space::hash<__strlit>()(_Value_);
return hv;
}
    };
    struct _ServerSideEncryptionByDefault {
    __strlit _SSEAlgorithm_;
    __strlit _KMSMasterKeyID_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_SSEAlgorithm_);
hv += hash_space::hash<__strlit>()(_KMSMasterKeyID_);
return hv;
}
    };
    struct _ServerSideEncryptionRule {
    _ServerSideEncryptionByDefault _ApplyServerSideEncryptionByDefault_;
    bool _BucketKeyEnabled_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_ServerSideEncryptionByDefault>()(_ApplyServerSideEncryptionByDefault_);
hv += hash_space::hash<bool>()(_BucketKeyEnabled_);
return hv;
}
    };
    class vector___ServerSideEncryptionRule__ : public std::vector<_ServerSideEncryptionRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_ServerSideEncryptionRule> >()(*this);};
    };
    struct _IntelligentTieringAndOperator {
    __strlit _Prefix_;
    vector___Tag__ _Tags_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<vector___Tag__>()(_Tags_);
return hv;
}
    };
    struct _IntelligentTieringFilter {
    __strlit _Prefix_;
    _Tag _Tag_;
    _IntelligentTieringAndOperator _And_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_Tag>()(_Tag_);
hv += hash_space::hash<_IntelligentTieringAndOperator>()(_And_);
return hv;
}
    };
    struct _Tiering {
    int _Days_;
    __strlit _AccessTier_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_Days_);
hv += hash_space::hash<__strlit>()(_AccessTier_);
return hv;
}
    };
    class vector___Tiering__ : public std::vector<_Tiering>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Tiering> >()(*this);};
    };
    struct _IntelligentTieringConfiguration {
    __strlit _Id_;
    _IntelligentTieringFilter _Filter_;
    __strlit _Status_;
    vector___Tiering__ _Tierings_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<_IntelligentTieringFilter>()(_Filter_);
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<vector___Tiering__>()(_Tierings_);
return hv;
}
    };
    struct _SSES3 {
        size_t __hash() const { size_t hv = 0;
return hv;
}
    };
    struct _SSEKMS {
    __strlit _KeyId_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_KeyId_);
return hv;
}
    };
    struct _InventoryEncryption {
    _SSES3 _SSES3_;
    _SSEKMS _SSEKMS_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_SSES3>()(_SSES3_);
hv += hash_space::hash<_SSEKMS>()(_SSEKMS_);
return hv;
}
    };
    struct _InventoryS3BucketDestination {
    __strlit _AccountId_;
    __strlit _Bucket_;
    __strlit _Format_;
    __strlit _Prefix_;
    _InventoryEncryption _Encryption_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_AccountId_);
hv += hash_space::hash<__strlit>()(_Bucket_);
hv += hash_space::hash<__strlit>()(_Format_);
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_InventoryEncryption>()(_Encryption_);
return hv;
}
    };
    struct _InventoryDestination {
    _InventoryS3BucketDestination _S3BucketDestination_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_InventoryS3BucketDestination>()(_S3BucketDestination_);
return hv;
}
    };
    struct _InventoryFilter {
    __strlit _Prefix_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
return hv;
}
    };
    struct _InventorySchedule {
    __strlit _Frequency_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Frequency_);
return hv;
}
    };
    struct _InventoryConfiguration {
    _InventoryDestination _Destination_;
    bool _IsEnabled_;
    _InventoryFilter _Filter_;
    __strlit _Id_;
    __strlit _IncludedObjectVersions_;
    vector__string__ _OptionalFields_;
    _InventorySchedule _Schedule_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_InventoryDestination>()(_Destination_);
hv += hash_space::hash<bool>()(_IsEnabled_);
hv += hash_space::hash<_InventoryFilter>()(_Filter_);
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<__strlit>()(_IncludedObjectVersions_);
hv += hash_space::hash<vector__string__>()(_OptionalFields_);
hv += hash_space::hash<_InventorySchedule>()(_Schedule_);
return hv;
}
    };
    struct _Rule {
    _LifecycleExpiration _Expiration_;
    __strlit _ID_;
    __strlit _Prefix_;
    __strlit _Status_;
    _Transition _Transition_;
    _NoncurrentVersionTransition _NoncurrentVersionTransition_;
    _NoncurrentVersionExpiration _NoncurrentVersionExpiration_;
    _AbortIncompleteMultipartUpload _AbortIncompleteMultipartUpload_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_LifecycleExpiration>()(_Expiration_);
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<_Transition>()(_Transition_);
hv += hash_space::hash<_NoncurrentVersionTransition>()(_NoncurrentVersionTransition_);
hv += hash_space::hash<_NoncurrentVersionExpiration>()(_NoncurrentVersionExpiration_);
hv += hash_space::hash<_AbortIncompleteMultipartUpload>()(_AbortIncompleteMultipartUpload_);
return hv;
}
    };
    class vector___Rule__ : public std::vector<_Rule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Rule> >()(*this);};
    };
    struct _MetricsAndOperator {
    __strlit _Prefix_;
    vector___Tag__ _Tags_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<vector___Tag__>()(_Tags_);
return hv;
}
    };
    struct _MetricsFilter {
    __strlit _Prefix_;
    _Tag _Tag_;
    _MetricsAndOperator _And_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_Tag>()(_Tag_);
hv += hash_space::hash<_MetricsAndOperator>()(_And_);
return hv;
}
    };
    struct _MetricsConfiguration {
    __strlit _Id_;
    _MetricsFilter _Filter_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<_MetricsFilter>()(_Filter_);
return hv;
}
    };
    struct _OwnershipControlsRule {
    __strlit _ObjectOwnership_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ObjectOwnership_);
return hv;
}
    };
    class vector___OwnershipControlsRule__ : public std::vector<_OwnershipControlsRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_OwnershipControlsRule> >()(*this);};
    };
    struct _ReplicationRuleAndOperator {
    __strlit _Prefix_;
    vector___Tag__ _Tags_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<vector___Tag__>()(_Tags_);
return hv;
}
    };
    struct _ReplicationRuleFilter {
    __strlit _Prefix_;
    _Tag _Tag_;
    _ReplicationRuleAndOperator _And_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_Tag>()(_Tag_);
hv += hash_space::hash<_ReplicationRuleAndOperator>()(_And_);
return hv;
}
    };
    struct _SseKmsEncryptedObjects {
    __strlit _Status_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
return hv;
}
    };
    struct _ReplicaModifications {
    __strlit _Status_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Status_);
return hv;
}
    };
    struct _SourceSelectionCriteria {
    _SseKmsEncryptedObjects _SseKmsEncryptedObjects_;
    _ReplicaModifications _ReplicaModifications_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_SseKmsEncryptedObjects>()(_SseKmsEncryptedObjects_);
hv += hash_space::hash<_ReplicaModifications>()(_ReplicaModifications_);
return hv;
}
    };
    struct _ReplicationRule {
    __strlit _ID_;
    int _Priority_;
    __strlit _Prefix_;
    _ReplicationRuleFilter _Filter_;
    __strlit _Status_;
    _SourceSelectionCriteria _SourceSelectionCriteria_;
    _ExistingObjectReplication _ExistingObjectReplication_;
    _Destination _Destination_;
    _DeleteMarkerReplication _DeleteMarkerReplication_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<int>()(_Priority_);
hv += hash_space::hash<__strlit>()(_Prefix_);
hv += hash_space::hash<_ReplicationRuleFilter>()(_Filter_);
hv += hash_space::hash<__strlit>()(_Status_);
hv += hash_space::hash<_SourceSelectionCriteria>()(_SourceSelectionCriteria_);
hv += hash_space::hash<_ExistingObjectReplication>()(_ExistingObjectReplication_);
hv += hash_space::hash<_Destination>()(_Destination_);
hv += hash_space::hash<_DeleteMarkerReplication>()(_DeleteMarkerReplication_);
return hv;
}
    };
    class vector___ReplicationRule__ : public std::vector<_ReplicationRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_ReplicationRule> >()(*this);};
    };
    struct _Redirect {
    __strlit _HostName_;
    __strlit _HttpRedirectCode_;
    __strlit _Protocol_;
    __strlit _ReplaceKeyPrefixWith_;
    __strlit _ReplaceKeyWith_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_HostName_);
hv += hash_space::hash<__strlit>()(_HttpRedirectCode_);
hv += hash_space::hash<__strlit>()(_Protocol_);
hv += hash_space::hash<__strlit>()(_ReplaceKeyPrefixWith_);
hv += hash_space::hash<__strlit>()(_ReplaceKeyWith_);
return hv;
}
    };
    struct _RoutingRule {
    _Condition _Condition_;
    _Redirect _Redirect_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_Condition>()(_Condition_);
hv += hash_space::hash<_Redirect>()(_Redirect_);
return hv;
}
    };
    class vector___RoutingRule__ : public std::vector<_RoutingRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_RoutingRule> >()(*this);};
    };
    struct _GetObjectOutput {
    blob _Body_;
    bool _DeleteMarker_;
    __strlit _AcceptRanges_;
    __strlit _Expiration_;
    __strlit _Restore_;
    int _LastModified_;
    int _ContentLength_;
    __strlit _ETag_;
    int _MissingMeta_;
    __strlit _VersionId_;
    __strlit _CacheControl_;
    __strlit _ContentDisposition_;
    __strlit _ContentEncoding_;
    __strlit _ContentLanguage_;
    __strlit _ContentRange_;
    __strlit _ContentType_;
    int _Expires_;
    __strlit _WebsiteRedirectLocation_;
    __strlit _ServerSideEncryption_;
    unordered_map__string____string__ _Metadata_;
    __strlit _SSECustomerAlgorithm_;
    __strlit _SSECustomerKeyMD5_;
    __strlit _SSEKMSKeyId_;
    bool _BucketKeyEnabled_;
    __strlit _StorageClass_;
    __strlit _RequestCharged_;
    __strlit _ReplicationStatus_;
    int _PartsCount_;
    int _TagCount_;
    __strlit _ObjectLockMode_;
    int _ObjectLockRetainUntilDate_;
    __strlit _ObjectLockLegalHoldStatus_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<blob>()(_Body_);
hv += hash_space::hash<bool>()(_DeleteMarker_);
hv += hash_space::hash<__strlit>()(_AcceptRanges_);
hv += hash_space::hash<__strlit>()(_Expiration_);
hv += hash_space::hash<__strlit>()(_Restore_);
hv += hash_space::hash<int>()(_LastModified_);
hv += hash_space::hash<int>()(_ContentLength_);
hv += hash_space::hash<__strlit>()(_ETag_);
hv += hash_space::hash<int>()(_MissingMeta_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<__strlit>()(_CacheControl_);
hv += hash_space::hash<__strlit>()(_ContentDisposition_);
hv += hash_space::hash<__strlit>()(_ContentEncoding_);
hv += hash_space::hash<__strlit>()(_ContentLanguage_);
hv += hash_space::hash<__strlit>()(_ContentRange_);
hv += hash_space::hash<__strlit>()(_ContentType_);
hv += hash_space::hash<int>()(_Expires_);
hv += hash_space::hash<__strlit>()(_WebsiteRedirectLocation_);
hv += hash_space::hash<__strlit>()(_ServerSideEncryption_);
hv += hash_space::hash<unordered_map__string____string__>()(_Metadata_);
hv += hash_space::hash<__strlit>()(_SSECustomerAlgorithm_);
hv += hash_space::hash<__strlit>()(_SSECustomerKeyMD5_);
hv += hash_space::hash<__strlit>()(_SSEKMSKeyId_);
hv += hash_space::hash<bool>()(_BucketKeyEnabled_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
hv += hash_space::hash<__strlit>()(_RequestCharged_);
hv += hash_space::hash<__strlit>()(_ReplicationStatus_);
hv += hash_space::hash<int>()(_PartsCount_);
hv += hash_space::hash<int>()(_TagCount_);
hv += hash_space::hash<__strlit>()(_ObjectLockMode_);
hv += hash_space::hash<int>()(_ObjectLockRetainUntilDate_);
hv += hash_space::hash<__strlit>()(_ObjectLockLegalHoldStatus_);
return hv;
}
    };
    struct _GetObjectRequest {
    __strlit _Bucket_;
    __strlit _IfMatch_;
    int _IfModifiedSince_;
    __strlit _IfNoneMatch_;
    int _IfUnmodifiedSince_;
    __strlit _Key_;
    __strlit _Range_;
    __strlit _ResponseCacheControl_;
    __strlit _ResponseContentDisposition_;
    __strlit _ResponseContentEncoding_;
    __strlit _ResponseContentLanguage_;
    __strlit _ResponseContentType_;
    int _ResponseExpires_;
    __strlit _VersionId_;
    __strlit _SSECustomerAlgorithm_;
    __strlit _SSECustomerKey_;
    __strlit _SSECustomerKeyMD5_;
    __strlit _RequestPayer_;
    int _PartNumber_;
    __strlit _ExpectedBucketOwner_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Bucket_);
hv += hash_space::hash<__strlit>()(_IfMatch_);
hv += hash_space::hash<int>()(_IfModifiedSince_);
hv += hash_space::hash<__strlit>()(_IfNoneMatch_);
hv += hash_space::hash<int>()(_IfUnmodifiedSince_);
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_Range_);
hv += hash_space::hash<__strlit>()(_ResponseCacheControl_);
hv += hash_space::hash<__strlit>()(_ResponseContentDisposition_);
hv += hash_space::hash<__strlit>()(_ResponseContentEncoding_);
hv += hash_space::hash<__strlit>()(_ResponseContentLanguage_);
hv += hash_space::hash<__strlit>()(_ResponseContentType_);
hv += hash_space::hash<int>()(_ResponseExpires_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<__strlit>()(_SSECustomerAlgorithm_);
hv += hash_space::hash<__strlit>()(_SSECustomerKey_);
hv += hash_space::hash<__strlit>()(_SSECustomerKeyMD5_);
hv += hash_space::hash<__strlit>()(_RequestPayer_);
hv += hash_space::hash<int>()(_PartNumber_);
hv += hash_space::hash<__strlit>()(_ExpectedBucketOwner_);
return hv;
}
    };
    struct _Initiator {
    __strlit _ID_;
    __strlit _DisplayName_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ID_);
hv += hash_space::hash<__strlit>()(_DisplayName_);
return hv;
}
    };
    class vector___FilterRule__ : public std::vector<_FilterRule>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_FilterRule> >()(*this);};
    };
    struct _S3KeyFilter {
    vector___FilterRule__ _FilterRules_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<vector___FilterRule__>()(_FilterRules_);
return hv;
}
    };
    struct _NotificationConfigurationFilter {
    _S3KeyFilter _Key_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<_S3KeyFilter>()(_Key_);
return hv;
}
    };
    struct _LambdaFunctionConfiguration {
    __strlit _Id_;
    __strlit _LambdaFunctionArn_;
    vector__string__ _Events_;
    _NotificationConfigurationFilter _Filter_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<__strlit>()(_LambdaFunctionArn_);
hv += hash_space::hash<vector__string__>()(_Events_);
hv += hash_space::hash<_NotificationConfigurationFilter>()(_Filter_);
return hv;
}
    };
    class vector___AnalyticsConfiguration__ : public std::vector<_AnalyticsConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_AnalyticsConfiguration> >()(*this);};
    };
    class vector___IntelligentTieringConfiguration__ : public std::vector<_IntelligentTieringConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_IntelligentTieringConfiguration> >()(*this);};
    };
    class vector___InventoryConfiguration__ : public std::vector<_InventoryConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_InventoryConfiguration> >()(*this);};
    };
    class vector___MetricsConfiguration__ : public std::vector<_MetricsConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_MetricsConfiguration> >()(*this);};
    };
    class vector___Bucket__ : public std::vector<_Bucket>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Bucket> >()(*this);};
    };
    struct _MultipartUpload {
    __strlit _UploadId_;
    __strlit _Key_;
    int _Initiated_;
    __strlit _StorageClass_;
    _Owner _Owner_;
    _Initiator _Initiator_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_UploadId_);
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<int>()(_Initiated_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
hv += hash_space::hash<_Owner>()(_Owner_);
hv += hash_space::hash<_Initiator>()(_Initiator_);
return hv;
}
    };
    class vector___CommonPrefix__ : public std::vector<_CommonPrefix>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_CommonPrefix> >()(*this);};
    };
    class vector___MultipartUpload__ : public std::vector<_MultipartUpload>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_MultipartUpload> >()(*this);};
    };
    struct _ObjectVersion {
    __strlit _ETag_;
    int _Size_;
    __strlit _StorageClass_;
    __strlit _Key_;
    __strlit _VersionId_;
    bool _IsLatest_;
    int _LastModified_;
    _Owner _Owner_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_ETag_);
hv += hash_space::hash<int>()(_Size_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<__strlit>()(_VersionId_);
hv += hash_space::hash<bool>()(_IsLatest_);
hv += hash_space::hash<int>()(_LastModified_);
hv += hash_space::hash<_Owner>()(_Owner_);
return hv;
}
    };
    class vector___ObjectVersion__ : public std::vector<_ObjectVersion>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_ObjectVersion> >()(*this);};
    };
    class vector___DeleteMarkerEntry__ : public std::vector<_DeleteMarkerEntry>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_DeleteMarkerEntry> >()(*this);};
    };
    struct _Object {
    __strlit _Key_;
    int _LastModified_;
    __strlit _ETag_;
    int _Size_;
    __strlit _StorageClass_;
    _Owner _Owner_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Key_);
hv += hash_space::hash<int>()(_LastModified_);
hv += hash_space::hash<__strlit>()(_ETag_);
hv += hash_space::hash<int>()(_Size_);
hv += hash_space::hash<__strlit>()(_StorageClass_);
hv += hash_space::hash<_Owner>()(_Owner_);
return hv;
}
    };
    class vector___Object__ : public std::vector<_Object>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Object> >()(*this);};
    };
    struct _Part {
    int _PartNumber_;
    int _LastModified_;
    __strlit _ETag_;
    int _Size_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<int>()(_PartNumber_);
hv += hash_space::hash<int>()(_LastModified_);
hv += hash_space::hash<__strlit>()(_ETag_);
hv += hash_space::hash<int>()(_Size_);
return hv;
}
    };
    class vector___Part__ : public std::vector<_Part>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_Part> >()(*this);};
    };
    struct _MetadataEntry {
    __strlit _Name_;
    __strlit _Value_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Name_);
hv += hash_space::hash<__strlit>()(_Value_);
return hv;
}
    };
    struct _TopicConfiguration {
    __strlit _Id_;
    __strlit _TopicArn_;
    vector__string__ _Events_;
    _NotificationConfigurationFilter _Filter_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<__strlit>()(_TopicArn_);
hv += hash_space::hash<vector__string__>()(_Events_);
hv += hash_space::hash<_NotificationConfigurationFilter>()(_Filter_);
return hv;
}
    };
    struct _QueueConfiguration {
    __strlit _Id_;
    __strlit _QueueArn_;
    vector__string__ _Events_;
    _NotificationConfigurationFilter _Filter_;
        size_t __hash() const { size_t hv = 0;
hv += hash_space::hash<__strlit>()(_Id_);
hv += hash_space::hash<__strlit>()(_QueueArn_);
hv += hash_space::hash<vector__string__>()(_Events_);
hv += hash_space::hash<_NotificationConfigurationFilter>()(_Filter_);
return hv;
}
    };
    class vector___QueueConfiguration__ : public std::vector<_QueueConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_QueueConfiguration> >()(*this);};
    };
    class vector___LambdaFunctionConfiguration__ : public std::vector<_LambdaFunctionConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_LambdaFunctionConfiguration> >()(*this);};
    };
    class vector___TopicConfiguration__ : public std::vector<_TopicConfiguration>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_TopicConfiguration> >()(*this);};
    };
    class vector___MetadataEntry__ : public std::vector<_MetadataEntry>{
        public: size_t __hash() const { return hash_space::hash<std::vector<_MetadataEntry> >()(*this);};
    };
    bool _generating;
    long long __CARD__vector___MultipartUpload____domain;
    long long __CARD__vector___ReplicationRule____domain;
    long long __CARD__vector___CompletedPart____domain;
    long long __CARD__vector___LambdaFunctionConfiguration____domain;
    long long __CARD__vector___ServerSideEncryptionRule____domain;
    long long __CARD__vector___MetricsConfiguration____domain;
    long long __CARD__vector___IntelligentTieringConfiguration____domain;
    long long __CARD__vector___Part____domain;
    long long __CARD__blob__domain;
    long long __CARD__vector___CommonPrefix____domain;
    long long __CARD__vector___TargetGrant____domain;
    long long __CARD__long;
    long long __CARD__vector___Error____domain;
    long long __CARD__vector___Transition____domain;
    long long __CARD__vector___ObjectVersion____domain;
    long long __CARD__vector___InventoryConfiguration____domain;
    long long __CARD__vector___MetadataEntry____domain;
    long long __CARD__vector__string____domain;
    long long __CARD__string;
    long long __CARD__vector___NoncurrentVersionTransition____domain;
    long long __CARD__timestamp;
    long long __CARD__vector___OwnershipControlsRule____domain;
    long long __CARD__vector___RoutingRule____domain;
    long long __CARD__vector___CORSRule____domain;
    long long __CARD__vector___Object____domain;
    long long __CARD__vector___DeletedObject____domain;
    long long __CARD__vector___Rule____domain;
    long long __CARD__integer;
    long long __CARD__byte;
    long long __CARD__vector___Bucket____domain;
    long long __CARD__vector___ObjectIdentifier____domain;
    long long __CARD__vector___Grant____domain;
    long long __CARD__vector___FilterRule____domain;
    long long __CARD__vector___TopicConfiguration____domain;
    long long __CARD__vector___LifecycleRule____domain;
    long long __CARD__vector___QueueConfiguration____domain;
    long long __CARD__vector___AnalyticsConfiguration____domain;
    long long __CARD__vector___Tiering____domain;
    long long __CARD__vector___DeleteMarkerEntry____domain;
    long long __CARD__vector___Tag____domain;
    virtual unsigned blob__value(const blob& a, unsigned long long i);
    virtual unsigned long long blob__end(const blob& a);
    virtual _Grant vector___Grant____value(const vector___Grant__& a, unsigned long long i);
    virtual unsigned long long vector___Grant____end(const vector___Grant__& a);
    virtual _Tag vector___Tag____value(const vector___Tag__& a, unsigned long long i);
    virtual unsigned long long vector___Tag____end(const vector___Tag__& a);
    virtual _Transition vector___Transition____value(const vector___Transition__& a, unsigned long long i);
    virtual unsigned long long vector___Transition____end(const vector___Transition__& a);
    virtual _NoncurrentVersionTransition vector___NoncurrentVersionTransition____value(const vector___NoncurrentVersionTransition__& a, unsigned long long i);
    virtual unsigned long long vector___NoncurrentVersionTransition____end(const vector___NoncurrentVersionTransition__& a);
    virtual _LifecycleRule vector___LifecycleRule____value(const vector___LifecycleRule__& a, unsigned long long i);
    virtual unsigned long long vector___LifecycleRule____end(const vector___LifecycleRule__& a);
    virtual _TargetGrant vector___TargetGrant____value(const vector___TargetGrant__& a, unsigned long long i);
    virtual unsigned long long vector___TargetGrant____end(const vector___TargetGrant__& a);
    virtual __strlit vector__string____value(const vector__string__& a, unsigned long long i);
    virtual unsigned long long vector__string____end(const vector__string__& a);
    virtual _CORSRule vector___CORSRule____value(const vector___CORSRule__& a, unsigned long long i);
    virtual unsigned long long vector___CORSRule____end(const vector___CORSRule__& a);
    virtual _CompletedPart vector___CompletedPart____value(const vector___CompletedPart__& a, unsigned long long i);
    virtual unsigned long long vector___CompletedPart____end(const vector___CompletedPart__& a);
    virtual _ObjectIdentifier vector___ObjectIdentifier____value(const vector___ObjectIdentifier__& a, unsigned long long i);
    virtual unsigned long long vector___ObjectIdentifier____end(const vector___ObjectIdentifier__& a);
    virtual _Error vector___Error____value(const vector___Error__& a, unsigned long long i);
    virtual unsigned long long vector___Error____end(const vector___Error__& a);
    virtual _DeletedObject vector___DeletedObject____value(const vector___DeletedObject__& a, unsigned long long i);
    virtual unsigned long long vector___DeletedObject____end(const vector___DeletedObject__& a);
    virtual _ServerSideEncryptionRule vector___ServerSideEncryptionRule____value(const vector___ServerSideEncryptionRule__& a, unsigned long long i);
    virtual unsigned long long vector___ServerSideEncryptionRule____end(const vector___ServerSideEncryptionRule__& a);
    virtual _Tiering vector___Tiering____value(const vector___Tiering__& a, unsigned long long i);
    virtual unsigned long long vector___Tiering____end(const vector___Tiering__& a);
    virtual _Rule vector___Rule____value(const vector___Rule__& a, unsigned long long i);
    virtual unsigned long long vector___Rule____end(const vector___Rule__& a);
    virtual _OwnershipControlsRule vector___OwnershipControlsRule____value(const vector___OwnershipControlsRule__& a, unsigned long long i);
    virtual unsigned long long vector___OwnershipControlsRule____end(const vector___OwnershipControlsRule__& a);
    virtual _ReplicationRule vector___ReplicationRule____value(const vector___ReplicationRule__& a, unsigned long long i);
    virtual unsigned long long vector___ReplicationRule____end(const vector___ReplicationRule__& a);
    virtual _RoutingRule vector___RoutingRule____value(const vector___RoutingRule__& a, unsigned long long i);
    virtual unsigned long long vector___RoutingRule____end(const vector___RoutingRule__& a);
    virtual _FilterRule vector___FilterRule____value(const vector___FilterRule__& a, unsigned long long i);
    virtual unsigned long long vector___FilterRule____end(const vector___FilterRule__& a);
    virtual _AnalyticsConfiguration vector___AnalyticsConfiguration____value(const vector___AnalyticsConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___AnalyticsConfiguration____end(const vector___AnalyticsConfiguration__& a);
    virtual _IntelligentTieringConfiguration vector___IntelligentTieringConfiguration____value(const vector___IntelligentTieringConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___IntelligentTieringConfiguration____end(const vector___IntelligentTieringConfiguration__& a);
    virtual _InventoryConfiguration vector___InventoryConfiguration____value(const vector___InventoryConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___InventoryConfiguration____end(const vector___InventoryConfiguration__& a);
    virtual _MetricsConfiguration vector___MetricsConfiguration____value(const vector___MetricsConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___MetricsConfiguration____end(const vector___MetricsConfiguration__& a);
    virtual _Bucket vector___Bucket____value(const vector___Bucket__& a, unsigned long long i);
    virtual unsigned long long vector___Bucket____end(const vector___Bucket__& a);
    virtual _CommonPrefix vector___CommonPrefix____value(const vector___CommonPrefix__& a, unsigned long long i);
    virtual unsigned long long vector___CommonPrefix____end(const vector___CommonPrefix__& a);
    virtual _MultipartUpload vector___MultipartUpload____value(const vector___MultipartUpload__& a, unsigned long long i);
    virtual unsigned long long vector___MultipartUpload____end(const vector___MultipartUpload__& a);
    virtual _ObjectVersion vector___ObjectVersion____value(const vector___ObjectVersion__& a, unsigned long long i);
    virtual unsigned long long vector___ObjectVersion____end(const vector___ObjectVersion__& a);
    virtual _DeleteMarkerEntry vector___DeleteMarkerEntry____value(const vector___DeleteMarkerEntry__& a, unsigned long long i);
    virtual unsigned long long vector___DeleteMarkerEntry____end(const vector___DeleteMarkerEntry__& a);
    virtual _Object vector___Object____value(const vector___Object__& a, unsigned long long i);
    virtual unsigned long long vector___Object____end(const vector___Object__& a);
    virtual _Part vector___Part____value(const vector___Part__& a, unsigned long long i);
    virtual unsigned long long vector___Part____end(const vector___Part__& a);
    virtual _QueueConfiguration vector___QueueConfiguration____value(const vector___QueueConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___QueueConfiguration____end(const vector___QueueConfiguration__& a);
    virtual _LambdaFunctionConfiguration vector___LambdaFunctionConfiguration____value(const vector___LambdaFunctionConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___LambdaFunctionConfiguration____end(const vector___LambdaFunctionConfiguration__& a);
    virtual _TopicConfiguration vector___TopicConfiguration____value(const vector___TopicConfiguration__& a, unsigned long long i);
    virtual unsigned long long vector___TopicConfiguration____end(const vector___TopicConfiguration__& a);
    virtual _MetadataEntry vector___MetadataEntry____value(const vector___MetadataEntry__& a, unsigned long long i);
    virtual unsigned long long vector___MetadataEntry____end(const vector___MetadataEntry__& a);
    s3_test();
    virtual void ext___GetObject__request(_GetObjectRequest input);
    virtual void __init();
    virtual void _GetObject__response_GetObjectOutput(const _GetObjectOutput& val);
    void __tick(int timeout);
};
inline bool operator ==(const s3_test::_AbortIncompleteMultipartUpload &s, const s3_test::_AbortIncompleteMultipartUpload &t){
    return ((s._DaysAfterInitiation_ == t._DaysAfterInitiation_));
}
inline bool operator ==(const s3_test::_Grantee &s, const s3_test::_Grantee &t){
    return ((s._DisplayName_ == t._DisplayName_) && (s._EmailAddress_ == t._EmailAddress_) && (s._ID_ == t._ID_) && (s._Type_ == t._Type_) && (s._URI_ == t._URI_));
}
inline bool operator ==(const s3_test::_Grant &s, const s3_test::_Grant &t){
    return ((s._Grantee_ == t._Grantee_) && (s._Permission_ == t._Permission_));
}
inline bool operator ==(const s3_test::_Owner &s, const s3_test::_Owner &t){
    return ((s._DisplayName_ == t._DisplayName_) && (s._ID_ == t._ID_));
}
inline bool operator ==(const s3_test::_AccessControlTranslation &s, const s3_test::_AccessControlTranslation &t){
    return ((s._Owner_ == t._Owner_));
}
inline bool operator ==(const s3_test::_Tag &s, const s3_test::_Tag &t){
    return ((s._Key_ == t._Key_) && (s._Value_ == t._Value_));
}
inline bool operator ==(const s3_test::_AnalyticsAndOperator &s, const s3_test::_AnalyticsAndOperator &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tags_ == t._Tags_));
}
inline bool operator ==(const s3_test::_AnalyticsFilter &s, const s3_test::_AnalyticsFilter &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tag_ == t._Tag_) && (s._And_ == t._And_));
}
inline bool operator ==(const s3_test::_AnalyticsS3BucketDestination &s, const s3_test::_AnalyticsS3BucketDestination &t){
    return ((s._Format_ == t._Format_) && (s._BucketAccountId_ == t._BucketAccountId_) && (s._Bucket_ == t._Bucket_) && (s._Prefix_ == t._Prefix_));
}
inline bool operator ==(const s3_test::_AnalyticsExportDestination &s, const s3_test::_AnalyticsExportDestination &t){
    return ((s._S3BucketDestination_ == t._S3BucketDestination_));
}
inline bool operator ==(const s3_test::_StorageClassAnalysisDataExport &s, const s3_test::_StorageClassAnalysisDataExport &t){
    return ((s._OutputSchemaVersion_ == t._OutputSchemaVersion_) && (s._Destination_ == t._Destination_));
}
inline bool operator ==(const s3_test::_StorageClassAnalysis &s, const s3_test::_StorageClassAnalysis &t){
    return ((s._DataExport_ == t._DataExport_));
}
inline bool operator ==(const s3_test::_AnalyticsConfiguration &s, const s3_test::_AnalyticsConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._Filter_ == t._Filter_) && (s._StorageClassAnalysis_ == t._StorageClassAnalysis_));
}
inline bool operator ==(const s3_test::_Bucket &s, const s3_test::_Bucket &t){
    return ((s._Name_ == t._Name_) && (s._CreationDate_ == t._CreationDate_));
}
inline bool operator ==(const s3_test::_LifecycleExpiration &s, const s3_test::_LifecycleExpiration &t){
    return ((s._Date_ == t._Date_) && (s._Days_ == t._Days_) && (s._ExpiredObjectDeleteMarker_ == t._ExpiredObjectDeleteMarker_));
}
inline bool operator ==(const s3_test::_LifecycleRuleAndOperator &s, const s3_test::_LifecycleRuleAndOperator &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tags_ == t._Tags_));
}
inline bool operator ==(const s3_test::_LifecycleRuleFilter &s, const s3_test::_LifecycleRuleFilter &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tag_ == t._Tag_) && (s._And_ == t._And_));
}
inline bool operator ==(const s3_test::_Transition &s, const s3_test::_Transition &t){
    return ((s._Date_ == t._Date_) && (s._Days_ == t._Days_) && (s._StorageClass_ == t._StorageClass_));
}
inline bool operator ==(const s3_test::_NoncurrentVersionTransition &s, const s3_test::_NoncurrentVersionTransition &t){
    return ((s._NoncurrentDays_ == t._NoncurrentDays_) && (s._StorageClass_ == t._StorageClass_));
}
inline bool operator ==(const s3_test::_NoncurrentVersionExpiration &s, const s3_test::_NoncurrentVersionExpiration &t){
    return ((s._NoncurrentDays_ == t._NoncurrentDays_));
}
inline bool operator ==(const s3_test::_LifecycleRule &s, const s3_test::_LifecycleRule &t){
    return ((s._Expiration_ == t._Expiration_) && (s._ID_ == t._ID_) && (s._Prefix_ == t._Prefix_) && (s._Filter_ == t._Filter_) && (s._Status_ == t._Status_) && (s._Transitions_ == t._Transitions_) && (s._NoncurrentVersionTransitions_ == t._NoncurrentVersionTransitions_) && (s._NoncurrentVersionExpiration_ == t._NoncurrentVersionExpiration_) && (s._AbortIncompleteMultipartUpload_ == t._AbortIncompleteMultipartUpload_));
}
inline bool operator ==(const s3_test::_TargetGrant &s, const s3_test::_TargetGrant &t){
    return ((s._Grantee_ == t._Grantee_) && (s._Permission_ == t._Permission_));
}
inline bool operator ==(const s3_test::_CORSRule &s, const s3_test::_CORSRule &t){
    return ((s._ID_ == t._ID_) && (s._AllowedHeaders_ == t._AllowedHeaders_) && (s._AllowedMethods_ == t._AllowedMethods_) && (s._AllowedOrigins_ == t._AllowedOrigins_) && (s._ExposeHeaders_ == t._ExposeHeaders_) && (s._MaxAgeSeconds_ == t._MaxAgeSeconds_));
}
inline bool operator ==(const s3_test::_CommonPrefix &s, const s3_test::_CommonPrefix &t){
    return ((s._Prefix_ == t._Prefix_));
}
inline bool operator ==(const s3_test::_CompletedPart &s, const s3_test::_CompletedPart &t){
    return ((s._ETag_ == t._ETag_) && (s._PartNumber_ == t._PartNumber_));
}
inline bool operator ==(const s3_test::_Condition &s, const s3_test::_Condition &t){
    return ((s._HttpErrorCodeReturnedEquals_ == t._HttpErrorCodeReturnedEquals_) && (s._KeyPrefixEquals_ == t._KeyPrefixEquals_));
}
inline bool operator ==(const s3_test::_ObjectIdentifier &s, const s3_test::_ObjectIdentifier &t){
    return ((s._Key_ == t._Key_) && (s._VersionId_ == t._VersionId_));
}
inline bool operator ==(const s3_test::_DeleteMarkerEntry &s, const s3_test::_DeleteMarkerEntry &t){
    return ((s._Owner_ == t._Owner_) && (s._Key_ == t._Key_) && (s._VersionId_ == t._VersionId_) && (s._IsLatest_ == t._IsLatest_) && (s._LastModified_ == t._LastModified_));
}
inline bool operator ==(const s3_test::_DeleteMarkerReplication &s, const s3_test::_DeleteMarkerReplication &t){
    return ((s._Status_ == t._Status_));
}
inline bool operator ==(const s3_test::_DeletedObject &s, const s3_test::_DeletedObject &t){
    return ((s._Key_ == t._Key_) && (s._VersionId_ == t._VersionId_) && (s._DeleteMarker_ == t._DeleteMarker_) && (s._DeleteMarkerVersionId_ == t._DeleteMarkerVersionId_));
}
inline bool operator ==(const s3_test::_Error &s, const s3_test::_Error &t){
    return ((s._Key_ == t._Key_) && (s._VersionId_ == t._VersionId_) && (s._Code_ == t._Code_) && (s._Message_ == t._Message_));
}
inline bool operator ==(const s3_test::_EncryptionConfiguration &s, const s3_test::_EncryptionConfiguration &t){
    return ((s._ReplicaKmsKeyID_ == t._ReplicaKmsKeyID_));
}
inline bool operator ==(const s3_test::_ReplicationTimeValue &s, const s3_test::_ReplicationTimeValue &t){
    return ((s._Minutes_ == t._Minutes_));
}
inline bool operator ==(const s3_test::_ReplicationTime &s, const s3_test::_ReplicationTime &t){
    return ((s._Status_ == t._Status_) && (s._Time_ == t._Time_));
}
inline bool operator ==(const s3_test::_Metrics &s, const s3_test::_Metrics &t){
    return ((s._Status_ == t._Status_) && (s._EventThreshold_ == t._EventThreshold_));
}
inline bool operator ==(const s3_test::_Destination &s, const s3_test::_Destination &t){
    return ((s._Bucket_ == t._Bucket_) && (s._Account_ == t._Account_) && (s._StorageClass_ == t._StorageClass_) && (s._AccessControlTranslation_ == t._AccessControlTranslation_) && (s._EncryptionConfiguration_ == t._EncryptionConfiguration_) && (s._ReplicationTime_ == t._ReplicationTime_) && (s._Metrics_ == t._Metrics_));
}
inline bool operator ==(const s3_test::_ExistingObjectReplication &s, const s3_test::_ExistingObjectReplication &t){
    return ((s._Status_ == t._Status_));
}
inline bool operator ==(const s3_test::_FilterRule &s, const s3_test::_FilterRule &t){
    return ((s._Name_ == t._Name_) && (s._Value_ == t._Value_));
}
inline bool operator ==(const s3_test::_ServerSideEncryptionByDefault &s, const s3_test::_ServerSideEncryptionByDefault &t){
    return ((s._SSEAlgorithm_ == t._SSEAlgorithm_) && (s._KMSMasterKeyID_ == t._KMSMasterKeyID_));
}
inline bool operator ==(const s3_test::_ServerSideEncryptionRule &s, const s3_test::_ServerSideEncryptionRule &t){
    return ((s._ApplyServerSideEncryptionByDefault_ == t._ApplyServerSideEncryptionByDefault_) && (s._BucketKeyEnabled_ == t._BucketKeyEnabled_));
}
inline bool operator ==(const s3_test::_IntelligentTieringAndOperator &s, const s3_test::_IntelligentTieringAndOperator &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tags_ == t._Tags_));
}
inline bool operator ==(const s3_test::_IntelligentTieringFilter &s, const s3_test::_IntelligentTieringFilter &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tag_ == t._Tag_) && (s._And_ == t._And_));
}
inline bool operator ==(const s3_test::_Tiering &s, const s3_test::_Tiering &t){
    return ((s._Days_ == t._Days_) && (s._AccessTier_ == t._AccessTier_));
}
inline bool operator ==(const s3_test::_IntelligentTieringConfiguration &s, const s3_test::_IntelligentTieringConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._Filter_ == t._Filter_) && (s._Status_ == t._Status_) && (s._Tierings_ == t._Tierings_));
}
inline bool operator ==(const s3_test::_SSES3 &s, const s3_test::_SSES3 &t){
    return true;
}
inline bool operator ==(const s3_test::_SSEKMS &s, const s3_test::_SSEKMS &t){
    return ((s._KeyId_ == t._KeyId_));
}
inline bool operator ==(const s3_test::_InventoryEncryption &s, const s3_test::_InventoryEncryption &t){
    return ((s._SSES3_ == t._SSES3_) && (s._SSEKMS_ == t._SSEKMS_));
}
inline bool operator ==(const s3_test::_InventoryS3BucketDestination &s, const s3_test::_InventoryS3BucketDestination &t){
    return ((s._AccountId_ == t._AccountId_) && (s._Bucket_ == t._Bucket_) && (s._Format_ == t._Format_) && (s._Prefix_ == t._Prefix_) && (s._Encryption_ == t._Encryption_));
}
inline bool operator ==(const s3_test::_InventoryDestination &s, const s3_test::_InventoryDestination &t){
    return ((s._S3BucketDestination_ == t._S3BucketDestination_));
}
inline bool operator ==(const s3_test::_InventoryFilter &s, const s3_test::_InventoryFilter &t){
    return ((s._Prefix_ == t._Prefix_));
}
inline bool operator ==(const s3_test::_InventorySchedule &s, const s3_test::_InventorySchedule &t){
    return ((s._Frequency_ == t._Frequency_));
}
inline bool operator ==(const s3_test::_InventoryConfiguration &s, const s3_test::_InventoryConfiguration &t){
    return ((s._Destination_ == t._Destination_) && (s._IsEnabled_ == t._IsEnabled_) && (s._Filter_ == t._Filter_) && (s._Id_ == t._Id_) && (s._IncludedObjectVersions_ == t._IncludedObjectVersions_) && (s._OptionalFields_ == t._OptionalFields_) && (s._Schedule_ == t._Schedule_));
}
inline bool operator ==(const s3_test::_Rule &s, const s3_test::_Rule &t){
    return ((s._Expiration_ == t._Expiration_) && (s._ID_ == t._ID_) && (s._Prefix_ == t._Prefix_) && (s._Status_ == t._Status_) && (s._Transition_ == t._Transition_) && (s._NoncurrentVersionTransition_ == t._NoncurrentVersionTransition_) && (s._NoncurrentVersionExpiration_ == t._NoncurrentVersionExpiration_) && (s._AbortIncompleteMultipartUpload_ == t._AbortIncompleteMultipartUpload_));
}
inline bool operator ==(const s3_test::_MetricsAndOperator &s, const s3_test::_MetricsAndOperator &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tags_ == t._Tags_));
}
inline bool operator ==(const s3_test::_MetricsFilter &s, const s3_test::_MetricsFilter &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tag_ == t._Tag_) && (s._And_ == t._And_));
}
inline bool operator ==(const s3_test::_MetricsConfiguration &s, const s3_test::_MetricsConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._Filter_ == t._Filter_));
}
inline bool operator ==(const s3_test::_OwnershipControlsRule &s, const s3_test::_OwnershipControlsRule &t){
    return ((s._ObjectOwnership_ == t._ObjectOwnership_));
}
inline bool operator ==(const s3_test::_ReplicationRuleAndOperator &s, const s3_test::_ReplicationRuleAndOperator &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tags_ == t._Tags_));
}
inline bool operator ==(const s3_test::_ReplicationRuleFilter &s, const s3_test::_ReplicationRuleFilter &t){
    return ((s._Prefix_ == t._Prefix_) && (s._Tag_ == t._Tag_) && (s._And_ == t._And_));
}
inline bool operator ==(const s3_test::_SseKmsEncryptedObjects &s, const s3_test::_SseKmsEncryptedObjects &t){
    return ((s._Status_ == t._Status_));
}
inline bool operator ==(const s3_test::_ReplicaModifications &s, const s3_test::_ReplicaModifications &t){
    return ((s._Status_ == t._Status_));
}
inline bool operator ==(const s3_test::_SourceSelectionCriteria &s, const s3_test::_SourceSelectionCriteria &t){
    return ((s._SseKmsEncryptedObjects_ == t._SseKmsEncryptedObjects_) && (s._ReplicaModifications_ == t._ReplicaModifications_));
}
inline bool operator ==(const s3_test::_ReplicationRule &s, const s3_test::_ReplicationRule &t){
    return ((s._ID_ == t._ID_) && (s._Priority_ == t._Priority_) && (s._Prefix_ == t._Prefix_) && (s._Filter_ == t._Filter_) && (s._Status_ == t._Status_) && (s._SourceSelectionCriteria_ == t._SourceSelectionCriteria_) && (s._ExistingObjectReplication_ == t._ExistingObjectReplication_) && (s._Destination_ == t._Destination_) && (s._DeleteMarkerReplication_ == t._DeleteMarkerReplication_));
}
inline bool operator ==(const s3_test::_Redirect &s, const s3_test::_Redirect &t){
    return ((s._HostName_ == t._HostName_) && (s._HttpRedirectCode_ == t._HttpRedirectCode_) && (s._Protocol_ == t._Protocol_) && (s._ReplaceKeyPrefixWith_ == t._ReplaceKeyPrefixWith_) && (s._ReplaceKeyWith_ == t._ReplaceKeyWith_));
}
inline bool operator ==(const s3_test::_RoutingRule &s, const s3_test::_RoutingRule &t){
    return ((s._Condition_ == t._Condition_) && (s._Redirect_ == t._Redirect_));
}
inline bool operator ==(const s3_test::_GetObjectOutput &s, const s3_test::_GetObjectOutput &t){
    return ((s._Body_ == t._Body_) && (s._DeleteMarker_ == t._DeleteMarker_) && (s._AcceptRanges_ == t._AcceptRanges_) && (s._Expiration_ == t._Expiration_) && (s._Restore_ == t._Restore_) && (s._LastModified_ == t._LastModified_) && (s._ContentLength_ == t._ContentLength_) && (s._ETag_ == t._ETag_) && (s._MissingMeta_ == t._MissingMeta_) && (s._VersionId_ == t._VersionId_) && (s._CacheControl_ == t._CacheControl_) && (s._ContentDisposition_ == t._ContentDisposition_) && (s._ContentEncoding_ == t._ContentEncoding_) && (s._ContentLanguage_ == t._ContentLanguage_) && (s._ContentRange_ == t._ContentRange_) && (s._ContentType_ == t._ContentType_) && (s._Expires_ == t._Expires_) && (s._WebsiteRedirectLocation_ == t._WebsiteRedirectLocation_) && (s._ServerSideEncryption_ == t._ServerSideEncryption_) && (s._Metadata_ == t._Metadata_) && (s._SSECustomerAlgorithm_ == t._SSECustomerAlgorithm_) && (s._SSECustomerKeyMD5_ == t._SSECustomerKeyMD5_) && (s._SSEKMSKeyId_ == t._SSEKMSKeyId_) && (s._BucketKeyEnabled_ == t._BucketKeyEnabled_) && (s._StorageClass_ == t._StorageClass_) && (s._RequestCharged_ == t._RequestCharged_) && (s._ReplicationStatus_ == t._ReplicationStatus_) && (s._PartsCount_ == t._PartsCount_) && (s._TagCount_ == t._TagCount_) && (s._ObjectLockMode_ == t._ObjectLockMode_) && (s._ObjectLockRetainUntilDate_ == t._ObjectLockRetainUntilDate_) && (s._ObjectLockLegalHoldStatus_ == t._ObjectLockLegalHoldStatus_));
}
inline bool operator ==(const s3_test::_GetObjectRequest &s, const s3_test::_GetObjectRequest &t){
    return ((s._Bucket_ == t._Bucket_) && (s._IfMatch_ == t._IfMatch_) && (s._IfModifiedSince_ == t._IfModifiedSince_) && (s._IfNoneMatch_ == t._IfNoneMatch_) && (s._IfUnmodifiedSince_ == t._IfUnmodifiedSince_) && (s._Key_ == t._Key_) && (s._Range_ == t._Range_) && (s._ResponseCacheControl_ == t._ResponseCacheControl_) && (s._ResponseContentDisposition_ == t._ResponseContentDisposition_) && (s._ResponseContentEncoding_ == t._ResponseContentEncoding_) && (s._ResponseContentLanguage_ == t._ResponseContentLanguage_) && (s._ResponseContentType_ == t._ResponseContentType_) && (s._ResponseExpires_ == t._ResponseExpires_) && (s._VersionId_ == t._VersionId_) && (s._SSECustomerAlgorithm_ == t._SSECustomerAlgorithm_) && (s._SSECustomerKey_ == t._SSECustomerKey_) && (s._SSECustomerKeyMD5_ == t._SSECustomerKeyMD5_) && (s._RequestPayer_ == t._RequestPayer_) && (s._PartNumber_ == t._PartNumber_) && (s._ExpectedBucketOwner_ == t._ExpectedBucketOwner_));
}
inline bool operator ==(const s3_test::_Initiator &s, const s3_test::_Initiator &t){
    return ((s._ID_ == t._ID_) && (s._DisplayName_ == t._DisplayName_));
}
inline bool operator ==(const s3_test::_S3KeyFilter &s, const s3_test::_S3KeyFilter &t){
    return ((s._FilterRules_ == t._FilterRules_));
}
inline bool operator ==(const s3_test::_NotificationConfigurationFilter &s, const s3_test::_NotificationConfigurationFilter &t){
    return ((s._Key_ == t._Key_));
}
inline bool operator ==(const s3_test::_LambdaFunctionConfiguration &s, const s3_test::_LambdaFunctionConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._LambdaFunctionArn_ == t._LambdaFunctionArn_) && (s._Events_ == t._Events_) && (s._Filter_ == t._Filter_));
}
inline bool operator ==(const s3_test::_MultipartUpload &s, const s3_test::_MultipartUpload &t){
    return ((s._UploadId_ == t._UploadId_) && (s._Key_ == t._Key_) && (s._Initiated_ == t._Initiated_) && (s._StorageClass_ == t._StorageClass_) && (s._Owner_ == t._Owner_) && (s._Initiator_ == t._Initiator_));
}
inline bool operator ==(const s3_test::_ObjectVersion &s, const s3_test::_ObjectVersion &t){
    return ((s._ETag_ == t._ETag_) && (s._Size_ == t._Size_) && (s._StorageClass_ == t._StorageClass_) && (s._Key_ == t._Key_) && (s._VersionId_ == t._VersionId_) && (s._IsLatest_ == t._IsLatest_) && (s._LastModified_ == t._LastModified_) && (s._Owner_ == t._Owner_));
}
inline bool operator ==(const s3_test::_Object &s, const s3_test::_Object &t){
    return ((s._Key_ == t._Key_) && (s._LastModified_ == t._LastModified_) && (s._ETag_ == t._ETag_) && (s._Size_ == t._Size_) && (s._StorageClass_ == t._StorageClass_) && (s._Owner_ == t._Owner_));
}
inline bool operator ==(const s3_test::_Part &s, const s3_test::_Part &t){
    return ((s._PartNumber_ == t._PartNumber_) && (s._LastModified_ == t._LastModified_) && (s._ETag_ == t._ETag_) && (s._Size_ == t._Size_));
}
inline bool operator ==(const s3_test::_MetadataEntry &s, const s3_test::_MetadataEntry &t){
    return ((s._Name_ == t._Name_) && (s._Value_ == t._Value_));
}
inline bool operator ==(const s3_test::_TopicConfiguration &s, const s3_test::_TopicConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._TopicArn_ == t._TopicArn_) && (s._Events_ == t._Events_) && (s._Filter_ == t._Filter_));
}
inline bool operator ==(const s3_test::_QueueConfiguration &s, const s3_test::_QueueConfiguration &t){
    return ((s._Id_ == t._Id_) && (s._QueueArn_ == t._QueueArn_) && (s._Events_ == t._Events_) && (s._Filter_ == t._Filter_));
}
