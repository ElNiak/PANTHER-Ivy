#lang ivy1.7

# File generated from service-2.json. Do not edit.

type txid_t
type unit
type string
type integer
type list
type timestamp
type long
include collections
include mymap
type blob
interpret blob -> strbv[3]
attribute libspec="aws-cpp-sdk-s3,aws-cpp-sdk-core,aws-crt-cpp,aws-c-common"

object _AbortIncompleteMultipartUpload = {
    type this = struct {
        _DaysAfterInitiation_ : integer 
    }
}

object _AbortMultipartUploadOutput = {
    type this = struct {
        _RequestCharged_ : string 
    }
}

object _AbortMultipartUploadRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _UploadId_ : string, 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _AccelerateConfiguration = {
    type this = struct {
        _Status_ : string 
    }
}

object _Grantee = {
    type this = struct {
        _DisplayName_ : option[string], 
        _EmailAddress_ : option[string], 
        _ID_ : option[string], 
        _Type_ : string, 
        _URI_ : option[string] 
    }
}

object _Grant = {
    type this = struct {
        _Grantee_ : _Grantee, 
        _Permission_ : string 
    }
}

object _Owner = {
    type this = struct {
        _DisplayName_ : string, 
        _ID_ : string 
    }
}

object _AccessControlPolicy = {
    type this = struct {
        _Grants_ : vector[_Grant], 
        _Owner_ : _Owner 
    }
}

object _AccessControlTranslation = {
    type this = struct {
        _Owner_ : string 
    }
}

object _Tag = {
    type this = struct {
        _Key_ : string, 
        _Value_ : string 
    }
}

object _AnalyticsAndOperator = {
    type this = struct {
        _Prefix_ : string, 
        _Tags_ : vector[_Tag] 
    }
}

object _AnalyticsFilter = {
    type this = struct {
        _Prefix_ : string, 
        _Tag_ : _Tag, 
        _And_ : _AnalyticsAndOperator 
    }
}

object _AnalyticsS3BucketDestination = {
    type this = struct {
        _Format_ : string, 
        _BucketAccountId_ : option[string], 
        _Bucket_ : string, 
        _Prefix_ : option[string] 
    }
}

object _AnalyticsExportDestination = {
    type this = struct {
        _S3BucketDestination_ : _AnalyticsS3BucketDestination 
    }
}

object _StorageClassAnalysisDataExport = {
    type this = struct {
        _OutputSchemaVersion_ : string, 
        _Destination_ : _AnalyticsExportDestination 
    }
}

object _StorageClassAnalysis = {
    type this = struct {
        _DataExport_ : _StorageClassAnalysisDataExport 
    }
}

object _AnalyticsConfiguration = {
    type this = struct {
        _Id_ : string, 
        _Filter_ : option[_AnalyticsFilter], 
        _StorageClassAnalysis_ : _StorageClassAnalysis 
    }
}

object _Bucket = {
    type this = struct {
        _Name_ : string, 
        _CreationDate_ : timestamp 
    }
}

object _BucketAlreadyExists = {
    type this = struct {
    }
}

object _BucketAlreadyOwnedByYou = {
    type this = struct {
    }
}

object _LifecycleExpiration = {
    type this = struct {
        _Date_ : timestamp, 
        _Days_ : integer, 
        _ExpiredObjectDeleteMarker_ : bool 
    }
}

object _LifecycleRuleAndOperator = {
    type this = struct {
        _Prefix_ : string, 
        _Tags_ : vector[_Tag] 
    }
}

object _LifecycleRuleFilter = {
    type this = struct {
        _Prefix_ : string, 
        _Tag_ : _Tag, 
        _And_ : _LifecycleRuleAndOperator 
    }
}

object _Transition = {
    type this = struct {
        _Date_ : timestamp, 
        _Days_ : integer, 
        _StorageClass_ : string 
    }
}

object _NoncurrentVersionTransition = {
    type this = struct {
        _NoncurrentDays_ : integer, 
        _StorageClass_ : string 
    }
}

object _NoncurrentVersionExpiration = {
    type this = struct {
        _NoncurrentDays_ : integer 
    }
}

object _LifecycleRule = {
    type this = struct {
        _Expiration_ : option[_LifecycleExpiration], 
        _ID_ : option[string], 
        _Prefix_ : option[string], 
        _Filter_ : option[_LifecycleRuleFilter], 
        _Status_ : string, 
        _Transitions_ : option[vector[_Transition]], 
        _NoncurrentVersionTransitions_ : option[vector[_NoncurrentVersionTransition]], 
        _NoncurrentVersionExpiration_ : option[_NoncurrentVersionExpiration], 
        _AbortIncompleteMultipartUpload_ : option[_AbortIncompleteMultipartUpload] 
    }
}

object _BucketLifecycleConfiguration = {
    type this = struct {
        _Rules_ : vector[_LifecycleRule] 
    }
}

object _TargetGrant = {
    type this = struct {
        _Grantee_ : _Grantee, 
        _Permission_ : string 
    }
}

object _LoggingEnabled = {
    type this = struct {
        _TargetBucket_ : string, 
        _TargetGrants_ : option[vector[_TargetGrant]], 
        _TargetPrefix_ : string 
    }
}

object _BucketLoggingStatus = {
    type this = struct {
        _LoggingEnabled_ : _LoggingEnabled 
    }
}

object _CORSRule = {
    type this = struct {
        _ID_ : option[string], 
        _AllowedHeaders_ : option[vector[string]], 
        _AllowedMethods_ : vector[string], 
        _AllowedOrigins_ : vector[string], 
        _ExposeHeaders_ : option[vector[string]], 
        _MaxAgeSeconds_ : option[integer] 
    }
}

object _CORSConfiguration = {
    type this = struct {
        _CORSRules_ : vector[_CORSRule] 
    }
}

object _CSVInput = {
    type this = struct {
        _FileHeaderInfo_ : string, 
        _Comments_ : string, 
        _QuoteEscapeCharacter_ : string, 
        _RecordDelimiter_ : string, 
        _FieldDelimiter_ : string, 
        _QuoteCharacter_ : string, 
        _AllowQuotedRecordDelimiter_ : bool 
    }
}

object _CSVOutput = {
    type this = struct {
        _QuoteFields_ : string, 
        _QuoteEscapeCharacter_ : string, 
        _RecordDelimiter_ : string, 
        _FieldDelimiter_ : string, 
        _QuoteCharacter_ : string 
    }
}

object _CloudFunctionConfiguration = {
    type this = struct {
        _Id_ : string, 
        _Event_ : string, 
        _Events_ : vector[string], 
        _CloudFunction_ : string, 
        _InvocationRole_ : string 
    }
}

object _CommonPrefix = {
    type this = struct {
        _Prefix_ : string 
    }
}

object _CompleteMultipartUploadOutput = {
    type this = struct {
        _Location_ : string, 
        _Bucket_ : string, 
        _Key_ : string, 
        _Expiration_ : string, 
        _ETag_ : string, 
        _ServerSideEncryption_ : string, 
        _VersionId_ : string, 
        _SSEKMSKeyId_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _CompletedPart = {
    type this = struct {
        _ETag_ : string, 
        _PartNumber_ : integer 
    }
}

object _CompletedMultipartUpload = {
    type this = struct {
        _Parts_ : vector[_CompletedPart] 
    }
}

object _CompleteMultipartUploadRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _MultipartUpload_ : option[_CompletedMultipartUpload], 
        _UploadId_ : string, 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _Condition = {
    type this = struct {
        _HttpErrorCodeReturnedEquals_ : string, 
        _KeyPrefixEquals_ : string 
    }
}

object _ContinuationEvent = {
    type this = struct {
    }
}

object _CopyObjectResult = {
    type this = struct {
        _ETag_ : string, 
        _LastModified_ : timestamp 
    }
}

object _CopyObjectOutput = {
    type this = struct {
        _CopyObjectResult_ : _CopyObjectResult, 
        _Expiration_ : string, 
        _CopySourceVersionId_ : string, 
        _VersionId_ : string, 
        _ServerSideEncryption_ : string, 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _SSEKMSEncryptionContext_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _CopyObjectRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _Bucket_ : string, 
        _CacheControl_ : option[string], 
        _ContentDisposition_ : option[string], 
        _ContentEncoding_ : option[string], 
        _ContentLanguage_ : option[string], 
        _ContentType_ : option[string], 
        _CopySource_ : string, 
        _CopySourceIfMatch_ : option[string], 
        _CopySourceIfModifiedSince_ : option[timestamp], 
        _CopySourceIfNoneMatch_ : option[string], 
        _CopySourceIfUnmodifiedSince_ : option[timestamp], 
        _Expires_ : option[timestamp], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _Key_ : string, 
        _Metadata_ : option[unordered_map[string][string]], 
        _MetadataDirective_ : option[string], 
        _TaggingDirective_ : option[string], 
        _ServerSideEncryption_ : option[string], 
        _StorageClass_ : option[string], 
        _WebsiteRedirectLocation_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _SSEKMSKeyId_ : option[string], 
        _SSEKMSEncryptionContext_ : option[string], 
        _BucketKeyEnabled_ : option[bool], 
        _CopySourceSSECustomerAlgorithm_ : option[string], 
        _CopySourceSSECustomerKey_ : option[string], 
        _CopySourceSSECustomerKeyMD5_ : option[string], 
        _RequestPayer_ : option[string], 
        _Tagging_ : option[string], 
        _ObjectLockMode_ : option[string], 
        _ObjectLockRetainUntilDate_ : option[timestamp], 
        _ObjectLockLegalHoldStatus_ : option[string], 
        _ExpectedBucketOwner_ : option[string], 
        _ExpectedSourceBucketOwner_ : option[string] 
    }
}

object _CopyPartResult = {
    type this = struct {
        _ETag_ : string, 
        _LastModified_ : timestamp 
    }
}

object _CreateBucketConfiguration = {
    type this = struct {
        _LocationConstraint_ : string 
    }
}

object _CreateBucketOutput = {
    type this = struct {
        _Location_ : string 
    }
}

object _CreateBucketRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _Bucket_ : string, 
        _CreateBucketConfiguration_ : option[_CreateBucketConfiguration], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWrite_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _ObjectLockEnabledForBucket_ : option[bool] 
    }
}

object _CreateMultipartUploadOutput = {
    type this = struct {
        _AbortDate_ : timestamp, 
        _AbortRuleId_ : string, 
        _Bucket_ : string, 
        _Key_ : string, 
        _UploadId_ : string, 
        _ServerSideEncryption_ : string, 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _SSEKMSEncryptionContext_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _CreateMultipartUploadRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _Bucket_ : string, 
        _CacheControl_ : option[string], 
        _ContentDisposition_ : option[string], 
        _ContentEncoding_ : option[string], 
        _ContentLanguage_ : option[string], 
        _ContentType_ : option[string], 
        _Expires_ : option[timestamp], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _Key_ : string, 
        _Metadata_ : option[unordered_map[string][string]], 
        _ServerSideEncryption_ : option[string], 
        _StorageClass_ : option[string], 
        _WebsiteRedirectLocation_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _SSEKMSKeyId_ : option[string], 
        _SSEKMSEncryptionContext_ : option[string], 
        _BucketKeyEnabled_ : option[bool], 
        _RequestPayer_ : option[string], 
        _Tagging_ : option[string], 
        _ObjectLockMode_ : option[string], 
        _ObjectLockRetainUntilDate_ : option[timestamp], 
        _ObjectLockLegalHoldStatus_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DefaultRetention = {
    type this = struct {
        _Mode_ : string, 
        _Days_ : integer, 
        _Years_ : integer 
    }
}

object _ObjectIdentifier = {
    type this = struct {
        _Key_ : string, 
        _VersionId_ : option[string] 
    }
}

object _Delete = {
    type this = struct {
        _Objects_ : vector[_ObjectIdentifier], 
        _Quiet_ : option[bool] 
    }
}

object _DeleteBucketAnalyticsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketCorsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketEncryptionRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketIntelligentTieringConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string 
    }
}

object _DeleteBucketInventoryConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketLifecycleRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketMetricsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketOwnershipControlsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketPolicyRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketReplicationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteBucketWebsiteRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteMarkerEntry = {
    type this = struct {
        _Owner_ : _Owner, 
        _Key_ : string, 
        _VersionId_ : string, 
        _IsLatest_ : bool, 
        _LastModified_ : timestamp 
    }
}

object _DeleteMarkerReplication = {
    type this = struct {
        _Status_ : string 
    }
}

object _DeleteObjectOutput = {
    type this = struct {
        _DeleteMarker_ : bool, 
        _VersionId_ : string, 
        _RequestCharged_ : string 
    }
}

object _DeleteObjectRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _MFA_ : option[string], 
        _VersionId_ : option[string], 
        _RequestPayer_ : option[string], 
        _BypassGovernanceRetention_ : option[bool], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeleteObjectTaggingOutput = {
    type this = struct {
        _VersionId_ : string 
    }
}

object _DeleteObjectTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeletedObject = {
    type this = struct {
        _Key_ : string, 
        _VersionId_ : string, 
        _DeleteMarker_ : bool, 
        _DeleteMarkerVersionId_ : string 
    }
}

object _Error = {
    type this = struct {
        _Key_ : string, 
        _VersionId_ : string, 
        _Code_ : string, 
        _Message_ : string 
    }
}

object _DeleteObjectsOutput = {
    type this = struct {
        _Deleted_ : vector[_DeletedObject], 
        _RequestCharged_ : string, 
        _Errors_ : vector[_Error] 
    }
}

object _DeleteObjectsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Delete_ : _Delete, 
        _MFA_ : option[string], 
        _RequestPayer_ : option[string], 
        _BypassGovernanceRetention_ : option[bool], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _DeletePublicAccessBlockRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _EncryptionConfiguration = {
    type this = struct {
        _ReplicaKmsKeyID_ : string 
    }
}

object _ReplicationTimeValue = {
    type this = struct {
        _Minutes_ : integer 
    }
}

object _ReplicationTime = {
    type this = struct {
        _Status_ : string, 
        _Time_ : _ReplicationTimeValue 
    }
}

object _Metrics = {
    type this = struct {
        _Status_ : string, 
        _EventThreshold_ : option[_ReplicationTimeValue] 
    }
}

object _Destination = {
    type this = struct {
        _Bucket_ : string, 
        _Account_ : option[string], 
        _StorageClass_ : option[string], 
        _AccessControlTranslation_ : option[_AccessControlTranslation], 
        _EncryptionConfiguration_ : option[_EncryptionConfiguration], 
        _ReplicationTime_ : option[_ReplicationTime], 
        _Metrics_ : option[_Metrics] 
    }
}

object _Encryption = {
    type this = struct {
        _EncryptionType_ : string, 
        _KMSKeyId_ : option[string], 
        _KMSContext_ : option[string] 
    }
}

object _EndEvent = {
    type this = struct {
    }
}

object _ErrorDocument = {
    type this = struct {
        _Key_ : string 
    }
}

object _ExistingObjectReplication = {
    type this = struct {
        _Status_ : string 
    }
}

object _FilterRule = {
    type this = struct {
        _Name_ : string, 
        _Value_ : string 
    }
}

object _GetBucketAccelerateConfigurationOutput = {
    type this = struct {
        _Status_ : string 
    }
}

object _GetBucketAccelerateConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketAclOutput = {
    type this = struct {
        _Owner_ : _Owner, 
        _Grants_ : vector[_Grant] 
    }
}

object _GetBucketAclRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketAnalyticsConfigurationOutput = {
    type this = struct {
        _AnalyticsConfiguration_ : _AnalyticsConfiguration 
    }
}

object _GetBucketAnalyticsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketCorsOutput = {
    type this = struct {
        _CORSRules_ : vector[_CORSRule] 
    }
}

object _GetBucketCorsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ServerSideEncryptionByDefault = {
    type this = struct {
        _SSEAlgorithm_ : string, 
        _KMSMasterKeyID_ : option[string] 
    }
}

object _ServerSideEncryptionRule = {
    type this = struct {
        _ApplyServerSideEncryptionByDefault_ : _ServerSideEncryptionByDefault, 
        _BucketKeyEnabled_ : bool 
    }
}

object _ServerSideEncryptionConfiguration = {
    type this = struct {
        _Rules_ : vector[_ServerSideEncryptionRule] 
    }
}

object _GetBucketEncryptionOutput = {
    type this = struct {
        _ServerSideEncryptionConfiguration_ : _ServerSideEncryptionConfiguration 
    }
}

object _GetBucketEncryptionRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _IntelligentTieringAndOperator = {
    type this = struct {
        _Prefix_ : string, 
        _Tags_ : vector[_Tag] 
    }
}

object _IntelligentTieringFilter = {
    type this = struct {
        _Prefix_ : string, 
        _Tag_ : _Tag, 
        _And_ : _IntelligentTieringAndOperator 
    }
}

object _Tiering = {
    type this = struct {
        _Days_ : integer, 
        _AccessTier_ : string 
    }
}

object _IntelligentTieringConfiguration = {
    type this = struct {
        _Id_ : string, 
        _Filter_ : option[_IntelligentTieringFilter], 
        _Status_ : string, 
        _Tierings_ : vector[_Tiering] 
    }
}

object _GetBucketIntelligentTieringConfigurationOutput = {
    type this = struct {
        _IntelligentTieringConfiguration_ : _IntelligentTieringConfiguration 
    }
}

object _GetBucketIntelligentTieringConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string 
    }
}

object _SSES3 = {
    type this = struct {
    }
}

object _SSEKMS = {
    type this = struct {
        _KeyId_ : string 
    }
}

object _InventoryEncryption = {
    type this = struct {
        _SSES3_ : _SSES3, 
        _SSEKMS_ : _SSEKMS 
    }
}

object _InventoryS3BucketDestination = {
    type this = struct {
        _AccountId_ : option[string], 
        _Bucket_ : string, 
        _Format_ : string, 
        _Prefix_ : option[string], 
        _Encryption_ : option[_InventoryEncryption] 
    }
}

object _InventoryDestination = {
    type this = struct {
        _S3BucketDestination_ : _InventoryS3BucketDestination 
    }
}

object _InventoryFilter = {
    type this = struct {
        _Prefix_ : string 
    }
}

object _InventorySchedule = {
    type this = struct {
        _Frequency_ : string 
    }
}

object _InventoryConfiguration = {
    type this = struct {
        _Destination_ : _InventoryDestination, 
        _IsEnabled_ : bool, 
        _Filter_ : option[_InventoryFilter], 
        _Id_ : string, 
        _IncludedObjectVersions_ : string, 
        _OptionalFields_ : option[vector[string]], 
        _Schedule_ : _InventorySchedule 
    }
}

object _GetBucketInventoryConfigurationOutput = {
    type this = struct {
        _InventoryConfiguration_ : _InventoryConfiguration 
    }
}

object _GetBucketInventoryConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketLifecycleConfigurationOutput = {
    type this = struct {
        _Rules_ : vector[_LifecycleRule] 
    }
}

object _GetBucketLifecycleConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _Rule = {
    type this = struct {
        _Expiration_ : option[_LifecycleExpiration], 
        _ID_ : option[string], 
        _Prefix_ : string, 
        _Status_ : string, 
        _Transition_ : option[_Transition], 
        _NoncurrentVersionTransition_ : option[_NoncurrentVersionTransition], 
        _NoncurrentVersionExpiration_ : option[_NoncurrentVersionExpiration], 
        _AbortIncompleteMultipartUpload_ : option[_AbortIncompleteMultipartUpload] 
    }
}

object _GetBucketLifecycleOutput = {
    type this = struct {
        _Rules_ : vector[_Rule] 
    }
}

object _GetBucketLifecycleRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketLocationOutput = {
    type this = struct {
        _LocationConstraint_ : string 
    }
}

object _GetBucketLocationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketLoggingOutput = {
    type this = struct {
        _LoggingEnabled_ : _LoggingEnabled 
    }
}

object _GetBucketLoggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _MetricsAndOperator = {
    type this = struct {
        _Prefix_ : string, 
        _Tags_ : vector[_Tag] 
    }
}

object _MetricsFilter = {
    type this = struct {
        _Prefix_ : string, 
        _Tag_ : _Tag, 
        _And_ : _MetricsAndOperator 
    }
}

object _MetricsConfiguration = {
    type this = struct {
        _Id_ : string, 
        _Filter_ : option[_MetricsFilter] 
    }
}

object _GetBucketMetricsConfigurationOutput = {
    type this = struct {
        _MetricsConfiguration_ : _MetricsConfiguration 
    }
}

object _GetBucketMetricsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketNotificationConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _OwnershipControlsRule = {
    type this = struct {
        _ObjectOwnership_ : string 
    }
}

object _OwnershipControls = {
    type this = struct {
        _Rules_ : vector[_OwnershipControlsRule] 
    }
}

object _GetBucketOwnershipControlsOutput = {
    type this = struct {
        _OwnershipControls_ : _OwnershipControls 
    }
}

object _GetBucketOwnershipControlsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketPolicyOutput = {
    type this = struct {
        _Policy_ : string 
    }
}

object _GetBucketPolicyRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PolicyStatus = {
    type this = struct {
        _IsPublic_ : bool 
    }
}

object _GetBucketPolicyStatusOutput = {
    type this = struct {
        _PolicyStatus_ : _PolicyStatus 
    }
}

object _GetBucketPolicyStatusRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ReplicationRuleAndOperator = {
    type this = struct {
        _Prefix_ : string, 
        _Tags_ : vector[_Tag] 
    }
}

object _ReplicationRuleFilter = {
    type this = struct {
        _Prefix_ : string, 
        _Tag_ : _Tag, 
        _And_ : _ReplicationRuleAndOperator 
    }
}

object _SseKmsEncryptedObjects = {
    type this = struct {
        _Status_ : string 
    }
}

object _ReplicaModifications = {
    type this = struct {
        _Status_ : string 
    }
}

object _SourceSelectionCriteria = {
    type this = struct {
        _SseKmsEncryptedObjects_ : _SseKmsEncryptedObjects, 
        _ReplicaModifications_ : _ReplicaModifications 
    }
}

object _ReplicationRule = {
    type this = struct {
        _ID_ : option[string], 
        _Priority_ : option[integer], 
        _Prefix_ : option[string], 
        _Filter_ : option[_ReplicationRuleFilter], 
        _Status_ : string, 
        _SourceSelectionCriteria_ : option[_SourceSelectionCriteria], 
        _ExistingObjectReplication_ : option[_ExistingObjectReplication], 
        _Destination_ : _Destination, 
        _DeleteMarkerReplication_ : option[_DeleteMarkerReplication] 
    }
}

object _ReplicationConfiguration = {
    type this = struct {
        _Role_ : string, 
        _Rules_ : vector[_ReplicationRule] 
    }
}

object _GetBucketReplicationOutput = {
    type this = struct {
        _ReplicationConfiguration_ : _ReplicationConfiguration 
    }
}

object _GetBucketReplicationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketRequestPaymentOutput = {
    type this = struct {
        _Payer_ : string 
    }
}

object _GetBucketRequestPaymentRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketTaggingOutput = {
    type this = struct {
        _TagSet_ : vector[_Tag] 
    }
}

object _GetBucketTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetBucketVersioningOutput = {
    type this = struct {
        _Status_ : string, 
        _MFADelete_ : string 
    }
}

object _GetBucketVersioningRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _RedirectAllRequestsTo = {
    type this = struct {
        _HostName_ : string, 
        _Protocol_ : option[string] 
    }
}

object _IndexDocument = {
    type this = struct {
        _Suffix_ : string 
    }
}

object _Redirect = {
    type this = struct {
        _HostName_ : string, 
        _HttpRedirectCode_ : string, 
        _Protocol_ : string, 
        _ReplaceKeyPrefixWith_ : string, 
        _ReplaceKeyWith_ : string 
    }
}

object _RoutingRule = {
    type this = struct {
        _Condition_ : option[_Condition], 
        _Redirect_ : _Redirect 
    }
}

object _GetBucketWebsiteOutput = {
    type this = struct {
        _RedirectAllRequestsTo_ : _RedirectAllRequestsTo, 
        _IndexDocument_ : _IndexDocument, 
        _ErrorDocument_ : _ErrorDocument, 
        _RoutingRules_ : vector[_RoutingRule] 
    }
}

object _GetBucketWebsiteRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetObjectAclOutput = {
    type this = struct {
        _Owner_ : _Owner, 
        _Grants_ : vector[_Grant], 
        _RequestCharged_ : string 
    }
}

object _GetObjectAclRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ObjectLockLegalHold = {
    type this = struct {
        _Status_ : string 
    }
}

object _GetObjectLegalHoldOutput = {
    type this = struct {
        _LegalHold_ : _ObjectLockLegalHold 
    }
}

object _GetObjectLegalHoldRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ObjectLockRule = {
    type this = struct {
        _DefaultRetention_ : _DefaultRetention 
    }
}

object _ObjectLockConfiguration = {
    type this = struct {
        _ObjectLockEnabled_ : string, 
        _Rule_ : _ObjectLockRule 
    }
}

object _GetObjectLockConfigurationOutput = {
    type this = struct {
        _ObjectLockConfiguration_ : _ObjectLockConfiguration 
    }
}

object _GetObjectLockConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetObjectOutput = {
    type this = struct {
        _Body_ : blob, 
        _DeleteMarker_ : bool, 
        _AcceptRanges_ : string, 
        _Expiration_ : string, 
        _Restore_ : string, 
        _LastModified_ : timestamp, 
        _ContentLength_ : long, 
        _ETag_ : string, 
        _MissingMeta_ : integer, 
        _VersionId_ : string, 
        _CacheControl_ : string, 
        _ContentDisposition_ : string, 
        _ContentEncoding_ : string, 
        _ContentLanguage_ : string, 
        _ContentRange_ : string, 
        _ContentType_ : string, 
        _Expires_ : timestamp, 
        _WebsiteRedirectLocation_ : string, 
        _ServerSideEncryption_ : string, 
        _Metadata_ : unordered_map[string][string], 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _BucketKeyEnabled_ : bool, 
        _StorageClass_ : string, 
        _RequestCharged_ : string, 
        _ReplicationStatus_ : string, 
        _PartsCount_ : integer, 
        _TagCount_ : integer, 
        _ObjectLockMode_ : string, 
        _ObjectLockRetainUntilDate_ : timestamp, 
        _ObjectLockLegalHoldStatus_ : string 
    }
}

object _GetObjectRequest = {
    type this = struct {
        _Bucket_ : string, 
        _IfMatch_ : option[string], 
        _IfModifiedSince_ : option[timestamp], 
        _IfNoneMatch_ : option[string], 
        _IfUnmodifiedSince_ : option[timestamp], 
        _Key_ : string, 
        _Range_ : option[string], 
        _ResponseCacheControl_ : option[string], 
        _ResponseContentDisposition_ : option[string], 
        _ResponseContentEncoding_ : option[string], 
        _ResponseContentLanguage_ : option[string], 
        _ResponseContentType_ : option[string], 
        _ResponseExpires_ : option[timestamp], 
        _VersionId_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _RequestPayer_ : option[string], 
        _PartNumber_ : option[integer], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ObjectLockRetention = {
    type this = struct {
        _Mode_ : string, 
        _RetainUntilDate_ : timestamp 
    }
}

object _GetObjectRetentionOutput = {
    type this = struct {
        _Retention_ : _ObjectLockRetention 
    }
}

object _GetObjectRetentionRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GetObjectTaggingOutput = {
    type this = struct {
        _VersionId_ : option[string], 
        _TagSet_ : vector[_Tag] 
    }
}

object _GetObjectTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _ExpectedBucketOwner_ : option[string], 
        _RequestPayer_ : option[string] 
    }
}

object _GetObjectTorrentOutput = {
    type this = struct {
        _Body_ : blob, 
        _RequestCharged_ : string 
    }
}

object _GetObjectTorrentRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PublicAccessBlockConfiguration = {
    type this = struct {
        _BlockPublicAcls_ : bool, 
        _IgnorePublicAcls_ : bool, 
        _BlockPublicPolicy_ : bool, 
        _RestrictPublicBuckets_ : bool 
    }
}

object _GetPublicAccessBlockOutput = {
    type this = struct {
        _PublicAccessBlockConfiguration_ : _PublicAccessBlockConfiguration 
    }
}

object _GetPublicAccessBlockRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _GlacierJobParameters = {
    type this = struct {
        _Tier_ : string 
    }
}

object _HeadBucketRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _HeadObjectOutput = {
    type this = struct {
        _DeleteMarker_ : bool, 
        _AcceptRanges_ : string, 
        _Expiration_ : string, 
        _Restore_ : string, 
        _ArchiveStatus_ : string, 
        _LastModified_ : timestamp, 
        _ContentLength_ : long, 
        _ETag_ : string, 
        _MissingMeta_ : integer, 
        _VersionId_ : string, 
        _CacheControl_ : string, 
        _ContentDisposition_ : string, 
        _ContentEncoding_ : string, 
        _ContentLanguage_ : string, 
        _ContentType_ : string, 
        _Expires_ : timestamp, 
        _WebsiteRedirectLocation_ : string, 
        _ServerSideEncryption_ : string, 
        _Metadata_ : unordered_map[string][string], 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _BucketKeyEnabled_ : bool, 
        _StorageClass_ : string, 
        _RequestCharged_ : string, 
        _ReplicationStatus_ : string, 
        _PartsCount_ : integer, 
        _ObjectLockMode_ : string, 
        _ObjectLockRetainUntilDate_ : timestamp, 
        _ObjectLockLegalHoldStatus_ : string 
    }
}

object _HeadObjectRequest = {
    type this = struct {
        _Bucket_ : string, 
        _IfMatch_ : option[string], 
        _IfModifiedSince_ : option[timestamp], 
        _IfNoneMatch_ : option[string], 
        _IfUnmodifiedSince_ : option[timestamp], 
        _Key_ : string, 
        _Range_ : option[string], 
        _VersionId_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _RequestPayer_ : option[string], 
        _PartNumber_ : option[integer], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _Initiator = {
    type this = struct {
        _ID_ : string, 
        _DisplayName_ : string 
    }
}

object _JSONInput = {
    type this = struct {
        _Type_ : string 
    }
}

object _ParquetInput = {
    type this = struct {
    }
}

object _InputSerialization = {
    type this = struct {
        _CSV_ : _CSVInput, 
        _CompressionType_ : string, 
        _JSON_ : _JSONInput, 
        _Parquet_ : _ParquetInput 
    }
}

object _InvalidObjectState = {
    type this = struct {
        _StorageClass_ : string, 
        _AccessTier_ : string 
    }
}

object _JSONOutput = {
    type this = struct {
        _RecordDelimiter_ : string 
    }
}

object _S3KeyFilter = {
    type this = struct {
        _FilterRules_ : vector[_FilterRule] 
    }
}

object _NotificationConfigurationFilter = {
    type this = struct {
        _Key_ : _S3KeyFilter 
    }
}

object _LambdaFunctionConfiguration = {
    type this = struct {
        _Id_ : option[string], 
        _LambdaFunctionArn_ : string, 
        _Events_ : vector[string], 
        _Filter_ : option[_NotificationConfigurationFilter] 
    }
}

object _LifecycleConfiguration = {
    type this = struct {
        _Rules_ : vector[_Rule] 
    }
}

object _ListBucketAnalyticsConfigurationsOutput = {
    type this = struct {
        _IsTruncated_ : bool, 
        _ContinuationToken_ : string, 
        _NextContinuationToken_ : string, 
        _AnalyticsConfigurationList_ : vector[_AnalyticsConfiguration] 
    }
}

object _ListBucketAnalyticsConfigurationsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContinuationToken_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ListBucketIntelligentTieringConfigurationsOutput = {
    type this = struct {
        _IsTruncated_ : bool, 
        _ContinuationToken_ : string, 
        _NextContinuationToken_ : string, 
        _IntelligentTieringConfigurationList_ : vector[_IntelligentTieringConfiguration] 
    }
}

object _ListBucketIntelligentTieringConfigurationsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContinuationToken_ : option[string] 
    }
}

object _ListBucketInventoryConfigurationsOutput = {
    type this = struct {
        _ContinuationToken_ : string, 
        _InventoryConfigurationList_ : vector[_InventoryConfiguration], 
        _IsTruncated_ : bool, 
        _NextContinuationToken_ : string 
    }
}

object _ListBucketInventoryConfigurationsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContinuationToken_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ListBucketMetricsConfigurationsOutput = {
    type this = struct {
        _IsTruncated_ : bool, 
        _ContinuationToken_ : string, 
        _NextContinuationToken_ : string, 
        _MetricsConfigurationList_ : vector[_MetricsConfiguration] 
    }
}

object _ListBucketMetricsConfigurationsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContinuationToken_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ListBucketsOutput = {
    type this = struct {
        _Buckets_ : vector[_Bucket], 
        _Owner_ : _Owner 
    }
}

object _MultipartUpload = {
    type this = struct {
        _UploadId_ : string, 
        _Key_ : string, 
        _Initiated_ : timestamp, 
        _StorageClass_ : string, 
        _Owner_ : _Owner, 
        _Initiator_ : _Initiator 
    }
}

object _ListMultipartUploadsOutput = {
    type this = struct {
        _Bucket_ : string, 
        _KeyMarker_ : string, 
        _UploadIdMarker_ : string, 
        _NextKeyMarker_ : string, 
        _Prefix_ : string, 
        _Delimiter_ : string, 
        _NextUploadIdMarker_ : string, 
        _MaxUploads_ : integer, 
        _IsTruncated_ : bool, 
        _Uploads_ : vector[_MultipartUpload], 
        _CommonPrefixes_ : vector[_CommonPrefix], 
        _EncodingType_ : string 
    }
}

object _ListMultipartUploadsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Delimiter_ : option[string], 
        _EncodingType_ : option[string], 
        _KeyMarker_ : option[string], 
        _MaxUploads_ : option[integer], 
        _Prefix_ : option[string], 
        _UploadIdMarker_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ObjectVersion = {
    type this = struct {
        _ETag_ : string, 
        _Size_ : integer, 
        _StorageClass_ : string, 
        _Key_ : string, 
        _VersionId_ : string, 
        _IsLatest_ : bool, 
        _LastModified_ : timestamp, 
        _Owner_ : _Owner 
    }
}

object _ListObjectVersionsOutput = {
    type this = struct {
        _IsTruncated_ : bool, 
        _KeyMarker_ : string, 
        _VersionIdMarker_ : string, 
        _NextKeyMarker_ : string, 
        _NextVersionIdMarker_ : string, 
        _Versions_ : vector[_ObjectVersion], 
        _DeleteMarkers_ : vector[_DeleteMarkerEntry], 
        _Name_ : string, 
        _Prefix_ : string, 
        _Delimiter_ : string, 
        _MaxKeys_ : integer, 
        _CommonPrefixes_ : vector[_CommonPrefix], 
        _EncodingType_ : string 
    }
}

object _ListObjectVersionsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Delimiter_ : option[string], 
        _EncodingType_ : option[string], 
        _KeyMarker_ : option[string], 
        _MaxKeys_ : option[integer], 
        _Prefix_ : option[string], 
        _VersionIdMarker_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _Object = {
    type this = struct {
        _Key_ : string, 
        _LastModified_ : timestamp, 
        _ETag_ : string, 
        _Size_ : integer, 
        _StorageClass_ : string, 
        _Owner_ : _Owner 
    }
}

object _ListObjectsOutput = {
    type this = struct {
        _IsTruncated_ : bool, 
        _Marker_ : string, 
        _NextMarker_ : string, 
        _Contents_ : vector[_Object], 
        _Name_ : string, 
        _Prefix_ : string, 
        _Delimiter_ : string, 
        _MaxKeys_ : integer, 
        _CommonPrefixes_ : vector[_CommonPrefix], 
        _EncodingType_ : string 
    }
}

object _ListObjectsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Delimiter_ : option[string], 
        _EncodingType_ : option[string], 
        _Marker_ : option[string], 
        _MaxKeys_ : option[integer], 
        _Prefix_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ListObjectsV2Output = {
    type this = struct {
        _IsTruncated_ : bool, 
        _Contents_ : vector[_Object], 
        _Name_ : string, 
        _Prefix_ : string, 
        _Delimiter_ : string, 
        _MaxKeys_ : integer, 
        _CommonPrefixes_ : vector[_CommonPrefix], 
        _EncodingType_ : string, 
        _KeyCount_ : integer, 
        _ContinuationToken_ : string, 
        _NextContinuationToken_ : string, 
        _StartAfter_ : string 
    }
}

object _ListObjectsV2Request = {
    type this = struct {
        _Bucket_ : string, 
        _Delimiter_ : option[string], 
        _EncodingType_ : option[string], 
        _MaxKeys_ : option[integer], 
        _Prefix_ : option[string], 
        _ContinuationToken_ : option[string], 
        _FetchOwner_ : option[bool], 
        _StartAfter_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _Part = {
    type this = struct {
        _PartNumber_ : integer, 
        _LastModified_ : timestamp, 
        _ETag_ : string, 
        _Size_ : integer 
    }
}

object _ListPartsOutput = {
    type this = struct {
        _AbortDate_ : timestamp, 
        _AbortRuleId_ : string, 
        _Bucket_ : string, 
        _Key_ : string, 
        _UploadId_ : string, 
        _PartNumberMarker_ : integer, 
        _NextPartNumberMarker_ : integer, 
        _MaxParts_ : integer, 
        _IsTruncated_ : bool, 
        _Parts_ : vector[_Part], 
        _Initiator_ : _Initiator, 
        _Owner_ : _Owner, 
        _StorageClass_ : string, 
        _RequestCharged_ : string 
    }
}

object _ListPartsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _MaxParts_ : option[integer], 
        _PartNumberMarker_ : option[integer], 
        _UploadId_ : string, 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _MetadataEntry = {
    type this = struct {
        _Name_ : string, 
        _Value_ : string 
    }
}

object _NoSuchBucket = {
    type this = struct {
    }
}

object _NoSuchKey = {
    type this = struct {
    }
}

object _NoSuchUpload = {
    type this = struct {
    }
}

object _TopicConfiguration = {
    type this = struct {
        _Id_ : option[string], 
        _TopicArn_ : string, 
        _Events_ : vector[string], 
        _Filter_ : option[_NotificationConfigurationFilter] 
    }
}

object _QueueConfiguration = {
    type this = struct {
        _Id_ : option[string], 
        _QueueArn_ : string, 
        _Events_ : vector[string], 
        _Filter_ : option[_NotificationConfigurationFilter] 
    }
}

object _NotificationConfiguration = {
    type this = struct {
        _TopicConfigurations_ : vector[_TopicConfiguration], 
        _QueueConfigurations_ : vector[_QueueConfiguration], 
        _LambdaFunctionConfigurations_ : vector[_LambdaFunctionConfiguration] 
    }
}

object _TopicConfigurationDeprecated = {
    type this = struct {
        _Id_ : string, 
        _Events_ : vector[string], 
        _Event_ : string, 
        _Topic_ : string 
    }
}

object _QueueConfigurationDeprecated = {
    type this = struct {
        _Id_ : string, 
        _Event_ : string, 
        _Events_ : vector[string], 
        _Queue_ : string 
    }
}

object _NotificationConfigurationDeprecated = {
    type this = struct {
        _TopicConfiguration_ : _TopicConfigurationDeprecated, 
        _QueueConfiguration_ : _QueueConfigurationDeprecated, 
        _CloudFunctionConfiguration_ : _CloudFunctionConfiguration 
    }
}

object _ObjectAlreadyInActiveTierError = {
    type this = struct {
    }
}

object _ObjectNotInActiveTierError = {
    type this = struct {
    }
}

object _Tagging = {
    type this = struct {
        _TagSet_ : vector[_Tag] 
    }
}

object _S3Location = {
    type this = struct {
        _BucketName_ : string, 
        _Prefix_ : string, 
        _Encryption_ : option[_Encryption], 
        _CannedACL_ : option[string], 
        _AccessControlList_ : option[vector[_Grant]], 
        _Tagging_ : option[_Tagging], 
        _UserMetadata_ : option[vector[_MetadataEntry]], 
        _StorageClass_ : option[string] 
    }
}

object _OutputLocation = {
    type this = struct {
        _S3_ : _S3Location 
    }
}

object _OutputSerialization = {
    type this = struct {
        _CSV_ : _CSVOutput, 
        _JSON_ : _JSONOutput 
    }
}

object _Progress = {
    type this = struct {
        _BytesScanned_ : long, 
        _BytesProcessed_ : long, 
        _BytesReturned_ : long 
    }
}

object _ProgressEvent = {
    type this = struct {
        _Details_ : _Progress 
    }
}

object _PutBucketAccelerateConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _AccelerateConfiguration_ : _AccelerateConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketAclRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _AccessControlPolicy_ : option[_AccessControlPolicy], 
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWrite_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketAnalyticsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _AnalyticsConfiguration_ : _AnalyticsConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketCorsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _CORSConfiguration_ : _CORSConfiguration, 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketEncryptionRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _ServerSideEncryptionConfiguration_ : _ServerSideEncryptionConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketIntelligentTieringConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _IntelligentTieringConfiguration_ : _IntelligentTieringConfiguration 
    }
}

object _PutBucketInventoryConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _InventoryConfiguration_ : _InventoryConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketLifecycleConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _LifecycleConfiguration_ : option[_BucketLifecycleConfiguration], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketLifecycleRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _LifecycleConfiguration_ : option[_LifecycleConfiguration], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketLoggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _BucketLoggingStatus_ : _BucketLoggingStatus, 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketMetricsConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Id_ : string, 
        _MetricsConfiguration_ : _MetricsConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketNotificationConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _NotificationConfiguration_ : _NotificationConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketNotificationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _NotificationConfiguration_ : _NotificationConfigurationDeprecated, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketOwnershipControlsRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string], 
        _OwnershipControls_ : _OwnershipControls 
    }
}

object _PutBucketPolicyRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _ConfirmRemoveSelfBucketAccess_ : option[bool], 
        _Policy_ : string, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketReplicationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _ReplicationConfiguration_ : _ReplicationConfiguration, 
        _Token_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _RequestPaymentConfiguration = {
    type this = struct {
        _Payer_ : string 
    }
}

object _PutBucketRequestPaymentRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _RequestPaymentConfiguration_ : _RequestPaymentConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutBucketTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _Tagging_ : _Tagging, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _VersioningConfiguration = {
    type this = struct {
        _MFADelete_ : string, 
        _Status_ : string 
    }
}

object _PutBucketVersioningRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _MFA_ : option[string], 
        _VersioningConfiguration_ : _VersioningConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _WebsiteConfiguration = {
    type this = struct {
        _ErrorDocument_ : _ErrorDocument, 
        _IndexDocument_ : _IndexDocument, 
        _RedirectAllRequestsTo_ : _RedirectAllRequestsTo, 
        _RoutingRules_ : vector[_RoutingRule] 
    }
}

object _PutBucketWebsiteRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _WebsiteConfiguration_ : _WebsiteConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectAclOutput = {
    type this = struct {
        _RequestCharged_ : string 
    }
}

object _PutObjectAclRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _AccessControlPolicy_ : option[_AccessControlPolicy], 
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWrite_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _Key_ : string, 
        _RequestPayer_ : option[string], 
        _VersionId_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectLegalHoldOutput = {
    type this = struct {
        _RequestCharged_ : string 
    }
}

object _PutObjectLegalHoldRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _LegalHold_ : option[_ObjectLockLegalHold], 
        _RequestPayer_ : option[string], 
        _VersionId_ : option[string], 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectLockConfigurationOutput = {
    type this = struct {
        _RequestCharged_ : string 
    }
}

object _PutObjectLockConfigurationRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ObjectLockConfiguration_ : option[_ObjectLockConfiguration], 
        _RequestPayer_ : option[string], 
        _Token_ : option[string], 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectOutput = {
    type this = struct {
        _Expiration_ : string, 
        _ETag_ : string, 
        _ServerSideEncryption_ : string, 
        _VersionId_ : string, 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _SSEKMSEncryptionContext_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _PutObjectRequest = {
    type this = struct {
        _ACL_ : option[string], 
        _Body_ : option[blob], 
        _Bucket_ : string, 
        _CacheControl_ : option[string], 
        _ContentDisposition_ : option[string], 
        _ContentEncoding_ : option[string], 
        _ContentLanguage_ : option[string], 
        _ContentLength_ : option[long], 
        _ContentMD5_ : option[string], 
        _ContentType_ : option[string], 
        _Expires_ : option[timestamp], 
        _GrantFullControl_ : option[string], 
        _GrantRead_ : option[string], 
        _GrantReadACP_ : option[string], 
        _GrantWriteACP_ : option[string], 
        _Key_ : string, 
        _Metadata_ : option[unordered_map[string][string]], 
        _ServerSideEncryption_ : option[string], 
        _StorageClass_ : option[string], 
        _WebsiteRedirectLocation_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _SSEKMSKeyId_ : option[string], 
        _SSEKMSEncryptionContext_ : option[string], 
        _BucketKeyEnabled_ : option[bool], 
        _RequestPayer_ : option[string], 
        _Tagging_ : option[string], 
        _ObjectLockMode_ : option[string], 
        _ObjectLockRetainUntilDate_ : option[timestamp], 
        _ObjectLockLegalHoldStatus_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectRetentionOutput = {
    type this = struct {
        _RequestCharged_ : string 
    }
}

object _PutObjectRetentionRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _Retention_ : option[_ObjectLockRetention], 
        _RequestPayer_ : option[string], 
        _VersionId_ : option[string], 
        _BypassGovernanceRetention_ : option[bool], 
        _ContentMD5_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _PutObjectTaggingOutput = {
    type this = struct {
        _VersionId_ : string 
    }
}

object _PutObjectTaggingRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _ContentMD5_ : option[string], 
        _Tagging_ : _Tagging, 
        _ExpectedBucketOwner_ : option[string], 
        _RequestPayer_ : option[string] 
    }
}

object _PutPublicAccessBlockRequest = {
    type this = struct {
        _Bucket_ : string, 
        _ContentMD5_ : option[string], 
        _PublicAccessBlockConfiguration_ : _PublicAccessBlockConfiguration, 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _RecordsEvent = {
    type this = struct {
        _Payload_ : blob 
    }
}

object _RequestProgress = {
    type this = struct {
        _Enabled_ : bool 
    }
}

object _RestoreObjectOutput = {
    type this = struct {
        _RequestCharged_ : string, 
        _RestoreOutputPath_ : string 
    }
}

object _SelectParameters = {
    type this = struct {
        _InputSerialization_ : _InputSerialization, 
        _ExpressionType_ : string, 
        _Expression_ : string, 
        _OutputSerialization_ : _OutputSerialization 
    }
}

object _RestoreRequest = {
    type this = struct {
        _Days_ : integer, 
        _GlacierJobParameters_ : _GlacierJobParameters, 
        _Type_ : string, 
        _Tier_ : string, 
        _Description_ : string, 
        _SelectParameters_ : _SelectParameters, 
        _OutputLocation_ : _OutputLocation 
    }
}

object _RestoreObjectRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _VersionId_ : option[string], 
        _RestoreRequest_ : option[_RestoreRequest], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _ScanRange = {
    type this = struct {
        _Start_ : long, 
        _End_ : long 
    }
}

object _Stats = {
    type this = struct {
        _BytesScanned_ : long, 
        _BytesProcessed_ : long, 
        _BytesReturned_ : long 
    }
}

object _StatsEvent = {
    type this = struct {
        _Details_ : _Stats 
    }
}

object _SelectObjectContentEventStream = {
    type this = struct {
        _Records_ : _RecordsEvent, 
        _Stats_ : _StatsEvent, 
        _Progress_ : _ProgressEvent, 
        _Cont_ : _ContinuationEvent, 
        _End_ : _EndEvent 
    }
}

object _SelectObjectContentOutput = {
    type this = struct {
        _Payload_ : _SelectObjectContentEventStream 
    }
}

object _SelectObjectContentRequest = {
    type this = struct {
        _Bucket_ : string, 
        _Key_ : string, 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _Expression_ : string, 
        _ExpressionType_ : string, 
        _RequestProgress_ : option[_RequestProgress], 
        _InputSerialization_ : _InputSerialization, 
        _OutputSerialization_ : _OutputSerialization, 
        _ScanRange_ : option[_ScanRange], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _UploadPartCopyOutput = {
    type this = struct {
        _CopySourceVersionId_ : string, 
        _CopyPartResult_ : _CopyPartResult, 
        _ServerSideEncryption_ : string, 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _UploadPartCopyRequest = {
    type this = struct {
        _Bucket_ : string, 
        _CopySource_ : string, 
        _CopySourceIfMatch_ : option[string], 
        _CopySourceIfModifiedSince_ : option[timestamp], 
        _CopySourceIfNoneMatch_ : option[string], 
        _CopySourceIfUnmodifiedSince_ : option[timestamp], 
        _CopySourceRange_ : option[string], 
        _Key_ : string, 
        _PartNumber_ : integer, 
        _UploadId_ : string, 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _CopySourceSSECustomerAlgorithm_ : option[string], 
        _CopySourceSSECustomerKey_ : option[string], 
        _CopySourceSSECustomerKeyMD5_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string], 
        _ExpectedSourceBucketOwner_ : option[string] 
    }
}

object _UploadPartOutput = {
    type this = struct {
        _ServerSideEncryption_ : string, 
        _ETag_ : string, 
        _SSECustomerAlgorithm_ : string, 
        _SSECustomerKeyMD5_ : string, 
        _SSEKMSKeyId_ : string, 
        _BucketKeyEnabled_ : bool, 
        _RequestCharged_ : string 
    }
}

object _UploadPartRequest = {
    type this = struct {
        _Body_ : option[blob], 
        _Bucket_ : string, 
        _ContentLength_ : option[long], 
        _ContentMD5_ : option[string], 
        _Key_ : string, 
        _PartNumber_ : integer, 
        _UploadId_ : string, 
        _SSECustomerAlgorithm_ : option[string], 
        _SSECustomerKey_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _RequestPayer_ : option[string], 
        _ExpectedBucketOwner_ : option[string] 
    }
}

object _WriteGetObjectResponseRequest = {
    type this = struct {
        _RequestRoute_ : string, 
        _RequestToken_ : string, 
        _Body_ : option[blob], 
        _StatusCode_ : option[integer], 
        _ErrorCode_ : option[string], 
        _ErrorMessage_ : option[string], 
        _AcceptRanges_ : option[string], 
        _CacheControl_ : option[string], 
        _ContentDisposition_ : option[string], 
        _ContentEncoding_ : option[string], 
        _ContentLanguage_ : option[string], 
        _ContentLength_ : option[long], 
        _ContentRange_ : option[string], 
        _ContentType_ : option[string], 
        _DeleteMarker_ : option[bool], 
        _ETag_ : option[string], 
        _Expires_ : option[timestamp], 
        _Expiration_ : option[string], 
        _LastModified_ : option[timestamp], 
        _MissingMeta_ : option[integer], 
        _Metadata_ : option[unordered_map[string][string]], 
        _ObjectLockMode_ : option[string], 
        _ObjectLockLegalHoldStatus_ : option[string], 
        _ObjectLockRetainUntilDate_ : option[timestamp], 
        _PartsCount_ : option[integer], 
        _ReplicationStatus_ : option[string], 
        _RequestCharged_ : option[string], 
        _Restore_ : option[string], 
        _ServerSideEncryption_ : option[string], 
        _SSECustomerAlgorithm_ : option[string], 
        _SSEKMSKeyId_ : option[string], 
        _SSECustomerKeyMD5_ : option[string], 
        _StorageClass_ : option[string], 
        _TagCount_ : option[integer], 
        _VersionId_ : option[string], 
        _BucketKeyEnabled_ : option[bool] 
    }
}

# operation: AbortMultipartUpload
object _AbortMultipartUpload = {

    action request(txid:txid_t,
        input : _AbortMultipartUploadRequest
    )

    action response_AbortMultipartUploadOutput(txid: txid_t, val:_AbortMultipartUploadOutput)

    action response_NoSuchUpload(txid: txid_t, val:_NoSuchUpload)
}

# operation: CompleteMultipartUpload
object _CompleteMultipartUpload = {

    action request(txid:txid_t,
        input : _CompleteMultipartUploadRequest
    )

    action response_CompleteMultipartUploadOutput(txid: txid_t, val:_CompleteMultipartUploadOutput)
}

# operation: CopyObject
object _CopyObject = {

    action request(txid:txid_t,
        input : _CopyObjectRequest
    )

    action response_CopyObjectOutput(txid: txid_t, val:_CopyObjectOutput)

    action response_ObjectNotInActiveTierError(txid: txid_t, val:_ObjectNotInActiveTierError)
}

# operation: CreateBucket
object _CreateBucket = {

    action request(txid:txid_t,
        input : _CreateBucketRequest
    )

    action response_CreateBucketOutput(txid: txid_t, val:_CreateBucketOutput)

    action response_BucketAlreadyExists(txid: txid_t, val:_BucketAlreadyExists)

    action response_BucketAlreadyOwnedByYou(txid: txid_t, val:_BucketAlreadyOwnedByYou)
}

# operation: CreateMultipartUpload
object _CreateMultipartUpload = {

    action request(txid:txid_t,
        input : _CreateMultipartUploadRequest
    )

    action response_CreateMultipartUploadOutput(txid: txid_t, val:_CreateMultipartUploadOutput)
}

# operation: DeleteBucket
object _DeleteBucket = {

    action request(txid:txid_t,
        input : _DeleteBucketRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketAnalyticsConfiguration
object _DeleteBucketAnalyticsConfiguration = {

    action request(txid:txid_t,
        input : _DeleteBucketAnalyticsConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketCors
object _DeleteBucketCors = {

    action request(txid:txid_t,
        input : _DeleteBucketCorsRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketEncryption
object _DeleteBucketEncryption = {

    action request(txid:txid_t,
        input : _DeleteBucketEncryptionRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketIntelligentTieringConfiguration
object _DeleteBucketIntelligentTieringConfiguration = {

    action request(txid:txid_t,
        input : _DeleteBucketIntelligentTieringConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketInventoryConfiguration
object _DeleteBucketInventoryConfiguration = {

    action request(txid:txid_t,
        input : _DeleteBucketInventoryConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketLifecycle
object _DeleteBucketLifecycle = {

    action request(txid:txid_t,
        input : _DeleteBucketLifecycleRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketMetricsConfiguration
object _DeleteBucketMetricsConfiguration = {

    action request(txid:txid_t,
        input : _DeleteBucketMetricsConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketOwnershipControls
object _DeleteBucketOwnershipControls = {

    action request(txid:txid_t,
        input : _DeleteBucketOwnershipControlsRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketPolicy
object _DeleteBucketPolicy = {

    action request(txid:txid_t,
        input : _DeleteBucketPolicyRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketReplication
object _DeleteBucketReplication = {

    action request(txid:txid_t,
        input : _DeleteBucketReplicationRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketTagging
object _DeleteBucketTagging = {

    action request(txid:txid_t,
        input : _DeleteBucketTaggingRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteBucketWebsite
object _DeleteBucketWebsite = {

    action request(txid:txid_t,
        input : _DeleteBucketWebsiteRequest
    )

    action response(txid: txid_t)
}

# operation: DeleteObject
object _DeleteObject = {

    action request(txid:txid_t,
        input : _DeleteObjectRequest
    )

    action response_DeleteObjectOutput(txid: txid_t, val:_DeleteObjectOutput)
}

# operation: DeleteObjectTagging
object _DeleteObjectTagging = {

    action request(txid:txid_t,
        input : _DeleteObjectTaggingRequest
    )

    action response_DeleteObjectTaggingOutput(txid: txid_t, val:_DeleteObjectTaggingOutput)
}

# operation: DeleteObjects
object _DeleteObjects = {

    action request(txid:txid_t,
        input : _DeleteObjectsRequest
    )

    action response_DeleteObjectsOutput(txid: txid_t, val:_DeleteObjectsOutput)
}

# operation: DeletePublicAccessBlock
object _DeletePublicAccessBlock = {

    action request(txid:txid_t,
        input : _DeletePublicAccessBlockRequest
    )

    action response(txid: txid_t)
}

# operation: GetBucketAccelerateConfiguration
object _GetBucketAccelerateConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketAccelerateConfigurationRequest
    )

    action response_GetBucketAccelerateConfigurationOutput(txid: txid_t, val:_GetBucketAccelerateConfigurationOutput)
}

# operation: GetBucketAcl
object _GetBucketAcl = {

    action request(txid:txid_t,
        input : _GetBucketAclRequest
    )

    action response_GetBucketAclOutput(txid: txid_t, val:_GetBucketAclOutput)
}

# operation: GetBucketAnalyticsConfiguration
object _GetBucketAnalyticsConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketAnalyticsConfigurationRequest
    )

    action response_GetBucketAnalyticsConfigurationOutput(txid: txid_t, val:_GetBucketAnalyticsConfigurationOutput)
}

# operation: GetBucketCors
object _GetBucketCors = {

    action request(txid:txid_t,
        input : _GetBucketCorsRequest
    )

    action response_GetBucketCorsOutput(txid: txid_t, val:_GetBucketCorsOutput)
}

# operation: GetBucketEncryption
object _GetBucketEncryption = {

    action request(txid:txid_t,
        input : _GetBucketEncryptionRequest
    )

    action response_GetBucketEncryptionOutput(txid: txid_t, val:_GetBucketEncryptionOutput)
}

# operation: GetBucketIntelligentTieringConfiguration
object _GetBucketIntelligentTieringConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketIntelligentTieringConfigurationRequest
    )

    action response_GetBucketIntelligentTieringConfigurationOutput(txid: txid_t, val:_GetBucketIntelligentTieringConfigurationOutput)
}

# operation: GetBucketInventoryConfiguration
object _GetBucketInventoryConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketInventoryConfigurationRequest
    )

    action response_GetBucketInventoryConfigurationOutput(txid: txid_t, val:_GetBucketInventoryConfigurationOutput)
}

# operation: GetBucketLifecycle
object _GetBucketLifecycle = {

    action request(txid:txid_t,
        input : _GetBucketLifecycleRequest
    )

    action response_GetBucketLifecycleOutput(txid: txid_t, val:_GetBucketLifecycleOutput)
}

# operation: GetBucketLifecycleConfiguration
object _GetBucketLifecycleConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketLifecycleConfigurationRequest
    )

    action response_GetBucketLifecycleConfigurationOutput(txid: txid_t, val:_GetBucketLifecycleConfigurationOutput)
}

# operation: GetBucketLocation
object _GetBucketLocation = {

    action request(txid:txid_t,
        input : _GetBucketLocationRequest
    )

    action response_GetBucketLocationOutput(txid: txid_t, val:_GetBucketLocationOutput)
}

# operation: GetBucketLogging
object _GetBucketLogging = {

    action request(txid:txid_t,
        input : _GetBucketLoggingRequest
    )

    action response_GetBucketLoggingOutput(txid: txid_t, val:_GetBucketLoggingOutput)
}

# operation: GetBucketMetricsConfiguration
object _GetBucketMetricsConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketMetricsConfigurationRequest
    )

    action response_GetBucketMetricsConfigurationOutput(txid: txid_t, val:_GetBucketMetricsConfigurationOutput)
}

# operation: GetBucketNotification
object _GetBucketNotification = {

    action request(txid:txid_t,
        input : _GetBucketNotificationConfigurationRequest
    )

    action response_NotificationConfigurationDeprecated(txid: txid_t, val:_NotificationConfigurationDeprecated)
}

# operation: GetBucketNotificationConfiguration
object _GetBucketNotificationConfiguration = {

    action request(txid:txid_t,
        input : _GetBucketNotificationConfigurationRequest
    )

    action response_NotificationConfiguration(txid: txid_t, val:_NotificationConfiguration)
}

# operation: GetBucketOwnershipControls
object _GetBucketOwnershipControls = {

    action request(txid:txid_t,
        input : _GetBucketOwnershipControlsRequest
    )

    action response_GetBucketOwnershipControlsOutput(txid: txid_t, val:_GetBucketOwnershipControlsOutput)
}

# operation: GetBucketPolicy
object _GetBucketPolicy = {

    action request(txid:txid_t,
        input : _GetBucketPolicyRequest
    )

    action response_GetBucketPolicyOutput(txid: txid_t, val:_GetBucketPolicyOutput)
}

# operation: GetBucketPolicyStatus
object _GetBucketPolicyStatus = {

    action request(txid:txid_t,
        input : _GetBucketPolicyStatusRequest
    )

    action response_GetBucketPolicyStatusOutput(txid: txid_t, val:_GetBucketPolicyStatusOutput)
}

# operation: GetBucketReplication
object _GetBucketReplication = {

    action request(txid:txid_t,
        input : _GetBucketReplicationRequest
    )

    action response_GetBucketReplicationOutput(txid: txid_t, val:_GetBucketReplicationOutput)
}

# operation: GetBucketRequestPayment
object _GetBucketRequestPayment = {

    action request(txid:txid_t,
        input : _GetBucketRequestPaymentRequest
    )

    action response_GetBucketRequestPaymentOutput(txid: txid_t, val:_GetBucketRequestPaymentOutput)
}

# operation: GetBucketTagging
object _GetBucketTagging = {

    action request(txid:txid_t,
        input : _GetBucketTaggingRequest
    )

    action response_GetBucketTaggingOutput(txid: txid_t, val:_GetBucketTaggingOutput)
}

# operation: GetBucketVersioning
object _GetBucketVersioning = {

    action request(txid:txid_t,
        input : _GetBucketVersioningRequest
    )

    action response_GetBucketVersioningOutput(txid: txid_t, val:_GetBucketVersioningOutput)
}

# operation: GetBucketWebsite
object _GetBucketWebsite = {

    action request(txid:txid_t,
        input : _GetBucketWebsiteRequest
    )

    action response_GetBucketWebsiteOutput(txid: txid_t, val:_GetBucketWebsiteOutput)
}

# operation: GetObject
object _GetObject = {

    action request(txid:txid_t,
        input : _GetObjectRequest
    )

    action response_GetObjectOutput(txid: txid_t, val:_GetObjectOutput)

    action response_NoSuchKey(txid: txid_t, val:_NoSuchKey)

    action response_InvalidObjectState(txid: txid_t, val:_InvalidObjectState)
}

# operation: GetObjectAcl
object _GetObjectAcl = {

    action request(txid:txid_t,
        input : _GetObjectAclRequest
    )

    action response_GetObjectAclOutput(txid: txid_t, val:_GetObjectAclOutput)

    action response_NoSuchKey(txid: txid_t, val:_NoSuchKey)
}

# operation: GetObjectLegalHold
object _GetObjectLegalHold = {

    action request(txid:txid_t,
        input : _GetObjectLegalHoldRequest
    )

    action response_GetObjectLegalHoldOutput(txid: txid_t, val:_GetObjectLegalHoldOutput)
}

# operation: GetObjectLockConfiguration
object _GetObjectLockConfiguration = {

    action request(txid:txid_t,
        input : _GetObjectLockConfigurationRequest
    )

    action response_GetObjectLockConfigurationOutput(txid: txid_t, val:_GetObjectLockConfigurationOutput)
}

# operation: GetObjectRetention
object _GetObjectRetention = {

    action request(txid:txid_t,
        input : _GetObjectRetentionRequest
    )

    action response_GetObjectRetentionOutput(txid: txid_t, val:_GetObjectRetentionOutput)
}

# operation: GetObjectTagging
object _GetObjectTagging = {

    action request(txid:txid_t,
        input : _GetObjectTaggingRequest
    )

    action response_GetObjectTaggingOutput(txid: txid_t, val:_GetObjectTaggingOutput)
}

# operation: GetObjectTorrent
object _GetObjectTorrent = {

    action request(txid:txid_t,
        input : _GetObjectTorrentRequest
    )

    action response_GetObjectTorrentOutput(txid: txid_t, val:_GetObjectTorrentOutput)
}

# operation: GetPublicAccessBlock
object _GetPublicAccessBlock = {

    action request(txid:txid_t,
        input : _GetPublicAccessBlockRequest
    )

    action response_GetPublicAccessBlockOutput(txid: txid_t, val:_GetPublicAccessBlockOutput)
}

# operation: HeadBucket
object _HeadBucket = {

    action request(txid:txid_t,
        input : _HeadBucketRequest
    )

    action response(txid: txid_t)

    action response_NoSuchBucket(txid: txid_t, val:_NoSuchBucket)
}

# operation: HeadObject
object _HeadObject = {

    action request(txid:txid_t,
        input : _HeadObjectRequest
    )

    action response_HeadObjectOutput(txid: txid_t, val:_HeadObjectOutput)

    action response_NoSuchKey(txid: txid_t, val:_NoSuchKey)
}

# operation: ListBucketAnalyticsConfigurations
object _ListBucketAnalyticsConfigurations = {

    action request(txid:txid_t,
        input : _ListBucketAnalyticsConfigurationsRequest
    )

    action response_ListBucketAnalyticsConfigurationsOutput(txid: txid_t, val:_ListBucketAnalyticsConfigurationsOutput)
}

# operation: ListBucketIntelligentTieringConfigurations
object _ListBucketIntelligentTieringConfigurations = {

    action request(txid:txid_t,
        input : _ListBucketIntelligentTieringConfigurationsRequest
    )

    action response_ListBucketIntelligentTieringConfigurationsOutput(txid: txid_t, val:_ListBucketIntelligentTieringConfigurationsOutput)
}

# operation: ListBucketInventoryConfigurations
object _ListBucketInventoryConfigurations = {

    action request(txid:txid_t,
        input : _ListBucketInventoryConfigurationsRequest
    )

    action response_ListBucketInventoryConfigurationsOutput(txid: txid_t, val:_ListBucketInventoryConfigurationsOutput)
}

# operation: ListBucketMetricsConfigurations
object _ListBucketMetricsConfigurations = {

    action request(txid:txid_t,
        input : _ListBucketMetricsConfigurationsRequest
    )

    action response_ListBucketMetricsConfigurationsOutput(txid: txid_t, val:_ListBucketMetricsConfigurationsOutput)
}

# operation: ListBuckets
object _ListBuckets = {

    action request(txid:txid_t    )

    action response_ListBucketsOutput(txid: txid_t, val:_ListBucketsOutput)
}

# operation: ListMultipartUploads
object _ListMultipartUploads = {

    action request(txid:txid_t,
        input : _ListMultipartUploadsRequest
    )

    action response_ListMultipartUploadsOutput(txid: txid_t, val:_ListMultipartUploadsOutput)
}

# operation: ListObjectVersions
object _ListObjectVersions = {

    action request(txid:txid_t,
        input : _ListObjectVersionsRequest
    )

    action response_ListObjectVersionsOutput(txid: txid_t, val:_ListObjectVersionsOutput)
}

# operation: ListObjects
object _ListObjects = {

    action request(txid:txid_t,
        input : _ListObjectsRequest
    )

    action response_ListObjectsOutput(txid: txid_t, val:_ListObjectsOutput)

    action response_NoSuchBucket(txid: txid_t, val:_NoSuchBucket)
}

# operation: ListObjectsV2
object _ListObjectsV2 = {

    action request(txid:txid_t,
        input : _ListObjectsV2Request
    )

    action response_ListObjectsV2Output(txid: txid_t, val:_ListObjectsV2Output)

    action response_NoSuchBucket(txid: txid_t, val:_NoSuchBucket)
}

# operation: ListParts
object _ListParts = {

    action request(txid:txid_t,
        input : _ListPartsRequest
    )

    action response_ListPartsOutput(txid: txid_t, val:_ListPartsOutput)
}

# operation: PutBucketAccelerateConfiguration
object _PutBucketAccelerateConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketAccelerateConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketAcl
object _PutBucketAcl = {

    action request(txid:txid_t,
        input : _PutBucketAclRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketAnalyticsConfiguration
object _PutBucketAnalyticsConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketAnalyticsConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketCors
object _PutBucketCors = {

    action request(txid:txid_t,
        input : _PutBucketCorsRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketEncryption
object _PutBucketEncryption = {

    action request(txid:txid_t,
        input : _PutBucketEncryptionRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketIntelligentTieringConfiguration
object _PutBucketIntelligentTieringConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketIntelligentTieringConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketInventoryConfiguration
object _PutBucketInventoryConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketInventoryConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketLifecycle
object _PutBucketLifecycle = {

    action request(txid:txid_t,
        input : _PutBucketLifecycleRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketLifecycleConfiguration
object _PutBucketLifecycleConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketLifecycleConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketLogging
object _PutBucketLogging = {

    action request(txid:txid_t,
        input : _PutBucketLoggingRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketMetricsConfiguration
object _PutBucketMetricsConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketMetricsConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketNotification
object _PutBucketNotification = {

    action request(txid:txid_t,
        input : _PutBucketNotificationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketNotificationConfiguration
object _PutBucketNotificationConfiguration = {

    action request(txid:txid_t,
        input : _PutBucketNotificationConfigurationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketOwnershipControls
object _PutBucketOwnershipControls = {

    action request(txid:txid_t,
        input : _PutBucketOwnershipControlsRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketPolicy
object _PutBucketPolicy = {

    action request(txid:txid_t,
        input : _PutBucketPolicyRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketReplication
object _PutBucketReplication = {

    action request(txid:txid_t,
        input : _PutBucketReplicationRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketRequestPayment
object _PutBucketRequestPayment = {

    action request(txid:txid_t,
        input : _PutBucketRequestPaymentRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketTagging
object _PutBucketTagging = {

    action request(txid:txid_t,
        input : _PutBucketTaggingRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketVersioning
object _PutBucketVersioning = {

    action request(txid:txid_t,
        input : _PutBucketVersioningRequest
    )

    action response(txid: txid_t)
}

# operation: PutBucketWebsite
object _PutBucketWebsite = {

    action request(txid:txid_t,
        input : _PutBucketWebsiteRequest
    )

    action response(txid: txid_t)
}

# operation: PutObject
object _PutObject = {

    action request(txid:txid_t,
        input : _PutObjectRequest
    )

    action response_PutObjectOutput(txid: txid_t, val:_PutObjectOutput)
}

# operation: PutObjectAcl
object _PutObjectAcl = {

    action request(txid:txid_t,
        input : _PutObjectAclRequest
    )

    action response_PutObjectAclOutput(txid: txid_t, val:_PutObjectAclOutput)

    action response_NoSuchKey(txid: txid_t, val:_NoSuchKey)
}

# operation: PutObjectLegalHold
object _PutObjectLegalHold = {

    action request(txid:txid_t,
        input : _PutObjectLegalHoldRequest
    )

    action response_PutObjectLegalHoldOutput(txid: txid_t, val:_PutObjectLegalHoldOutput)
}

# operation: PutObjectLockConfiguration
object _PutObjectLockConfiguration = {

    action request(txid:txid_t,
        input : _PutObjectLockConfigurationRequest
    )

    action response_PutObjectLockConfigurationOutput(txid: txid_t, val:_PutObjectLockConfigurationOutput)
}

# operation: PutObjectRetention
object _PutObjectRetention = {

    action request(txid:txid_t,
        input : _PutObjectRetentionRequest
    )

    action response_PutObjectRetentionOutput(txid: txid_t, val:_PutObjectRetentionOutput)
}

# operation: PutObjectTagging
object _PutObjectTagging = {

    action request(txid:txid_t,
        input : _PutObjectTaggingRequest
    )

    action response_PutObjectTaggingOutput(txid: txid_t, val:_PutObjectTaggingOutput)
}

# operation: PutPublicAccessBlock
object _PutPublicAccessBlock = {

    action request(txid:txid_t,
        input : _PutPublicAccessBlockRequest
    )

    action response(txid: txid_t)
}

# operation: RestoreObject
object _RestoreObject = {

    action request(txid:txid_t,
        input : _RestoreObjectRequest
    )

    action response_RestoreObjectOutput(txid: txid_t, val:_RestoreObjectOutput)

    action response_ObjectAlreadyInActiveTierError(txid: txid_t, val:_ObjectAlreadyInActiveTierError)
}

# operation: SelectObjectContent
object _SelectObjectContent = {

    action request(txid:txid_t,
        input : _SelectObjectContentRequest
    )

    action response_SelectObjectContentOutput(txid: txid_t, val:_SelectObjectContentOutput)
}

# operation: UploadPart
object _UploadPart = {

    action request(txid:txid_t,
        input : _UploadPartRequest
    )

    action response_UploadPartOutput(txid: txid_t, val:_UploadPartOutput)
}

# operation: UploadPartCopy
object _UploadPartCopy = {

    action request(txid:txid_t,
        input : _UploadPartCopyRequest
    )

    action response_UploadPartCopyOutput(txid: txid_t, val:_UploadPartCopyOutput)
}

# operation: WriteGetObjectResponse
object _WriteGetObjectResponse = {

    action request(txid:txid_t,
        input : _WriteGetObjectResponseRequest
    )

    action response(txid: txid_t)
}

<<< impl
#include <aws/core/Aws.h>
#include <aws/s3/S3Client.h>
#include <sstream>
#include <functional>

std::shared_ptr<Aws::IOStream> blob_to_iostream(const `blob` &data) {
    Aws::String s;
    s.insert(s.begin(),data.begin(),data.end());
    Aws::IOStream *x = new Aws::StringStream(s);
    std::shared_ptr<Aws::IOStream> y(x);
    return y;
}

Aws::Map<Aws::String, Aws::String> map_to_aws(`unordered_map[string][string]` map) {
    Aws::Map<Aws::String, Aws::String> res;
    for(auto it=map.begin(), en=map.end(); it != en; ++it){
        res[it->first.c_str()] = it->second.c_str();
    }
    return res;
}

std::vector<Aws::S3::S3Client *> aws_client_pool;

Aws::S3::S3Client *get_aws_client() {
    Aws::S3::S3Client *s3_client;
    if (aws_client_pool.size()) {
        s3_client = aws_client_pool.back();
        aws_client_pool.pop_back();
    } else {
        Aws::Client::ClientConfiguration config;
        s3_client = new Aws::S3::S3Client(config);
    }
    return s3_client;
}

void return_aws_client(Aws::S3::S3Client *s3_client) {
    aws_client_pool.push_back(s3_client);
}

>>>
<<< init 
{
    Aws::SDKOptions options;
    Aws::InitAPI(options);
}
>>>


<<< impl
#include <aws/s3/model/AbortMultipartUploadRequest.h>
>>>


implement _AbortMultipartUpload.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_AbortMultipartUploadOutput` output;

       `txid_t` txid;
       %`_AbortMultipartUpload.response_AbortMultipartUploadOutput` cb;
        %`_AbortMultipartUpload.response_NoSuchUpload` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_AbortMultipartUpload.response_AbortMultipartUploadOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_AbortMultipartUpload.response_NoSuchUpload` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchUpload" == errcode.GetExceptionName()) {`_NoSuchUpload` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::AbortMultipartUploadRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    request.SetUploadId(input._UploadId_.c_str());
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::AbortMultipartUploadOutcome outcome = s3_client->AbortMultipartUpload(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_AbortMultipartUploadOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_AbortMultipartUpload.response_AbortMultipartUploadOutput`,func,`_AbortMultipartUpload.response_NoSuchUpload`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/CompleteMultipartUploadRequest.h>
>>>


implement _CompleteMultipartUpload.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_CompleteMultipartUploadOutput` output;

       `txid_t` txid;
       %`_CompleteMultipartUpload.response_CompleteMultipartUploadOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_CompleteMultipartUpload.response_CompleteMultipartUploadOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::CompleteMultipartUploadRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._MultipartUpload_.size()) {
        request.SetMultipartUpload(input._MultipartUpload_[0]);
    }
    request.SetUploadId(input._UploadId_.c_str());
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::CompleteMultipartUploadOutcome outcome = s3_client->CompleteMultipartUpload(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_CompleteMultipartUploadOutput` res;
        res._Location_ = result.GetLocation().c_str();
        res._Bucket_ = result.GetBucket().c_str();
        res._Key_ = result.GetKey().c_str();
        res._Expiration_ = result.GetExpiration().c_str();
        res._ETag_ = result.GetETag().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._VersionId_ = result.GetVersionId().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_CompleteMultipartUpload.response_CompleteMultipartUploadOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/CopyObjectRequest.h>
>>>


implement _CopyObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_CopyObjectOutput` output;

       `txid_t` txid;
       %`_CopyObject.response_CopyObjectOutput` cb;
        %`_CopyObject.response_ObjectNotInActiveTierError` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_CopyObject.response_CopyObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_CopyObject.response_ObjectNotInActiveTierError` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("ObjectNotInActiveTierError" == errcode.GetExceptionName()) {`_ObjectNotInActiveTierError` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::CopyObjectRequest request;
    if (input._ACL_.size()) {
        request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._CacheControl_.size()) {
        request.SetCacheControl(input._CacheControl_[0].c_str());
    }
    if (input._ContentDisposition_.size()) {
        request.SetContentDisposition(input._ContentDisposition_[0].c_str());
    }
    if (input._ContentEncoding_.size()) {
        request.SetContentEncoding(input._ContentEncoding_[0].c_str());
    }
    if (input._ContentLanguage_.size()) {
        request.SetContentLanguage(input._ContentLanguage_[0].c_str());
    }
    if (input._ContentType_.size()) {
        request.SetContentType(input._ContentType_[0].c_str());
    }
    request.SetCopySource(input._CopySource_.c_str());
    if (input._CopySourceIfMatch_.size()) {
        request.SetCopySourceIfMatch(input._CopySourceIfMatch_[0].c_str());
    }
    if (input._CopySourceIfModifiedSince_.size()) {
        request.SetCopySourceIfModifiedSince(Aws::Utils::DateTime((int64_t)input._CopySourceIfModifiedSince_[0]));
    }
    if (input._CopySourceIfNoneMatch_.size()) {
        request.SetCopySourceIfNoneMatch(input._CopySourceIfNoneMatch_[0].c_str());
    }
    if (input._CopySourceIfUnmodifiedSince_.size()) {
        request.SetCopySourceIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._CopySourceIfUnmodifiedSince_[0]));
    }
    if (input._Expires_.size()) {
        request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    if (input._Metadata_.size()) {
        request.SetMetadata(map_to_aws(input._Metadata_[0]));
    }
    if (input._MetadataDirective_.size()) {
        request.SetMetadataDirective(input._MetadataDirective_[0].c_str());
    }
    if (input._TaggingDirective_.size()) {
        request.SetTaggingDirective(input._TaggingDirective_[0].c_str());
    }
    if (input._ServerSideEncryption_.size()) {
        request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
    }
    if (input._StorageClass_.size()) {
        request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
    }
    if (input._WebsiteRedirectLocation_.size()) {
        request.SetWebsiteRedirectLocation(input._WebsiteRedirectLocation_[0].c_str());
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._SSEKMSKeyId_.size()) {
        request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
    }
    if (input._SSEKMSEncryptionContext_.size()) {
        request.SetSSEKMSEncryptionContext(input._SSEKMSEncryptionContext_[0].c_str());
    }
    if (input._BucketKeyEnabled_.size()) {
        request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
    }
    if (input._CopySourceSSECustomerAlgorithm_.size()) {
        request.SetCopySourceSSECustomerAlgorithm(input._CopySourceSSECustomerAlgorithm_[0].c_str());
    }
    if (input._CopySourceSSECustomerKey_.size()) {
        request.SetCopySourceSSECustomerKey(input._CopySourceSSECustomerKey_[0].c_str());
    }
    if (input._CopySourceSSECustomerKeyMD5_.size()) {
        request.SetCopySourceSSECustomerKeyMD5(input._CopySourceSSECustomerKeyMD5_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._Tagging_.size()) {
        request.SetTagging(input._Tagging_[0].c_str());
    }
    if (input._ObjectLockMode_.size()) {
        request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
    }
    if (input._ObjectLockRetainUntilDate_.size()) {
        request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
    }
    if (input._ObjectLockLegalHoldStatus_.size()) {
        request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
    if (input._ExpectedSourceBucketOwner_.size()) {
        request.SetExpectedSourceBucketOwner(input._ExpectedSourceBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::CopyObjectOutcome outcome = s3_client->CopyObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_CopyObjectOutput` res;
        res._CopyObjectResult_ = result.GetCopyObjectResult();
        res._Expiration_ = result.GetExpiration().c_str();
        res._CopySourceVersionId_ = result.GetCopySourceVersionId().c_str();
        res._VersionId_ = result.GetVersionId().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._SSEKMSEncryptionContext_ = result.GetSSEKMSEncryptionContext().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_CopyObject.response_CopyObjectOutput`,func,`_CopyObject.response_ObjectNotInActiveTierError`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/CreateBucketRequest.h>
>>>


implement _CreateBucket.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_CreateBucketOutput` output;

       `txid_t` txid;
       %`_CreateBucket.response_CreateBucketOutput` cb;
        %`_CreateBucket.response_BucketAlreadyExists` err0;
        %`_CreateBucket.response_BucketAlreadyOwnedByYou` err1;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_CreateBucket.response_CreateBucketOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_CreateBucket.response_BucketAlreadyExists` err0,%`_CreateBucket.response_BucketAlreadyOwnedByYou` err1 ) : ivy(ivy),txid(txid),cb(cb),err0(err0),err1(err1) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("BucketAlreadyExists" == errcode.GetExceptionName()) {`_BucketAlreadyExists` thing; err0(txid,thing);}
if ("BucketAlreadyOwnedByYou" == errcode.GetExceptionName()) {`_BucketAlreadyOwnedByYou` thing; err1(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::CreateBucketRequest request;
    if (input._ACL_.size()) {
        request.SetACL(input._ACL_[0].c_str());
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._CreateBucketConfiguration_.size()) {
        request.SetCreateBucketConfiguration(input._CreateBucketConfiguration_[0]);
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWrite_.size()) {
        request.SetGrantWrite(input._GrantWrite_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    if (input._ObjectLockEnabledForBucket_.size()) {
        request.SetObjectLockEnabledForBucket(input._ObjectLockEnabledForBucket_[0]);
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::CreateBucketOutcome outcome = s3_client->CreateBucket(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_CreateBucketOutput` res;
        res._Location_ = result.GetLocation().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_CreateBucket.response_CreateBucketOutput`,func,`_CreateBucket.response_BucketAlreadyExists`,`_CreateBucket.response_BucketAlreadyOwnedByYou`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/CreateMultipartUploadRequest.h>
>>>


implement _CreateMultipartUpload.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_CreateMultipartUploadOutput` output;

       `txid_t` txid;
       %`_CreateMultipartUpload.response_CreateMultipartUploadOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_CreateMultipartUpload.response_CreateMultipartUploadOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::CreateMultipartUploadRequest request;
    if (input._ACL_.size()) {
        request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._CacheControl_.size()) {
        request.SetCacheControl(input._CacheControl_[0].c_str());
    }
    if (input._ContentDisposition_.size()) {
        request.SetContentDisposition(input._ContentDisposition_[0].c_str());
    }
    if (input._ContentEncoding_.size()) {
        request.SetContentEncoding(input._ContentEncoding_[0].c_str());
    }
    if (input._ContentLanguage_.size()) {
        request.SetContentLanguage(input._ContentLanguage_[0].c_str());
    }
    if (input._ContentType_.size()) {
        request.SetContentType(input._ContentType_[0].c_str());
    }
    if (input._Expires_.size()) {
        request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    if (input._Metadata_.size()) {
        request.SetMetadata(map_to_aws(input._Metadata_[0]));
    }
    if (input._ServerSideEncryption_.size()) {
        request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
    }
    if (input._StorageClass_.size()) {
        request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
    }
    if (input._WebsiteRedirectLocation_.size()) {
        request.SetWebsiteRedirectLocation(input._WebsiteRedirectLocation_[0].c_str());
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._SSEKMSKeyId_.size()) {
        request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
    }
    if (input._SSEKMSEncryptionContext_.size()) {
        request.SetSSEKMSEncryptionContext(input._SSEKMSEncryptionContext_[0].c_str());
    }
    if (input._BucketKeyEnabled_.size()) {
        request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._Tagging_.size()) {
        request.SetTagging(input._Tagging_[0].c_str());
    }
    if (input._ObjectLockMode_.size()) {
        request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
    }
    if (input._ObjectLockRetainUntilDate_.size()) {
        request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
    }
    if (input._ObjectLockLegalHoldStatus_.size()) {
        request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::CreateMultipartUploadOutcome outcome = s3_client->CreateMultipartUpload(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_CreateMultipartUploadOutput` res;
        res._AbortDate_ = result.GetAbortDate().Millis();
        res._AbortRuleId_ = result.GetAbortRuleId().c_str();
        res._Bucket_ = result.GetBucket().c_str();
        res._Key_ = result.GetKey().c_str();
        res._UploadId_ = result.GetUploadId().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._SSEKMSEncryptionContext_ = result.GetSSEKMSEncryptionContext().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_CreateMultipartUpload.response_CreateMultipartUploadOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketRequest.h>
>>>


implement _DeleteBucket.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucket.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucket.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketOutcome outcome = s3_client->DeleteBucket(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucket.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketAnalyticsConfigurationRequest.h>
>>>


implement _DeleteBucketAnalyticsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketAnalyticsConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketAnalyticsConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketAnalyticsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketAnalyticsConfigurationOutcome outcome = s3_client->DeleteBucketAnalyticsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketAnalyticsConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketCorsRequest.h>
>>>


implement _DeleteBucketCors.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketCors.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketCors.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketCorsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketCorsOutcome outcome = s3_client->DeleteBucketCors(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketCors.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketEncryptionRequest.h>
>>>


implement _DeleteBucketEncryption.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketEncryption.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketEncryption.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketEncryptionRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketEncryptionOutcome outcome = s3_client->DeleteBucketEncryption(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketEncryption.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketIntelligentTieringConfigurationRequest.h>
>>>


implement _DeleteBucketIntelligentTieringConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketIntelligentTieringConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketIntelligentTieringConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketIntelligentTieringConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketIntelligentTieringConfigurationOutcome outcome = s3_client->DeleteBucketIntelligentTieringConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketIntelligentTieringConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketInventoryConfigurationRequest.h>
>>>


implement _DeleteBucketInventoryConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketInventoryConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketInventoryConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketInventoryConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketInventoryConfigurationOutcome outcome = s3_client->DeleteBucketInventoryConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketInventoryConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketLifecycleRequest.h>
>>>


implement _DeleteBucketLifecycle.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketLifecycle.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketLifecycle.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketLifecycleRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketLifecycleOutcome outcome = s3_client->DeleteBucketLifecycle(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketLifecycle.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketMetricsConfigurationRequest.h>
>>>


implement _DeleteBucketMetricsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketMetricsConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketMetricsConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketMetricsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketMetricsConfigurationOutcome outcome = s3_client->DeleteBucketMetricsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketMetricsConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketOwnershipControlsRequest.h>
>>>


implement _DeleteBucketOwnershipControls.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketOwnershipControls.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketOwnershipControls.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketOwnershipControlsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketOwnershipControlsOutcome outcome = s3_client->DeleteBucketOwnershipControls(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketOwnershipControls.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketPolicyRequest.h>
>>>


implement _DeleteBucketPolicy.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketPolicy.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketPolicy.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketPolicyRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketPolicyOutcome outcome = s3_client->DeleteBucketPolicy(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketPolicy.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketReplicationRequest.h>
>>>


implement _DeleteBucketReplication.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketReplication.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketReplication.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketReplicationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketReplicationOutcome outcome = s3_client->DeleteBucketReplication(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketReplication.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketTaggingRequest.h>
>>>


implement _DeleteBucketTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketTagging.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketTagging.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketTaggingOutcome outcome = s3_client->DeleteBucketTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketTagging.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteBucketWebsiteRequest.h>
>>>


implement _DeleteBucketWebsite.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeleteBucketWebsite.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteBucketWebsite.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteBucketWebsiteRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteBucketWebsiteOutcome outcome = s3_client->DeleteBucketWebsite(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteBucketWebsite.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteObjectRequest.h>
>>>


implement _DeleteObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_DeleteObjectOutput` output;

       `txid_t` txid;
       %`_DeleteObject.response_DeleteObjectOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteObject.response_DeleteObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteObjectRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._MFA_.size()) {
        request.SetMFA(input._MFA_[0].c_str());
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._BypassGovernanceRetention_.size()) {
        request.SetBypassGovernanceRetention(input._BypassGovernanceRetention_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteObjectOutcome outcome = s3_client->DeleteObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_DeleteObjectOutput` res;
        res._DeleteMarker_ = result.GetDeleteMarker();
        res._VersionId_ = result.GetVersionId().c_str();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteObject.response_DeleteObjectOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteObjectTaggingRequest.h>
>>>


implement _DeleteObjectTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_DeleteObjectTaggingOutput` output;

       `txid_t` txid;
       %`_DeleteObjectTagging.response_DeleteObjectTaggingOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteObjectTagging.response_DeleteObjectTaggingOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteObjectTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteObjectTaggingOutcome outcome = s3_client->DeleteObjectTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_DeleteObjectTaggingOutput` res;
        res._VersionId_ = result.GetVersionId().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteObjectTagging.response_DeleteObjectTaggingOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeleteObjectsRequest.h>
>>>


implement _DeleteObjects.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_DeleteObjectsOutput` output;

       `txid_t` txid;
       %`_DeleteObjects.response_DeleteObjectsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeleteObjects.response_DeleteObjectsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeleteObjectsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetDelete(input._Delete_);
    if (input._MFA_.size()) {
        request.SetMFA(input._MFA_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._BypassGovernanceRetention_.size()) {
        request.SetBypassGovernanceRetention(input._BypassGovernanceRetention_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeleteObjectsOutcome outcome = s3_client->DeleteObjects(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_DeleteObjectsOutput` res;
        for (auto it = result.GetDeleted().begin(), en = result.GetDeleted().end(); it != en; ++it) { res._Deleted_.resize(res._Deleted_.size()+1); res._Deleted_.back().first = it->first.c_str(); res._Deleted_.back().second = it->second.c_str(); } 
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        for (auto it = result.GetErrors().begin(), en = result.GetErrors().end(); it != en; ++it) { res._Errors_.resize(res._Errors_.size()+1); res._Errors_.back().first = it->first.c_str(); res._Errors_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeleteObjects.response_DeleteObjectsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/DeletePublicAccessBlockRequest.h>
>>>


implement _DeletePublicAccessBlock.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_DeletePublicAccessBlock.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_DeletePublicAccessBlock.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::DeletePublicAccessBlockRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::DeletePublicAccessBlockOutcome outcome = s3_client->DeletePublicAccessBlock(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_DeletePublicAccessBlock.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketAccelerateConfigurationRequest.h>
>>>


implement _GetBucketAccelerateConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketAccelerateConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketAccelerateConfiguration.response_GetBucketAccelerateConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketAccelerateConfiguration.response_GetBucketAccelerateConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketAccelerateConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketAccelerateConfigurationOutcome outcome = s3_client->GetBucketAccelerateConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketAccelerateConfigurationOutput` res;
        res._Status_ = result.GetStatus().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketAccelerateConfiguration.response_GetBucketAccelerateConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketAclRequest.h>
>>>


implement _GetBucketAcl.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketAclOutput` output;

       `txid_t` txid;
       %`_GetBucketAcl.response_GetBucketAclOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketAcl.response_GetBucketAclOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketAclRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketAclOutcome outcome = s3_client->GetBucketAcl(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketAclOutput` res;
        res._Owner_ = result.GetOwner();
        for (auto it = result.GetGrants().begin(), en = result.GetGrants().end(); it != en; ++it) { res._Grants_.resize(res._Grants_.size()+1); res._Grants_.back().first = it->first.c_str(); res._Grants_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketAcl.response_GetBucketAclOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketAnalyticsConfigurationRequest.h>
>>>


implement _GetBucketAnalyticsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketAnalyticsConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketAnalyticsConfiguration.response_GetBucketAnalyticsConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketAnalyticsConfiguration.response_GetBucketAnalyticsConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketAnalyticsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketAnalyticsConfigurationOutcome outcome = s3_client->GetBucketAnalyticsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketAnalyticsConfigurationOutput` res;
        res._AnalyticsConfiguration_ = result.GetAnalyticsConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketAnalyticsConfiguration.response_GetBucketAnalyticsConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketCorsRequest.h>
>>>


implement _GetBucketCors.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketCorsOutput` output;

       `txid_t` txid;
       %`_GetBucketCors.response_GetBucketCorsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketCors.response_GetBucketCorsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketCorsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketCorsOutcome outcome = s3_client->GetBucketCors(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketCorsOutput` res;
        for (auto it = result.GetCORSRules().begin(), en = result.GetCORSRules().end(); it != en; ++it) { res._CORSRules_.resize(res._CORSRules_.size()+1); res._CORSRules_.back().first = it->first.c_str(); res._CORSRules_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketCors.response_GetBucketCorsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketEncryptionRequest.h>
>>>


implement _GetBucketEncryption.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketEncryptionOutput` output;

       `txid_t` txid;
       %`_GetBucketEncryption.response_GetBucketEncryptionOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketEncryption.response_GetBucketEncryptionOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketEncryptionRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketEncryptionOutcome outcome = s3_client->GetBucketEncryption(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketEncryptionOutput` res;
        res._ServerSideEncryptionConfiguration_ = result.GetServerSideEncryptionConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketEncryption.response_GetBucketEncryptionOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketIntelligentTieringConfigurationRequest.h>
>>>


implement _GetBucketIntelligentTieringConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketIntelligentTieringConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketIntelligentTieringConfiguration.response_GetBucketIntelligentTieringConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketIntelligentTieringConfiguration.response_GetBucketIntelligentTieringConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketIntelligentTieringConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketIntelligentTieringConfigurationOutcome outcome = s3_client->GetBucketIntelligentTieringConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketIntelligentTieringConfigurationOutput` res;
        res._IntelligentTieringConfiguration_ = result.GetIntelligentTieringConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketIntelligentTieringConfiguration.response_GetBucketIntelligentTieringConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketInventoryConfigurationRequest.h>
>>>


implement _GetBucketInventoryConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketInventoryConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketInventoryConfiguration.response_GetBucketInventoryConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketInventoryConfiguration.response_GetBucketInventoryConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketInventoryConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketInventoryConfigurationOutcome outcome = s3_client->GetBucketInventoryConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketInventoryConfigurationOutput` res;
        res._InventoryConfiguration_ = result.GetInventoryConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketInventoryConfiguration.response_GetBucketInventoryConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


implement _GetBucketLifecycle.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketLifecycleOutput` output;

       `txid_t` txid;
       %`_GetBucketLifecycle.response_GetBucketLifecycleOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketLifecycle.response_GetBucketLifecycleOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketLifecycleRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketLifecycleOutcome outcome = s3_client->GetBucketLifecycle(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketLifecycleOutput` res;
        for (auto it = result.GetRules().begin(), en = result.GetRules().end(); it != en; ++it) { res._Rules_.resize(res._Rules_.size()+1); res._Rules_.back().first = it->first.c_str(); res._Rules_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketLifecycle.response_GetBucketLifecycleOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketLifecycleConfigurationRequest.h>
>>>


implement _GetBucketLifecycleConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketLifecycleConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketLifecycleConfiguration.response_GetBucketLifecycleConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketLifecycleConfiguration.response_GetBucketLifecycleConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketLifecycleConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketLifecycleConfigurationOutcome outcome = s3_client->GetBucketLifecycleConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketLifecycleConfigurationOutput` res;
        for (auto it = result.GetRules().begin(), en = result.GetRules().end(); it != en; ++it) { res._Rules_.resize(res._Rules_.size()+1); res._Rules_.back().first = it->first.c_str(); res._Rules_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketLifecycleConfiguration.response_GetBucketLifecycleConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketLocationRequest.h>
>>>


implement _GetBucketLocation.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketLocationOutput` output;

       `txid_t` txid;
       %`_GetBucketLocation.response_GetBucketLocationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketLocation.response_GetBucketLocationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketLocationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketLocationOutcome outcome = s3_client->GetBucketLocation(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketLocationOutput` res;
        res._LocationConstraint_ = result.GetLocationConstraint().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketLocation.response_GetBucketLocationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketLoggingRequest.h>
>>>


implement _GetBucketLogging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketLoggingOutput` output;

       `txid_t` txid;
       %`_GetBucketLogging.response_GetBucketLoggingOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketLogging.response_GetBucketLoggingOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketLoggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketLoggingOutcome outcome = s3_client->GetBucketLogging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketLoggingOutput` res;
        res._LoggingEnabled_ = result.GetLoggingEnabled();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketLogging.response_GetBucketLoggingOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketMetricsConfigurationRequest.h>
>>>


implement _GetBucketMetricsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketMetricsConfigurationOutput` output;

       `txid_t` txid;
       %`_GetBucketMetricsConfiguration.response_GetBucketMetricsConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketMetricsConfiguration.response_GetBucketMetricsConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketMetricsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketMetricsConfigurationOutcome outcome = s3_client->GetBucketMetricsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketMetricsConfigurationOutput` res;
        res._MetricsConfiguration_ = result.GetMetricsConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketMetricsConfiguration.response_GetBucketMetricsConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


implement _GetBucketNotification.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_NotificationConfigurationDeprecated` output;

       `txid_t` txid;
       %`_GetBucketNotification.response_NotificationConfigurationDeprecated` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketNotification.response_NotificationConfigurationDeprecated` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketNotificationConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketNotificationOutcome outcome = s3_client->GetBucketNotification(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_NotificationConfigurationDeprecated` res;
        res._TopicConfiguration_ = result.GetTopicConfiguration();
        res._QueueConfiguration_ = result.GetQueueConfiguration();
        res._CloudFunctionConfiguration_ = result.GetCloudFunctionConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketNotification.response_NotificationConfigurationDeprecated`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketNotificationConfigurationRequest.h>
>>>


implement _GetBucketNotificationConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_NotificationConfiguration` output;

       `txid_t` txid;
       %`_GetBucketNotificationConfiguration.response_NotificationConfiguration` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketNotificationConfiguration.response_NotificationConfiguration` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketNotificationConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketNotificationConfigurationOutcome outcome = s3_client->GetBucketNotificationConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_NotificationConfiguration` res;
        for (auto it = result.GetTopicConfigurations().begin(), en = result.GetTopicConfigurations().end(); it != en; ++it) { res._TopicConfigurations_.resize(res._TopicConfigurations_.size()+1); res._TopicConfigurations_.back().first = it->first.c_str(); res._TopicConfigurations_.back().second = it->second.c_str(); } 
        for (auto it = result.GetQueueConfigurations().begin(), en = result.GetQueueConfigurations().end(); it != en; ++it) { res._QueueConfigurations_.resize(res._QueueConfigurations_.size()+1); res._QueueConfigurations_.back().first = it->first.c_str(); res._QueueConfigurations_.back().second = it->second.c_str(); } 
        for (auto it = result.GetLambdaFunctionConfigurations().begin(), en = result.GetLambdaFunctionConfigurations().end(); it != en; ++it) { res._LambdaFunctionConfigurations_.resize(res._LambdaFunctionConfigurations_.size()+1); res._LambdaFunctionConfigurations_.back().first = it->first.c_str(); res._LambdaFunctionConfigurations_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketNotificationConfiguration.response_NotificationConfiguration`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketOwnershipControlsRequest.h>
>>>


implement _GetBucketOwnershipControls.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketOwnershipControlsOutput` output;

       `txid_t` txid;
       %`_GetBucketOwnershipControls.response_GetBucketOwnershipControlsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketOwnershipControls.response_GetBucketOwnershipControlsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketOwnershipControlsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketOwnershipControlsOutcome outcome = s3_client->GetBucketOwnershipControls(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketOwnershipControlsOutput` res;
        res._OwnershipControls_ = result.GetOwnershipControls();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketOwnershipControls.response_GetBucketOwnershipControlsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketPolicyRequest.h>
>>>


implement _GetBucketPolicy.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketPolicyOutput` output;

       `txid_t` txid;
       %`_GetBucketPolicy.response_GetBucketPolicyOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketPolicy.response_GetBucketPolicyOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketPolicyRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketPolicyOutcome outcome = s3_client->GetBucketPolicy(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketPolicyOutput` res;
        res._Policy_ = result.GetPolicy().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketPolicy.response_GetBucketPolicyOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketPolicyStatusRequest.h>
>>>


implement _GetBucketPolicyStatus.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketPolicyStatusOutput` output;

       `txid_t` txid;
       %`_GetBucketPolicyStatus.response_GetBucketPolicyStatusOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketPolicyStatus.response_GetBucketPolicyStatusOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketPolicyStatusRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketPolicyStatusOutcome outcome = s3_client->GetBucketPolicyStatus(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketPolicyStatusOutput` res;
        res._PolicyStatus_ = result.GetPolicyStatus();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketPolicyStatus.response_GetBucketPolicyStatusOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketReplicationRequest.h>
>>>


implement _GetBucketReplication.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketReplicationOutput` output;

       `txid_t` txid;
       %`_GetBucketReplication.response_GetBucketReplicationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketReplication.response_GetBucketReplicationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketReplicationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketReplicationOutcome outcome = s3_client->GetBucketReplication(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketReplicationOutput` res;
        res._ReplicationConfiguration_ = result.GetReplicationConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketReplication.response_GetBucketReplicationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketRequestPaymentRequest.h>
>>>


implement _GetBucketRequestPayment.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketRequestPaymentOutput` output;

       `txid_t` txid;
       %`_GetBucketRequestPayment.response_GetBucketRequestPaymentOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketRequestPayment.response_GetBucketRequestPaymentOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketRequestPaymentRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketRequestPaymentOutcome outcome = s3_client->GetBucketRequestPayment(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketRequestPaymentOutput` res;
        res._Payer_ = result.GetPayer().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketRequestPayment.response_GetBucketRequestPaymentOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketTaggingRequest.h>
>>>


implement _GetBucketTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketTaggingOutput` output;

       `txid_t` txid;
       %`_GetBucketTagging.response_GetBucketTaggingOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketTagging.response_GetBucketTaggingOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketTaggingOutcome outcome = s3_client->GetBucketTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketTaggingOutput` res;
        for (auto it = result.GetTagSet().begin(), en = result.GetTagSet().end(); it != en; ++it) { res._TagSet_.resize(res._TagSet_.size()+1); res._TagSet_.back().first = it->first.c_str(); res._TagSet_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketTagging.response_GetBucketTaggingOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketVersioningRequest.h>
>>>


implement _GetBucketVersioning.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketVersioningOutput` output;

       `txid_t` txid;
       %`_GetBucketVersioning.response_GetBucketVersioningOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketVersioning.response_GetBucketVersioningOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketVersioningRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketVersioningOutcome outcome = s3_client->GetBucketVersioning(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketVersioningOutput` res;
        res._Status_ = result.GetStatus().c_str();
        res._MFADelete_ = result.GetMFADelete().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketVersioning.response_GetBucketVersioningOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetBucketWebsiteRequest.h>
>>>


implement _GetBucketWebsite.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetBucketWebsiteOutput` output;

       `txid_t` txid;
       %`_GetBucketWebsite.response_GetBucketWebsiteOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetBucketWebsite.response_GetBucketWebsiteOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetBucketWebsiteRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetBucketWebsiteOutcome outcome = s3_client->GetBucketWebsite(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetBucketWebsiteOutput` res;
        res._RedirectAllRequestsTo_ = result.GetRedirectAllRequestsTo();
        res._IndexDocument_ = result.GetIndexDocument();
        res._ErrorDocument_ = result.GetErrorDocument();
        for (auto it = result.GetRoutingRules().begin(), en = result.GetRoutingRules().end(); it != en; ++it) { res._RoutingRules_.resize(res._RoutingRules_.size()+1); res._RoutingRules_.back().first = it->first.c_str(); res._RoutingRules_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetBucketWebsite.response_GetBucketWebsiteOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectRequest.h>
>>>


implement _GetObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectOutput` output;

       `txid_t` txid;
       %`_GetObject.response_GetObjectOutput` cb;
        %`_GetObject.response_NoSuchKey` err0;
        %`_GetObject.response_InvalidObjectState` err1;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObject.response_GetObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_GetObject.response_NoSuchKey` err0,%`_GetObject.response_InvalidObjectState` err1 ) : ivy(ivy),txid(txid),cb(cb),err0(err0),err1(err1) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchKey" == errcode.GetExceptionName()) {`_NoSuchKey` thing; err0(txid,thing);}
if ("InvalidObjectState" == errcode.GetExceptionName()) {`_InvalidObjectState` thing; err1(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._IfMatch_.size()) {
        request.SetIfMatch(input._IfMatch_[0].c_str());
    }
    if (input._IfModifiedSince_.size()) {
        request.SetIfModifiedSince(Aws::Utils::DateTime((int64_t)input._IfModifiedSince_[0]));
    }
    if (input._IfNoneMatch_.size()) {
        request.SetIfNoneMatch(input._IfNoneMatch_[0].c_str());
    }
    if (input._IfUnmodifiedSince_.size()) {
        request.SetIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._IfUnmodifiedSince_[0]));
    }
    request.SetKey(input._Key_.c_str());
    if (input._Range_.size()) {
        request.SetRange(input._Range_[0].c_str());
    }
    if (input._ResponseCacheControl_.size()) {
        request.SetResponseCacheControl(input._ResponseCacheControl_[0].c_str());
    }
    if (input._ResponseContentDisposition_.size()) {
        request.SetResponseContentDisposition(input._ResponseContentDisposition_[0].c_str());
    }
    if (input._ResponseContentEncoding_.size()) {
        request.SetResponseContentEncoding(input._ResponseContentEncoding_[0].c_str());
    }
    if (input._ResponseContentLanguage_.size()) {
        request.SetResponseContentLanguage(input._ResponseContentLanguage_[0].c_str());
    }
    if (input._ResponseContentType_.size()) {
        request.SetResponseContentType(input._ResponseContentType_[0].c_str());
    }
    if (input._ResponseExpires_.size()) {
        request.SetResponseExpires(Aws::Utils::DateTime((int64_t)input._ResponseExpires_[0]));
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._PartNumber_.size()) {
        request.SetPartNumber(input._PartNumber_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectOutcome outcome = s3_client->GetObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectOutput` res;
        { char c; while (result.GetBody().get(c)) res._Body_.push_back(((int)c)&0xff);}        res._DeleteMarker_ = result.GetDeleteMarker();
        res._AcceptRanges_ = result.GetAcceptRanges().c_str();
        res._Expiration_ = result.GetExpiration().c_str();
        res._Restore_ = result.GetRestore().c_str();
        res._LastModified_ = result.GetLastModified().Millis();
        res._ContentLength_ = result.GetContentLength();
        res._ETag_ = result.GetETag().c_str();
        res._MissingMeta_ = result.GetMissingMeta();
        res._VersionId_ = result.GetVersionId().c_str();
        res._CacheControl_ = result.GetCacheControl().c_str();
        res._ContentDisposition_ = result.GetContentDisposition().c_str();
        res._ContentEncoding_ = result.GetContentEncoding().c_str();
        res._ContentLanguage_ = result.GetContentLanguage().c_str();
        res._ContentRange_ = result.GetContentRange().c_str();
        res._ContentType_ = result.GetContentType().c_str();
        res._Expires_ = result.GetExpires().Millis();
        res._WebsiteRedirectLocation_ = result.GetWebsiteRedirectLocation().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        for (auto it = result.GetMetadata().begin(), en = result.GetMetadata().end(); it != en; ++it) { res._Metadata_.resize(res._Metadata_.size()+1); res._Metadata_.back().first = it->first.c_str(); res._Metadata_.back().second = it->second.c_str(); } 
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._StorageClass_ = Aws::S3::Model::StorageClassMapper::GetNameForStorageClass(result.GetStorageClass()).c_str();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        res._ReplicationStatus_ = Aws::S3::Model::ReplicationStatusMapper::GetNameForReplicationStatus(result.GetReplicationStatus()).c_str();
        res._PartsCount_ = result.GetPartsCount();
        res._TagCount_ = result.GetTagCount();
        res._ObjectLockMode_ = Aws::S3::Model::ObjectLockModeMapper::GetNameForObjectLockMode(result.GetObjectLockMode()).c_str();
        res._ObjectLockRetainUntilDate_ = result.GetObjectLockRetainUntilDate().Millis();
        res._ObjectLockLegalHoldStatus_ = Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetNameForObjectLockLegalHoldStatus(result.GetObjectLockLegalHoldStatus()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObject.response_GetObjectOutput`,func,`_GetObject.response_NoSuchKey`,`_GetObject.response_InvalidObjectState`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectAclRequest.h>
>>>


implement _GetObjectAcl.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectAclOutput` output;

       `txid_t` txid;
       %`_GetObjectAcl.response_GetObjectAclOutput` cb;
        %`_GetObjectAcl.response_NoSuchKey` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectAcl.response_GetObjectAclOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_GetObjectAcl.response_NoSuchKey` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchKey" == errcode.GetExceptionName()) {`_NoSuchKey` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectAclRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectAclOutcome outcome = s3_client->GetObjectAcl(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectAclOutput` res;
        res._Owner_ = result.GetOwner();
        for (auto it = result.GetGrants().begin(), en = result.GetGrants().end(); it != en; ++it) { res._Grants_.resize(res._Grants_.size()+1); res._Grants_.back().first = it->first.c_str(); res._Grants_.back().second = it->second.c_str(); } 
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectAcl.response_GetObjectAclOutput`,func,`_GetObjectAcl.response_NoSuchKey`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectLegalHoldRequest.h>
>>>


implement _GetObjectLegalHold.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectLegalHoldOutput` output;

       `txid_t` txid;
       %`_GetObjectLegalHold.response_GetObjectLegalHoldOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectLegalHold.response_GetObjectLegalHoldOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectLegalHoldRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectLegalHoldOutcome outcome = s3_client->GetObjectLegalHold(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectLegalHoldOutput` res;
        res._LegalHold_ = result.GetLegalHold();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectLegalHold.response_GetObjectLegalHoldOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectLockConfigurationRequest.h>
>>>


implement _GetObjectLockConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectLockConfigurationOutput` output;

       `txid_t` txid;
       %`_GetObjectLockConfiguration.response_GetObjectLockConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectLockConfiguration.response_GetObjectLockConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectLockConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectLockConfigurationOutcome outcome = s3_client->GetObjectLockConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectLockConfigurationOutput` res;
        res._ObjectLockConfiguration_ = result.GetObjectLockConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectLockConfiguration.response_GetObjectLockConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectRetentionRequest.h>
>>>


implement _GetObjectRetention.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectRetentionOutput` output;

       `txid_t` txid;
       %`_GetObjectRetention.response_GetObjectRetentionOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectRetention.response_GetObjectRetentionOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectRetentionRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectRetentionOutcome outcome = s3_client->GetObjectRetention(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectRetentionOutput` res;
        res._Retention_ = result.GetRetention();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectRetention.response_GetObjectRetentionOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectTaggingRequest.h>
>>>


implement _GetObjectTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectTaggingOutput` output;

       `txid_t` txid;
       %`_GetObjectTagging.response_GetObjectTaggingOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectTagging.response_GetObjectTaggingOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectTaggingOutcome outcome = s3_client->GetObjectTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectTaggingOutput` res;
        if (result.VersionIdHasBeenSet()) {
            out_fld.resize(1);
            res._VersionId_[0] = result.GetVersionId().c_str();
        }
        for (auto it = result.GetTagSet().begin(), en = result.GetTagSet().end(); it != en; ++it) { res._TagSet_.resize(res._TagSet_.size()+1); res._TagSet_.back().first = it->first.c_str(); res._TagSet_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectTagging.response_GetObjectTaggingOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetObjectTorrentRequest.h>
>>>


implement _GetObjectTorrent.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetObjectTorrentOutput` output;

       `txid_t` txid;
       %`_GetObjectTorrent.response_GetObjectTorrentOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetObjectTorrent.response_GetObjectTorrentOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetObjectTorrentRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetObjectTorrentOutcome outcome = s3_client->GetObjectTorrent(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetObjectTorrentOutput` res;
        { char c; while (result.GetBody().get(c)) res._Body_.push_back(((int)c)&0xff);}        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetObjectTorrent.response_GetObjectTorrentOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/GetPublicAccessBlockRequest.h>
>>>


implement _GetPublicAccessBlock.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_GetPublicAccessBlockOutput` output;

       `txid_t` txid;
       %`_GetPublicAccessBlock.response_GetPublicAccessBlockOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_GetPublicAccessBlock.response_GetPublicAccessBlockOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::GetPublicAccessBlockRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::GetPublicAccessBlockOutcome outcome = s3_client->GetPublicAccessBlock(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_GetPublicAccessBlockOutput` res;
        res._PublicAccessBlockConfiguration_ = result.GetPublicAccessBlockConfiguration();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_GetPublicAccessBlock.response_GetPublicAccessBlockOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/HeadBucketRequest.h>
>>>


implement _HeadBucket.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_HeadBucket.response` cb;
        %`_HeadBucket.response_NoSuchBucket` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_HeadBucket.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_HeadBucket.response_NoSuchBucket` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchBucket" == errcode.GetExceptionName()) {`_NoSuchBucket` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::HeadBucketRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::HeadBucketOutcome outcome = s3_client->HeadBucket(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_HeadBucket.response`,func,`_HeadBucket.response_NoSuchBucket`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/HeadObjectRequest.h>
>>>


implement _HeadObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_HeadObjectOutput` output;

       `txid_t` txid;
       %`_HeadObject.response_HeadObjectOutput` cb;
        %`_HeadObject.response_NoSuchKey` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_HeadObject.response_HeadObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_HeadObject.response_NoSuchKey` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchKey" == errcode.GetExceptionName()) {`_NoSuchKey` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::HeadObjectRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._IfMatch_.size()) {
        request.SetIfMatch(input._IfMatch_[0].c_str());
    }
    if (input._IfModifiedSince_.size()) {
        request.SetIfModifiedSince(Aws::Utils::DateTime((int64_t)input._IfModifiedSince_[0]));
    }
    if (input._IfNoneMatch_.size()) {
        request.SetIfNoneMatch(input._IfNoneMatch_[0].c_str());
    }
    if (input._IfUnmodifiedSince_.size()) {
        request.SetIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._IfUnmodifiedSince_[0]));
    }
    request.SetKey(input._Key_.c_str());
    if (input._Range_.size()) {
        request.SetRange(input._Range_[0].c_str());
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._PartNumber_.size()) {
        request.SetPartNumber(input._PartNumber_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::HeadObjectOutcome outcome = s3_client->HeadObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_HeadObjectOutput` res;
        res._DeleteMarker_ = result.GetDeleteMarker();
        res._AcceptRanges_ = result.GetAcceptRanges().c_str();
        res._Expiration_ = result.GetExpiration().c_str();
        res._Restore_ = result.GetRestore().c_str();
        res._ArchiveStatus_ = result.GetArchiveStatus().c_str();
        res._LastModified_ = result.GetLastModified().Millis();
        res._ContentLength_ = result.GetContentLength();
        res._ETag_ = result.GetETag().c_str();
        res._MissingMeta_ = result.GetMissingMeta();
        res._VersionId_ = result.GetVersionId().c_str();
        res._CacheControl_ = result.GetCacheControl().c_str();
        res._ContentDisposition_ = result.GetContentDisposition().c_str();
        res._ContentEncoding_ = result.GetContentEncoding().c_str();
        res._ContentLanguage_ = result.GetContentLanguage().c_str();
        res._ContentType_ = result.GetContentType().c_str();
        res._Expires_ = result.GetExpires().Millis();
        res._WebsiteRedirectLocation_ = result.GetWebsiteRedirectLocation().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        for (auto it = result.GetMetadata().begin(), en = result.GetMetadata().end(); it != en; ++it) { res._Metadata_.resize(res._Metadata_.size()+1); res._Metadata_.back().first = it->first.c_str(); res._Metadata_.back().second = it->second.c_str(); } 
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._StorageClass_ = Aws::S3::Model::StorageClassMapper::GetNameForStorageClass(result.GetStorageClass()).c_str();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        res._ReplicationStatus_ = Aws::S3::Model::ReplicationStatusMapper::GetNameForReplicationStatus(result.GetReplicationStatus()).c_str();
        res._PartsCount_ = result.GetPartsCount();
        res._ObjectLockMode_ = Aws::S3::Model::ObjectLockModeMapper::GetNameForObjectLockMode(result.GetObjectLockMode()).c_str();
        res._ObjectLockRetainUntilDate_ = result.GetObjectLockRetainUntilDate().Millis();
        res._ObjectLockLegalHoldStatus_ = Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetNameForObjectLockLegalHoldStatus(result.GetObjectLockLegalHoldStatus()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_HeadObject.response_HeadObjectOutput`,func,`_HeadObject.response_NoSuchKey`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListBucketAnalyticsConfigurationsRequest.h>
>>>


implement _ListBucketAnalyticsConfigurations.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListBucketAnalyticsConfigurationsOutput` output;

       `txid_t` txid;
       %`_ListBucketAnalyticsConfigurations.response_ListBucketAnalyticsConfigurationsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListBucketAnalyticsConfigurations.response_ListBucketAnalyticsConfigurationsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListBucketAnalyticsConfigurationsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContinuationToken_.size()) {
        request.SetContinuationToken(input._ContinuationToken_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListBucketAnalyticsConfigurationsOutcome outcome = s3_client->ListBucketAnalyticsConfigurations(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListBucketAnalyticsConfigurationsOutput` res;
        res._IsTruncated_ = result.GetIsTruncated();
        res._ContinuationToken_ = result.GetContinuationToken().c_str();
        res._NextContinuationToken_ = result.GetNextContinuationToken().c_str();
        for (auto it = result.GetAnalyticsConfigurationList().begin(), en = result.GetAnalyticsConfigurationList().end(); it != en; ++it) { res._AnalyticsConfigurationList_.resize(res._AnalyticsConfigurationList_.size()+1); res._AnalyticsConfigurationList_.back().first = it->first.c_str(); res._AnalyticsConfigurationList_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListBucketAnalyticsConfigurations.response_ListBucketAnalyticsConfigurationsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListBucketIntelligentTieringConfigurationsRequest.h>
>>>


implement _ListBucketIntelligentTieringConfigurations.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListBucketIntelligentTieringConfigurationsOutput` output;

       `txid_t` txid;
       %`_ListBucketIntelligentTieringConfigurations.response_ListBucketIntelligentTieringConfigurationsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListBucketIntelligentTieringConfigurations.response_ListBucketIntelligentTieringConfigurationsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListBucketIntelligentTieringConfigurationsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContinuationToken_.size()) {
        request.SetContinuationToken(input._ContinuationToken_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListBucketIntelligentTieringConfigurationsOutcome outcome = s3_client->ListBucketIntelligentTieringConfigurations(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListBucketIntelligentTieringConfigurationsOutput` res;
        res._IsTruncated_ = result.GetIsTruncated();
        res._ContinuationToken_ = result.GetContinuationToken().c_str();
        res._NextContinuationToken_ = result.GetNextContinuationToken().c_str();
        for (auto it = result.GetIntelligentTieringConfigurationList().begin(), en = result.GetIntelligentTieringConfigurationList().end(); it != en; ++it) { res._IntelligentTieringConfigurationList_.resize(res._IntelligentTieringConfigurationList_.size()+1); res._IntelligentTieringConfigurationList_.back().first = it->first.c_str(); res._IntelligentTieringConfigurationList_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListBucketIntelligentTieringConfigurations.response_ListBucketIntelligentTieringConfigurationsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListBucketInventoryConfigurationsRequest.h>
>>>


implement _ListBucketInventoryConfigurations.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListBucketInventoryConfigurationsOutput` output;

       `txid_t` txid;
       %`_ListBucketInventoryConfigurations.response_ListBucketInventoryConfigurationsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListBucketInventoryConfigurations.response_ListBucketInventoryConfigurationsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListBucketInventoryConfigurationsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContinuationToken_.size()) {
        request.SetContinuationToken(input._ContinuationToken_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListBucketInventoryConfigurationsOutcome outcome = s3_client->ListBucketInventoryConfigurations(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListBucketInventoryConfigurationsOutput` res;
        res._ContinuationToken_ = result.GetContinuationToken().c_str();
        for (auto it = result.GetInventoryConfigurationList().begin(), en = result.GetInventoryConfigurationList().end(); it != en; ++it) { res._InventoryConfigurationList_.resize(res._InventoryConfigurationList_.size()+1); res._InventoryConfigurationList_.back().first = it->first.c_str(); res._InventoryConfigurationList_.back().second = it->second.c_str(); } 
        res._IsTruncated_ = result.GetIsTruncated();
        res._NextContinuationToken_ = result.GetNextContinuationToken().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListBucketInventoryConfigurations.response_ListBucketInventoryConfigurationsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListBucketMetricsConfigurationsRequest.h>
>>>


implement _ListBucketMetricsConfigurations.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListBucketMetricsConfigurationsOutput` output;

       `txid_t` txid;
       %`_ListBucketMetricsConfigurations.response_ListBucketMetricsConfigurationsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListBucketMetricsConfigurations.response_ListBucketMetricsConfigurationsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListBucketMetricsConfigurationsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContinuationToken_.size()) {
        request.SetContinuationToken(input._ContinuationToken_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListBucketMetricsConfigurationsOutcome outcome = s3_client->ListBucketMetricsConfigurations(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListBucketMetricsConfigurationsOutput` res;
        res._IsTruncated_ = result.GetIsTruncated();
        res._ContinuationToken_ = result.GetContinuationToken().c_str();
        res._NextContinuationToken_ = result.GetNextContinuationToken().c_str();
        for (auto it = result.GetMetricsConfigurationList().begin(), en = result.GetMetricsConfigurationList().end(); it != en; ++it) { res._MetricsConfigurationList_.resize(res._MetricsConfigurationList_.size()+1); res._MetricsConfigurationList_.back().first = it->first.c_str(); res._MetricsConfigurationList_.back().second = it->second.c_str(); } 
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListBucketMetricsConfigurations.response_ListBucketMetricsConfigurationsOutput`,func);
        install_reader(rdr);
            >>>
}


implement _ListBuckets.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListBucketsOutput` output;

       `txid_t` txid;
       %`_ListBuckets.response_ListBucketsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListBuckets.response_ListBucketsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
//std::cout << "about to do request without output" << std::endl;
    Aws::S3::Model::MetricsConfigurationListOutcome outcome = s3_client->MetricsConfigurationList();
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListBucketsOutput` res;
        for (auto it = result.GetBuckets().begin(), en = result.GetBuckets().end(); it != en; ++it) { res._Buckets_.resize(res._Buckets_.size()+1); res._Buckets_.back().first = it->first.c_str(); res._Buckets_.back().second = it->second.c_str(); } 
        res._Owner_ = result.GetOwner();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListBuckets.response_ListBucketsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListMultipartUploadsRequest.h>
>>>


implement _ListMultipartUploads.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListMultipartUploadsOutput` output;

       `txid_t` txid;
       %`_ListMultipartUploads.response_ListMultipartUploadsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListMultipartUploads.response_ListMultipartUploadsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListMultipartUploadsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._Delimiter_.size()) {
        request.SetDelimiter(input._Delimiter_[0].c_str());
    }
    if (input._EncodingType_.size()) {
        request.SetEncodingType(input._EncodingType_[0].c_str());
    }
    if (input._KeyMarker_.size()) {
        request.SetKeyMarker(input._KeyMarker_[0].c_str());
    }
    if (input._MaxUploads_.size()) {
        request.SetMaxUploads(input._MaxUploads_[0]);
    }
    if (input._Prefix_.size()) {
        request.SetPrefix(input._Prefix_[0].c_str());
    }
    if (input._UploadIdMarker_.size()) {
        request.SetUploadIdMarker(input._UploadIdMarker_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListMultipartUploadsOutcome outcome = s3_client->ListMultipartUploads(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListMultipartUploadsOutput` res;
        res._Bucket_ = result.GetBucket().c_str();
        res._KeyMarker_ = result.GetKeyMarker().c_str();
        res._UploadIdMarker_ = result.GetUploadIdMarker().c_str();
        res._NextKeyMarker_ = result.GetNextKeyMarker().c_str();
        res._Prefix_ = result.GetPrefix().c_str();
        res._Delimiter_ = result.GetDelimiter().c_str();
        res._NextUploadIdMarker_ = result.GetNextUploadIdMarker().c_str();
        res._MaxUploads_ = result.GetMaxUploads();
        res._IsTruncated_ = result.GetIsTruncated();
        for (auto it = result.GetUploads().begin(), en = result.GetUploads().end(); it != en; ++it) { res._Uploads_.resize(res._Uploads_.size()+1); res._Uploads_.back().first = it->first.c_str(); res._Uploads_.back().second = it->second.c_str(); } 
        for (auto it = result.GetCommonPrefixes().begin(), en = result.GetCommonPrefixes().end(); it != en; ++it) { res._CommonPrefixes_.resize(res._CommonPrefixes_.size()+1); res._CommonPrefixes_.back().first = it->first.c_str(); res._CommonPrefixes_.back().second = it->second.c_str(); } 
        res._EncodingType_ = result.GetEncodingType().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListMultipartUploads.response_ListMultipartUploadsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListObjectVersionsRequest.h>
>>>


implement _ListObjectVersions.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListObjectVersionsOutput` output;

       `txid_t` txid;
       %`_ListObjectVersions.response_ListObjectVersionsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListObjectVersions.response_ListObjectVersionsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListObjectVersionsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._Delimiter_.size()) {
        request.SetDelimiter(input._Delimiter_[0].c_str());
    }
    if (input._EncodingType_.size()) {
        request.SetEncodingType(input._EncodingType_[0].c_str());
    }
    if (input._KeyMarker_.size()) {
        request.SetKeyMarker(input._KeyMarker_[0].c_str());
    }
    if (input._MaxKeys_.size()) {
        request.SetMaxKeys(input._MaxKeys_[0]);
    }
    if (input._Prefix_.size()) {
        request.SetPrefix(input._Prefix_[0].c_str());
    }
    if (input._VersionIdMarker_.size()) {
        request.SetVersionIdMarker(input._VersionIdMarker_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListObjectVersionsOutcome outcome = s3_client->ListObjectVersions(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListObjectVersionsOutput` res;
        res._IsTruncated_ = result.GetIsTruncated();
        res._KeyMarker_ = result.GetKeyMarker().c_str();
        res._VersionIdMarker_ = result.GetVersionIdMarker().c_str();
        res._NextKeyMarker_ = result.GetNextKeyMarker().c_str();
        res._NextVersionIdMarker_ = result.GetNextVersionIdMarker().c_str();
        for (auto it = result.GetVersions().begin(), en = result.GetVersions().end(); it != en; ++it) { res._Versions_.resize(res._Versions_.size()+1); res._Versions_.back().first = it->first.c_str(); res._Versions_.back().second = it->second.c_str(); } 
        for (auto it = result.GetDeleteMarkers().begin(), en = result.GetDeleteMarkers().end(); it != en; ++it) { res._DeleteMarkers_.resize(res._DeleteMarkers_.size()+1); res._DeleteMarkers_.back().first = it->first.c_str(); res._DeleteMarkers_.back().second = it->second.c_str(); } 
        res._Name_ = result.GetName().c_str();
        res._Prefix_ = result.GetPrefix().c_str();
        res._Delimiter_ = result.GetDelimiter().c_str();
        res._MaxKeys_ = result.GetMaxKeys();
        for (auto it = result.GetCommonPrefixes().begin(), en = result.GetCommonPrefixes().end(); it != en; ++it) { res._CommonPrefixes_.resize(res._CommonPrefixes_.size()+1); res._CommonPrefixes_.back().first = it->first.c_str(); res._CommonPrefixes_.back().second = it->second.c_str(); } 
        res._EncodingType_ = result.GetEncodingType().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListObjectVersions.response_ListObjectVersionsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListObjectsRequest.h>
>>>


implement _ListObjects.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListObjectsOutput` output;

       `txid_t` txid;
       %`_ListObjects.response_ListObjectsOutput` cb;
        %`_ListObjects.response_NoSuchBucket` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListObjects.response_ListObjectsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_ListObjects.response_NoSuchBucket` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchBucket" == errcode.GetExceptionName()) {`_NoSuchBucket` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListObjectsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._Delimiter_.size()) {
        request.SetDelimiter(input._Delimiter_[0].c_str());
    }
    if (input._EncodingType_.size()) {
        request.SetEncodingType(input._EncodingType_[0].c_str());
    }
    if (input._Marker_.size()) {
        request.SetMarker(input._Marker_[0].c_str());
    }
    if (input._MaxKeys_.size()) {
        request.SetMaxKeys(input._MaxKeys_[0]);
    }
    if (input._Prefix_.size()) {
        request.SetPrefix(input._Prefix_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListObjectsOutcome outcome = s3_client->ListObjects(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListObjectsOutput` res;
        res._IsTruncated_ = result.GetIsTruncated();
        res._Marker_ = result.GetMarker().c_str();
        res._NextMarker_ = result.GetNextMarker().c_str();
        for (auto it = result.GetContents().begin(), en = result.GetContents().end(); it != en; ++it) { res._Contents_.resize(res._Contents_.size()+1); res._Contents_.back().first = it->first.c_str(); res._Contents_.back().second = it->second.c_str(); } 
        res._Name_ = result.GetName().c_str();
        res._Prefix_ = result.GetPrefix().c_str();
        res._Delimiter_ = result.GetDelimiter().c_str();
        res._MaxKeys_ = result.GetMaxKeys();
        for (auto it = result.GetCommonPrefixes().begin(), en = result.GetCommonPrefixes().end(); it != en; ++it) { res._CommonPrefixes_.resize(res._CommonPrefixes_.size()+1); res._CommonPrefixes_.back().first = it->first.c_str(); res._CommonPrefixes_.back().second = it->second.c_str(); } 
        res._EncodingType_ = result.GetEncodingType().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListObjects.response_ListObjectsOutput`,func,`_ListObjects.response_NoSuchBucket`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListObjectsV2Request.h>
>>>


implement _ListObjectsV2.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListObjectsV2Output` output;

       `txid_t` txid;
       %`_ListObjectsV2.response_ListObjectsV2Output` cb;
        %`_ListObjectsV2.response_NoSuchBucket` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListObjectsV2.response_ListObjectsV2Output` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_ListObjectsV2.response_NoSuchBucket` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchBucket" == errcode.GetExceptionName()) {`_NoSuchBucket` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListObjectsV2Request request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._Delimiter_.size()) {
        request.SetDelimiter(input._Delimiter_[0].c_str());
    }
    if (input._EncodingType_.size()) {
        request.SetEncodingType(input._EncodingType_[0].c_str());
    }
    if (input._MaxKeys_.size()) {
        request.SetMaxKeys(input._MaxKeys_[0]);
    }
    if (input._Prefix_.size()) {
        request.SetPrefix(input._Prefix_[0].c_str());
    }
    if (input._ContinuationToken_.size()) {
        request.SetContinuationToken(input._ContinuationToken_[0].c_str());
    }
    if (input._FetchOwner_.size()) {
        request.SetFetchOwner(input._FetchOwner_[0]);
    }
    if (input._StartAfter_.size()) {
        request.SetStartAfter(input._StartAfter_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListObjectsV2Outcome outcome = s3_client->ListObjectsV2(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListObjectsV2Output` res;
        res._IsTruncated_ = result.GetIsTruncated();
        for (auto it = result.GetContents().begin(), en = result.GetContents().end(); it != en; ++it) { res._Contents_.resize(res._Contents_.size()+1); res._Contents_.back().first = it->first.c_str(); res._Contents_.back().second = it->second.c_str(); } 
        res._Name_ = result.GetName().c_str();
        res._Prefix_ = result.GetPrefix().c_str();
        res._Delimiter_ = result.GetDelimiter().c_str();
        res._MaxKeys_ = result.GetMaxKeys();
        for (auto it = result.GetCommonPrefixes().begin(), en = result.GetCommonPrefixes().end(); it != en; ++it) { res._CommonPrefixes_.resize(res._CommonPrefixes_.size()+1); res._CommonPrefixes_.back().first = it->first.c_str(); res._CommonPrefixes_.back().second = it->second.c_str(); } 
        res._EncodingType_ = result.GetEncodingType().c_str();
        res._KeyCount_ = result.GetKeyCount();
        res._ContinuationToken_ = result.GetContinuationToken().c_str();
        res._NextContinuationToken_ = result.GetNextContinuationToken().c_str();
        res._StartAfter_ = result.GetStartAfter().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListObjectsV2.response_ListObjectsV2Output`,func,`_ListObjectsV2.response_NoSuchBucket`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/ListPartsRequest.h>
>>>


implement _ListParts.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_ListPartsOutput` output;

       `txid_t` txid;
       %`_ListParts.response_ListPartsOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_ListParts.response_ListPartsOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::ListPartsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._MaxParts_.size()) {
        request.SetMaxParts(input._MaxParts_[0]);
    }
    if (input._PartNumberMarker_.size()) {
        request.SetPartNumberMarker(input._PartNumberMarker_[0]);
    }
    request.SetUploadId(input._UploadId_.c_str());
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::ListPartsOutcome outcome = s3_client->ListParts(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_ListPartsOutput` res;
        res._AbortDate_ = result.GetAbortDate().Millis();
        res._AbortRuleId_ = result.GetAbortRuleId().c_str();
        res._Bucket_ = result.GetBucket().c_str();
        res._Key_ = result.GetKey().c_str();
        res._UploadId_ = result.GetUploadId().c_str();
        res._PartNumberMarker_ = result.GetPartNumberMarker();
        res._NextPartNumberMarker_ = result.GetNextPartNumberMarker();
        res._MaxParts_ = result.GetMaxParts();
        res._IsTruncated_ = result.GetIsTruncated();
        for (auto it = result.GetParts().begin(), en = result.GetParts().end(); it != en; ++it) { res._Parts_.resize(res._Parts_.size()+1); res._Parts_.back().first = it->first.c_str(); res._Parts_.back().second = it->second.c_str(); } 
        res._Initiator_ = result.GetInitiator();
        res._Owner_ = result.GetOwner();
        res._StorageClass_ = Aws::S3::Model::StorageClassMapper::GetNameForStorageClass(result.GetStorageClass()).c_str();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_ListParts.response_ListPartsOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketAccelerateConfigurationRequest.h>
>>>


implement _PutBucketAccelerateConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketAccelerateConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketAccelerateConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketAccelerateConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetAccelerateConfiguration(input._AccelerateConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketAccelerateConfigurationOutcome outcome = s3_client->PutBucketAccelerateConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketAccelerateConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketAclRequest.h>
>>>


implement _PutBucketAcl.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketAcl.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketAcl.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketAclRequest request;
    if (input._ACL_.size()) {
        request.SetACL(input._ACL_[0].c_str());
    }
    if (input._AccessControlPolicy_.size()) {
        request.SetAccessControlPolicy(input._AccessControlPolicy_[0]);
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWrite_.size()) {
        request.SetGrantWrite(input._GrantWrite_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketAclOutcome outcome = s3_client->PutBucketAcl(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketAcl.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketAnalyticsConfigurationRequest.h>
>>>


implement _PutBucketAnalyticsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketAnalyticsConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketAnalyticsConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketAnalyticsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    request.SetAnalyticsConfiguration(input._AnalyticsConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketAnalyticsConfigurationOutcome outcome = s3_client->PutBucketAnalyticsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketAnalyticsConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketCorsRequest.h>
>>>


implement _PutBucketCors.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketCors.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketCors.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketCorsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetCORSConfiguration(input._CORSConfiguration_);
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketCorsOutcome outcome = s3_client->PutBucketCors(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketCors.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketEncryptionRequest.h>
>>>


implement _PutBucketEncryption.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketEncryption.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketEncryption.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketEncryptionRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetServerSideEncryptionConfiguration(input._ServerSideEncryptionConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketEncryptionOutcome outcome = s3_client->PutBucketEncryption(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketEncryption.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketIntelligentTieringConfigurationRequest.h>
>>>


implement _PutBucketIntelligentTieringConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketIntelligentTieringConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketIntelligentTieringConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketIntelligentTieringConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    request.SetIntelligentTieringConfiguration(input._IntelligentTieringConfiguration_);
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketIntelligentTieringConfigurationOutcome outcome = s3_client->PutBucketIntelligentTieringConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketIntelligentTieringConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketInventoryConfigurationRequest.h>
>>>


implement _PutBucketInventoryConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketInventoryConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketInventoryConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketInventoryConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    request.SetInventoryConfiguration(input._InventoryConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketInventoryConfigurationOutcome outcome = s3_client->PutBucketInventoryConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketInventoryConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


implement _PutBucketLifecycle.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketLifecycle.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketLifecycle.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketLifecycleRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._LifecycleConfiguration_.size()) {
        request.SetLifecycleConfiguration(input._LifecycleConfiguration_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketLifecycleOutcome outcome = s3_client->PutBucketLifecycle(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketLifecycle.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketLifecycleConfigurationRequest.h>
>>>


implement _PutBucketLifecycleConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketLifecycleConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketLifecycleConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketLifecycleConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._LifecycleConfiguration_.size()) {
        request.SetLifecycleConfiguration(input._LifecycleConfiguration_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketLifecycleConfigurationOutcome outcome = s3_client->PutBucketLifecycleConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketLifecycleConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketLoggingRequest.h>
>>>


implement _PutBucketLogging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketLogging.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketLogging.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketLoggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetBucketLoggingStatus(input._BucketLoggingStatus_);
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketLoggingOutcome outcome = s3_client->PutBucketLogging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketLogging.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketMetricsConfigurationRequest.h>
>>>


implement _PutBucketMetricsConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketMetricsConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketMetricsConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketMetricsConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetId(input._Id_.c_str());
    request.SetMetricsConfiguration(input._MetricsConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketMetricsConfigurationOutcome outcome = s3_client->PutBucketMetricsConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketMetricsConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


implement _PutBucketNotification.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketNotification.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketNotification.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketNotificationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetNotificationConfiguration(input._NotificationConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketNotificationOutcome outcome = s3_client->PutBucketNotification(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketNotification.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketNotificationConfigurationRequest.h>
>>>


implement _PutBucketNotificationConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketNotificationConfiguration.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketNotificationConfiguration.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketNotificationConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetNotificationConfiguration(input._NotificationConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketNotificationConfigurationOutcome outcome = s3_client->PutBucketNotificationConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketNotificationConfiguration.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketOwnershipControlsRequest.h>
>>>


implement _PutBucketOwnershipControls.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketOwnershipControls.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketOwnershipControls.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketOwnershipControlsRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
    request.SetOwnershipControls(input._OwnershipControls_);
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketOwnershipControlsOutcome outcome = s3_client->PutBucketOwnershipControls(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketOwnershipControls.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketPolicyRequest.h>
>>>


implement _PutBucketPolicy.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketPolicy.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketPolicy.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketPolicyRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ConfirmRemoveSelfBucketAccess_.size()) {
        request.SetConfirmRemoveSelfBucketAccess(input._ConfirmRemoveSelfBucketAccess_[0]);
    }
    request.SetPolicy(input._Policy_.c_str());
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketPolicyOutcome outcome = s3_client->PutBucketPolicy(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketPolicy.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketReplicationRequest.h>
>>>


implement _PutBucketReplication.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketReplication.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketReplication.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketReplicationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetReplicationConfiguration(input._ReplicationConfiguration_);
    if (input._Token_.size()) {
        request.SetToken(input._Token_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketReplicationOutcome outcome = s3_client->PutBucketReplication(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketReplication.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketRequestPaymentRequest.h>
>>>


implement _PutBucketRequestPayment.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketRequestPayment.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketRequestPayment.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketRequestPaymentRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetRequestPaymentConfiguration(input._RequestPaymentConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketRequestPaymentOutcome outcome = s3_client->PutBucketRequestPayment(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketRequestPayment.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketTaggingRequest.h>
>>>


implement _PutBucketTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketTagging.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketTagging.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetTagging(input._Tagging_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketTaggingOutcome outcome = s3_client->PutBucketTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketTagging.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketVersioningRequest.h>
>>>


implement _PutBucketVersioning.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketVersioning.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketVersioning.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketVersioningRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._MFA_.size()) {
        request.SetMFA(input._MFA_[0].c_str());
    }
    request.SetVersioningConfiguration(input._VersioningConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketVersioningOutcome outcome = s3_client->PutBucketVersioning(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketVersioning.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutBucketWebsiteRequest.h>
>>>


implement _PutBucketWebsite.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutBucketWebsite.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutBucketWebsite.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutBucketWebsiteRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetWebsiteConfiguration(input._WebsiteConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutBucketWebsiteOutcome outcome = s3_client->PutBucketWebsite(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutBucketWebsite.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectRequest.h>
>>>


implement _PutObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectOutput` output;

       `txid_t` txid;
       %`_PutObject.response_PutObjectOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObject.response_PutObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectRequest request;
    if (input._ACL_.size()) {
        request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
    }
    if (input._Body_.size()) {
        request.SetBody(blob_to_iostream(input._Body_[0]));
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._CacheControl_.size()) {
        request.SetCacheControl(input._CacheControl_[0].c_str());
    }
    if (input._ContentDisposition_.size()) {
        request.SetContentDisposition(input._ContentDisposition_[0].c_str());
    }
    if (input._ContentEncoding_.size()) {
        request.SetContentEncoding(input._ContentEncoding_[0].c_str());
    }
    if (input._ContentLanguage_.size()) {
        request.SetContentLanguage(input._ContentLanguage_[0].c_str());
    }
    if (input._ContentLength_.size()) {
        request.SetContentLength(input._ContentLength_[0]);
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ContentType_.size()) {
        request.SetContentType(input._ContentType_[0].c_str());
    }
    if (input._Expires_.size()) {
        request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    if (input._Metadata_.size()) {
        request.SetMetadata(map_to_aws(input._Metadata_[0]));
    }
    if (input._ServerSideEncryption_.size()) {
        request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
    }
    if (input._StorageClass_.size()) {
        request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
    }
    if (input._WebsiteRedirectLocation_.size()) {
        request.SetWebsiteRedirectLocation(input._WebsiteRedirectLocation_[0].c_str());
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._SSEKMSKeyId_.size()) {
        request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
    }
    if (input._SSEKMSEncryptionContext_.size()) {
        request.SetSSEKMSEncryptionContext(input._SSEKMSEncryptionContext_[0].c_str());
    }
    if (input._BucketKeyEnabled_.size()) {
        request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._Tagging_.size()) {
        request.SetTagging(input._Tagging_[0].c_str());
    }
    if (input._ObjectLockMode_.size()) {
        request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
    }
    if (input._ObjectLockRetainUntilDate_.size()) {
        request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
    }
    if (input._ObjectLockLegalHoldStatus_.size()) {
        request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectOutcome outcome = s3_client->PutObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectOutput` res;
        res._Expiration_ = result.GetExpiration().c_str();
        res._ETag_ = result.GetETag().c_str();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._VersionId_ = result.GetVersionId().c_str();
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._SSEKMSEncryptionContext_ = result.GetSSEKMSEncryptionContext().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObject.response_PutObjectOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectAclRequest.h>
>>>


implement _PutObjectAcl.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectAclOutput` output;

       `txid_t` txid;
       %`_PutObjectAcl.response_PutObjectAclOutput` cb;
        %`_PutObjectAcl.response_NoSuchKey` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObjectAcl.response_PutObjectAclOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_PutObjectAcl.response_NoSuchKey` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("NoSuchKey" == errcode.GetExceptionName()) {`_NoSuchKey` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectAclRequest request;
    if (input._ACL_.size()) {
        request.SetACL(Aws::S3::Model::ObjectCannedACLMapper::GetObjectCannedACLForName(input._ACL_[0].c_str()));
    }
    if (input._AccessControlPolicy_.size()) {
        request.SetAccessControlPolicy(input._AccessControlPolicy_[0]);
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._GrantFullControl_.size()) {
        request.SetGrantFullControl(input._GrantFullControl_[0].c_str());
    }
    if (input._GrantRead_.size()) {
        request.SetGrantRead(input._GrantRead_[0].c_str());
    }
    if (input._GrantReadACP_.size()) {
        request.SetGrantReadACP(input._GrantReadACP_[0].c_str());
    }
    if (input._GrantWrite_.size()) {
        request.SetGrantWrite(input._GrantWrite_[0].c_str());
    }
    if (input._GrantWriteACP_.size()) {
        request.SetGrantWriteACP(input._GrantWriteACP_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectAclOutcome outcome = s3_client->PutObjectAcl(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectAclOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObjectAcl.response_PutObjectAclOutput`,func,`_PutObjectAcl.response_NoSuchKey`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectLegalHoldRequest.h>
>>>


implement _PutObjectLegalHold.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectLegalHoldOutput` output;

       `txid_t` txid;
       %`_PutObjectLegalHold.response_PutObjectLegalHoldOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObjectLegalHold.response_PutObjectLegalHoldOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectLegalHoldRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._LegalHold_.size()) {
        request.SetLegalHold(input._LegalHold_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectLegalHoldOutcome outcome = s3_client->PutObjectLegalHold(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectLegalHoldOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObjectLegalHold.response_PutObjectLegalHoldOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectLockConfigurationRequest.h>
>>>


implement _PutObjectLockConfiguration.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectLockConfigurationOutput` output;

       `txid_t` txid;
       %`_PutObjectLockConfiguration.response_PutObjectLockConfigurationOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObjectLockConfiguration.response_PutObjectLockConfigurationOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectLockConfigurationRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ObjectLockConfiguration_.size()) {
        request.SetObjectLockConfiguration(input._ObjectLockConfiguration_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._Token_.size()) {
        request.SetToken(input._Token_[0].c_str());
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectLockConfigurationOutcome outcome = s3_client->PutObjectLockConfiguration(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectLockConfigurationOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObjectLockConfiguration.response_PutObjectLockConfigurationOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectRetentionRequest.h>
>>>


implement _PutObjectRetention.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectRetentionOutput` output;

       `txid_t` txid;
       %`_PutObjectRetention.response_PutObjectRetentionOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObjectRetention.response_PutObjectRetentionOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectRetentionRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._Retention_.size()) {
        request.SetRetention(input._Retention_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._BypassGovernanceRetention_.size()) {
        request.SetBypassGovernanceRetention(input._BypassGovernanceRetention_[0]);
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectRetentionOutcome outcome = s3_client->PutObjectRetention(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectRetentionOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObjectRetention.response_PutObjectRetentionOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutObjectTaggingRequest.h>
>>>


implement _PutObjectTagging.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_PutObjectTaggingOutput` output;

       `txid_t` txid;
       %`_PutObjectTagging.response_PutObjectTaggingOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutObjectTagging.response_PutObjectTaggingOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutObjectTaggingRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetTagging(input._Tagging_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutObjectTaggingOutcome outcome = s3_client->PutObjectTagging(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_PutObjectTaggingOutput` res;
        res._VersionId_ = result.GetVersionId().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutObjectTagging.response_PutObjectTaggingOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/PutPublicAccessBlockRequest.h>
>>>


implement _PutPublicAccessBlock.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_PutPublicAccessBlock.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_PutPublicAccessBlock.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::PutPublicAccessBlockRequest request;
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetPublicAccessBlockConfiguration(input._PublicAccessBlockConfiguration_);
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::PutPublicAccessBlockOutcome outcome = s3_client->PutPublicAccessBlock(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_PutPublicAccessBlock.response`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/RestoreObjectRequest.h>
>>>


implement _RestoreObject.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_RestoreObjectOutput` output;

       `txid_t` txid;
       %`_RestoreObject.response_RestoreObjectOutput` cb;
        %`_RestoreObject.response_ObjectAlreadyInActiveTierError` err0;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_RestoreObject.response_RestoreObjectOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func,%`_RestoreObject.response_ObjectAlreadyInActiveTierError` err0 ) : ivy(ivy),txid(txid),cb(cb),err0(err0) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
if ("ObjectAlreadyInActiveTierError" == errcode.GetExceptionName()) {`_ObjectAlreadyInActiveTierError` thing; err0(txid,thing);}
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::RestoreObjectRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._RestoreRequest_.size()) {
        request.SetRestoreRequest(input._RestoreRequest_[0]);
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::RestoreObjectOutcome outcome = s3_client->RestoreObject(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_RestoreObjectOutput` res;
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        res._RestoreOutputPath_ = result.GetRestoreOutputPath().c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_RestoreObject.response_RestoreObjectOutput`,func,`_RestoreObject.response_ObjectAlreadyInActiveTierError`);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/SelectObjectContentRequest.h>
>>>


implement _SelectObjectContent.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_SelectObjectContentOutput` output;

       `txid_t` txid;
       %`_SelectObjectContent.response_SelectObjectContentOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_SelectObjectContent.response_SelectObjectContentOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::SelectObjectContentRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetKey(input._Key_.c_str());
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    request.SetExpression(input._Expression_.c_str());
    request.SetExpressionType(input._ExpressionType_.c_str());
    if (input._RequestProgress_.size()) {
        request.SetRequestProgress(input._RequestProgress_[0]);
    }
    request.SetInputSerialization(input._InputSerialization_);
    request.SetOutputSerialization(input._OutputSerialization_);
    if (input._ScanRange_.size()) {
        request.SetScanRange(input._ScanRange_[0]);
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::SelectObjectContentOutcome outcome = s3_client->SelectObjectContent(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_SelectObjectContentOutput` res;
        res._Payload_ = result.GetPayload();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_SelectObjectContent.response_SelectObjectContentOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/UploadPartRequest.h>
>>>


implement _UploadPart.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_UploadPartOutput` output;

       `txid_t` txid;
       %`_UploadPart.response_UploadPartOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_UploadPart.response_UploadPartOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::UploadPartRequest request;
    if (input._Body_.size()) {
        request.SetBody(blob_to_iostream(input._Body_[0]));
    }
    request.SetBucket(input._Bucket_.c_str());
    if (input._ContentLength_.size()) {
        request.SetContentLength(input._ContentLength_[0]);
    }
    if (input._ContentMD5_.size()) {
        request.SetContentMD5(input._ContentMD5_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    request.SetPartNumber(input._PartNumber_);
    request.SetUploadId(input._UploadId_.c_str());
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::UploadPartOutcome outcome = s3_client->UploadPart(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_UploadPartOutput` res;
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._ETag_ = result.GetETag().c_str();
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_UploadPart.response_UploadPartOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/UploadPartCopyRequest.h>
>>>


implement _UploadPartCopy.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)
`_UploadPartCopyOutput` output;

       `txid_t` txid;
       %`_UploadPartCopy.response_UploadPartCopyOutput` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_UploadPartCopy.response_UploadPartCopyOutput` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid,output);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::UploadPartCopyRequest request;
    request.SetBucket(input._Bucket_.c_str());
    request.SetCopySource(input._CopySource_.c_str());
    if (input._CopySourceIfMatch_.size()) {
        request.SetCopySourceIfMatch(input._CopySourceIfMatch_[0].c_str());
    }
    if (input._CopySourceIfModifiedSince_.size()) {
        request.SetCopySourceIfModifiedSince(Aws::Utils::DateTime((int64_t)input._CopySourceIfModifiedSince_[0]));
    }
    if (input._CopySourceIfNoneMatch_.size()) {
        request.SetCopySourceIfNoneMatch(input._CopySourceIfNoneMatch_[0].c_str());
    }
    if (input._CopySourceIfUnmodifiedSince_.size()) {
        request.SetCopySourceIfUnmodifiedSince(Aws::Utils::DateTime((int64_t)input._CopySourceIfUnmodifiedSince_[0]));
    }
    if (input._CopySourceRange_.size()) {
        request.SetCopySourceRange(input._CopySourceRange_[0].c_str());
    }
    request.SetKey(input._Key_.c_str());
    request.SetPartNumber(input._PartNumber_);
    request.SetUploadId(input._UploadId_.c_str());
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSECustomerKey_.size()) {
        request.SetSSECustomerKey(input._SSECustomerKey_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._CopySourceSSECustomerAlgorithm_.size()) {
        request.SetCopySourceSSECustomerAlgorithm(input._CopySourceSSECustomerAlgorithm_[0].c_str());
    }
    if (input._CopySourceSSECustomerKey_.size()) {
        request.SetCopySourceSSECustomerKey(input._CopySourceSSECustomerKey_[0].c_str());
    }
    if (input._CopySourceSSECustomerKeyMD5_.size()) {
        request.SetCopySourceSSECustomerKeyMD5(input._CopySourceSSECustomerKeyMD5_[0].c_str());
    }
    if (input._RequestPayer_.size()) {
        request.SetRequestPayer(Aws::S3::Model::RequestPayerMapper::GetRequestPayerForName(input._RequestPayer_[0].c_str()));
    }
    if (input._ExpectedBucketOwner_.size()) {
        request.SetExpectedBucketOwner(input._ExpectedBucketOwner_[0].c_str());
    }
    if (input._ExpectedSourceBucketOwner_.size()) {
        request.SetExpectedSourceBucketOwner(input._ExpectedSourceBucketOwner_[0].c_str());
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::UploadPartCopyOutcome outcome = s3_client->UploadPartCopy(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        auto result = outcome.GetResultWithOwnership();
        `_UploadPartCopyOutput` res;
        res._CopySourceVersionId_ = result.GetCopySourceVersionId().c_str();
        res._CopyPartResult_ = result.GetCopyPartResult();
        res._ServerSideEncryption_ = Aws::S3::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(result.GetServerSideEncryption()).c_str();
        res._SSECustomerAlgorithm_ = result.GetSSECustomerAlgorithm().c_str();
        res._SSECustomerKeyMD5_ = result.GetSSECustomerKeyMD5().c_str();
        res._SSEKMSKeyId_ = result.GetSSEKMSKeyId().c_str();
        res._BucketKeyEnabled_ = result.GetBucketKeyEnabled();
        res._RequestCharged_ = Aws::S3::Model::RequestChargedMapper::GetNameForRequestCharged(result.GetRequestCharged()).c_str();
        rdr->output = res;
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_UploadPartCopy.response_UploadPartCopyOutput`,func);
        install_reader(rdr);
            >>>
}


<<< impl
#include <aws/s3/model/WriteGetObjectResponseRequest.h>
>>>


implement _WriteGetObjectResponse.request {
    <<<

    struct myreader : reader {

       int fildes[2];
       ivy_class *ivy;     // pointer to main ivy object (mainly to get lock)

       `txid_t` txid;
       %`_WriteGetObjectResponse.response` cb;

       std::thread *thr;
       Aws::S3::S3Client *s3_client;
       Aws::S3::S3Error errcode;
       myreader(ivy_class *ivy, `txid_t` txid, %`_WriteGetObjectResponse.response` cb, std::function<void(myreader*,Aws::S3::S3Client *)> func ) : ivy(ivy),txid(txid),cb(cb) {
           if (::pipe(fildes)) {
               perror("failed to create pipe");
               exit(1);
           }
           s3_client = get_aws_client();
           thr = new std::thread(func,this,s3_client);
       }
       virtual int fdes() {
           return fildes[0];
       }
       virtual void read () {
//           std::cout << "about to read" << std::endl;
           char buf[1];
           ::read(fildes[0],buf,1);
           ::close(fildes[0]);
           ::close(fildes[1]);
           fildes[0] = -1;
           if (buf[0]) {
//               std::cout << "about to do callback" << std::endl;
               ivy->__lock();
               cb(txid);
               return_aws_client(s3_client);
               ivy->__unlock();
//               std::cout << "finished callback" << std::endl;
           } else {
//               std::cout << "exception" << errcode.GetExceptionName() << std::endl;
               
           }
           thr->join();
           delete thr;
       }
    };
        //std::cout << "about to create function" << std::endl;
    auto func = [input](myreader *rdr, Aws::S3::S3Client *s3_client){
//std::cout << "in thread" << std::endl;
        Aws::S3::Model::WriteGetObjectResponseRequest request;
    request.SetRequestRoute(input._RequestRoute_.c_str());
    request.SetRequestToken(input._RequestToken_.c_str());
    if (input._Body_.size()) {
        request.SetBody(blob_to_iostream(input._Body_[0]));
    }
    if (input._StatusCode_.size()) {
        request.SetStatusCode(input._StatusCode_[0]);
    }
    if (input._ErrorCode_.size()) {
        request.SetErrorCode(input._ErrorCode_[0].c_str());
    }
    if (input._ErrorMessage_.size()) {
        request.SetErrorMessage(input._ErrorMessage_[0].c_str());
    }
    if (input._AcceptRanges_.size()) {
        request.SetAcceptRanges(input._AcceptRanges_[0].c_str());
    }
    if (input._CacheControl_.size()) {
        request.SetCacheControl(input._CacheControl_[0].c_str());
    }
    if (input._ContentDisposition_.size()) {
        request.SetContentDisposition(input._ContentDisposition_[0].c_str());
    }
    if (input._ContentEncoding_.size()) {
        request.SetContentEncoding(input._ContentEncoding_[0].c_str());
    }
    if (input._ContentLanguage_.size()) {
        request.SetContentLanguage(input._ContentLanguage_[0].c_str());
    }
    if (input._ContentLength_.size()) {
        request.SetContentLength(input._ContentLength_[0]);
    }
    if (input._ContentRange_.size()) {
        request.SetContentRange(input._ContentRange_[0].c_str());
    }
    if (input._ContentType_.size()) {
        request.SetContentType(input._ContentType_[0].c_str());
    }
    if (input._DeleteMarker_.size()) {
        request.SetDeleteMarker(input._DeleteMarker_[0]);
    }
    if (input._ETag_.size()) {
        request.SetETag(input._ETag_[0].c_str());
    }
    if (input._Expires_.size()) {
        request.SetExpires(Aws::Utils::DateTime((int64_t)input._Expires_[0]));
    }
    if (input._Expiration_.size()) {
        request.SetExpiration(input._Expiration_[0].c_str());
    }
    if (input._LastModified_.size()) {
        request.SetLastModified(Aws::Utils::DateTime((int64_t)input._LastModified_[0]));
    }
    if (input._MissingMeta_.size()) {
        request.SetMissingMeta(input._MissingMeta_[0]);
    }
    if (input._Metadata_.size()) {
        request.SetMetadata(map_to_aws(input._Metadata_[0]));
    }
    if (input._ObjectLockMode_.size()) {
        request.SetObjectLockMode(Aws::S3::Model::ObjectLockModeMapper::GetObjectLockModeForName(input._ObjectLockMode_[0].c_str()));
    }
    if (input._ObjectLockLegalHoldStatus_.size()) {
        request.SetObjectLockLegalHoldStatus(Aws::S3::Model::ObjectLockLegalHoldStatusMapper::GetObjectLockLegalHoldStatusForName(input._ObjectLockLegalHoldStatus_[0].c_str()));
    }
    if (input._ObjectLockRetainUntilDate_.size()) {
        request.SetObjectLockRetainUntilDate(Aws::Utils::DateTime((int64_t)input._ObjectLockRetainUntilDate_[0]));
    }
    if (input._PartsCount_.size()) {
        request.SetPartsCount(input._PartsCount_[0]);
    }
    if (input._ReplicationStatus_.size()) {
        request.SetReplicationStatus(Aws::S3::Model::ReplicationStatusMapper::GetReplicationStatusForName(input._ReplicationStatus_[0].c_str()));
    }
    if (input._RequestCharged_.size()) {
        request.SetRequestCharged(Aws::S3::Model::RequestChargedMapper::GetRequestChargedForName(input._RequestCharged_[0].c_str()));
    }
    if (input._Restore_.size()) {
        request.SetRestore(input._Restore_[0].c_str());
    }
    if (input._ServerSideEncryption_.size()) {
        request.SetServerSideEncryption(Aws::S3::Model::ServerSideEncryptionMapper::GetServerSideEncryptionForName(input._ServerSideEncryption_[0].c_str()));
    }
    if (input._SSECustomerAlgorithm_.size()) {
        request.SetSSECustomerAlgorithm(input._SSECustomerAlgorithm_[0].c_str());
    }
    if (input._SSEKMSKeyId_.size()) {
        request.SetSSEKMSKeyId(input._SSEKMSKeyId_[0].c_str());
    }
    if (input._SSECustomerKeyMD5_.size()) {
        request.SetSSECustomerKeyMD5(input._SSECustomerKeyMD5_[0].c_str());
    }
    if (input._StorageClass_.size()) {
        request.SetStorageClass(Aws::S3::Model::StorageClassMapper::GetStorageClassForName(input._StorageClass_[0].c_str()));
    }
    if (input._TagCount_.size()) {
        request.SetTagCount(input._TagCount_[0]);
    }
    if (input._VersionId_.size()) {
        request.SetVersionId(input._VersionId_[0].c_str());
    }
    if (input._BucketKeyEnabled_.size()) {
        request.SetBucketKeyEnabled(input._BucketKeyEnabled_[0]);
    }
//std::cout << "about to do request with output" << std::endl;
    Aws::S3::Model::WriteGetObjectResponseOutcome outcome = s3_client->WriteGetObjectResponse(request);
//std::cout << "finished request" << std::endl;
    if (outcome.IsSuccess()) {
        char buf[1] = {1};
//std::cout << "about to write" << std::endl;
        ::write(rdr->fildes[1],buf,1);
    }
    else {char buf[1] = {0}; rdr->errcode = outcome.GetError(); ::write(rdr->fildes[1],buf,1);}
    };
//std::cout << "about to create reader" << std::endl;

        auto rdr = new myreader(this,txid,`_WriteGetObjectResponse.response`,func);
        install_reader(rdr);
            >>>
}
