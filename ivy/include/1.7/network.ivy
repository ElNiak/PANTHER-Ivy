#lang ivy


include udp_impl
include tcp_serdes
include serdes

global {

    object udp = {

        object endpoint = {
            type this = struct {
                addr : ip.addr,
                port : ip.port
            }
        }

        action to_ip_endpoint(id:endpoint) returns (res:ip.endpoint) = {
            res.addr := id.addr;
            res.port := id.port;
            res.protocol := ip.udp;
        }

        action from_ip_endpoint(id:ip.endpoint) returns (res:endpoint) = {
            res.addr := id.addr;
            res.port := id.port;
        }

        type host = {me}

        module net_serdes(msg_t,ser,des) = {

            module socket = {

                parameter id : udp.endpoint
                attribute id.global_parameter = true    

                action send(dst : udp.endpoint, msg : msg_t)
                action recv(src : udp.endpoint, msg : msg_t)

                implementation {

                    instance intf : udp_impl(udp.host,msg_t,ser,des)
                    var sock :intf.socket

                    after init {
                        sock := intf.open(udp.me,udp.to_ip_endpoint(id));
                    }

                    implement send {
                        call intf.send(udp.me,sock,udp.to_ip_endpoint(dst),msg);
                    }

                    implement intf.recv(h:udp.host, s:intf.socket, src:ip.endpoint, msg:msg_t) {
                        call recv(udp.from_ip_endpoint(src), msg:msg_t);
                    }
                }
            }

            trusted isolate iso = this

            attribute test = impl
        }

        module net(msg_t) = {
            instantiate net_serdes(msg_t,std_serdes.serializer,std_serdes.deserializer)
        }
    }


    object tcp = {

        object endpoint = {
            type this = struct {
                addr : ip.addr,
                port : ip.port
            }
        }

        action to_ip_endpoint(id:endpoint) returns (res:ip.endpoint) = {
            res.addr := id.addr;
            res.port := id.port;
            res.protocol := ip.tcp;
        }

        action from_ip_endpoint(id:ip.endpoint) returns (res:endpoint) = {
            res.addr := id.addr;
            res.port := id.port;
        }

        type host = {me}

        module net(msg_t) = {

            specification {
                relation sent(S:tcp.endpoint,D:tcp.endpoint,M:msg_t)
            }
            
            module socket = {

                parameter id : tcp.endpoint
                attribute id.global_parameter = true    

                action send(dst : tcp.endpoint, msg : msg_t)
                action recv(src : tcp.endpoint, msg : msg_t)

                specification {

                    after init {
                        net.sent(X,Y,M) := false;
                    }
                    
                    before send {
                        require net.sent(id,dst,M) -> M < msg;
                    }
                    after send {
                        net.sent(id,dst,msg) := true;
                    }
                    before recv {
                        require net.sent(src,id,msg);
                        require net.sent(src,id,M) -> msg <= M;
                    }
                    after recv {
                        net.sent(src,id,msg) := false;
                    }
                }

                implementation {

                    instance intf : tcp_serdes(tcp.endpoint,msg_t)
                    var sock :intf.socket
                    relation connected_to(X:tcp.endpoint)
                    function dst_socket(X:tcp.endpoint) : intf.socket
                    function socket_src(X:intf.socket) : tcp.endpoint
                    
                    after init {
                        sock := intf.open(id);
                    }

                    implement send {
                        if ~connected_to(dst) {
                            var dst_sock := intf.connect(dst);
                            dst_socket(dst) := dst_sock;
                            connected_to(dst) := true;
                        }
                        var ok := intf.send(dst_socket(dst),msg);
                        # If send fails, it means the TCP connection
                        # closed. We can't recover from this because
                        # we don't know which messages were received,
                        # so we can't maintain message order.
                    }

                    implement intf.accept(s:intf.socket, src:tcp.endpoint) { 
                        socket_src(s) := src;
                    }

                    implement intf.recv(s:intf.socket, msg:msg_t) {
                        call recv(socket_src(s), msg:msg_t);
                    }
                }
                trusted isolate iso = this
                
                attribute test = impl
            }

            trusted isolate iso = this

            attribute test = impl
        }
    }
}
