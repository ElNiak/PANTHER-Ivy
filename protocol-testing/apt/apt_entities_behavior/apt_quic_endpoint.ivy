#lang ivy1.7


include apt_endpoint

object endpoint = {

    ...

    object client_endpoint = {
        ...

        module client_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of client_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

        } 
    }

    object server_endpoint = {
        ...

        module server_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of server_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

        }
    }

    object man_in_the_middle_endpoint = {
        ...

        module mim_quic_ep(address:ip.addr,
                    port:ip.port, 
                    oport:ip.port, 
                    toward_client:bool, 
                    standalone: bool,
                    bridged: bool) = { 
            
            # variant this of man_in_the_middle_endpoint = struct { }
            
            individual ep_client : ip.endpoint
            individual ep_server : ip.endpoint
            individual ep_target : ip.endpoint

            function number_packet_recv_from(H:endpoint_id)    : stream_pos
            function number_packet_forwarded_to(H:endpoint_id) : stream_pos

            individual tls_id : tls_api.id

            individual nat_configured : bool

            individual ppkt_saved_b : bool
            individual ppkt_saved   : packet.quic_packet
            
            individual ppkt_to_be_replayed_to_server : packet.quic_packet
            function   ppkt_to_be_forwarded_to_server(C:stream_pos) : packet.quic_packet
            function   enc_ppkt_to_be_forwarded_to_server(C:stream_pos) : packet.encrypted_quic_packet.arr
            individual cppkt_forwarded_to_server : stream_pos
            individual last_cppkt_forwarded_to_server : stream_pos
            individual enc_cppkt_forwarded_to_server : stream_pos
            individual enc_last_cppkt_forwarded_to_server : stream_pos

            individual force_client_forward : bool  # useless for now
            function   ppkt_to_be_forwarded_to_client(C:stream_pos) : packet.quic_packet
            function   enc_padding_to_client(C:stream_pos) : stream_data
            function   enc_padding_to_server(C:stream_pos) : stream_data
            function   enc_ppkt_to_be_forwarded_to_client(C:stream_pos) : packet.encrypted_quic_packet.arr
            individual cppkt_forwarded_to_client : stream_pos
            individual last_cppkt_forwarded_to_client : stream_pos
            individual enc_cppkt_forwarded_to_client : stream_pos
            individual enc_last_cppkt_forwarded_to_client : stream_pos

            individual force_server_forward : bool
            
            individual forward_turn : bool
            individual forward_turn_count : stream_pos
            
            individual ppkt_to_be_reflected_to_target : packet.quic_packet
        
            individual ppkt_to_be_forge : packet.quic_packet

            individual init_cids : bool # TODO remove

            individual wait_forward : bool # TODO remove


            after init {
                if ep_server.addr = 0x7f000001 {
                    ep_server.interface := ip.lo;
                } else {
                    ep_client.protocol := ip.udp;
                    ep_client.addr := address;
                    ep_client.port := port;

                    ep_server.protocol := ip.udp;
                    ep_server.addr := address;
                    ep_server.port := oport;
                    if standalone {
                        if bridged {
                                ep_client.interface  := ip.veth_ivy;
                                ep_server.interface := ip.veth_ivy;
                        }
                        else {
                            if toward_client {
                                ep_client.interface  := ip.ivy_server;
                                ep_server.interface := ip.ivy_client;
                            } 
                            else {
                                ep_client.interface  := ip.ivy_client;
                                ep_server.interface := ip.ivy_server;
                            }
                        }
                    }
                    else {
                        ep_client.interface  := ip.lo;
                        ep_server.interface := ip.ivy;
                    }
                }
                
                nat_configured := false;
                ppkt_saved_b := false;
                init_cids := false;

                force_client_forward := false;
                force_server_forward := false;

                # ppkt_to_be_forwarded_to_server(C) := packet.packet.quic_packet.arr.empty;
                # ppkt_to_be_forwarded_to_client(C) := packet.packet.quic_packet.arr.empty;

                # Allow to keep coalesced packed
                cppkt_forwarded_to_server := 0;
                cppkt_forwarded_to_client := 0;
                last_cppkt_forwarded_to_server := 0;
                last_cppkt_forwarded_to_client := 0;

                forward_turn := false;
                forward_turn_count := 0;
                
                wait_forward := true;
                
                # ppkt_to_be_forge := packet.quic_packet;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep_client := e; # TODO
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint_mim(host,s,src);  # because quic_net API doesn't tell us the dst socket_endpoint_mim
                var idx := pkts.begin;
                # TODO should not be here

                if ~nat_configured {
                    nat_configured := true;
                    ep_client := src; # Like initial connection from client 
                    call nat_configured_event(src,dst);
                } 

                var is_enc := true;
                var to_forward := false;

                while idx < pkts.end {
                    var ppkt := pkts.value(idx);

                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    var version := ppkt.segment(1,1+4);
                    var bversion := bytes_to_version(version);
                    var ptype : byte := bvand(0x30,header);

                    var rnum := reference_pkt_num(ppkt,true);

                    var res := quic_prot.decrypt_quic(tls_id,rnum,ppkt);
                    var dcil : stream_pos := bfe[0][7](ppkt.value(5));
                    var ikm := cid_to_bytes(0,1); # dcid
                    if(~dcil = 0) {
                        client_initial_dcil := dcil;
                        ikm := ppkt.segment(6,6+dcil); # dcid
                    };
                    var dcid : cid := bytes_to_cid(ikm);

                    if res.ok {
                        is_enc := false;
                        var rppkt     := quic_packet_serdes.from_bytes(res.data);
                        rppkt.seq_num := quic_prot.correct_pnum(rnum,rppkt.seq_num,quic_prot.get_pnum_len(res.data));

                        call recv_packet(host,src,dst,rppkt);

                        var jdx := rppkt.payload.begin;
                        while jdx < rppkt.payload.end {
                            var f := rppkt.payload.value(jdx);
                            jdx := jdx.next;
                        };


                        if forward_packets { # To server
                            if src = ep_client {
                                #if ~packets_forwarded(rppkt) {
                                    # TODO manage coallesced packet -> stream_data_array + loop
                                    ppkt_to_be_forwarded_to_server(cppkt_forwarded_to_server) := rppkt;
                                    if ~keep_coalesed {
                                        cppkt_forwarded_to_server := cppkt_forwarded_to_server + 1;
                                    };
                                #}

                            } else if src = ep_server {
                                # if ~ packets_forwarded(rppkt) {
                                    ppkt_to_be_forwarded_to_client(cppkt_forwarded_to_client) := rppkt;
                                    if ~keep_coalesed {
                                        cppkt_forwarded_to_client := cppkt_forwarded_to_client + 1;
                                    };
                                #}
                            }
                        };
                        
                        if forward_packets_target {
                            var ddst := ep_target;
                            ppkt_to_be_reflected_to_target := rppkt;
                            call reflection_packets(rppkt,0);
                        };

                        if replay_packets { # To server
                            call forward_packet_to(ppkt_saved,host,s,src,dst);
                        };
                    
                    } else {
                        if is_random_padding_packet(ppkt) {
                            call random_padding_or_short_packet_event(src,dst,ppkt);
                            if forward_packets { # To server
                                if src = ep_client {
                                    enc_padding_to_server(enc_cppkt_forwarded_to_server) := ppkt;
                                } else if src = ep_server {
                                    enc_padding_to_client(enc_cppkt_forwarded_to_client) := ppkt;
                                }
                            };
                        } else {
                            var rppkt := quic_encrypted_packet_serdes.from_bytes(ppkt);
                            call show_payload_len(rppkt.payload.end);
                            # rppkt.seq_num := quic_prot.correct_pnum(rnum,rppkt.seq_num,quic_prot.get_pnum_len(res.data));
                            if packet_forwarded(rppkt){
                                call arp_duplicated_encrypted_packet_event(src,dst,rppkt);
                            } else {
                                to_forward := true;
                                call recv_encrypted_packet(host,src,dst,rppkt);
                                #call undecryptable_packet_event(host,src,dst,ppkt);
                                if forward_packets { # To server
                                    if src = ep_client {
                                        #if ~packets_forwarded(rppkt) {
                                            # TODO manage coallesced packet -> stream_data_array + loop
                                            enc_ppkt_to_be_forwarded_to_server(enc_cppkt_forwarded_to_server) := enc_ppkt_to_be_forwarded_to_server(enc_cppkt_forwarded_to_server).append(rppkt);
                                            if ~keep_coalesed {
                                                enc_cppkt_forwarded_to_server := enc_cppkt_forwarded_to_server + 1;
                                            };
                                        #}

                                    } else if src = ep_server {
                                        # if ~ packets_forwarded(rppkt) {
                                            enc_ppkt_to_be_forwarded_to_client(enc_cppkt_forwarded_to_client) := enc_ppkt_to_be_forwarded_to_client(enc_cppkt_forwarded_to_client).append(rppkt);
                                            if ~keep_coalesed {
                                                enc_cppkt_forwarded_to_client := enc_cppkt_forwarded_to_client + 1;
                                            };
                                        #}
                                    }
                                };
                            } 
                        }
                    }
                    idx := idx.next; 
                };

                if forward_packets & keep_coalesed & to_forward { # To server
                    if src = ep_client {
                        if is_enc {
                            enc_cppkt_forwarded_to_server := enc_cppkt_forwarded_to_server + 1;
                        } else {
                            cppkt_forwarded_to_server := cppkt_forwarded_to_server + 1;
                        };
                    } else if src = ep_server {
                        if is_enc {
                            enc_cppkt_forwarded_to_client := enc_cppkt_forwarded_to_client + 1;
                        } else {
                            cppkt_forwarded_to_client := cppkt_forwarded_to_client + 1;
                        };
                    };
                    call cppkt_forwarded_to_client_count_debug_event(cppkt_forwarded_to_client);
                    call cppkt_forwarded_to_server_count_debug_event(cppkt_forwarded_to_server);

                    call cppkt_forwarded_to_client_count_debug_event(enc_cppkt_forwarded_to_client);
                    call cppkt_forwarded_to_server_count_debug_event(enc_cppkt_forwarded_to_server);
                };

            }

            action is_random_padding_packet(spkt:stream_data) returns (is_padding:bool) = {
                var first_byte := spkt.value(0);
                var header_typer := bvand(first_byte,0x7f);
                if header_typer = first_byte {
                    is_padding := true;
                } else {
                    is_padding := false;
                };
            }

            action forward_packet_to(ppkt:packet.quic_packet,host:endpoint_id, s:quic_net.socket, src:ip.endpoint, dst:ip.endpoint) = {
                # forward packet
                var pkts_mim := quic_prot.arr.empty;
                var spkt := quic_packet_serdes.to_bytes(ppkt);
                pkts_mim := pkts_mim.append(spkt);
                call quic_net.send(endpoint_id.man_in_the_middle,endpoint_to_socket(src),dst,pkts_mim);
            }

            action replay_packet(ppkt:packet.quic_packet,host:endpoint_id, s:quic_net.socket, src:ip.endpoint) = {
                # replay packet
                var dst := socket_endpoint(host,s);
                var pkts_mim := quic_prot.arr.empty;
                var spkt := quic_packet_serdes.to_bytes(ppkt);
                pkts_mim := pkts_mim.append(spkt);
                call quic_net.send(endpoint_id.man_in_the_middle,endpoint_to_socket(src),dst,pkts_mim);
            }

            # TODO use serializer
            # action modify_packet(ppkt:packet.quic_packet) returns(rppkt:packet.quic_packet) =  {
            #     #var version := bytes_to_version(spkt.segment(1,5));
            #     var tppkt := ppkt;
            #     tppkt := tppkt.set(1,0xff);
            #     tppkt := tppkt.set(2,0x00);
            #     tppkt := tppkt.set(3,0x00);
            #     tppkt := tppkt.set(4,0x1d);
            #     rppkt := tppkt;
            # }

            # TODO add dynamic condition to save packets
            action save_packets(ppkt:packet.quic_packet) = {
                # TODO if saved_packet_type ...
                #ppkt_saved := ppkt;
                <<<
                    const char * session_file = getenv("SAVED_PACKET");
                    std::cerr << "SAVED_PACKET 5b " << ppkt.size() << "\n";
                    FILE *fp;
                    if(session_file != NULL) {
                        fp = fopen(session_file,"w");
                        for(int j = 0; j < ppkt.size(); j++) {
                            fprintf(fp, "%02x",  ppkt[j]); //length field
                        }
                        fclose(fp);
                    }        
                >>>
            }

            action get_saved_packets returns(ppkt:packet.quic_packet) = {
                # TODO if saved_packet_type ...
                #ppkt_saved := ppkt;
                <<<
                    const char * session_file = getenv("SAVED_PACKET");
                    std::cerr << "SAVED_PACKET 5b " << session_file<< "\n";
                    FILE *fp;
                    if(session_file != NULL) {
                        fp = fopen(session_file,"r");
                        read = getline(&line, &len, fp);
                        fclose(fp);
                        bool is_error = false;
                        if(line != NULL) { 
                            std::cerr << "SAVED_PACKET 1 " << line << std::endl;
                            int hex_len = strlen(line);
                            std::cerr << "SAVED_PACKET hex_len " << hex_len << std::endl;
                            uint8_t secret[hex_len/2];
                            for (int j = 0; j < hex_len/2; j++) {
                                int a = ws_xton(line[j*2]);
                                int b = ws_xton(line[j*2 + 1]);
                                if (a == -1 || b == -1) {
                                    is_error = true;
                                    std::cerr << "a ERROR " << line[j*2] << std::endl;
                                    std::cerr << "b ERROR " << line[j*2 + 1] << std::endl;
                                    std::cerr << "SAVED_PACKET ERROR " << std::endl;
                                    break;
                                }
                                secret[j] = a << 4 | b;
                            }  
                            std::cerr << "SAVED_PACKET TEST_ST 2 " << secret << std::endl;
                            for(int i = 0; i < hex_len/2 && !is_error; i++)
                                ppkt.push_back(secret[i]);
                        }
                    }        
                >>>
            }

            action reflection_packets(ppkt:packet.quic_packet,dst_port:ip.port) = {
                # spoof source ip/port
                # TODO: we should modify the packet directly, however we only see the QUIC packet and thus this 
                # is impossible for now to do so 
                # Instead: we send with target ep so it simulate the ip spoofing
                # forward to server
                var dst := ep_server;
                var pkts_mim := quic_prot.arr.empty;
                var spkt := quic_packet_serdes.to_bytes(ppkt);
                pkts_mim := pkts_mim.append(spkt);
                call quic_net.send(endpoint_id.target,sock_target,dst,pkts_mim);
            }

            action configure_NAT_attack_in = {
                <<<
                    //  very important for modifying the packet
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.2  10.0.0.3 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_bidir = {
                <<<
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.3  -r 10.0.0.2 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_out = {
                <<<
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.3  10.0.0.2 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action reset_NAT = {
                <<<
                    const char * command = "pkill arpspoof;"; 
                    int cr = system( command );
                >>>
            }

            import action cppkt_forwarded_to_server_count_debug_event(count:stream_pos)
            import action cppkt_forwarded_to_client_count_debug_event(count:stream_pos)

            import action nat_configured_event(src:ip.endpoint, dst:ip.endpoint)
            import action client_target_setup_event(src:ip.endpoint)
            import action random_padding_or_short_packet_event(src:ip.endpoint, dst:ip.endpoint, pkt:stream_data)
            import action arp_duplicated_encrypted_packet_event(src:ip.endpoint, dst:ip.endpoint, pkt:packet.encrypted_quic_packet)
            import action recv_packet(host:endpoint_id,src:ip.endpoint,dst:ip.endpoint,pkt:packet.quic_packet)
            import action recv_encrypted_packet(host:endpoint_id,src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet)
        }
    
    }

    object attacker_endpoint = {
        ...

        module attacker_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of attacker_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

            action configure_NAT_attack_in_spoof(server_quic:ip.port,target_ep:ip.port) = {
                <<<
                    // should use postrouting
                    std::string command = "iptables -t nat -A OUTPUT -o lo -d 127.0.0.1 -p udp --dport " + std::to_string(server_quic) + ":" + std::to_string(server_quic) + " -j DNAT --to-destination 127.0.0.1:"+ std::to_string(target_ep) +">/dev/null 2>&1"; 
                    int n = command.length();
                    std::cerr << "configure_NAT_attack_in_spoof " << command << "\n";
                    // declaring character array
                    char command_array[n + 1];
                
                    // copying the contents of the
                    // string to char array
                    strcpy(command_array, command.c_str());

                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_in_spoof_hack(server_quic:ip.port,target_ep:ip.port) = {
                sock_attacker := sock_target; 
            }
            
            action reset_NAT = {
                <<<
                    const char * command = "iptables -t nat -L -n -v;iptables -t nat -F >/dev/null 2>&1"; 
                    int cr = system( command );
                >>>
            }
        }
    }
}
