#lang ivy1.7


include apt_endpoint

object endpoint = {

    ...

    object client_endpoint = {
        ...

        module client_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of client_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

        } 
    }

    object server_endpoint = {
        ...

        module server_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of server_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

        }
    }

    object man_in_the_middle_endpoint = {
        ...

        module mim_quic_ep(address:ip.addr,
                    port:ip.port, 
                    oport:ip.port, 
                    toward_client:bool, 
                    standalone: bool,
                    bridged: bool) = { 
            
            # variant this of man_in_the_middle_endpoint = struct { }
            
            individual ep_client : ip.endpoint
            individual ep_server : ip.endpoint
            individual ep_target : ip.endpoint

            individual tls_id : tls_api.id

            individual nat_configured : bool

            individual force_client_forward : bool  # useless for now
            individual force_server_forward : bool
            individual forward_turn : bool
            individual forward_turn_count : stream_pos

            function   number_packet_recv_from(H:ip.endpoint)    : stream_pos
            function   packet_to_replay_to(H:ip.endpoint,C:stream_pos) : packet.quic_packet.arr
            function   packet_to_forward_to(H:ip.endpoint,C:stream_pos) : packet.quic_packet.arr
            individual number_packet_forwarded_to(H:ip.endpoint) : stream_pos
            individual last_packet_forwarded_to(H:ip.endpoint) : stream_pos

            function   number_encrypted_packet_recv_from(H:ip.endpoint) : stream_pos
            function   encrypted_packet_to_replay_to(H:ip.endpoint,C:stream_pos) : packet.encrypted_quic_packet.arr
            function   encrypted_packet_to_forward_to(H:ip.endpoint,C:stream_pos) : packet.encrypted_quic_packet.arr
            individual number_encrypted_packet_forwarded_to(H:ip.endpoint) : stream_pos
            individual last_encrypted_packet_forwarded_to(H:ip.endpoint) : stream_pos
           
            function   encrypted_padding_packet_to_forward_to(H:ip.endpoint, C:stream_pos) : stream_data

            function   packet_number_to_be_replayed(H:ip.endpoint) : stream_pos

            individual ppkt_to_be_reflected_to_target : packet.quic_packet
        
            individual ppkt_to_be_forge : packet.quic_packet
            individual ppkt_saved_b : bool
            individual ppkt_saved   : packet.quic_packet

            after init {
                if ep_server.addr = 0x7f000001 {
                    ep_server.interface := ip.lo;
                } else {
                    ep_client.protocol := ip.udp;
                    ep_client.addr := address;
                    ep_client.port := port;

                    ep_server.protocol := ip.udp;
                    ep_server.addr := address;
                    ep_server.port := oport;
                    if standalone {
                        if bridged {
                                ep_client.interface  := ip.veth_ivy;
                                ep_server.interface := ip.veth_ivy;
                        }
                        else {
                            if toward_client {
                                ep_client.interface  := ip.ivy_server;
                                ep_server.interface := ip.ivy_client;
                            } 
                            else {
                                ep_client.interface  := ip.ivy_client;
                                ep_server.interface := ip.ivy_server;
                            }
                        }
                    }
                    else {
                        ep_client.interface  := ip.lo;
                        ep_server.interface := ip.ivy;
                    }
                }
                
                nat_configured := false;

                force_client_forward := false;
                force_server_forward := false;

                forward_turn := false;
                forward_turn_count := 0;
                                
                # ppkt_to_be_forge := packet.quic_packet;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep_client := e; # TODO
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint_mim(host,s,src);  # because quic_net API doesn't tell us the dst socket_endpoint_mim
                is_receiving(dst) := true;
                var idx := pkts.begin;
                var past_data : stream_data := stream_data.empty;
                # TODO should not be here

                if ~nat_configured {
                    nat_configured := true;
                    ep_client      := src; # Like initial connection from client 
                    call nat_configured_event(src,dst);
                } 

                var is_enc     := true;
                var to_forward := false;
                var packet_number_of_coalesed : stream_pos := 0;

                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    var version := ppkt.segment(1,1+4);
                    var bversion := bytes_to_version(version);
                    var ptype : byte := bvand(0x30,header);

                    if bvand(ppkt.value(0),0xf0) = 0xc0 {
                        call tls_start_eavedrop(src,dst,ppkt)
                    };

                    if (bversion = 0 & is_long) | version_not_found(src) { 
                        # for server test, for version_negociation
                        # 1000 0000 == version_negociation
                        past_data := past_data.extend(ppkt);
                        # TODO
                    } 
                
                    else if (tt = 0x30 & is_long) & ~(bversion = 0)  {
                        #  Retry packet
                        # TODO
                    } 
                    else { 
                        var rnum := reference_pkt_num(ppkt,true);
                        var res := quic_prot.decrypt_quic(tls_id,rnum,ppkt);
                        var dcil : stream_pos := bfe[0][7](ppkt.value(5));
                        var ikm := cid_to_bytes(0,1); # dcid
                        if(~dcil = 0) {
                            client_initial_dcil := dcil;
                            ikm := ppkt.segment(6,6+dcil); # dcid
                        };
                        var dcid : cid := bytes_to_cid(ikm);

                        if res.ok {
                            is_enc := false;
                            var rppkt     := quic_packet_serdes.from_bytes(res.data);
                            rppkt.seq_num := quic_prot.correct_pnum(rnum,rppkt.seq_num,quic_prot.get_pnum_len(res.data));

                            call recv_packet(host,src,dst,rppkt);

                            var jdx := rppkt.payload.begin;
                            while jdx < rppkt.payload.end {
                                var f := rppkt.payload.value(jdx);
                                # TODO for frame
                                jdx := jdx.next;
                            };

                            if forward_packets { # To server
                                call receiving_packet(src,dst,rppkt, packet_number_of_coalesed);
                                packet_number_of_coalesed := packet_number_of_coalesed + 1;
                                if ~keep_coalesed {
                                    number_packet_recv_from(src) := number_packet_recv_from(src) + 1;
                                };
                            };                     
                        } else {
                            if is_long {
                                if is_random_padding_packet(ppkt) {
                                    var rppkt := quic_random_padding_encrypted_packet_serdes.from_bytes(ppkt);
                                    call recv_random_padding_or_short_packet_event(src,dst,rppkt);
                                    to_forward := true;
                                    if forward_packets { # To server
                                        call receiving_packet(src,dst,rppkt, packet_number_of_coalesed);
                                        packet_number_of_coalesed := packet_number_of_coalesed + 1;
                                        if ~keep_coalesed {
                                            number_encrypted_packet_recv_from(src) := number_encrypted_packet_recv_from(src) + 1;
                                        };
                                    };
                                } else {
                                    var rppkt := quic_encrypted_packet_serdes.from_bytes(ppkt);
                                    if already_forwarded(src,dst,rppkt) {
                                        call arp_duplicated_encrypted_packet_event(src,dst,rppkt);
                                    } else {
                                        to_forward := true;
                                        call recv_encrypted_packet(host,src,dst,rppkt);
                                        if forward_packets { # To server
                                            call receiving_packet(src,dst,rppkt, packet_number_of_coalesed);
                                            packet_number_of_coalesed := packet_number_of_coalesed + 1;
                                            if ~keep_coalesed {
                                                number_encrypted_packet_recv_from(src) := number_encrypted_packet_recv_from(src) + 1;
                                            };
                                        };
                                    } 
                                }
                            }
                            else {
                                # probably short header
                                to_forward := true;
                                var rppkt := quic_encrypted_short_packet_serdes.from_bytes(ppkt);
                                call recv_encrypted_short_packet(src,dst,rppkt);
                                if forward_packets { # To server
                                    call receiving_packet(src,dst,rppkt, packet_number_of_coalesed);
                                    packet_number_of_coalesed := packet_number_of_coalesed + 1;
                                    if ~keep_coalesed {
                                        number_encrypted_packet_recv_from(src) := number_encrypted_packet_recv_from(src) + 1;
                                    };
                                };
                            }
                        }
                    }
                    idx := idx.next; 
                };

                if forward_packets & keep_coalesed & to_forward { # To server
                    if is_enc {
                        number_encrypted_packet_recv_from(src) := number_encrypted_packet_recv_from(src) + 1;
                    } else {
                        number_packet_recv_from(src) := number_packet_recv_from(src) + 1;
                    };
                    call cppkt_forwarded_to_client_count_debug_event(number_packet_recv_from(src));
                    call cppkt_forwarded_to_server_count_debug_event(number_packet_recv_from(dst));

                    call cppkt_forwarded_to_client_count_debug_event(number_encrypted_packet_recv_from(src));
                    call cppkt_forwarded_to_server_count_debug_event(number_encrypted_packet_recv_from(dst));
                };
                is_receiving(dst) := false;
            }

            action tls_start_eavedrop(src:ip.endpoint,dst:ip.endpoint,spkt:stream_data) = {
                call client.set_ep(src);
                var tls_id := src_tls_id(dst); # todo multiple
                
                var version := bytes_to_version(spkt.segment(1,5));
                var lens := spkt.value(5);
                var dcil : stream_pos := bfe[0][7](spkt.value(5));
                var ikm := cid_to_bytes(0,1); # dcid
                if(~dcil = 0) {
                    client_initial_dcil := dcil;
                    ikm := spkt.segment(6,6+dcil); # dcid
                };
                var dcid : cid := bytes_to_cid(ikm);
                var scil : stream_pos := bfe[0][7](spkt.value(6+dcil));
                var skm := cid_to_bytes(0,1); # scid
                if(~scil = 0) {
                    client_initial_scil := scil;
                    client_non_zero_scil := true;	
                    skm := spkt.segment(6+dcil+1,6+dcil+1+scil); # scid
                };
                var scid : cid := bytes_to_cid(skm);

                if scil = 0 | dcil = 0 {
                    issued_zero_length_cid := true;
                }

                #  When an Initial packet is sent by a client that has not previously
                #    received an Initial or Retry packet from the server, the client
                #    populates the Destination Connection ID field with an unpredictable
                #    value.  This Destination Connection ID MUST be at least 8 bytes in
                #    length

                require dcil >= 8;

                if ~retry_sent(dcid) {
                    client_initial_dcid := dcid;
                    client_initial_scid := scid; # skm
                    call export_length_cid_extension(dcil,scil);
                    call export_length_cid(dcil,scil);
                };

                if ~tp_client_set | negocation_of_version(src) {
                    call tls_api.upper.eavesdrop(tls_id);  
                    # 'true' means this instance of tls is a server
                    tp_client_set := true;
                }; 

                client_initial_version := version;

                if client_initial_version ~= initial_version & client_initial_version ~= 0xfaceb002 { #initial_version todo
                    negocation_of_version(src) := true;
                } 
                else if (~initial_keys_set(dcid) & retry_client_test -> retry_sent(dcid)) | negocation_of_version(src) { 
                    call export_length_cid_extension(dcil,scil);
                    negocation_of_version(src) := false;

                    var salt : stream_data := stream_data.empty;
                    
                    #0xc3 ee f7 12 c7 2e bb 5a 11 a7 d2 43 2b b4 63 65 be f9 f5 02 QUIC-27
                    if client_initial_version = 0xfaceb002  
                    | client_initial_version = 0xff00001b 
                    | client_initial_version = 0xff00001c {
                        salt := salt.append(0xc3);
                        salt := salt.append(0xee);
                        salt := salt.append(0xf7);
                        salt := salt.append(0x12);
                        salt := salt.append(0xc7);
                        salt := salt.append(0x2e);
                        salt := salt.append(0xbb);
                        salt := salt.append(0x5a);
                        salt := salt.append(0x11);
                        salt := salt.append(0xa7);
                        salt := salt.append(0xd2);
                        salt := salt.append(0x43);
                        salt := salt.append(0x2b);
                        salt := salt.append(0xb4);
                        salt := salt.append(0x63);
                        salt := salt.append(0x65);
                        salt := salt.append(0xbe);
                        salt := salt.append(0xf9);
                        salt := salt.append(0xf5);
                        salt := salt.append(0x02);
                    };
                    #0xaf bf ec 28 99 93 d2 4c 9e 97 86 f1 9c 61 11 e0 43 90 a8 99 QUIC-29
                    if client_initial_version = 0xff00001d  {
                        salt := salt.append(0xaf);
                        salt := salt.append(0xbf);
                        salt := salt.append(0xec);
                        salt := salt.append(0x28);
                        salt := salt.append(0x99);
                        salt := salt.append(0x93);
                        salt := salt.append(0xd2);
                        salt := salt.append(0x4c);
                        salt := salt.append(0x9e);
                        salt := salt.append(0x97);
                        salt := salt.append(0x86);
                        salt := salt.append(0xf1);
                        salt := salt.append(0x9c);
                        salt := salt.append(0x61);
                        salt := salt.append(0x11);
                        salt := salt.append(0xe0);
                        salt := salt.append(0x43);
                        salt := salt.append(0x90);
                        salt := salt.append(0xa8);
                        salt := salt.append(0x99);
                    };
                    if client_initial_version = 0x00000001 | client_initial_version = 0xff000022 {
                        salt := salt.append(0x38);
                        salt := salt.append(0x76);
                        salt := salt.append(0x2c);
                        salt := salt.append(0xf7);
                        salt := salt.append(0xf5);
                        salt := salt.append(0x59);
                        salt := salt.append(0x34);
                        salt := salt.append(0xb3);
                        salt := salt.append(0x4d);
                        salt := salt.append(0x17);
                        salt := salt.append(0x9a);
                        salt := salt.append(0xe6);
                        salt := salt.append(0xa4);
                        salt := salt.append(0xc8);
                        salt := salt.append(0x0c);
                        salt := salt.append(0xad);
                        salt := salt.append(0xcc);
                        salt := salt.append(0xbb);
                        salt := salt.append(0x7f);
                        salt := salt.append(0x0a);
                    };

                    call show_set_initial_keys(ikm, tls_id);
                    call tls_api.upper.set_initial_keys(tls_id,salt,ikm);
                    
                    initial_keys_set(dcid) := true;
                }
            }
                

            action is_random_padding_packet(spkt:stream_data) returns (is_padding:bool) = {
                var first_byte := spkt.value(0);
                var header_typer := bvand(first_byte,0x7f);
                if header_typer = first_byte {
                    is_padding := true;
                } else {
                    is_padding := false;
                };
            }

            # TODO use serializer
            # action modify_packet(ppkt:packet.quic_packet) returns(rppkt:packet.quic_packet) =  {
            #     #var version := bytes_to_version(spkt.segment(1,5));
            #     var tppkt := ppkt;
            #     tppkt := tppkt.set(1,0xff);
            #     tppkt := tppkt.set(2,0x00);
            #     tppkt := tppkt.set(3,0x00);
            #     tppkt := tppkt.set(4,0x1d);
            #     rppkt := tppkt;
            # }

            # TODO add dynamic condition to save packets
            action save_packets(ppkt:packet.quic_packet) = {
                # TODO if saved_packet_type ...
                #ppkt_saved := ppkt;
                <<<
                    const char * session_file = getenv("SAVED_PACKET");
                    std::cerr << "SAVED_PACKET 5b " << ppkt.size() << "\n";
                    FILE *fp;
                    if(session_file != NULL) {
                        fp = fopen(session_file,"w");
                        for(int j = 0; j < ppkt.size(); j++) {
                            fprintf(fp, "%02x",  ppkt[j]); //length field
                        }
                        fclose(fp);
                    }        
                >>>
            }

            action get_saved_packets returns(ppkt:packet.quic_packet) = {
                # TODO if saved_packet_type ...
                #ppkt_saved := ppkt;
                <<<
                    const char * session_file = getenv("SAVED_PACKET");
                    std::cerr << "SAVED_PACKET 5b " << session_file<< "\n";
                    FILE *fp;
                    if(session_file != NULL) {
                        fp = fopen(session_file,"r");
                        read = getline(&line, &len, fp);
                        fclose(fp);
                        bool is_error = false;
                        if(line != NULL) { 
                            std::cerr << "SAVED_PACKET 1 " << line << std::endl;
                            int hex_len = strlen(line);
                            std::cerr << "SAVED_PACKET hex_len " << hex_len << std::endl;
                            uint8_t secret[hex_len/2];
                            for (int j = 0; j < hex_len/2; j++) {
                                int a = ws_xton(line[j*2]);
                                int b = ws_xton(line[j*2 + 1]);
                                if (a == -1 || b == -1) {
                                    is_error = true;
                                    std::cerr << "a ERROR " << line[j*2] << std::endl;
                                    std::cerr << "b ERROR " << line[j*2 + 1] << std::endl;
                                    std::cerr << "SAVED_PACKET ERROR " << std::endl;
                                    break;
                                }
                                secret[j] = a << 4 | b;
                            }  
                            std::cerr << "SAVED_PACKET TEST_ST 2 " << secret << std::endl;
                            for(int i = 0; i < hex_len/2 && !is_error; i++)
                                ppkt.push_back(secret[i]);
                        }
                    }        
                >>>
            }

            action reflection_packets(ppkt:packet.quic_packet,dst_port:ip.port) = {
                # spoof source ip/port
                # TODO: we should modify the packet directly, however we only see the QUIC packet and thus this 
                # is impossible for now to do so 
                # Instead: we send with target ep so it simulate the ip spoofing
                # forward to server
                var dst := ep_server;
                var pkts_mim := quic_prot.arr.empty;
                var spkt := quic_packet_serdes.to_bytes(ppkt);
                pkts_mim := pkts_mim.append(spkt);
                call quic_net.send(endpoint_id.target,sock_target,dst,pkts_mim);
            }

            action configure_NAT_attack_in = {
                <<<
                    //  very important for modifying the packet
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.2  10.0.0.3 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_bidir = {
                <<<
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.3  -r 10.0.0.2 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_out = {
                <<<
                    std::string command = "arpspoof -i veth_ivy -t 10.0.0.3  10.0.0.2 &";
                    int n = command.length();
                    char command_array[n + 1];
                    strcpy(command_array, command.c_str());
                    int cr = system(command_array);
                >>>
            }

            action reset_NAT = {
                <<<
                    const char * command = "pkill arpspoof;"; 
                    int cr = system( command );
                >>>
            }

            import action cppkt_forwarded_to_server_count_debug_event(count:stream_pos)
            import action cppkt_forwarded_to_client_count_debug_event(count:stream_pos)

            import action nat_configured_event(src:ip.endpoint, dst:ip.endpoint)
            import action client_target_setup_event(src:ip.endpoint)
            import action recv_encrypted_short_packet(src:ip.endpoint, dst:ip.endpoint, pkt:packet.encrypted_short_quic_packet)
            import action recv_random_padding_or_short_packet_event(src:ip.endpoint, dst:ip.endpoint, pkt:packet.random_padding_encrypted_quic_packet)
            import action arp_duplicated_encrypted_packet_event(src:ip.endpoint, dst:ip.endpoint, pkt:packet.encrypted_quic_packet)
            import action recv_packet(host:endpoint_id,src:ip.endpoint,dst:ip.endpoint,pkt:packet.quic_packet)
            import action recv_encrypted_packet(host:endpoint_id,src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet)
        }
    
    }

    object attacker_endpoint = {
        ...

        module attacker_quic_ep(address:ip.addr,port:ip.port) = { 
            #variant endpoint of attacker_endpoint = struct { }
            individual ep        : ip.endpoint
            individual tls_id    : tls_api.id

            after init {
                ep.protocol := ip.udp;
                ep.addr := address;
                ep.port := port;
            }
            
            action set_ep(e:ip.endpoint) = {
                ep := e;
            }

            action set_tls_id(e:tls_api.id) = {
                tls_id := e;
            }

            action behavior(host:endpoint_id, s:quic_net.socket, src:ip.endpoint, pkts:quic_prot.arr) = {
                var dst := socket_endpoint(host,s);  # because quic_net API doesn't tell us the dst
                var idx := pkts.begin;
                # var past_data : packet.quic_packet := packet.quic_packet.arr.empty;
                while idx < pkts.end {
                    var ppkt := pkts.value(idx);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var header := ppkt.value(0);
                    var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                    var tt := bvand(hdr_type,0x30);
                    var is_long : bool := bvand(0x80,header) ~= 0;
                    
                    var version := ppkt.segment(1,1+4);
                    # var bversion := bytes_to_version(version);
                    
                    var ptype : byte := bvand(0x30,header);
                    idx := idx.next;
                };
            }

            action configure_NAT_attack_in_spoof(server_quic:ip.port,target_ep:ip.port) = {
                <<<
                    // should use postrouting
                    std::string command = "iptables -t nat -A OUTPUT -o lo -d 127.0.0.1 -p udp --dport " + std::to_string(server_quic) + ":" + std::to_string(server_quic) + " -j DNAT --to-destination 127.0.0.1:"+ std::to_string(target_ep) +">/dev/null 2>&1"; 
                    int n = command.length();
                    std::cerr << "configure_NAT_attack_in_spoof " << command << "\n";
                    // declaring character array
                    char command_array[n + 1];
                
                    // copying the contents of the
                    // string to char array
                    strcpy(command_array, command.c_str());

                    int cr = system(command_array);
                >>>
            }

            action configure_NAT_attack_in_spoof_hack(server_quic:ip.port,target_ep:ip.port) = {
                sock_attacker := sock_target; 
            }
            
            action reset_NAT = {
                <<<
                    const char * command = "iptables -t nat -L -n -v;iptables -t nat -F >/dev/null 2>&1"; 
                    int cr = system( command );
                >>>
            }
        }
    }
}
