#lang ivy1.7 

include collections

object packet = {
    
    type this 

    instance idx : unbounded_sequence
    instance arr : array(idx,this) 

    # Normal behavior

    action handle(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    ## Man in the middle

    action forward_to(src:ip.endpoint,dst:ip.endpoint,pkt:packet.arr)

    around forward_to(src:ip.endpoint,dst:ip.endpoint,pkt:packet.arr) {
        # require _generating;
        require pkt.end > 0;
        require src = mim_agent.ep_server & dst = mim_agent.ep_client  |
                src = mim_agent.ep_client & dst = mim_agent.ep_server;

        require packet_to_forward(dst).end > 0;
        require mim_agent.nat_configured;
        require src ~= dst;
        require num_queued_packets(dst) > 0;
        require pkt = packet_to_forward(dst);
        ...
        packet_to_forward(dst)  := packet.arr.empty;
        num_queued_packets(dst) := 0;
        call update_received_packet(src,dst);
    }

    action replay_to(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action replay_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action replay_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action drop(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action drop_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action drop_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action modify(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action modify_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action modify_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action delay_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action delay_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action duplicate_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action duplicate_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action reorder_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    action reorder_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:this) = {
        require false; 
    }

    ## White noise

    # 1. Denial-of-Service (DoS) Attacks

    action flood(src:ip.endpoint,dst:ip.endpoint, pkt:this) = {
        require false; 
    }
}


# Packet protocol state
# ---------------------

function packets_received_last_round(C:ip.endpoint) : packet.arr
function packets_received(C:ip.endpoint)            : packet.arr
 
function num_queued_packets(C:ip.endpoint) : packet.idx
function packet_to_forward(C:ip.endpoint)  : packet.arr

after init {
    num_queued_packets(C)         := 0;
    packet_to_forward(C)          := packet.arr.empty;
    packets_received(C)            := packet.arr.empty;
    packets_received_last_round(C) := packet.arr.empty;
}

action enqueue_packet(src:ip.endpoint,dst:ip.endpoint,pkt:packet) = {
    packet_to_forward(dst)  := packet_to_forward(dst).append(pkt);
    num_queued_packets(dst) := packet_to_forward(dst).end; 
}

action receiving_packet(src:ip.endpoint,dst:ip.endpoint,pkt:packet)

action already_forwarded(src:ip.endpoint,dst:ip.endpoint,pkt:packet) returns (res:bool) = {
    var i : packet.idx := 0;
    res := false;
    while i < packets_received(dst).end {
        if packets_received(dst).value(i) = pkt {
            res := true;
        }
        i := i.next;
    }
}

action update_received_packet(src:ip.endpoint,dst:ip.endpoint) 

after update_received_packet(src:ip.endpoint,dst:ip.endpoint) {
    var i : packet.idx := 0;
    while i < packets_received_last_round(dst).end {
        packets_received(dst) := packets_received(dst).append(packets_received_last_round(dst).value(i));
        i := i.next;
    }
    packets_received_last_round(dst) := packet.arr.empty;
}