#lang ivy1.7

# Packet protocol state
# ---------------------

object packet = {
    ...

    object ping_packet = {

        ...

        action forward_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet)
        around forward_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet) {
            require _generating;
            require pkt.payload.end > 0;
            require mim_agent.nat_configured;
            require src ~= dst;
            ...
            call enqueue_packet(src,dst,pkt);
            is_ping_packet_received(dst,pkt) := true;
        }
        
        action forward_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet)
        around forward_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet) {
            require _generating;
            require pkt.payload.end > 0;
            require mim_agent.nat_configured;
            require src ~= dst;
            ...
            call enqueue_packet(src,dst,pkt);
            is_ping_packet_received(dst,pkt) := true;
        }

        action replay_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet)
        around replay_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet) {
            require _generating;
            require pkt.payload.end > 0;
            require is_ping_packet_received(dst,pkt);
            require ping_packets_received_last_round(dst).end > 0;
            require mim_agent.nat_configured;
            require src = mim_agent.ep_server & dst = mim_agent.ep_client;
            require src ~= dst;
            ...
            call enqueue_packet(src,dst,pkt);
            is_ping_packet_received(dst,pkt) := false;
        }

        action replay_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet)
        around replay_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet) {
            require _generating;
            require pkt.payload.end > 0;
            require is_ping_packet_received(dst,pkt);
            require ping_packets_received_last_round(dst).end > 0;
            require mim_agent.nat_configured;
            require src = mim_agent.ep_client & dst = mim_agent.ep_server;
            require src ~= dst;
            ...
            call enqueue_packet(src,dst,pkt);
            is_ping_packet_received(dst,pkt) := false;
        }

        action modify(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet)
        around modify(src:ip.endpoint,dst:ip.endpoint,pkt:packet.ping_packet) {
            require _generating;
            require pkt.payload.end > 0;
            require mim_agent.nat_configured;
            require is_ping_packet_received(dst,pkt);
            require ping_packets_received_last_round(dst).end > 0;
            require src ~= dst;
            ...
            call enqueue_packet(src,dst,pkt);
            is_ping_packet_received(dst,pkt) := true;
        }   
    }
}



function ping_packets_received_last_round(C:ip.endpoint) : packet.ping_packet.arr 
function ping_packet_received_last_round(C:ip.endpoint) : packet.ping_packet
relation is_ping_packet_received(C:ip.endpoint, P:packet.ping_packet) 

after init {
    ping_packets_received_last_round(C) := packet.ping_packet.arr.empty;
}

after receiving_packet(src:ip.endpoint,dst:ip.endpoint,pkt:packet) {
    packets_received_last_round(dst) := packets_received_last_round(dst).append(pkt);
    packets_received(dst)            := packets_received(dst).append(pkt);
    if some(cf:packet.ping_packet) pkt *> cf  {
        ping_packet_received_last_round(dst)  := cf;
        is_ping_packet_received(dst,cf)       := true;
        ping_packets_received_last_round(dst) := ping_packets_received_last_round(dst).append(cf);
    } 
}

after update_received_packet(src:ip.endpoint,dst:ip.endpoint) {
    # is_ping_packet_received(dst) := false;
    ping_packets_received_last_round(dst) := packet.ping_packet.arr.empty;
}