#lang ivy1.7
include order
include collections

include apt_types

include apt_byte_stream

include apt_packet

include apt_time
include tls_api

include protection

##import action show_current_time_debug_event(now:milliseconds)


object packet = {
    ...

    after forward_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.arr) {
        if _generating {
            # TODO assert it is smaller than MTU
            var idx := pkt.begin;
            var pkts_mim := quic_prot.arr.empty;
            while idx < pkt.end {
                # packets_received(pkt.value(idx)) := true;
                var p := pkt.value(idx);
                # QUIC
                if some(cf:packet.quic_packet)p *> cf {
                    var spkt := quic_packet_serdes.to_bytes(cf);
                    var rnum := reference_pkt_num(spkt,false);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var other_tls_id := dst_tls_id(dst);
                    var ppkt := quic_prot.encrypt_quic(other_tls_id,rnum,spkt);
                    pkts_mim := pkts_mim.append(ppkt);
                } 
                else if some(cf:packet.encrypted_quic_packet)p *> cf {
                    var spkt := quic_encrypted_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                } 
                else if some(cf:packet.encrypted_short_quic_packet)p *> cf {
                    var spkt := quic_encrypted_short_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                } 
                else if some(cf:packet.random_padding_encrypted_quic_packet)p *> cf {
                    var spkt := quic_random_padding_encrypted_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                }
                # MiniP
                else if some(cf:packet.ping_packet)p *> cf {
                    var spkt := ping_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                }
                # Stream Data
                else if some(cf:packet.malicious_stream_data_packet)p *> cf {
                    pkts_mim := pkts_mim.append(cf.payload);
                };
                #TODO allow forwarding coalesed packet or not
                idx := idx.next; 
            }; 
            call quic_net.send(endpoint_id.man_in_the_middle,endpoint_to_socket_mim(src),dst,pkts_mim); # TODO endpoint_to_socket_mim
        }
    }  

    after forward_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.arr) {
        if _generating {
            # TODO assert it is smaller than MTU
            var idx := pkt.begin;
            var pkts_mim := quic_prot.arr.empty;
            while idx < pkt.end {
                # packets_received(pkt.value(idx)) := true;
                var p := pkt.value(idx);
                # QUIC
                if some(cf:packet.quic_packet)p *> cf {
                    var spkt := quic_packet_serdes.to_bytes(cf);
                    var rnum := reference_pkt_num(spkt,false);
                    var tls_id := src_tls_id(dst); # todo multiple
                    var other_tls_id := dst_tls_id(dst);
                    # if ~mim_agent.server_initial_response {
                    #     tls_id := other_tls_id;
                    # }
                    var ppkt := quic_prot.encrypt_quic(tls_id,rnum,spkt);
                    pkts_mim := pkts_mim.append(ppkt);
                } 
                else if some(cf:packet.encrypted_quic_packet)p *> cf {
                    var spkt := quic_encrypted_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                } 
                else if some(cf:packet.encrypted_short_quic_packet)p *> cf {
                    var spkt := quic_encrypted_short_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                } 
                else if some(cf:packet.random_padding_encrypted_quic_packet)p *> cf {
                    var spkt := quic_random_padding_encrypted_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                }
                # MiniP
                else if some(cf:packet.ping_packet)p *> cf {
                    var spkt := ping_packet_serdes.to_bytes(cf);
                    pkts_mim := pkts_mim.append(spkt);
                }
                # Stream Data
                else if some(cf:packet.malicious_stream_data_packet)p *> cf {
                    pkts_mim := pkts_mim.append(cf.payload);
                };
                #TODO allow forwarding coalesed packet or not
                idx := idx.next; 
            }; 
            call quic_net.send(endpoint_id.man_in_the_middle,endpoint_to_socket_mim(src),dst,pkts_mim); # TODO endpoint_to_socket_mim
        }
    }  
}
# Print in hex format
attribute radix=16
attribute stream_pos.cardinality = 4