#lang ivy1.7

include order
include file
# include random_value

include ivy_quic_mim
include ivy_quic_target
include ivy_quic_attacker

include ivy_quic_shim
include ivy_quic_shim_mim

include ivy_man_in_the_middle_quic_behavior

include ivy_quic_client_standard_tp

# NB: need bigger timeout (at least 90 sec)

after init {
    is_mim_standalone := true;
    call mim_agent.configure_NAT_attack_in;
    call mim_agent.configure_NAT_attack_out;
}


object packet = {
    ...
    
    object quic_packet = {
        ...
        before forward_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_client.addr ~= 0;  # must have a client address to send to
                require src = mim_agent.ep_server;
                require dst = mim_agent.ep_client;
                require pkt = mim_agent.packet_to_forward_to(mim_agent.ep_client,mim_agent.last_packet_forwarded_to(mim_agent.ep_client)); # TODO check
            } 
        }
        
        before forward_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_server.addr ~= 0;  # must have a client address to send to
                require dst = mim_agent.ep_server;
                require src = mim_agent.ep_client;
                require pkt = mim_agent.packet_to_forward_to(mim_agent.ep_server,mim_agent.last_packet_forwarded_to(mim_agent.ep_server)); # TODO check       
            } 
        }
    }
}

import action show_last_cppkt_forwarded_to_client_debug_event(x:stream_pos)
import action show_last_cppkt_forwarded_to_server_debug_event(x:stream_pos)

export packet.quic_packet.forward_to_client
export packet.quic_packet.forward_to_server

attribute packet.quic_packet.forward_to_server.weight = "5"
attribute packet.quic_packet.forward_to_client.weight = "15"


object packet = {
    ...
    
    object encrypted_quic_packet = {
        ...

        before replay_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_client.addr ~= 0;  # must have a client address to send to
                require src = mim_agent.ep_server;
                require dst = mim_agent.ep_client;
                # require mim_agent.packet_number_to_be_replayed(mim_agent.ep_client) < mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client) & mim_agent.packet_number_to_be_replayed(mim_agent.ep_client) > 0;
                # require exists H. H < mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client) & H >= 0 & pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_client, H) ; # TODO check
            } 
        }

        before replay_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_server.addr ~= 0;  # must have a client address to send to
                require dst = mim_agent.ep_server;
                require src = mim_agent.ep_client;
                # require mim_agent.packet_number_to_be_replayed(mim_agent.ep_server) < mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server) & mim_agent.packet_number_to_be_replayed(mim_agent.ep_server) >= 0;
                # require exists H. H < mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server) & H >= 0 & pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_server, H); # TODO check
            } 
        }

        before forward_to_client(src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_client.addr ~= 0;  # must have a client address to send to
                require src = mim_agent.ep_server;
                require dst = mim_agent.ep_client;
                if mim_agent.encrypted_padding_packet_to_forward_to(mim_agent.ep_client,1000).end > 0 {
                    require pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_client,mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client)+1);
                } else {
                    require pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_client,mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client)); # TODO check
                }
            } 
        }
        
        before forward_to_server(src:ip.endpoint,dst:ip.endpoint,pkt:packet.encrypted_quic_packet.arr) {
            call show_last_cppkt_forwarded_to_server_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server));
            call show_last_cppkt_forwarded_to_client_debug_event(mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client));
            if _generating {
                require mim_agent.ep_server.addr ~= 0;  # must have a client address to send to
                require dst = mim_agent.ep_server;
                require src = mim_agent.ep_client;
                if mim_agent.encrypted_padding_packet_to_forward_to(mim_agent.ep_server,1000).end > 0 {
                    require pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_server,mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server)+1); # TODO check
                } else {
                    require pkt = mim_agent.encrypted_packet_to_forward_to(mim_agent.ep_server,mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server)); # TODO check       
                }
            } 
        }
    }
}


export packet.encrypted_quic_packet.forward_to_client
export packet.encrypted_quic_packet.forward_to_server

attribute packet.encrypted_quic_packet.forward_to_server.weight = "5"
attribute packet.encrypted_quic_packet.forward_to_client.weight = "15"

# export packet.encrypted_quic_packet.replay_to_client
# export packet.encrypted_quic_packet.replay_to_server

# attribute packet.encrypted_quic_packet.replay_to_server.weight = "20"
# attribute packet.encrypted_quic_packet.replay_to_client.weight = "20"

# Final check
#
# When the test is complete, the tester calls the special action `_finalize`.
# We use this action to make some heuristic checks, for example that some
# data was actually received from the server. We can add advice to this
# action with additional checks.

export action _finalize = {
    # chris TODO 
    call mim_agent.reset_NAT;
    require mim_agent.last_packet_forwarded_to(mim_agent.ep_server) > 0 | mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server) > 0;
    require mim_agent.last_packet_forwarded_to(mim_agent.ep_client) > 0 | mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client) > 0;
    require mim_agent.last_packet_forwarded_to(mim_agent.ep_client) = mim_agent.number_packet_forwarded_to(mim_agent.ep_client) | mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_client) = mim_agent.number_encrypted_packet_forwarded_to(mim_agent.ep_client);
    require mim_agent.last_packet_forwarded_to(mim_agent.ep_server) = mim_agent.number_packet_forwarded_to(mim_agent.ep_server) | mim_agent.last_encrypted_packet_forwarded_to(mim_agent.ep_server) = mim_agent.number_encrypted_packet_forwarded_to(mim_agent.ep_server);
}


attribute radix=16

# This gives the interpretation of some of the basic data types.
# Some of these interpretations are chosen to make solving more efficient.
# Notably, the `intbv` type can be used to represent large numbers with
# small bit vector enodings.

interpret cid -> longbv[1][13][20]
interpret version -> bv[32]
interpret pkt_num -> bv[32]
interpret error_code -> bv[16]
interpret stream_id -> bv[16]

attribute quic_frame.idx.cardinality = 1
attribute quic_frame.ack.range.idx.cardinality = 1
attribute pkt_num.cardinality = 1
attribute stream_pos.cardinality = 4