#lang ivy1.7

include tcp_impl

module bgp_network(addr,pkt,ser,des) = {

    type socket

    # calls

    action close(self:addr,s:socket)

    action connect(self:addr,other:addr) returns (s:socket)

    action send(self:addr,s:socket,p:pkt) returns (ok:bool)

    # callbacks

    action accept(self:addr,s:socket,other:addr)

    action recv(self:addr,s:socket,p:pkt)

    action failed(self:addr,s:socket)

    action connected(self:addr,s:socket)
    
    var open(A:addr,S:socket) : bool
    var req(A1:addr,S1:socket,A2:addr) : bool
    var ack(A1:addr,S1:socket) : bool
    var conn(A1:addr,S1:socket,A2:addr,S2:socket) : bool
    var sent_to(A:addr,S:socket,P:pkt) : bool
        
    object spec =  {


        after init {
            open(A,S) := false;
            req(A,S,A1) := false;
            ack(A,S) := false;
            conn(A1,S1,A2,S2) := false;
            sent_to(A,S,P) := false;
        }


        after connect {
            assume ~open(self,s) & ~req(self,s,A) & ~ack(self,s); # can't return socket in use
            req(self,s,other) := true;
        }

        around accept {
            require exists S. req(other,S,self);
            require ~open(self,s) & ~req(self,s,A) & ~ack(self,s); # can't return socket in use
            ...
            open(self,s) := true;
            if some (s2 : socket) req(other,s2,self) {
                conn(self,s,other,s2) := true;
                conn(other,s2,self,s) := true;
                req(other,s2,self) := false;
                ack(other,s2) := true
            }
        }

        around connected {
            require ack(self,s);
            ...
            open(self,s) := true;
            ack(self,s) := false;
        }

        around send {
            require open(self,s);
            ...
            if ok {
                if some (other:addr,s2:socket) conn(self,s,other,s2) {
                    sent_to(other,s2,p) := true
                }
            } 
        }

        before recv {
            require open(self,s);
            require sent_to(self,s,p);
        }            

        around close {
            require open(self,s);
            ...
            open(self,s) := false;
            sent_to(self,s,P) := false;
            conn(A,S,self,s) := false;
            conn(self,s,A,S) := false;
        }

        around failed {
            require exists A. req(self,s,A) | ack(self,s) | open(self,s);
            ...
            open(self,s) := false;
            req(self,s,A) := false;
            ack(self,s) := false;
            sent_to(self,s,P) := false;
            conn(A,S,self,s) := false;
        }
        
        invariant ~(open(A,S) & (req(A,S,A1) | ack(A,S))) & ~(req(A,S,A1) & ack(A,S))
        invariant req(A,S,A1) & req(A,S,A2) -> A1 = A2
        invariant (conn(A,S,A1,S1) | sent_to(A1,S1,P)) -> (open(A1,S1) | ack(A1,S1))
        invariant conn(A1,S1,A,S) -> (open(A1,S1) | ack(A1,S1))
    }

    
    implementation {
        instance impl(X:addr) : tcp_impl(addr,pkt,X,179,)
    }

    isolate iso = this
    attribute test = impl
}

instance net : bgp_network(endpoint_id,prot.arr,bgp_prot_ser,bgp_prot_deser)