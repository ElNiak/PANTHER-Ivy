#lang ivy1.7

# This file provide the theory of greatest common divisors for
# the natural numbers. 

# First, we instantiate a type corresponding to the natural numbers.

include arith_nat

instance nat : arith_nat

# Relation `dvds(X,Y)` is true if X is a divisor of Y. We define it
# here in terms of the integer divison operator instead of saying the
# there exists a number `N` such that `N * Y = Y`. This is convenient
# because it lets Z3's non-linear arithmetic capability do some work
# for us.

relation dvds(X:nat,Y:nat)
definition dvds(X,Y) = (X > 0 & (Y/X) * X = Y)

# Relation `commdiv(Z,X,Y)` is true if Z is a common divisor of X and
# Y.

function commdiv(Z,X,Y) = dvds(Z,X) & dvds(Z,Y) 

# Definition of greatest common divisor (GCD). Z is a GCD of X,Y if Z
# is a common divisor of X and Y and if no lesser number is so.

relation is_gcd(Z:nat,X:nat,Y:nat)

definition {is_gcd(Z,X,Y) =
    commdiv(Z,X,Y) & forall W. commdiv(W,X,Y) -> Z >= W}

# Definition (GCD function). 
#
# We can now define a function `gcd(X,Y)` that returns the GCD when X
# and Y are positive and is otherwise undefined. We firsty prove a
# lemma [foo] that, under the assumption, that `X` and `Y` are
# positive, a GCD exists. This is done by unfolding the definition of
# GCD and matching the greatest element principle provided by
# `arith_nat`. This says that any non-empty, upper-bounded set of
# natural numbers has a maximum element.  As the upper bound `n`, we
# use X, since a divisor of X cannot be greater than X.

# This generates two subgoals: that there exists a common divisor
# [prem1] and that there is no common divisor greater than `X`
# [prem2].  The first premise we witness with 1, which is always a
# common divisor.  The second Z3 can prove by itself. From the lemma,
# Z3 can prove the goal.  This amounts to just moving the condition 'X
# and Y are positive' inside the existential quantifier.
#
# By showing the existence of Z, we can define a function `gcd(X,Y)`
# that yields some Z satisfying the property. This gives us the
# property `X > 0 & Y > 0 -> is_gcd(gcd(X,Y),X,Y)`. When X or Y is
# zero, `gcd(X,Y)` can be any number.

explicit property [gcd_prop]
exists Z. X > 0 & Y > 0 -> is_gcd(Z,X,Y)
named gcd(X,Y)

proof {
    theorem [foo] {
        property X:nat>0 & Y:nat>0
        property exists Z. is_gcd(Z,X,Y)
    }
    proof {
        unfold with is_gcd
        apply nat.gep with n=X
        proof [prem1] {
            instantiate with Z=1:nat
        }
    }
}

# Definition (prime number).
#
# A natural number `X > 1`  is *prime* if its divisors are only one and
# itself.
#

relation prime(X:nat)
definition {prime(X) = X > 1 & forall Y. dvds(Y,X) -> Y=1 | Y=X}

# Lemma.
#
# If `N>0` is a natural number and `P` is a prime number, then either
# `N` and `P` are coprime or `P` divides `N`.
#
# To prove this, we instantiate the GCD property, the definition
# `is_gcd`, the definition of prime number and the definition of
# common divisor. The idea is that since `gcd(N,P)` divides `P` and
# `P` is prime, it must equal `1` or `P`. In the first case we have
# our conclusion directly.  in the second case, we have the
# `dvds(P,N)` by the definition of common divisor.

isolate bif = {

    theorem [lemma_prime_coprime] {
        property N:nat > 0
        property [prem] prime(P)
        property gcd(N,P) = 1 | dvds(P,N)
    }
    proof {
        unfold prem with prime
        instantiate prem with Y=gcd(N,P)
        instantiate [gp] gcd_prop with X=N,Y=P
        unfold gp with is_gcd
        instantiate gp with W = N
        instantiate commdiv with Z=gcd(N,P),X=N,Y=P
    }
} with nat

isolate ms = {

    # Lemma (Multiplication expanding).
    #
    # If `X` is positive, then `MX >= M`.

    theorem [mul_expand] {
        property X:nat > 0
        property M:nat * X >= M
    }

    # Lemma (Division by subtraction).
    #
    # If `M` positive and `N >= M` then `N:nat/M = (N - M) / M + 1`
    #
    # Proof. Z3 can't prove this directly. We have to tell it to
    # distribute the division over the subtraction. Note, integer
    # division does not always distribute, but it does in this case.
    
    theorem [div_rec] {
        property M:nat > 0 & N:nat >= M
        property N:nat/M = (N - M) / M + 1
    }
     proof {
        property (N:nat - M) / M = N/M - M/M proof {}
    }

} with nat


relation quot_rem(N:nat,M:nat,Q:nat,R:nat)
definition {quot_rem(N,M,Q,R) = R < M & N = Q * M + R}

isolate dv = {

# Theorem (Quotient/Remainder existence).
#
# Let `N,M` be natural numbers with `M > 0`. There exists natural numbers `Q,R`
# such that `R < M`  and  `N = Q * M + R`
#
# Proof by general induction on `N`. If `N` is less than `M`, then
# `Q=0` and `R=N`. Else let `_Q,_R` be the quotient and remainder for
# `N-M`, by the inductive hypothesis. Then `Q=_Q+1` and `R=_R`.


    explicit property [quot_rem_ex]
    M:nat > 0 -> exists Q,R. quot_rem(N,M,Q,R)
    proof {
        unfold with quot_rem
        apply nat.gen_ind with X=N
        apply exmid with q = (x < M)
        proof [pos] {
            instantiate with Q=0:nat,R=x
            forget ind_hyp
        }
        proof [neg] {
            instantiate ind_hyp with Y = x - M
            tactic skolemize
            instantiate with Q = _Q + 1, R = _R
        }
    }

    # Theorem (Quotient/Remainder uniqueness).
    # 
    # Let `N,M` be natural numbers with `M > 0` and let `Q,R,Q1,R1` be such thar
    # `quot_rem(N,M,Q,R)` and `quot_rem(N,M,Q1,R1)`. Then `Q1=Q` and `R1=R`.
    #
    # Proof. Assume `Q1~=Q` and consider the case `Q < Q1`. We have `R
    # = M:nat * (Q1-Q) + R1` and, since `Q1-Q` is positive, we have `M * (Q:nat -Q1) >= M`.
    # Thus, `R1 >= M`, a contradiction. The case `Q > Q1` is symmetric. Thus
    # by contradiction `Q1=Q` and hence `R1=R`.
    #
    # Notice in the proof, the cases `Q < Q1` and `Q > Q1` are not
    # quite symmetric. This is because in the latter case, Z3 doesn't
    # get the fact that `M * (Q:nat -Q1) >= M` and we have to prove it
    # manually. This is characteriztic of non-linear arithmetic using
    # Z3: sometimes there are very simple facts that is doesn't get,
    # and there is some guesswork involved in finding the missing fact
    # that it needs. Although the proof below looks simple, it was
    # quite time-consuming to produce because Z3 diverged or produced
    # an "unknown" result without giving good feedback as to the
    # source of the problem.
    
    explicit property [quot_rem_uniq]
    M:nat > 0 & quot_rem(N,M,Q,R) & quot_rem(N,M,Q1,R1) -> Q1=Q & R1=R
    proof {
        unfold with quot_rem
        apply introImp
        apply exmid with q = (Q=Q1)
        proof [neg] {
            apply exmid with q = (Q < Q1)
            proof [pos] {
                property R = M:nat * (Q1-Q) + R1 proof {}
            }
            proof [neg] {
                property R1 = M:nat * (Q-Q1) + R proof {}
                property M * (Q:nat -Q1) >= M proof {apply ms.mul_expand}
            }
        }
    }

    # Lemma (Division).
    #
    # If `M > 0` then for some `R`, `quot_rem(N,M,N/M,R)`.
    #
    # Since `R` is unique, this coould be seen as a definition of the
    # division operator. However, we can't define `/` because it is
    # already interpreted in the natural number theory. Instead, we
    # prove it from this theory. Unfortunately, Z3 can't prove it
    # because of the existential quantifier.
    #

    theorem [div_lem] {
        property M:nat > 0
        property exists R. quot_rem(N,M,N/M,R)
    }

    proof {
        unfold with quot_rem
        apply nat.gen_ind with X=N
        apply exmid with q = (x < M)
        proof [pos] {
#            property Q = 0 proof {}
            instantiate with R = x
            forget ind_hyp
        }
        proof [neg] {
            instantiate ind_hyp with Y = x - M
            tactic skolemize
            property x/M = (x - M) / M + 1 proof {apply ms.div_rec}
            instantiate with R = _R
        }
    }

} with nat

# Lemma.
#
# If `N>M>0` then `gcd(M,N) = gcd(M,N-M)`
#

isolate da = {
    explicit property [dvds_alt] forall X,Y. dvds(X,Y) <-> (X > 0 & exists Z. Z * X = Y)
    proof {
        tactic skolemize
        apply introIff
        proof [fwd] {
            instantiate with Z = _Y/_X
            unfold prem with dvds
        }
        proof [rev] {
            tactic skolemize
            unfold with dvds
            property _Y/_X = _Z 
            showgoals
        }
    }
} with nat

isolate ge = {
    explicit property [gcd_euclid] N > M & M > 0 -> gcd(M,N) = gcd(M,N-M)

    proof {
        apply introImp
        property [lem] forall Z. (commdiv(Z,M,N) <-> commdiv(Z,M,N-M))
        proof {
            tactic skolemize
            apply introIff
            proof [fwd] {
                unfold prem with commdiv,da.dvds_alt
                unfold with commdiv,da.dvds_alt
                tactic skolemize
                instantiate with Z_a = (_Z_b - _Z_a), Z = _Z_a
            }
            proof [rev] {
                unfold prem with commdiv,da.dvds_alt
                unfold with commdiv,da.dvds_alt
                tactic skolemize
                instantiate with Z_a = (_Z_b + _Z_a), Z = _Z_a
            }
        }
        instantiate [g1] gcd_prop with X=M,Y=N
        instantiate [g2] gcd_prop with X=M,Y=N-M
        unfold g1 with is_gcd
        unfold g2 with is_gcd
    }
} with nat

isolate bl = {

    # Theorem (Bezout's lemma).

    # explicit property [bezout_lemma]
    # forall S:nat. S > 0 & T >= S -> exists A,B. A*S - B*T = gcd(S,T)
    
    # proof {
    #     apply nat.gen_ind with X=T
    #     apply introA<_S/x>
    #     apply exmid with q = (x-_S >= _S)
    #     proof [pos] {
    #         apply exmid with q = x > _S
    #         proof [pos] {
    #             instantiate ind_hyp with S=_S, Y = x-_S
    #             instantiate ge.gcd_euclid with M=_S, N=x
    #             tactic skolemize
    #             instantiate with A = _A + _B, B = _B
    #         }
    #         proof [neg] {
    #             property gcd(_S,_S) = _S proof {apply admit}
    #             instantiate with A = 1:nat , B = 0:nat
    #             forget ind_hyp
    #         }
    #     }
    #     proof [neg] {
    #         instantiate ind_hyp with S=x-_S, Y = _S
    #         instantiate ge.gcd_euclid with M=_S, N=x
    #         tactic skolemize
    #         showgoals
    #         instantiate with A = _A + _B, B = _B
    #         apply admit
    #     }
    # }

    explicit property [bezout_lemma]
    forall S:nat,T. S > 0 & T > 0 & M = (S if S > T else T)
       -> exists A,B. A*S - B*T = gcd(S,T)
    
    proof {
        apply nat.gen_ind with X=M
        apply introA<_S/x>
        apply introA<_T/x>
        apply exmid with q = (_S >= _T)
        property forall X,Y. gcd(X,Y) = gcd(Y,X) proof {apply admit}
        proof [pos] {
            apply exmid with q = _S > _T
            proof [pos] {
                instantiate ind_hyp with S=_S-_T, T=_T, Y = _S-_T if _S-_T > _T else _T
                instantiate ge.gcd_euclid with M=_T, N=_S
                tactic skolemize
                instantiate with A = _A, B = _A+_B
                showgoals
            }
            proof [neg] {
                property gcd(_S,_S) = _S proof {apply admit}
                instantiate with A = 1:nat , B = 0:nat
                forget ind_hyp
                showgoals
            }
        }
        proof [neg] {
            instantiate ind_hyp with S=_S, T=_T-_S, Y = _T-_S if _T-_S > _S else _S
            instantiate ge.gcd_euclid with M=_S, N=_T
            tactic skolemize
            instantiate with A = _A+_B, B = _B
            showgoals
        }
    }

} with nat

explicit axiom [bezout_lemma]
    S:nat > 0 & T:nat > 0 -> exists A,B. A*S - B*T = gcd(S,T)

# Lemma.
#
# For any positive `P`, `N` and `M`, if `N` and `P are coprime and `P`
# divides `N * M` then `P` divides `M`.
# 

isolate bif3 = {
    theorem [coprime_product] {
        property N:nat > 0 & P:nat > 0 & M:nat > 0
        property gcd(N,P) = 1
        property [prem] dvds(P,N*M)
        property dvds(P,M)
    }
    proof {
        instantiate bezout_lemma with S=N, T=P
        showgoals
        tactic skolemize
        unfold prem with da.dvds_alt
        unfold with da.dvds_alt
        tactic skolemize
        instantiate with Z = _A * _Z - _B * M
    }
} with nat

# Lemma.
#
# For any prime `P` and `N` and `M`, if `P` divides `N * M` then `P`
# divides `M`.
# 

isolate bif2 = {

    theorem [prime_dvds_product] {
        property N:nat > 0
        property M:nat > 0
        property [prem1] prime(P)
        property [prem2] dvds(P,M*N)
        property dvds(P,M) | dvds(P,N)
    }
    proof {
        property  gcd(N,P) = 1 | dvds(P,N) proof {
            apply bif.lemma_prime_coprime
        }
        property gcd(N,P) = 1 -> dvds(P,M) proof {
            apply introImp
            apply bif3.coprime_product
            unfold prem1 with prime
        }
    }
} with nat
